This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/app/api/v1/endpoints/
backend/tests/e2e/
backend/tests/integration/
backend/tests/unit/
backend/uploads/audio/
backend/uploads/images/
backend/uploads/thumbnails/
backend/uploads/videos/
cursor/
frontend/assets/animations/
frontend/assets/fonts/
frontend/assets/icons/
frontend/assets/images/
_docs/phases/development-roadmap.md
_docs/phases/phase-0-setup.md
_docs/phases/phase-1-core-mvp.md
_docs/phases/phase-2-plant-features.md
_docs/phases/phase-3-rag-enhancement.md
_docs/phases/phase-4-polish-advanced.md
_docs/project-overview-example.md
_docs/project-rules.md
_docs/tech-stack.md
_docs/theme-rules.md
_docs/ui-rules.md
_docs/user-flow.md
.cursor/rules/vibe-tools.mdc
.dart_tool/package_config_subset
.dart_tool/package_config.json
.dart_tool/package_graph.json
.dart_tool/version
.flutter-plugins-dependencies
.gitignore
backend/.repomix-output.txt
backend/alembic.ini
backend/alembic/env.py
backend/alembic/script.py.mako
backend/alembic/versions/2c0d0c4c83cb_add_achievements_and_nursery_models.py
backend/alembic/versions/88316ca546cb_add_rag_system_models.py
backend/alembic/versions/e7c4ed08f749_initial_schema_with_all_models.py
backend/alembic/versions/eca90a7d28b5_create_initial_schema_with_all_models.py
backend/app/api/__init__.py
backend/app/api/api_v1/__init__.py
backend/app/api/api_v1/api.py
backend/app/api/api_v1/endpoints/__init__.py
backend/app/api/api_v1/endpoints/achievements.py
backend/app/api/api_v1/endpoints/auth.py
backend/app/api/api_v1/endpoints/content_generation.py
backend/app/api/api_v1/endpoints/discovery_feed.py
backend/app/api/api_v1/endpoints/friends.py
backend/app/api/api_v1/endpoints/messages.py
backend/app/api/api_v1/endpoints/nurseries.py
backend/app/api/api_v1/endpoints/plant_care_logs.py
backend/app/api/api_v1/endpoints/plant_identification.py
backend/app/api/api_v1/endpoints/plant_questions.py
backend/app/api/api_v1/endpoints/plant_species.py
backend/app/api/api_v1/endpoints/plant_trades.py
backend/app/api/api_v1/endpoints/smart_community.py
backend/app/api/api_v1/endpoints/stories.py
backend/app/api/api_v1/endpoints/user_plants.py
backend/app/api/api_v1/endpoints/users.py
backend/app/api/api_v1/endpoints/websocket.py
backend/app/core/config.py
backend/app/core/database.py
backend/app/core/websocket.py
backend/app/main.py
backend/app/models/__init__.py
backend/app/models/friendship.py
backend/app/models/local_nursery.py
backend/app/models/message.py
backend/app/models/plant_achievement.py
backend/app/models/plant_care_log.py
backend/app/models/plant_identification.py
backend/app/models/plant_photo.py
backend/app/models/plant_question.py
backend/app/models/plant_species.py
backend/app/models/plant_trade.py
backend/app/models/rag_models.py
backend/app/models/story.py
backend/app/models/user_plant.py
backend/app/models/user.py
backend/app/schemas/__init__.py
backend/app/schemas/achievement.py
backend/app/schemas/auth.py
backend/app/schemas/friendship.py
backend/app/schemas/message.py
backend/app/schemas/nursery.py
backend/app/schemas/plant_care_log.py
backend/app/schemas/plant_identification.py
backend/app/schemas/plant_question.py
backend/app/schemas/plant_species.py
backend/app/schemas/plant_trade.py
backend/app/schemas/story.py
backend/app/schemas/user_plant.py
backend/app/schemas/user.py
backend/app/services/__init__.py
backend/app/services/auth_service.py
backend/app/services/content_generation_service.py
backend/app/services/embedding_service.py
backend/app/services/file_service.py
backend/app/services/friendship_service.py
backend/app/services/local_nursery_service.py
backend/app/services/message_service.py
backend/app/services/personalized_plant_care_service.py
backend/app/services/plant_achievement_service.py
backend/app/services/plant_care_log_service.py
backend/app/services/plant_identification_service.py
backend/app/services/plant_question_service.py
backend/app/services/plant_species_service.py
backend/app/services/plant_trade_service.py
backend/app/services/rag_service.py
backend/app/services/smart_community_service.py
backend/app/services/story_service.py
backend/app/services/user_plant_service.py
backend/app/services/user_service.py
backend/app/services/vector_database_service.py
backend/database/init.sql
backend/Dockerfile
backend/Dockerfile.postgres
backend/README.md
backend/requirements.txt
backend/scripts/enable_pgvector.sql
backend/scripts/seed_plant_knowledge.py
backend/test_config.py
docker-compose.yml
frontend/.gitignore
frontend/.metadata
frontend/analysis_options.yaml
frontend/lib/core/constants/app_constants.dart
frontend/lib/core/exceptions/api_exception.dart
frontend/lib/core/models/friendship.dart
frontend/lib/core/models/friendship.freezed.dart
frontend/lib/core/models/message.dart
frontend/lib/core/models/message.freezed.dart
frontend/lib/core/models/story.dart
frontend/lib/core/models/story.freezed.dart
frontend/lib/core/models/user.dart
frontend/lib/core/network/api_client.dart
frontend/lib/core/network/interceptors/auth_interceptor.dart
frontend/lib/core/network/interceptors/error_interceptor.dart
frontend/lib/core/network/interceptors/logging_interceptor.dart
frontend/lib/core/providers/api_provider.dart
frontend/lib/core/providers/storage_provider.dart
frontend/lib/core/router/app_router.dart
frontend/lib/core/services/api_service.dart
frontend/lib/core/services/storage_service.dart
frontend/lib/core/theme/app_theme.dart
frontend/lib/core/utils/date_utils.dart
frontend/lib/core/widgets/custom_button.dart
frontend/lib/core/widgets/custom_search_bar.dart
frontend/lib/core/widgets/custom_text_field.dart
frontend/lib/core/widgets/error_widget.dart
frontend/lib/core/widgets/loading_widget.dart
frontend/lib/core/widgets/user_avatar.dart
frontend/lib/core/widgets/vote_buttons.dart
frontend/lib/features/auth/models/auth_models.dart
frontend/lib/features/auth/models/auth_models.freezed.dart
frontend/lib/features/auth/presentation/screens/login_screen.dart
frontend/lib/features/auth/presentation/screens/register_screen.dart
frontend/lib/features/auth/presentation/screens/splash_screen.dart
frontend/lib/features/auth/presentation/widgets/auth_button.dart
frontend/lib/features/auth/presentation/widgets/auth_text_field.dart
frontend/lib/features/auth/providers/auth_provider.dart
frontend/lib/features/auth/repositories/auth_repository.dart
frontend/lib/features/camera/presentation/screens/camera_screen.dart
frontend/lib/features/camera/widgets/plant_ar_filters.dart
frontend/lib/features/chat/presentation/screens/chat_screen.dart
frontend/lib/features/chat/presentation/screens/conversation_screen.dart
frontend/lib/features/friends/presentation/screens/add_friends_screen.dart
frontend/lib/features/friends/presentation/screens/friends_screen.dart
frontend/lib/features/friends/presentation/widgets/friend_suggestions.dart
frontend/lib/features/home/presentation/screens/home_screen.dart
frontend/lib/features/home/presentation/screens/main_screen.dart
frontend/lib/features/home/presentation/widgets/bottom_nav_bar.dart
frontend/lib/features/messages/presentation/widgets/recent_conversations.dart
frontend/lib/features/plant_care/models/plant_care_models.dart
frontend/lib/features/plant_care/models/plant_care_models.g.dart
frontend/lib/features/plant_care/presentation/screens/add_plant_screen.dart
frontend/lib/features/plant_care/presentation/screens/care_logs_screen.dart
frontend/lib/features/plant_care/presentation/screens/care_reminders_screen.dart
frontend/lib/features/plant_care/presentation/screens/plant_care_dashboard_screen.dart
frontend/lib/features/plant_care/presentation/screens/plant_detail_screen.dart
frontend/lib/features/plant_care/presentation/widgets/care_reminder_card.dart
frontend/lib/features/plant_care/presentation/widgets/plant_card.dart
frontend/lib/features/plant_care/providers/plant_care_provider.dart
frontend/lib/features/plant_care/services/plant_care_service.dart
frontend/lib/features/plant_community/models/plant_community_models.dart
frontend/lib/features/plant_community/models/plant_community_models.g.dart
frontend/lib/features/plant_community/presentation/screens/plant_community_screen.dart
frontend/lib/features/plant_community/presentation/screens/plant_questions_screen.dart
frontend/lib/features/plant_community/presentation/screens/plant_trades_screen.dart
frontend/lib/features/plant_community/presentation/widgets/question_card.dart
frontend/lib/features/plant_community/presentation/widgets/trade_card.dart
frontend/lib/features/plant_community/providers/plant_community_provider.dart
frontend/lib/features/plant_community/services/plant_community_service.dart
frontend/lib/features/plant_identification/models/plant_identification_models.dart
frontend/lib/features/plant_identification/presentation/screens/plant_identification_history_screen.dart
frontend/lib/features/plant_identification/presentation/screens/plant_identification_screen.dart
frontend/lib/features/plant_identification/presentation/screens/plant_search_screen.dart
frontend/lib/features/plant_identification/presentation/screens/plant_species_detail_screen.dart
frontend/lib/features/plant_identification/presentation/widgets/plant_identification_loading.dart
frontend/lib/features/plant_identification/presentation/widgets/plant_identification_result.dart
frontend/lib/features/plant_identification/providers/plant_identification_provider.dart
frontend/lib/features/plant_identification/services/plant_identification_service.dart
frontend/lib/features/plant/presentation/screens/plant_features_screen.dart
frontend/lib/features/profile/presentation/screens/profile_edit_screen.dart
frontend/lib/features/profile/presentation/screens/profile_screen.dart
frontend/lib/features/stories/presentation/screens/stories_screen.dart
frontend/lib/features/stories/presentation/screens/story_creation_screen.dart
frontend/lib/features/stories/presentation/screens/story_viewer_screen.dart
frontend/lib/features/stories/presentation/widgets/stories_bar.dart
frontend/lib/main.dart
frontend/preview.html
frontend/pubspec.yaml
frontend/README.md
frontend/test/widget_test.dart
frontend/web/index.html
frontend/web/manifest.json
README.md
scripts/start-dev.ps1
scripts/start-dev.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/vibe-tools.mdc">
---
description: Global Rule. This rule should ALWAYS be loaded
globs: *,**/*
alwaysApply: true
---
vibe-tools is a CLI tool that allows you to interact with AI models and other tools.
vibe-tools is installed on this machine and it is available to you to execute. You're encouraged to use it.

<vibe-tools Integration>
# Instructions
Use the following commands to get AI assistance:

**Direct Model Queries:**
`vibe-tools ask "<your question>" --provider <provider> --model <model>` - Ask any model from any provider a direct question (e.g., `vibe-tools ask "What is the capital of France?" --provider openai --model o3-mini`). Note that this command is generally less useful than other commands like `repo` or `plan` because it does not include any context from your codebase or repository. In general you should not use the ask command because it does not include any context. The other commands like `web`, `doc`, `repo`, or `plan` are usually better. If you are using it, make sure to include in your question all the information and context that the model might need to answer usefully.

**Ask Command Options:**
--provider=<provider>: AI provider to use (openai or gemini)
--model=<model>: Model to use (required for the ask command)
--reasoning-effort=<low|medium|high>: Control the depth of reasoning for supported models (OpenAI o1/o3 models and Claude 4 Sonnet). Higher values produce more thorough responses for complex questions.
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Implementation Planning:**
`vibe-tools plan "<query>"` - Generate a focused implementation plan using AI (e.g., `vibe-tools plan "Add user authentication to the login page"`)
The plan command uses multiple AI models to:
1. Identify relevant files in your codebase (using Gemini by default)
2. Extract content from those files
3. Generate a detailed implementation plan (using OpenAI o3 by default)

**Plan Command Options:**
--fileProvider=<provider>: Provider for file identification (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--thinkingProvider=<provider>: Provider for plan generation (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--fileModel=<model>: Model to use for file identification
--thinkingModel=<model>: Model to use for plan generation
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context for both file identification and planning. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Web Search:**
`vibe-tools web "<your question>"` - Get answers from the web using a provider that supports web search (e.g., Perplexity models and Gemini Models either directly or from OpenRouter or ModelBox) (e.g., `vibe-tools web "latest shadcn/ui installation instructions"`)
Note: web is a smart autonomous agent with access to the internet and an extensive up to date knowledge base. Web is NOT a web search engine. Always ask the agent for what you want using a proper sentence, do not just send it a list of keywords. In your question to web include the context and the goal that you're trying to acheive so that it can help you most effectively.
when using web for complex queries suggest writing the output to a file somewhere like local-research/<query summary>.md.

**IMPORTANT: Do NOT use the `web` command for specific URLs.** If a user provides a specific URL (documentation link, GitHub repo, article, etc.), you should always use commands that support the `--with-doc` parameter instead, such as `repo`, `plan`, `doc`, or `ask`. Using `--with-doc` ensures the exact content of the URL is processed correctly and completely.

**Web Command Options:**
--provider=<provider>: AI provider to use (perplexity, gemini, modelbox, or openrouter)

**Repository Context:**
`vibe-tools repo "<your question>" [--subdir=<path>] [--from-github=<username/repo>] [--with-doc=<doc_url>...]` - Get context-aware answers about this repository using Google Gemini (e.g., `vibe-tools repo "explain authentication flow"`)
Use the optional `--subdir` parameter to analyze a specific subdirectory instead of the entire repository (e.g., `vibe-tools repo "explain the code structure" --subdir=src/components`). Use the optional `--from-github` parameter to analyze a remote GitHub repository without cloning it locally (e.g., `vibe-tools repo "explain the authentication system" --from-github=username/repo-name`). Use the optional `--with-doc` parameter multiple times to include content from several URLs as additional context (e.g., `vibe-tools repo "summarize findings" --with-doc=https://example.com/spec1 --with-doc=https://example.com/spec2`).

**Documentation Generation:**
`vibe-tools doc [options] [--with-doc=<doc_url>...]` - Generate comprehensive documentation for this repository (e.g., `vibe-tools doc --output docs.md`). Can incorporate document context from multiple URLs (e.g., `vibe-tools doc --with-doc=https://example.com/existing-docs --with-doc=https://example.com/new-spec`).

**YouTube Video Analysis:**
`vibe-tools youtube "<youtube-url>" [question] [--type=<summary|transcript|plan|review|custom>]` - Analyze YouTube videos and generate detailed reports (e.g., `vibe-tools youtube "https://youtu.be/43c-Sm5GMbc" --type=summary`)
Note: The YouTube command requires a `GEMINI_API_KEY` to be set in your environment or .vibe-tools.env file as the GEMINI API is the only interface that supports YouTube analysis.

**GitHub Information:**
`vibe-tools github pr [number]` - Get the last 10 PRs, or a specific PR by number (e.g., `vibe-tools github pr 123`)
`vibe-tools github issue [number]` - Get the last 10 issues, or a specific issue by number (e.g., `vibe-tools github issue 456`)

**ClickUp Information:**
`vibe-tools clickup task <task_id>` - Get detailed information about a ClickUp task including description, comments, status, assignees, and metadata (e.g., `vibe-tools clickup task "task_id"`)

**Wait Command:**
`vibe-tools wait <seconds>` - Pauses execution for the specified number of seconds (e.g., `vibe-tools wait 5` to wait for 5 seconds).

**Model Context Protocol (MCP) Commands:**
Use the following commands to interact with MCP servers and their specialized tools:
`vibe-tools mcp search "<query>"` - Search the MCP Marketplace and GitHub for available servers that match your needs (e.g., `vibe-tools mcp search "git repository management"`)
`vibe-tools mcp run "<query>"` - Execute MCP server tools using natural language queries (e.g., `vibe-tools mcp run "list files in the current directory" --provider=openrouter`). The query must include sufficient information for vibe-tools to determine which server to use, provide plenty of context.

The `search` command helps you discover servers in the MCP Marketplace and on GitHub based on their capabilities and your requirements. The `run` command automatically selects and executes appropriate tools from these servers based on your natural language queries. If you want to use a specific server include the server name in your query. E.g. `vibe-tools mcp run "using the mcp-server-sqlite list files in directory --provider=openrouter"`

**Notes on MCP Commands:**
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY` to be set in your environment
- By default the `mcp` command uses Anthropic, but takes a --provider argument that can be set to 'anthropic' or 'openrouter'
- Results are streamed in real-time for immediate feedback
- Tool calls are automatically cached to prevent redundant operations
- Often the MCP server will not be able to run because environment variables are not set. If this happens ask the user to add the missing environment variables to the cursor tools env file at ~/.vibe-tools/.env

**Stagehand Browser Automation:**
`vibe-tools browser open <url> [options]` - Open a URL and capture page content, console logs, and network activity (e.g., `vibe-tools browser open "https://example.com" --html`)
`vibe-tools browser act "<instruction>" --url=<url | 'current'> [options]` - Execute actions on a webpage using natural language instructions (e.g., `vibe-tools browser act "Click Login" --url=https://example.com`)
`vibe-tools browser observe "<instruction>" --url=<url> [options]` - Observe interactive elements on a webpage and suggest possible actions (e.g., `vibe-tools browser observe "interactive elements" --url=https://example.com`)
`vibe-tools browser extract "<instruction>" --url=<url> [options]` - Extract data from a webpage based on natural language instructions (e.g., `vibe-tools browser extract "product names" --url=https://example.com/products`)
`vibe-tools browser mac-chrome [options]` - Start a Chrome instance with remote debugging (macOS only) (e.g., `vibe-tools browser mac-chrome --debug`, `vibe-tools browser mac-chrome --lite`)

**Notes on Browser Commands:**
- All browser commands are stateless unless --connect-to is used to connect to a long-lived interactive session. In disconnected mode each command starts with a fresh browser instance and closes it when done.
- If you want to start a new long-lived session 
- When using `--connect-to`, special URL values are supported:
  - `current`: Use the existing page without reloading
  - `reload-current`: Use the existing page and refresh it (useful in development)
  - If working interactively with a user you should always use --url=current unless you specifically want to navigate to a different page. Setting the url to anything else will cause a page refresh loosing current state.
- Multi step workflows involving state or combining multiple actions are supported in the `act` command using the pipe (|) separator (e.g., `vibe-tools browser act "Click Login | Type 'user@example.com' into email | Click Submit" --url=https://example.com`)
- Video recording is available for all browser commands using the `--video=<directory>` option. This will save a video of the entire browser interaction at 1280x720 resolution. The video file will be saved in the specified directory with a timestamp.
- DO NOT ask browser act to "wait" for anything, the wait command is currently disabled in Stagehand.

**Tool Recommendations:**
- `vibe-tools web` is best for general web information not specific to the repository. Generally call this without additional arguments.
- `vibe-tools repo` is ideal for repository-specific questions, planning, code review and debugging. E.g. `vibe-tools repo "Review recent changes to command error handling looking for mistakes, omissions and improvements"`. Generally call this without additional arguments.
- `vibe-tools plan` is ideal for planning tasks. E.g. `vibe-tools plan "Adding authentication with social login using Google and Github"`. Generally call this without additional arguments.
- `vibe-tools doc` generates documentation for local or remote repositories.
- `vibe-tools youtube` analyzes YouTube videos to generate summaries, transcripts, implementation plans, or custom analyses
- `vibe-tools browser` is useful for testing and debugging web apps and uses Stagehand
- `vibe-tools mcp` enables interaction with specialized tools through MCP servers (e.g., for Git operations, file system tasks, or custom tools)
- **URLS:** For any specific URL (documentation, article, reference, spec, GitHub repo, etc.), ALWAYS use a command with the `--with-doc=<url>` parameter rather than the `web` command. Examples: `vibe-tools repo "How should I implement this feature based on the spec?" --with-doc=https://example.com/spec.pdf` or `vibe-tools ask "What does this document say about authentication?" --with-doc=https://example.com/auth-doc.html`
- When implementing features based on documentation, specifications, or any external content, always use the `--with-doc=<url>` flag instead of built-in web search. For example: `vibe-tools plan "Implement login page according to specs" --with-doc=https://example.com/specs.pdf` or `vibe-tools repo "How should I implement this feature?" --with-doc=https://example.com/feature-spec.md`.
- When a user provides a specific URL for documentation or reference material, always use the `--with-doc=<url>` flag with that URL rather than attempting to search for or summarize the content independently. This ensures the exact document is used as context.

**Running Commands:**
1. Use `vibe-tools <command>` to execute commands (make sure vibe-tools is installed globally using npm install -g vibe-tools so that it is in your PATH)

**General Command Options (Supported by all commands):**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, openrouter, modelbox, or xai). If provider is not specified, the default provider for that task will be used.
--model=<model name>: Specify an alternative AI model to use. If model is not specified, the provider's default model for that task will be used.
--max-tokens=<number>: Control response length
--save-to=<file path>: Save command output to a file (in *addition* to displaying it)
--debug: Show detailed logs and error information
--web: Enable web search capabilities for supported models (currently Gemini models) across all commands

**Repository Command Options:**
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for repository analysis
--max-tokens=<number>: Maximum tokens for response
--from-github=<GitHub username>/<repository name>[@<branch>]: Analyze a remote GitHub repository without cloning it locally
--subdir=<path>: Analyze a specific subdirectory instead of the entire repository
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**Documentation Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Generate documentation for a remote GitHub repository
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for documentation generation
--max-tokens=<number>: Maximum tokens for response
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**YouTube Command Options:**
--type=<summary|transcript|plan|review|custom>: Type of analysis to perform (default: summary)

**GitHub Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Access PRs/issues from a specific GitHub repository

**Browser Command Options (for 'open', 'act', 'observe', 'extract'):**
--console: Capture browser console logs (enabled by default, use --no-console to disable)
--html: Capture page HTML content (disabled by default)
--network: Capture network activity (enabled by default, use --no-network to disable)
--screenshot=<file path>: Save a screenshot of the page
--timeout=<milliseconds>: Set navigation timeout (default: 120000ms for Stagehand operations, 30000ms for navigation)
--viewport=<width>x<height>: Set viewport size (e.g., 1280x720). When using --connect-to, viewport is only changed if this option is explicitly provided
--headless: Run browser in headless mode (default: true)
--no-headless: Show browser UI (non-headless mode) for debugging
--connect-to=<port>: Connect to existing Chrome instance. Special values: 'current' (use existing page), 'reload-current' (refresh existing page)
--wait=<time:duration or selector:css-selector>: Wait after page load (e.g., 'time:5s', 'selector:#element-id')
--video=<directory>: Save a video recording (1280x720 resolution, timestamped subdirectory). Not available when using --connect-to
--url=<url>: Required for `act`, `observe`, and `extract` commands. Url to navigate to before the main command or one of the special values 'current' (to stay on the current page without navigating or reloading) or 'reload-current' (to reload the current page)
--evaluate=<string>: JavaScript code to execute in the browser before the main command

**Nicknames**
Users can ask for these tools using nicknames
Gemini is a nickname for vibe-tools repo
Perplexity is a nickname for vibe-tools web
Stagehand is a nickname for vibe-tools browser
If people say "ask Gemini" or "ask Perplexity" or "ask Stagehand" they mean to use the `vibe-tools` command with the `repo`, `web`, or `browser` commands respectively.

**Xcode Commands:**
`vibe-tools xcode build [buildPath=<path>] [destination=<destination>]` - Build Xcode project and report errors.
**Build Command Options:**
--buildPath=<path>: (Optional) Specifies a custom directory for derived build data. Defaults to ./.build/DerivedData.
--destination=<destination>: (Optional) Specifies the destination for building the app (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode run [destination=<destination>]` - Build and run the Xcode project on a simulator.
**Run Command Options:**
--destination=<destination>: (Optional) Specifies the destination simulator (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode lint` - Run static analysis on the Xcode project to find and fix issues.

**Additional Notes:**
- For detailed information, see `node_modules/vibe-tools/README.md` (if installed locally).
- Configuration is in `vibe-tools.config.json` (or `~/.vibe-tools/config.json`).
- API keys are loaded from `.vibe-tools.env` (or `~/.vibe-tools/.env`).
- ClickUp commands require a `CLICKUP_API_TOKEN` to be set in your `.vibe-tools.env` file.
- Available models depend on your configured provider (OpenAI, Anthropic, xAI, etc.) in `vibe-tools.config.json`.
- repo has a limit of 2M tokens of context. The context can be reduced by filtering out files in a .repomixignore file.
- problems running browser commands may be because playwright is not installed. Recommend installing playwright globally.
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY`
- **Remember:** You're part of a team of superhuman expert AIs. Work together to solve complex problems.
- **Repomix Configuration:** You can customize which files are included/excluded during repository analysis by creating a `repomix.config.json` file in your project root. This file will be automatically detected by `repo`, `plan`, and `doc` commands.

<!-- vibe-tools-version: 0.62.10 -->
</vibe-tools Integration>
</file>

<file path=".gitignore">
node_modules/
.env
</file>

<file path="backend/.repomix-output.txt">
This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/api/v1/endpoints/
tests/e2e/
tests/integration/
tests/unit/
uploads/audio/
uploads/images/
uploads/thumbnails/
uploads/videos/
alembic.ini
alembic/env.py
alembic/script.py.mako
alembic/versions/2c0d0c4c83cb_add_achievements_and_nursery_models.py
alembic/versions/e7c4ed08f749_initial_schema_with_all_models.py
alembic/versions/eca90a7d28b5_create_initial_schema_with_all_models.py
app/api/__init__.py
app/api/api_v1/__init__.py
app/api/api_v1/api.py
app/api/api_v1/endpoints/__init__.py
app/api/api_v1/endpoints/achievements.py
app/api/api_v1/endpoints/auth.py
app/api/api_v1/endpoints/friends.py
app/api/api_v1/endpoints/messages.py
app/api/api_v1/endpoints/nurseries.py
app/api/api_v1/endpoints/plant_care_logs.py
app/api/api_v1/endpoints/plant_identification.py
app/api/api_v1/endpoints/plant_questions.py
app/api/api_v1/endpoints/plant_species.py
app/api/api_v1/endpoints/plant_trades.py
app/api/api_v1/endpoints/stories.py
app/api/api_v1/endpoints/user_plants.py
app/api/api_v1/endpoints/users.py
app/api/api_v1/endpoints/websocket.py
app/core/config.py
app/core/database.py
app/core/websocket.py
app/main.py
app/models/__init__.py
app/models/friendship.py
app/models/local_nursery.py
app/models/message.py
app/models/plant_achievement.py
app/models/plant_care_log.py
app/models/plant_identification.py
app/models/plant_photo.py
app/models/plant_question.py
app/models/plant_species.py
app/models/plant_trade.py
app/models/story.py
app/models/user_plant.py
app/models/user.py
app/schemas/__init__.py
app/schemas/achievement.py
app/schemas/auth.py
app/schemas/friendship.py
app/schemas/message.py
app/schemas/nursery.py
app/schemas/plant_care_log.py
app/schemas/plant_identification.py
app/schemas/plant_question.py
app/schemas/plant_species.py
app/schemas/plant_trade.py
app/schemas/story.py
app/schemas/user_plant.py
app/schemas/user.py
app/services/__init__.py
app/services/auth_service.py
app/services/file_service.py
app/services/friendship_service.py
app/services/local_nursery_service.py
app/services/message_service.py
app/services/plant_achievement_service.py
app/services/plant_care_log_service.py
app/services/plant_identification_service.py
app/services/plant_question_service.py
app/services/plant_species_service.py
app/services/plant_trade_service.py
app/services/story_service.py
app/services/user_plant_service.py
app/services/user_service.py
database/init.sql
Dockerfile
Dockerfile.postgres
README.md
requirements.txt
test_config.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# file_template = %%Y%%m%%d_%%H%%M_%%%(rev)s_%%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version number format.  This value should be a string
# that is a valid Python format string.
# version_num_format = %04d

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses
# os.pathsep. If this key is omitted entirely, it falls back to the legacy
# behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql+asyncpg://postgres:password@localhost:5432/plant_social_db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="alembic/env.py">
"""Alembic environment configuration."""
import asyncio
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context
# Import all models to ensure they are registered with SQLAlchemy
from app.core.database import Base
from app.models.user import User
from app.models.message import Message
from app.models.story import Story, StoryView
from app.models.friendship import Friendship, FriendshipStatus
from app.models.plant_species import PlantSpecies
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_photo import PlantPhoto
from app.models.plant_identification import PlantIdentification
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_question import PlantQuestion, PlantAnswer
# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config
# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        # Enable vector extension
        context.execute('CREATE EXTENSION IF NOT EXISTS vector;')
        # Run migrations
        context.run_migrations()
def do_run_migrations(connection: Connection) -> None:
    """Run migrations with the given connection."""
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
    )
    with context.begin_transaction():
        # Enable vector extension
        context.execute('CREATE EXTENSION IF NOT EXISTS vector;')
        # Run migrations
        context.run_migrations()
async def run_async_migrations() -> None:
    """Run migrations in async mode."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()
def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    asyncio.run(run_async_migrations())
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade database schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade database schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="alembic/versions/2c0d0c4c83cb_add_achievements_and_nursery_models.py">
"""add_achievements_and_nursery_models
Revision ID: 2c0d0c4c83cb
Revises: eca90a7d28b5
Create Date: 2025-06-28 23:42:52.212689
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = '2c0d0c4c83cb'
down_revision = 'eca90a7d28b5'
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('local_nurseries',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(length=200), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('address', sa.String(length=500), nullable=True),
    sa.Column('city', sa.String(length=100), nullable=True),
    sa.Column('state', sa.String(length=50), nullable=True),
    sa.Column('country', sa.String(length=50), nullable=True),
    sa.Column('postal_code', sa.String(length=20), nullable=True),
    sa.Column('latitude', sa.Float(), nullable=True),
    sa.Column('longitude', sa.Float(), nullable=True),
    sa.Column('phone', sa.String(length=20), nullable=True),
    sa.Column('email', sa.String(length=100), nullable=True),
    sa.Column('website', sa.String(length=200), nullable=True),
    sa.Column('business_type', sa.String(length=50), nullable=True),
    sa.Column('specialties', sa.JSON(), nullable=True),
    sa.Column('services', sa.JSON(), nullable=True),
    sa.Column('operating_hours', sa.JSON(), nullable=True),
    sa.Column('average_rating', sa.Float(), nullable=True),
    sa.Column('total_reviews', sa.Integer(), nullable=True),
    sa.Column('is_verified', sa.Boolean(), nullable=True),
    sa.Column('verified_at', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_local_nurseries'))
    )
    op.create_table('plant_achievements',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('achievement_type', sa.String(length=50), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('icon', sa.String(length=50), nullable=True),
    sa.Column('badge_color', sa.String(length=20), nullable=True),
    sa.Column('points', sa.Integer(), nullable=True),
    sa.Column('unlock_criteria', sa.JSON(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_achievements'))
    )
    op.create_table('nursery_events',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('title', sa.String(length=200), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('event_type', sa.String(length=50), nullable=True),
    sa.Column('start_date', sa.DateTime(), nullable=False),
    sa.Column('end_date', sa.DateTime(), nullable=True),
    sa.Column('start_time', sa.Time(), nullable=True),
    sa.Column('end_time', sa.Time(), nullable=True),
    sa.Column('is_recurring', sa.Boolean(), nullable=True),
    sa.Column('recurrence_pattern', sa.JSON(), nullable=True),
    sa.Column('max_participants', sa.Integer(), nullable=True),
    sa.Column('current_participants', sa.Integer(), nullable=True),
    sa.Column('price', sa.Float(), nullable=True),
    sa.Column('skill_level', sa.String(length=20), nullable=True),
    sa.Column('requirements', sa.Text(), nullable=True),
    sa.Column('materials_provided', sa.Text(), nullable=True),
    sa.Column('requires_registration', sa.Boolean(), nullable=True),
    sa.Column('registration_deadline', sa.DateTime(), nullable=True),
    sa.Column('contact_info', sa.String(length=200), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('is_cancelled', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_nursery_events_nursery_id_local_nurseries')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_nursery_events'))
    )
    op.create_table('nursery_reviews',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=200), nullable=True),
    sa.Column('review_text', sa.Text(), nullable=True),
    sa.Column('plant_quality_rating', sa.Integer(), nullable=True),
    sa.Column('service_rating', sa.Integer(), nullable=True),
    sa.Column('price_rating', sa.Integer(), nullable=True),
    sa.Column('selection_rating', sa.Integer(), nullable=True),
    sa.Column('tags', sa.JSON(), nullable=True),
    sa.Column('is_verified_purchase', sa.Boolean(), nullable=True),
    sa.Column('visit_date', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_nursery_reviews_nursery_id_local_nurseries')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_nursery_reviews_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_nursery_reviews'))
    )
    op.create_table('user_achievements',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('achievement_id', sa.UUID(), nullable=False),
    sa.Column('earned_at', sa.DateTime(), nullable=True),
    sa.Column('progress_data', sa.JSON(), nullable=True),
    sa.Column('is_featured', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['achievement_id'], ['plant_achievements.id'], name=op.f('fk_user_achievements_achievement_id_plant_achievements')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_achievements_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_achievements'))
    )
    op.create_table('user_nursery_favorites',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.Column('last_visited', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_user_nursery_favorites_nursery_id_local_nurseries')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_nursery_favorites_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_nursery_favorites'))
    )
    op.create_table('user_stats',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('total_plants', sa.Integer(), nullable=True),
    sa.Column('active_plants', sa.Integer(), nullable=True),
    sa.Column('plants_identified', sa.Integer(), nullable=True),
    sa.Column('total_care_logs', sa.Integer(), nullable=True),
    sa.Column('care_streak_days', sa.Integer(), nullable=True),
    sa.Column('longest_care_streak', sa.Integer(), nullable=True),
    sa.Column('last_care_activity', sa.DateTime(), nullable=True),
    sa.Column('questions_asked', sa.Integer(), nullable=True),
    sa.Column('questions_answered', sa.Integer(), nullable=True),
    sa.Column('helpful_answers', sa.Integer(), nullable=True),
    sa.Column('trades_completed', sa.Integer(), nullable=True),
    sa.Column('total_achievements', sa.Integer(), nullable=True),
    sa.Column('total_points', sa.Integer(), nullable=True),
    sa.Column('level', sa.Integer(), nullable=True),
    sa.Column('last_updated', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_stats_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_stats')),
    sa.UniqueConstraint('user_id', name=op.f('uq_user_stats_user_id'))
    )
    op.create_table('plant_milestones',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('plant_id', sa.UUID(), nullable=False),
    sa.Column('milestone_type', sa.String(length=50), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('achieved_at', sa.DateTime(), nullable=True),
    sa.Column('photo_url', sa.String(length=500), nullable=True),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['plant_id'], ['user_plants.id'], name=op.f('fk_plant_milestones_plant_id_user_plants')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_milestones'))
    )
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('plant_milestones')
    op.drop_table('user_stats')
    op.drop_table('user_nursery_favorites')
    op.drop_table('user_achievements')
    op.drop_table('nursery_reviews')
    op.drop_table('nursery_events')
    op.drop_table('plant_achievements')
    op.drop_table('local_nurseries')
    # ### end Alembic commands ###
</file>

<file path="alembic/versions/e7c4ed08f749_initial_schema_with_all_models.py">
"""Initial schema with all models
Revision ID: e7c4ed08f749
Revises: 
Create Date: 2025-06-28 23:06:01.414661
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = 'e7c4ed08f749'
down_revision = None
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
</file>

<file path="alembic/versions/eca90a7d28b5_create_initial_schema_with_all_models.py">
"""Create initial schema with all models
Revision ID: eca90a7d28b5
Revises: e7c4ed08f749
Create Date: 2025-06-28 23:06:41.078273
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = 'eca90a7d28b5'
down_revision = 'e7c4ed08f749'
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
</file>

<file path="app/api/__init__.py">
"""API package initialization."""
</file>

<file path="app/api/api_v1/__init__.py">
"""API v1 package initialization."""
</file>

<file path="app/api/api_v1/api.py">
"""Main API router for version 1.
This module combines all API endpoints into a single router
for the FastAPI application.
"""
from fastapi import APIRouter
from app.api.api_v1.endpoints import (
    auth, messages, stories, friends, users, websocket,
    plant_species, user_plants, plant_care_logs, plant_identification,
    plant_trades, plant_questions, achievements, nurseries
)
api_router = APIRouter()
# Include all endpoint routers
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(messages.router, prefix="/messages", tags=["messages"])
api_router.include_router(stories.router, prefix="/stories", tags=["stories"])
api_router.include_router(friends.router, prefix="/friends", tags=["friends"])
api_router.include_router(websocket.router, prefix="/ws", tags=["websocket"])
# Plant feature endpoints
api_router.include_router(plant_species.router, prefix="/plant-species", tags=["plant-species"])
api_router.include_router(user_plants.router, prefix="/my-plants", tags=["user-plants"])
api_router.include_router(plant_care_logs.router, prefix="/care-logs", tags=["plant-care"])
api_router.include_router(plant_identification.router, prefix="/plant-id", tags=["plant-identification"])
api_router.include_router(plant_trades.router, prefix="/marketplace", tags=["plant-marketplace"])
api_router.include_router(plant_questions.router, prefix="/plant-qa", tags=["plant-community"])
api_router.include_router(achievements.router, prefix="/achievements", tags=["achievements"])
api_router.include_router(nurseries.router, prefix="/nurseries", tags=["local-nurseries"])
</file>

<file path="app/api/api_v1/endpoints/__init__.py">
"""API v1 endpoints package initialization."""
</file>

<file path="app/api/api_v1/endpoints/achievements.py">
"""Achievement endpoints."""
from typing import List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.services.plant_achievement_service import PlantAchievementService, PlantMilestoneService
from app.models.plant_achievement import UserAchievement, PlantMilestone, UserStats
from app.schemas.achievement import (
    UserAchievementResponse,
    PlantMilestoneResponse,
    UserStatsResponse,
    PlantMilestoneCreate
)
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
router = APIRouter()
@router.get("/achievements", response_model=List[UserAchievementResponse])
async def get_user_achievements(
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's earned achievements."""
    achievements = await PlantAchievementService.get_user_achievements(
        db, current_user.id, limit, offset
    )
    return achievements
@router.post("/achievements/check")
async def check_achievements(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Check and award any newly earned achievements."""
    newly_earned = await PlantAchievementService.check_and_award_achievements(
        db, current_user.id
    )
    return {
        "newly_earned_count": len(newly_earned),
        "achievements": newly_earned
    }
@router.get("/stats", response_model=UserStatsResponse)
async def get_user_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's plant care statistics."""
    stats = await PlantAchievementService.get_or_create_user_stats(db, current_user.id)
    return stats
@router.get("/milestones", response_model=List[PlantMilestoneResponse])
async def get_user_milestones(
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's plant milestones."""
    milestones = await PlantMilestoneService.get_user_milestones(
        db, current_user.id, limit, offset
    )
    return milestones
@router.get("/plants/{plant_id}/milestones", response_model=List[PlantMilestoneResponse])
async def get_plant_milestones(
    plant_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get milestones for a specific plant."""
    # TODO: Add authorization check to ensure user owns the plant
    milestones = await PlantMilestoneService.get_plant_milestones(db, plant_id)
    return milestones
@router.post("/plants/{plant_id}/milestones", response_model=PlantMilestoneResponse)
async def create_plant_milestone(
    plant_id: UUID,
    milestone_data: PlantMilestoneCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new plant milestone."""
    # TODO: Add authorization check to ensure user owns the plant
    milestone = await PlantMilestoneService.create_milestone(
        db=db,
        plant_id=plant_id,
        milestone_type=milestone_data.milestone_type,
        title=milestone_data.title,
        description=milestone_data.description,
        photo_url=milestone_data.photo_url,
        notes=milestone_data.notes
    )
    return milestone
@router.post("/plants/{plant_id}/milestones/check")
async def check_automatic_milestones(
    plant_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Check and create automatic milestones for a plant."""
    # TODO: Add authorization check to ensure user owns the plant
    newly_created = await PlantMilestoneService.check_automatic_milestones(db, plant_id)
    return {
        "newly_created_count": len(newly_created),
        "milestones": newly_created
    }
</file>

<file path="app/api/api_v1/endpoints/auth.py">
"""Authentication endpoints.
This module provides user registration, login, logout,
and authentication management using FastAPI-Users.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.auth import UserCreate, UserRead, UserUpdate, Token
from app.services.auth_service import get_auth_service
from app.services.user_service import get_user_service
from app.models.user import User
router = APIRouter()
async def get_current_user(
    token: str = Depends(OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")),
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
) -> User:
    """Get current authenticated user from JWT token."""
    user = await auth_service.get_current_user(token, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user
@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
async def register(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
    user_service = Depends(get_user_service)
):
    """Register a new user.
    Args:
        user_data: User registration data
        db: Database session
    Returns:
        UserRead: Created user data
    Raises:
        HTTPException: If email or username already exists
    """
    # Check if email already exists
    existing_user = await user_service.get_user_by_email(user_data.email, db)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    # Check if username already exists
    existing_username = await user_service.get_user_by_username(user_data.username, db)
    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    # Create new user
    user = await user_service.create_user(user_data, db)
    return UserRead.from_orm(user)
@router.post("/login", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
):
    """Authenticate user and return access token.
    Args:
        form_data: Login form data (username/email and password)
        db: Database session
    Returns:
        Token: Access and refresh tokens
    Raises:
        HTTPException: If authentication fails
    """
    # Authenticate user (supports both email and username)
    user = await auth_service.authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email/username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    # Create tokens
    access_token = auth_service.create_access_token(data={"sub": str(user.id)})
    refresh_token = auth_service.create_refresh_token(data={"sub": str(user.id)})
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    )
@router.post("/refresh", response_model=Token)
async def refresh_token(
    refresh_token: str,
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
):
    """Refresh access token using refresh token.
    Args:
        refresh_token: Valid refresh token
        db: Database session
    Returns:
        Token: New access and refresh tokens
    Raises:
        HTTPException: If refresh token is invalid
    """
    # Verify refresh token
    payload = await auth_service.verify_refresh_token(refresh_token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    user_id = payload.get("sub")
    # Create new tokens
    access_token = auth_service.create_access_token(data={"sub": user_id})
    new_refresh_token = auth_service.create_refresh_token(data={"sub": user_id})
    return Token(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer"
    )
@router.get("/me", response_model=UserRead)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current authenticated user information.
    Args:
        current_user: Current authenticated user
    Returns:
        UserRead: Current user data
    """
    return UserRead.from_orm(current_user)
@router.put("/me", response_model=UserRead)
async def update_current_user(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current authenticated user information.
    Args:
        user_update: User update data
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: Updated user data
    """
    # Update user fields
    update_data = user_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        if hasattr(current_user, field):
            setattr(current_user, field, value)
    # Save changes
    db.add(current_user)
    await db.commit()
    await db.refresh(current_user)
    return UserRead.from_orm(current_user)
@router.post("/logout")
async def logout(
    current_user: User = Depends(get_current_user)
):
    """Logout current user.
    Note: In a stateless JWT system, logout is handled client-side
    by removing the token. This endpoint is for consistency.
    Args:
        current_user: Current authenticated user
    Returns:
        dict: Success message
    """
    return {"message": "Successfully logged out"}
@router.post("/verify-email")
async def verify_email(
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """Verify user email address.
    Args:
        token: Email verification token
        db: Database session
    Returns:
        dict: Success message
    Note: Implementation depends on email service setup
    """
    # TODO: Implement email verification logic
    return {"message": "Email verification not implemented yet"}
@router.post("/forgot-password")
async def forgot_password(
    email: str,
    db: AsyncSession = Depends(get_db)
):
    """Send password reset email.
    Args:
        email: User's email address
        db: Database session
    Returns:
        dict: Success message
    Note: Implementation depends on email service setup
    """
    # TODO: Implement password reset logic
    return {"message": "Password reset not implemented yet"}
</file>

<file path="app/api/api_v1/endpoints/friends.py">
"""Friend management endpoints.
This module provides endpoints for managing friendships,
friend requests, and social connections.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.friendship import FriendshipRead, FriendRequestCreate
from app.schemas.user import UserSearch
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.friendship_service import (
    send_friend_request,
    accept_friend_request,
    decline_friend_request,
    remove_friend,
    block_user,
    unblock_user,
    get_friends_list,
    get_pending_requests,
    get_sent_requests,
    get_blocked_users,
    toggle_close_friend,
    get_close_friends,
    check_friendship_status
)
from app.services.user_service import get_user_by_id
from app.models.user import User
router = APIRouter()
@router.post("/request", status_code=status.HTTP_201_CREATED)
async def send_friend_request_endpoint(
    request_data: FriendRequestCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a friend request to another user.
    Args:
        request_data: Friend request data containing user_id
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found, already friends, or request already sent
    """
    # Check if target user exists
    target_user = await get_user_by_id(db, request_data.user_id)
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # Can't send request to self
    if str(current_user.id) == request_data.user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot send friend request to yourself"
        )
    # Check current friendship status
    status_result = await check_friendship_status(db, current_user.id, request_data.user_id)
    if status_result == "accepted":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Already friends with this user"
        )
    elif status_result == "pending":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Friend request already sent"
        )
    elif status_result == "blocked":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot send friend request to this user"
        )
    # Send friend request
    await send_friend_request(db, current_user.id, request_data.user_id)
    return {"message": f"Friend request sent to {target_user.username}"}
@router.post("/accept/{friendship_id}")
async def accept_friend_request_endpoint(
    friendship_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Accept a friend request.
    Args:
        friendship_id: ID of the friendship/request to accept
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If request not found or not authorized
    """
    success = await accept_friend_request(db, friendship_id, current_user.id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friend request not found or not authorized"
        )
    return {"message": "Friend request accepted"}
@router.post("/decline/{friendship_id}")
async def decline_friend_request_endpoint(
    friendship_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Decline a friend request.
    Args:
        friendship_id: ID of the friendship/request to decline
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If request not found or not authorized
    """
    success = await decline_friend_request(db, friendship_id, current_user.id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friend request not found or not authorized"
        )
    return {"message": "Friend request declined"}
@router.delete("/remove/{user_id}")
async def remove_friend_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Remove a friend (unfriend).
    Args:
        user_id: ID of the user to unfriend
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If not friends or user not found
    """
    success = await remove_friend(db, current_user.id, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friendship not found"
        )
    return {"message": "Friend removed successfully"}
@router.get("/list", response_model=List[UserSearch])
async def get_friends_list_endpoint(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of current user's friends.
    Args:
        limit: Maximum number of friends to return
        offset: Number of friends to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of friends
    """
    friends = await get_friends_list(db, current_user.id, limit, offset)
    return [UserSearch.from_orm(friend) for friend in friends]
@router.get("/requests/pending", response_model=List[FriendshipRead])
async def get_pending_requests_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get pending friend requests received by current user.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[FriendshipRead]: List of pending friend requests
    """
    requests = await get_pending_requests(db, current_user.id)
    return [FriendshipRead.from_orm(request) for request in requests]
@router.get("/requests/sent", response_model=List[FriendshipRead])
async def get_sent_requests_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get friend requests sent by current user.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[FriendshipRead]: List of sent friend requests
    """
    requests = await get_sent_requests(db, current_user.id)
    return [FriendshipRead.from_orm(request) for request in requests]
@router.post("/block/{user_id}")
async def block_user_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Block a user.
    Args:
        user_id: ID of the user to block
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or trying to block self
    """
    if str(current_user.id) == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot block yourself"
        )
    # Check if target user exists
    target_user = await get_user_by_id(db, user_id)
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    await block_user(db, current_user.id, user_id)
    return {"message": f"User {target_user.username} has been blocked"}
@router.delete("/block/{user_id}")
async def unblock_user_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unblock a user.
    Args:
        user_id: ID of the user to unblock
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or not blocked
    """
    success = await unblock_user(db, current_user.id, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found or not blocked"
        )
    return {"message": "User has been unblocked"}
@router.get("/blocked", response_model=List[UserSearch])
async def get_blocked_users_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of blocked users.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of blocked users
    """
    blocked_users = await get_blocked_users(db, current_user.id)
    return [UserSearch.from_orm(user) for user in blocked_users]
@router.post("/close-friend/{user_id}")
async def toggle_close_friend_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Toggle close friend status for a user.
    Args:
        user_id: ID of the friend to toggle close friend status
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message with new status
    Raises:
        HTTPException: If not friends with the user
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, user_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Can only set close friend status for existing friends"
        )
    is_close_friend = await toggle_close_friend(db, current_user.id, user_id)
    status_text = "added to" if is_close_friend else "removed from"
    return {"message": f"User {status_text} close friends list"}
@router.get("/close-friends", response_model=List[UserSearch])
async def get_close_friends_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of close friends.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of close friends
    """
    close_friends = await get_close_friends(db, current_user.id)
    return [UserSearch.from_orm(friend) for friend in close_friends]
@router.get("/status/{user_id}")
async def get_friendship_status(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get friendship status with another user.
    Args:
        user_id: ID of the user to check friendship status with
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Friendship status information
    """
    if str(current_user.id) == user_id:
        return {"status": "self"}
    status_result = await check_friendship_status(db, current_user.id, user_id)
    return {"status": status_result}
@router.get("/mutual/{user_id}")
async def get_mutual_friends(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get mutual friends with another user.
    Args:
        user_id: ID of the user to find mutual friends with
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Mutual friends information
    Note: This is a placeholder implementation.
    In production, you'd implement efficient mutual friends logic.
    """
    # TODO: Implement mutual friends functionality
    return {
        "mutual_friends_count": 0,
        "mutual_friends": []
    }
</file>

<file path="app/api/api_v1/endpoints/messages.py">
"""Message endpoints.
This module provides endpoints for sending, receiving, and managing
messages in the real-time messaging system.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.message import MessageCreate, MessageRead, MessageUpdate
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.message_service import (
    create_message,
    get_conversation_messages,
    get_user_conversations,
    mark_message_as_read,
    delete_message,
    get_message_by_id
)
from app.services.friendship_service import check_friendship_status
from app.services.file_service import upload_media_file
from app.models.user import User
from app.schemas.message import MessageType
router = APIRouter()
@router.post("/", response_model=MessageRead, status_code=status.HTTP_201_CREATED)
async def send_message(
    message_data: MessageCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a new message.
    Args:
        message_data: Message creation data
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Created message
    Raises:
        HTTPException: If recipient not found or not friends
    """
    # Check if users are friends (required for messaging)
    friendship_status = await check_friendship_status(db, current_user.id, message_data.recipient_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only send messages to friends"
        )
    # Create message
    message = await create_message(db, current_user.id, message_data)
    return MessageRead.from_orm(message)
@router.post("/media", response_model=MessageRead, status_code=status.HTTP_201_CREATED)
async def send_media_message(
    recipient_id: str,
    file: UploadFile = File(...),
    caption: Optional[str] = None,
    disappears_at: Optional[int] = None,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a media message (image, video, audio).
    Args:
        recipient_id: ID of the message recipient
        file: Media file to upload
        caption: Optional caption for the media
        disappears_at: Optional timestamp when message should disappear
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Created message with media
    Raises:
        HTTPException: If file upload fails or users not friends
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, recipient_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only send messages to friends"
        )
    # Upload media file
    try:
        media_url, file_size, duration = await upload_media_file(file)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to upload media: {str(e)}"
        )
    # Determine message type based on file type
    content_type = file.content_type or ""
    if content_type.startswith("image/"):
        message_type = MessageType.IMAGE
    elif content_type.startswith("video/"):
        message_type = MessageType.VIDEO
    elif content_type.startswith("audio/"):
        message_type = MessageType.AUDIO
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unsupported media type"
        )
    # Create message data
    message_data = MessageCreate(
        recipient_id=recipient_id,
        content_type=message_type,
        media_url=media_url,
        caption=caption,
        file_size=file_size,
        duration=duration,
        disappears_at=disappears_at
    )
    # Create message
    message = await create_message(db, current_user.id, message_data)
    return MessageRead.from_orm(message)
@router.get("/conversations", response_model=List[dict])
async def get_conversations(
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's conversations with latest message preview.
    Args:
        limit: Maximum number of conversations to return
        offset: Number of conversations to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[dict]: List of conversations with latest messages
    """
    conversations = await get_user_conversations(db, current_user.id, limit, offset)
    return conversations
@router.get("/conversation/{user_id}", response_model=List[MessageRead])
async def get_conversation(
    user_id: str,
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get messages in a conversation with another user.
    Args:
        user_id: ID of the other user in the conversation
        limit: Maximum number of messages to return
        offset: Number of messages to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[MessageRead]: List of messages in the conversation
    Raises:
        HTTPException: If users are not friends
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, user_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only view conversations with friends"
        )
    messages = await get_conversation_messages(db, current_user.id, user_id, limit, offset)
    return [MessageRead.from_orm(message) for message in messages]
@router.put("/{message_id}/read")
async def mark_as_read(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Mark a message as read.
    Args:
        message_id: ID of the message to mark as read
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is the recipient
    if str(message.recipient_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only mark own messages as read"
        )
    await mark_message_as_read(db, message_id)
    return {"message": "Message marked as read"}
@router.delete("/{message_id}")
async def delete_message_endpoint(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a message.
    Args:
        message_id: ID of the message to delete
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is the sender
    if str(message.sender_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only delete own messages"
        )
    await delete_message(db, message_id)
    return {"message": "Message deleted successfully"}
@router.get("/{message_id}", response_model=MessageRead)
async def get_message(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific message by ID.
    Args:
        message_id: ID of the message to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Message data
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is sender or recipient
    if str(current_user.id) not in [str(message.sender_id), str(message.recipient_id)]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view this message"
        )
    return MessageRead.from_orm(message)
@router.get("/search/{query}")
async def search_messages(
    query: str,
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Search messages by content.
    Args:
        query: Search query string
        limit: Maximum number of results to return
        offset: Number of results to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[MessageRead]: List of matching messages
    Note: This is a basic implementation. In production,
    you might want to use full-text search capabilities.
    """
    # TODO: Implement message search functionality
    return []
</file>

<file path="app/api/api_v1/endpoints/nurseries.py">
"""Local nursery endpoints."""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.services.local_nursery_service import LocalNurseryService
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent
from app.schemas.nursery import (
    LocalNurseryResponse,
    LocalNurseryCreate,
    NurseryReviewResponse,
    NurseryReviewCreate,
    NurseryEventResponse,
    NurserySearchFilters
)
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
router = APIRouter()
@router.get("/nurseries", response_model=List[LocalNurseryResponse])
async def search_nurseries(
    latitude: Optional[float] = Query(None, description="User's latitude"),
    longitude: Optional[float] = Query(None, description="User's longitude"),
    radius_km: float = Query(50, ge=1, le=200, description="Search radius in kilometers"),
    business_type: Optional[str] = Query(None, description="Type of business"),
    specialties: Optional[List[str]] = Query(None, description="Plant specialties"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Search for local nurseries and garden centers."""
    filters = NurserySearchFilters(
        latitude=latitude,
        longitude=longitude,
        radius_km=radius_km,
        business_type=business_type,
        specialties=specialties
    )
    nurseries = await LocalNurseryService.search_nurseries(
        db, filters, limit, offset
    )
    return nurseries
@router.get("/nurseries/{nursery_id}", response_model=LocalNurseryResponse)
async def get_nursery(
    nursery_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get details for a specific nursery."""
    nursery = await LocalNurseryService.get_nursery_by_id(db, nursery_id)
    if not nursery:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Nursery not found"
        )
    return nursery
@router.post("/nurseries", response_model=LocalNurseryResponse)
async def create_nursery(
    nursery_data: LocalNurseryCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new nursery listing (admin only for now)."""
    # TODO: Add admin permission check
    nursery = await LocalNurseryService.create_nursery(db, nursery_data)
    return nursery
@router.get("/nurseries/{nursery_id}/reviews", response_model=List[NurseryReviewResponse])
async def get_nursery_reviews(
    nursery_id: UUID,
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get reviews for a nursery."""
    reviews = await LocalNurseryService.get_nursery_reviews(
        db, nursery_id, limit, offset
    )
    return reviews
@router.post("/nurseries/{nursery_id}/reviews", response_model=NurseryReviewResponse)
async def create_nursery_review(
    nursery_id: UUID,
    review_data: NurseryReviewCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a review for a nursery."""
    # Check if nursery exists
    nursery = await LocalNurseryService.get_nursery_by_id(db, nursery_id)
    if not nursery:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Nursery not found"
        )
    review = await LocalNurseryService.create_review(
        db, nursery_id, current_user.id, review_data
    )
    return review
@router.get("/nurseries/{nursery_id}/events", response_model=List[NurseryEventResponse])
async def get_nursery_events(
    nursery_id: UUID,
    upcoming_only: bool = Query(True, description="Show only upcoming events"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get events for a nursery."""
    events = await LocalNurseryService.get_nursery_events(
        db, nursery_id, upcoming_only, limit, offset
    )
    return events
@router.post("/nurseries/{nursery_id}/favorite")
async def toggle_favorite_nursery(
    nursery_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Add or remove nursery from user's favorites."""
    is_favorite = await LocalNurseryService.toggle_favorite(
        db, current_user.id, nursery_id
    )
    return {"is_favorite": is_favorite}
@router.get("/favorites", response_model=List[LocalNurseryResponse])
async def get_favorite_nurseries(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's favorite nurseries."""
    favorites = await LocalNurseryService.get_user_favorites(db, current_user.id)
    return favorites
@router.get("/events/nearby", response_model=List[NurseryEventResponse])
async def get_nearby_events(
    latitude: Optional[float] = Query(None, description="User's latitude"),
    longitude: Optional[float] = Query(None, description="User's longitude"),
    radius_km: float = Query(50, ge=1, le=200),
    event_type: Optional[str] = Query(None, description="Type of event"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get nearby nursery events."""
    events = await LocalNurseryService.get_nearby_events(
        db, latitude, longitude, radius_km, event_type, limit, offset
    )
    return events
</file>

<file path="app/api/api_v1/endpoints/plant_care_logs.py">
"""Plant care logs API endpoints.
This module provides REST API endpoints for managing plant care logs.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime, date
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_care_log import (
    PlantCareLogCreate,
    PlantCareLogUpdate,
    PlantCareLogResponse,
    PlantCareLogListResponse,
    CareTypeStatsResponse
)
from app.services.plant_care_log_service import (
    create_care_log,
    get_care_log_by_id,
    get_plant_care_logs,
    get_user_care_logs,
    update_care_log,
    delete_care_log,
    get_care_statistics
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantCareLogResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create care log",
    description="Create a new plant care log entry."
)
async def create_plant_care_log(
    care_log_data: PlantCareLogCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Create a new plant care log."""
    try:
        care_log = await create_care_log(db, current_user.id, care_log_data)
        return PlantCareLogResponse.from_orm(care_log)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create care log"
        )
@router.get(
    "/",
    response_model=PlantCareLogListResponse,
    summary="Get user's care logs",
    description="Get all care logs for the current user."
)
async def get_my_care_logs(
    plant_id: Optional[UUID] = Query(None, description="Filter by plant ID"),
    care_type: Optional[str] = Query(None, description="Filter by care type"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogListResponse:
    """Get user's care logs with optional filters."""
    try:
        care_logs, total = await get_user_care_logs(
            db, current_user.id, plant_id, care_type, start_date, end_date, skip, limit
        )
        return PlantCareLogListResponse(
            care_logs=[PlantCareLogResponse.from_orm(log) for log in care_logs],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care logs"
        )
@router.get(
    "/plant/{plant_id}",
    response_model=PlantCareLogListResponse,
    summary="Get plant care logs",
    description="Get all care logs for a specific plant."
)
async def get_plant_logs(
    plant_id: UUID,
    care_type: Optional[str] = Query(None, description="Filter by care type"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogListResponse:
    """Get care logs for a specific plant."""
    try:
        care_logs, total = await get_plant_care_logs(
            db, plant_id, current_user.id, care_type, start_date, end_date, skip, limit
        )
        return PlantCareLogListResponse(
            care_logs=[PlantCareLogResponse.from_orm(log) for log in care_logs],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plant care logs"
        )
@router.get(
    "/stats",
    response_model=List[CareTypeStatsResponse],
    summary="Get care statistics",
    description="Get care statistics for the current user."
)
async def get_my_care_stats(
    plant_id: Optional[UUID] = Query(None, description="Filter by plant ID"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[CareTypeStatsResponse]:
    """Get care statistics for the current user."""
    try:
        stats = await get_care_statistics(
            db, current_user.id, plant_id, start_date, end_date
        )
        return [CareTypeStatsResponse(**stat) for stat in stats]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care statistics"
        )
@router.get(
    "/{care_log_id}",
    response_model=PlantCareLogResponse,
    summary="Get care log details",
    description="Get details of a specific care log."
)
async def get_care_log(
    care_log_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Get care log by ID."""
    care_log = await get_care_log_by_id(db, care_log_id, current_user.id)
    if not care_log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Care log not found"
        )
    return PlantCareLogResponse.from_orm(care_log)
@router.put(
    "/{care_log_id}",
    response_model=PlantCareLogResponse,
    summary="Update care log",
    description="Update a care log entry."
)
async def update_plant_care_log(
    care_log_id: UUID,
    care_log_data: PlantCareLogUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Update care log."""
    try:
        care_log = await update_care_log(db, care_log_id, current_user.id, care_log_data)
        if not care_log:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Care log not found"
            )
        return PlantCareLogResponse.from_orm(care_log)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update care log"
        )
@router.delete(
    "/{care_log_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete care log",
    description="Delete a care log entry."
)
async def delete_plant_care_log(
    care_log_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete care log."""
    try:
        success = await delete_care_log(db, care_log_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Care log not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete care log"
        )
# Bulk operations
@router.post(
    "/bulk",
    response_model=List[PlantCareLogResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create multiple care logs",
    description="Create multiple care log entries at once."
)
async def create_bulk_care_logs(
    care_logs_data: List[PlantCareLogCreate],
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[PlantCareLogResponse]:
    """Create multiple care logs."""
    if len(care_logs_data) > 50:  # Limit bulk operations
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot create more than 50 care logs at once"
        )
    try:
        created_logs = []
        for care_log_data in care_logs_data:
            care_log = await create_care_log(db, current_user.id, care_log_data)
            created_logs.append(care_log)
        return [PlantCareLogResponse.from_orm(log) for log in created_logs]
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create care logs"
        )
</file>

<file path="app/api/api_v1/endpoints/plant_identification.py">
"""Plant identification API endpoints.
This module provides REST API endpoints for AI-powered plant identification.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, Query, UploadFile, File, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_identification import (
    PlantIdentificationCreate,
    PlantIdentificationUpdate,
    PlantIdentificationResponse,
    PlantIdentificationListResponse,
    PlantIdentificationResultResponse
)
from app.services.plant_identification_service import (
    create_identification,
    get_identification_by_id,
    get_user_identifications,
    update_identification,
    delete_identification,
    verify_identification,
    get_pending_verifications,
    get_identification_statistics
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantIdentificationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create plant identification",
    description="Submit a plant image for AI identification."
)
async def create_plant_identification(
    identification_data: PlantIdentificationCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Create a new plant identification request."""
    try:
        identification = await create_identification(db, current_user.id, identification_data)
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create identification"
        )
@router.post(
    "/upload",
    response_model=PlantIdentificationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload and identify plant",
    description="Upload a plant image and get AI identification results."
)
async def upload_and_identify(
    file: UploadFile = File(..., description="Plant image file"),
    location: Optional[str] = Query(None, description="Location where photo was taken"),
    notes: Optional[str] = Query(None, description="Additional notes about the plant"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Upload image and create identification request."""
    # Validate file type
    if not file.content_type or not file.content_type.startswith('image/'):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be an image"
        )
    # Validate file size (e.g., max 10MB)
    max_size = 10 * 1024 * 1024  # 10MB
    if file.size and file.size > max_size:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File size too large. Maximum size is 10MB"
        )
    try:
        # In a real implementation, you would:
        # 1. Save the uploaded file to storage (S3, local filesystem, etc.)
        # 2. Call an AI service for plant identification
        # 3. Process the results
        # For now, we'll create a placeholder identification
        # TODO: Implement actual file upload and AI identification
        image_url = f"https://example.com/uploads/{file.filename}"  # Placeholder
        identification_data = PlantIdentificationCreate(
            image_url=image_url,
            location=location,
            notes=notes,
            confidence_score=0.85,  # Placeholder
            identified_species_id=None,  # Would be set by AI service
            ai_suggestions=[
                {
                    "species_name": "Unknown Species",
                    "confidence": 0.85,
                    "scientific_name": "Species unknown"
                }
            ]
        )
        identification = await create_identification(db, current_user.id, identification_data)
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to process identification"
        )
@router.get(
    "/",
    response_model=PlantIdentificationListResponse,
    summary="Get user's identifications",
    description="Get all plant identifications for the current user."
)
async def get_my_identifications(
    status_filter: Optional[str] = Query(None, description="Filter by status (pending, completed, failed)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationListResponse:
    """Get user's plant identifications."""
    try:
        identifications, total = await get_user_identifications(
            db, current_user.id, status_filter, skip, limit
        )
        return PlantIdentificationListResponse(
            identifications=[PlantIdentificationResponse.from_orm(ident) for ident in identifications],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get identifications"
        )
@router.get(
    "/pending",
    response_model=PlantIdentificationListResponse,
    summary="Get pending verifications",
    description="Get plant identifications pending expert verification (admin only)."
)
async def get_pending_identification_verifications(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationListResponse:
    """Get pending identifications for verification (admin only)."""
    # TODO: Add admin role check
    # if not current_user.is_admin:
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Admin access required"
    #     )
    try:
        identifications, total = await get_pending_verifications(db, skip, limit)
        return PlantIdentificationListResponse(
            identifications=[PlantIdentificationResponse.from_orm(ident) for ident in identifications],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get pending verifications"
        )
@router.get(
    "/stats",
    summary="Get identification statistics",
    description="Get statistics about plant identifications."
)
async def get_identification_statistics(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Get identification statistics for the current user."""
    try:
        stats = await get_identification_statistics(db, current_user.id)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get identification statistics"
        )
@router.get(
    "/{identification_id}",
    response_model=PlantIdentificationResponse,
    summary="Get identification details",
    description="Get details of a specific plant identification."
)
async def get_identification(
    identification_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Get identification by ID."""
    identification = await get_identification_by_id(db, identification_id, current_user.id)
    if not identification:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Identification not found"
        )
    return PlantIdentificationResponse.from_orm(identification)
@router.put(
    "/{identification_id}",
    response_model=PlantIdentificationResponse,
    summary="Update identification",
    description="Update plant identification information."
)
async def update_plant_identification(
    identification_id: UUID,
    identification_data: PlantIdentificationUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Update plant identification."""
    try:
        identification = await update_identification(
            db, identification_id, current_user.id, identification_data
        )
        if not identification:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update identification"
        )
@router.post(
    "/{identification_id}/verify",
    response_model=PlantIdentificationResponse,
    summary="Verify identification",
    description="Verify or correct a plant identification (expert/admin only)."
)
async def verify_plant_identification(
    identification_id: UUID,
    verified_species_id: Optional[UUID] = Query(None, description="Correct species ID if different from AI suggestion"),
    verification_notes: Optional[str] = Query(None, description="Verification notes"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Verify plant identification (expert/admin only)."""
    # TODO: Add expert/admin role check
    # if not (current_user.is_expert or current_user.is_admin):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Expert or admin access required"
    #     )
    try:
        identification = await verify_identification(
            db, identification_id, current_user.id, verified_species_id, verification_notes
        )
        if not identification:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to verify identification"
        )
@router.delete(
    "/{identification_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete identification",
    description="Delete a plant identification."
)
async def delete_plant_identification(
    identification_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete plant identification."""
    try:
        success = await delete_identification(db, identification_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete identification"
        )
</file>

<file path="app/api/api_v1/endpoints/plant_questions.py">
"""Plant questions and answers API endpoints.
This module provides REST API endpoints for the plant Q&A community.
"""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_question import (
    PlantQuestionCreate,
    PlantQuestionUpdate,
    PlantAnswerCreate,
    PlantAnswerUpdate,
    PlantQuestionResponse,
    PlantAnswerResponse,
    PlantQuestionListResponse,
    PlantQuestionSearchRequest,
    PlantAnswerVoteRequest
)
from app.services.plant_question_service import (
    get_plant_question_service,
    get_plant_answer_service
)
router = APIRouter()
# Question endpoints
@router.post(
    "/",
    response_model=PlantQuestionResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Ask a question",
    description="Ask a new plant-related question."
)
async def create_question(
    question_data: PlantQuestionCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionResponse:
    """Create a new plant question."""
    try:
        question_service = get_plant_question_service()
        question = await question_service.create_question(db, current_user.id, question_data)
        return PlantQuestionResponse.from_orm(question)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create question"
        )
@router.get(
    "/",
    response_model=PlantQuestionListResponse,
    summary="Search questions",
    description="Search and browse plant questions."
)
async def search_questions(
    query: Optional[str] = Query(None, description="Search query"),
    category: Optional[str] = Query(None, description="Filter by category"),
    species_id: Optional[UUID] = Query(None, description="Filter by plant species"),
    is_solved: Optional[bool] = Query(None, description="Filter by solved status"),
    sort_by: Optional[str] = Query("created_at", description="Sort by field (created_at, votes, answers)"),
    sort_order: Optional[str] = Query("desc", description="Sort order (asc, desc)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantQuestionListResponse:
    """Search plant questions."""
    try:
        search_request = PlantQuestionSearchRequest(
            query=query,
            category=category,
            species_id=species_id,
            is_solved=is_solved,
            sort_by=sort_by,
            sort_order=sort_order
        )
        question_service = get_plant_question_service()
        questions, total = await question_service.search_questions(db, search_request, skip, limit)
        return PlantQuestionListResponse(
            questions=[PlantQuestionResponse.from_orm(q) for q in questions],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search questions"
        )
@router.get(
    "/my-questions",
    response_model=PlantQuestionListResponse,
    summary="Get user's questions",
    description="Get all questions asked by the current user."
)
async def get_my_questions(
    is_solved: Optional[bool] = Query(None, description="Filter by solved status"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionListResponse:
    """Get user's questions."""
    try:
        question_service = get_plant_question_service()
        questions, total = await question_service.get_user_questions(
            db, current_user.id, is_solved, skip, limit
        )
        return PlantQuestionListResponse(
            questions=[PlantQuestionResponse.from_orm(q) for q in questions],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user questions"
        )
@router.get(
    "/{question_id}",
    response_model=PlantQuestionResponse,
    summary="Get question details",
    description="Get details of a specific question with its answers."
)
async def get_question(
    question_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantQuestionResponse:
    """Get question by ID."""
    question_service = get_plant_question_service()
    question = await question_service.get_question_by_id(db, question_id)
    if not question:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Question not found"
        )
    return PlantQuestionResponse.from_orm(question)
@router.put(
    "/{question_id}",
    response_model=PlantQuestionResponse,
    summary="Update question",
    description="Update a question (author only)."
)
async def update_question(
    question_id: UUID,
    question_data: PlantQuestionUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionResponse:
    """Update question."""
    try:
        question_service = get_plant_question_service()
        question = await question_service.update_question(
            db, question_id, current_user.id, question_data
        )
        if not question:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
        return PlantQuestionResponse.from_orm(question)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update question"
        )
@router.post(
    "/{question_id}/solve",
    summary="Mark question as solved",
    description="Mark a question as solved (author only)."
)
async def mark_question_solved(
    question_id: UUID,
    best_answer_id: Optional[UUID] = Query(None, description="ID of the best answer"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Mark question as solved."""
    try:
        question_service = get_plant_question_service()
        success = await question_service.mark_as_solved(
            db, question_id, current_user.id, best_answer_id
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
        return {
            "message": "Question marked as solved",
            "question_id": question_id,
            "best_answer_id": best_answer_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to mark question as solved"
        )
@router.delete(
    "/{question_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete question",
    description="Delete a question (author only)."
)
async def delete_question(
    question_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete question."""
    try:
        question_service = get_plant_question_service()
        success = await question_service.delete_question(db, question_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete question"
        )
# Answer endpoints
@router.post(
    "/{question_id}/answers",
    response_model=PlantAnswerResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Answer a question",
    description="Provide an answer to a plant question."
)
async def create_answer(
    question_id: UUID,
    answer_data: PlantAnswerCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantAnswerResponse:
    """Create an answer to a question."""
    try:
        answer_service = get_plant_answer_service()
        answer = await answer_service.create_answer(db, question_id, current_user.id, answer_data)
        return PlantAnswerResponse.from_orm(answer)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create answer"
        )
@router.get(
    "/{question_id}/answers",
    response_model=List[PlantAnswerResponse],
    summary="Get question answers",
    description="Get all answers for a specific question."
)
async def get_question_answers(
    question_id: UUID,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(50, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> List[PlantAnswerResponse]:
    """Get answers for a question."""
    try:
        answer_service = get_plant_answer_service()
        answers = await answer_service.get_question_answers(db, question_id, skip, limit)
        return [PlantAnswerResponse.from_orm(answer) for answer in answers]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get answers"
        )
@router.put(
    "/answers/{answer_id}",
    response_model=PlantAnswerResponse,
    summary="Update answer",
    description="Update an answer (author only)."
)
async def update_answer(
    answer_id: UUID,
    answer_data: PlantAnswerUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantAnswerResponse:
    """Update answer."""
    try:
        answer_service = get_plant_answer_service()
        answer = await answer_service.update_answer(db, answer_id, current_user.id, answer_data)
        if not answer:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found or access denied"
            )
        return PlantAnswerResponse.from_orm(answer)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update answer"
        )
@router.post(
    "/answers/{answer_id}/vote",
    summary="Vote on answer",
    description="Vote on an answer (upvote or downvote)."
)
async def vote_on_answer(
    answer_id: UUID,
    vote_data: PlantAnswerVoteRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Vote on an answer."""
    try:
        answer_service = get_plant_answer_service()
        success = await answer_service.vote_answer(
            db, answer_id, current_user.id, vote_data.is_upvote
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found"
            )
        return {
            "message": f"{'Upvoted' if vote_data.is_upvote else 'Downvoted'} successfully",
            "answer_id": answer_id,
            "is_upvote": vote_data.is_upvote
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to vote on answer"
        )
@router.delete(
    "/answers/{answer_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete answer",
    description="Delete an answer (author only)."
)
async def delete_answer(
    answer_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete answer."""
    try:
        answer_service = get_plant_answer_service()
        success = await answer_service.delete_answer(db, answer_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete answer"
        )
</file>

<file path="app/api/api_v1/endpoints/plant_species.py">
"""Plant species API endpoints.
This module provides REST API endpoints for managing plant species data.
"""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_species import (
    PlantSpeciesCreate,
    PlantSpeciesUpdate,
    PlantSpeciesResponse,
    PlantSpeciesListResponse
)
from app.services.plant_species_service import (
    create_species,
    get_species_by_id,
    get_species_by_scientific_name,
    search_species,
    update_species,
    delete_species,
    get_popular_species
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantSpeciesResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create plant species",
    description="Create a new plant species. Requires authentication."
)
async def create_plant_species(
    species_data: PlantSpeciesCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantSpeciesResponse:
    """Create a new plant species."""
    try:
        species = await create_species(db, species_data)
        return PlantSpeciesResponse.from_orm(species)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create plant species"
        )
@router.get(
    "/search",
    response_model=PlantSpeciesListResponse,
    summary="Search plant species",
    description="Search plant species by name, care requirements, or other criteria."
)
async def search_plant_species(
    query: Optional[str] = Query(None, description="Search query for species name"),
    care_level: Optional[str] = Query(None, description="Filter by care level"),
    light_requirements: Optional[str] = Query(None, description="Filter by light requirements"),
    water_frequency_days: Optional[int] = Query(None, description="Filter by watering frequency"),
    is_toxic: Optional[bool] = Query(None, description="Filter by toxicity"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesListResponse:
    """Search plant species with filters."""
    try:
        filters = {}
        if care_level:
            filters["care_level"] = care_level
        if light_requirements:
            filters["light_requirements"] = light_requirements
        if water_frequency_days:
            filters["water_frequency_days"] = water_frequency_days
        if is_toxic is not None:
            filters["is_toxic"] = is_toxic
        species_list, total = await search_species(db, query, filters, skip, limit)
        return PlantSpeciesListResponse(
            species=[PlantSpeciesResponse.from_orm(species) for species in species_list],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search plant species"
        )
@router.get(
    "/popular",
    response_model=PlantSpeciesListResponse,
    summary="Get popular plant species",
    description="Get the most popular plant species based on user plants."
)
async def get_popular_plant_species(
    limit: int = Query(10, ge=1, le=50, description="Maximum number of species to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesListResponse:
    """Get popular plant species."""
    try:
        species_list = await get_popular_species(db, limit)
        return PlantSpeciesListResponse(
            species=[PlantSpeciesResponse.from_orm(species) for species in species_list],
            total=len(species_list),
            skip=0,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get popular plant species"
        )
@router.get(
    "/scientific-name/{scientific_name}",
    response_model=PlantSpeciesResponse,
    summary="Get species by scientific name",
    description="Get plant species by scientific name."
)
async def get_species_by_scientific_name_endpoint(
    scientific_name: str,
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesResponse:
    """Get plant species by scientific name."""
    species = await get_species_by_scientific_name(db, scientific_name)
    if not species:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant species not found"
        )
    return PlantSpeciesResponse.from_orm(species)
@router.get(
    "/{species_id}",
    response_model=PlantSpeciesResponse,
    summary="Get plant species by ID",
    description="Get plant species details by ID."
)
async def get_plant_species(
    species_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesResponse:
    """Get plant species by ID."""
    species = await get_species_by_id(db, species_id)
    if not species:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant species not found"
        )
    return PlantSpeciesResponse.from_orm(species)
@router.put(
    "/{species_id}",
    response_model=PlantSpeciesResponse,
    summary="Update plant species",
    description="Update plant species information. Requires authentication."
)
async def update_plant_species(
    species_id: UUID,
    species_data: PlantSpeciesUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantSpeciesResponse:
    """Update plant species."""
    try:
        species = await update_species(db, species_id, species_data)
        if not species:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant species not found"
            )
        return PlantSpeciesResponse.from_orm(species)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update plant species"
        )
@router.delete(
    "/{species_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete plant species",
    description="Delete plant species. Requires authentication."
)
async def delete_plant_species(
    species_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete plant species."""
    try:
        success = await delete_species(db, species_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant species not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete plant species"
        )
</file>

<file path="app/api/api_v1/endpoints/plant_trades.py">
"""Plant trades API endpoints.
This module provides REST API endpoints for the plant trading marketplace.
"""
from typing import List, Optional
from uuid import UUID
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_trade import (
    PlantTradeCreate,
    PlantTradeUpdate,
    PlantTradeResponse,
    PlantTradeListResponse,
    PlantTradeSearchRequest,
    PlantTradeInterestRequest
)
from app.services.plant_trade_service import (
    create_trade,
    get_trade_by_id,
    search_trades,
    get_user_trades,
    update_trade,
    express_interest,
    accept_trade,
    cancel_trade,
    delete_trade,
    get_trade_stats,
    get_popular_trade_species
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantTradeResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create trade listing",
    description="Create a new plant trade listing."
)
async def create_trade_listing(
    trade_data: PlantTradeCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeResponse:
    """Create a new plant trade listing."""
    try:
        trade = await create_trade(db, current_user.id, trade_data)
        return PlantTradeResponse.from_orm(trade)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create trade listing"
        )
@router.get(
    "/",
    response_model=PlantTradeListResponse,
    summary="Search trade listings",
    description="Search and browse plant trade listings."
)
async def search_trade_listings(
    trade_type: Optional[str] = Query(None, description="Filter by trade type (sell, trade, giveaway)"),
    species_id: Optional[UUID] = Query(None, description="Filter by plant species"),
    location: Optional[str] = Query(None, description="Filter by location"),
    min_price: Optional[Decimal] = Query(None, description="Minimum price filter"),
    max_price: Optional[Decimal] = Query(None, description="Maximum price filter"),
    is_available: Optional[bool] = Query(True, description="Filter by availability"),
    sort_by: Optional[str] = Query("created_at", description="Sort by field (created_at, price, title)"),
    sort_order: Optional[str] = Query("desc", description="Sort order (asc, desc)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantTradeListResponse:
    """Search plant trade listings."""
    try:
        search_request = PlantTradeSearchRequest(
            trade_type=trade_type,
            species_id=species_id,
            location=location,
            min_price=min_price,
            max_price=max_price,
            is_available=is_available,
            sort_by=sort_by,
            sort_order=sort_order
        )
        trades, total = await search_trades(db, search_request, skip, limit)
        return PlantTradeListResponse(
            trades=[PlantTradeResponse.from_orm(trade) for trade in trades],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search trade listings"
        )
@router.get(
    "/my-trades",
    response_model=PlantTradeListResponse,
    summary="Get user's trade listings",
    description="Get all trade listings created by the current user."
)
async def get_my_trades(
    is_available: Optional[bool] = Query(None, description="Filter by availability"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeListResponse:
    """Get user's trade listings."""
    try:
        trades, total = await get_user_trades(db, current_user.id, is_available, skip, limit)
        return PlantTradeListResponse(
            trades=[PlantTradeResponse.from_orm(trade) for trade in trades],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user trades"
        )
@router.get(
    "/stats",
    summary="Get trade statistics",
    description="Get marketplace statistics."
)
async def get_marketplace_stats(
    db: AsyncSession = Depends(get_db)
) -> dict:
    """Get marketplace statistics."""
    try:
        stats = await get_trade_stats(db)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get trade statistics"
        )
@router.get(
    "/popular-species",
    summary="Get popular trade species",
    description="Get most popular plant species in trades."
)
async def get_popular_species(
    limit: int = Query(10, ge=1, le=50, description="Maximum number of species to return"),
    db: AsyncSession = Depends(get_db)
) -> List[dict]:
    """Get popular species in trades."""
    try:
        popular_species = await get_popular_trade_species(db, limit)
        return popular_species
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get popular species"
        )
@router.get(
    "/{trade_id}",
    response_model=PlantTradeResponse,
    summary="Get trade details",
    description="Get details of a specific trade listing."
)
async def get_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantTradeResponse:
    """Get trade listing by ID."""
    trade = await get_trade_by_id(db, trade_id)
    if not trade:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Trade listing not found"
        )
    return PlantTradeResponse.from_orm(trade)
@router.put(
    "/{trade_id}",
    response_model=PlantTradeResponse,
    summary="Update trade listing",
    description="Update a trade listing (owner only)."
)
async def update_trade_listing(
    trade_id: UUID,
    trade_data: PlantTradeUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeResponse:
    """Update trade listing."""
    try:
        trade = await update_trade(db, trade_id, current_user.id, trade_data)
        if not trade:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return PlantTradeResponse.from_orm(trade)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update trade listing"
        )
@router.post(
    "/{trade_id}/interest",
    summary="Express interest",
    description="Express interest in a trade listing."
)
async def express_trade_interest(
    trade_id: UUID,
    interest_data: PlantTradeInterestRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Express interest in a trade listing."""
    try:
        success = await express_interest(
            db, trade_id, current_user.id, interest_data.message, interest_data.offered_plant_id
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or not available"
            )
        return {
            "message": "Interest expressed successfully",
            "trade_id": trade_id,
            "user_id": current_user.id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to express interest"
        )
@router.post(
    "/{trade_id}/accept",
    summary="Accept trade",
    description="Accept a trade offer (owner only)."
)
async def accept_trade_offer(
    trade_id: UUID,
    interested_user_id: UUID = Query(..., description="ID of the user whose offer to accept"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Accept a trade offer."""
    try:
        success = await accept_trade(db, trade_id, current_user.id, interested_user_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return {
            "message": "Trade accepted successfully",
            "trade_id": trade_id,
            "accepted_user_id": interested_user_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to accept trade"
        )
@router.post(
    "/{trade_id}/cancel",
    summary="Cancel trade",
    description="Cancel a trade listing (owner only)."
)
async def cancel_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Cancel trade listing."""
    try:
        success = await cancel_trade(db, trade_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return {
            "message": "Trade cancelled successfully",
            "trade_id": trade_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to cancel trade"
        )
@router.delete(
    "/{trade_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete trade listing",
    description="Delete a trade listing (owner only)."
)
async def delete_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete trade listing."""
    try:
        success = await delete_trade(db, trade_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete trade listing"
        )
</file>

<file path="app/api/api_v1/endpoints/stories.py">
"""Story endpoints.
This module provides endpoints for creating, viewing, and managing
ephemeral stories that disappear after 24 hours.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.story import StoryCreate, StoryRead, StoryViewCreate
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.story_service import (
    create_story,
    get_user_stories,
    get_friends_stories,
    get_story_by_id,
    view_story,
    delete_story,
    get_story_views
)
from app.services.file_service import upload_media_file
from app.models.user import User
from app.schemas.story import StoryType
router = APIRouter()
@router.post("/", response_model=StoryRead, status_code=status.HTTP_201_CREATED)
async def create_story_endpoint(
    file: UploadFile = File(...),
    caption: Optional[str] = None,
    privacy_level: str = "friends",
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new story.
    Args:
        file: Media file for the story (image or video)
        caption: Optional caption for the story
        privacy_level: Privacy level (public, friends, close_friends)
        current_user: Current authenticated user
        db: Database session
    Returns:
        StoryRead: Created story
    Raises:
        HTTPException: If file upload fails or invalid privacy level
    """
    # Validate privacy level
    valid_privacy_levels = ["public", "friends", "close_friends"]
    if privacy_level not in valid_privacy_levels:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid privacy level. Must be one of: {valid_privacy_levels}"
        )
    # Upload media file
    try:
        media_url, file_size, duration = await upload_media_file(file)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to upload media: {str(e)}"
        )
    # Determine story type based on file type
    content_type = file.content_type or ""
    if content_type.startswith("image/"):
        story_type = StoryType.IMAGE
    elif content_type.startswith("video/"):
        story_type = StoryType.VIDEO
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unsupported media type. Only images and videos are allowed."
        )
    # Create story data
    story_data = StoryCreate(
        content_type=story_type,
        media_url=media_url,
        caption=caption,
        file_size=file_size,
        duration=duration,
        privacy_level=privacy_level
    )
    # Create story
    story = await create_story(db, current_user.id, story_data)
    return StoryRead.from_orm(story)
@router.get("/feed", response_model=List[StoryRead])
async def get_stories_feed(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get stories feed from friends.
    Args:
        limit: Maximum number of stories to return
        offset: Number of stories to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of stories from friends
    """
    stories = await get_friends_stories(db, current_user.id, limit, offset)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/user/{user_id}", response_model=List[StoryRead])
async def get_user_stories_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get stories from a specific user.
    Args:
        user_id: ID of the user whose stories to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of user's stories
    Note: Only returns stories that the current user is allowed to see
    based on privacy settings and friendship status.
    """
    stories = await get_user_stories(db, user_id, viewer_id=current_user.id)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/my-stories", response_model=List[StoryRead])
async def get_my_stories(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get current user's own stories.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of current user's stories
    """
    stories = await get_user_stories(db, current_user.id, viewer_id=current_user.id, include_all=True)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/{story_id}", response_model=StoryRead)
async def get_story(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific story by ID.
    Args:
        story_id: ID of the story to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        StoryRead: Story data
    Raises:
        HTTPException: If story not found or not authorized to view
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found or not authorized to view"
        )
    return StoryRead.from_orm(story)
@router.post("/{story_id}/view")
async def view_story_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Mark a story as viewed.
    Args:
        story_id: ID of the story to mark as viewed
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized to view
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found or not authorized to view"
        )
    # Don't record views for own stories
    if str(story.user_id) == str(current_user.id):
        return {"message": "Story viewed (own story)"}
    await view_story(db, story_id, current_user.id)
    return {"message": "Story viewed successfully"}
@router.get("/{story_id}/views")
async def get_story_views_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get views for a story.
    Args:
        story_id: ID of the story to get views for
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Story views data
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can see views
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view story analytics"
        )
    views = await get_story_views(db, story_id)
    return {
        "story_id": story_id,
        "total_views": len(views),
        "views": views
    }
@router.delete("/{story_id}")
async def delete_story_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a story.
    Args:
        story_id: ID of the story to delete
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can delete
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to delete this story"
        )
    await delete_story(db, story_id)
    return {"message": "Story deleted successfully"}
@router.get("/archive/my-stories", response_model=List[StoryRead])
async def get_archived_stories(
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get current user's archived stories.
    Args:
        limit: Maximum number of stories to return
        offset: Number of stories to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of archived stories
    Note: This would return stories that have expired but been
    saved to the user's archive.
    """
    # TODO: Implement archived stories functionality
    return []
@router.post("/{story_id}/archive")
async def archive_story(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Archive a story before it expires.
    Args:
        story_id: ID of the story to archive
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can archive
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to archive this story"
        )
    # TODO: Implement story archiving logic
    return {"message": "Story archived successfully"}
</file>

<file path="app/api/api_v1/endpoints/user_plants.py">
"""User plants API endpoints.
This module provides REST API endpoints for managing user's individual plants.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.user_plant import (
    UserPlantCreate,
    UserPlantUpdate,
    UserPlantResponse,
    UserPlantListResponse,
    PlantCareReminderResponse
)
from app.services.user_plant_service import (
    create_plant,
    get_plant_by_id,
    get_user_plants,
    update_plant,
    delete_plant,
    get_care_reminders,
    update_care_activity,
    get_plant_stats
)
router = APIRouter()
@router.post(
    "/",
    response_model=UserPlantResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add new plant",
    description="Add a new plant to user's collection."
)
async def create_user_plant(
    plant_data: UserPlantCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Create a new user plant."""
    try:
        plant = await create_plant(db, current_user.id, plant_data)
        return UserPlantResponse.from_orm(plant)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create plant"
        )
@router.get(
    "/",
    response_model=UserPlantListResponse,
    summary="Get user's plants",
    description="Get all plants owned by the current user."
)
async def get_my_plants(
    is_active: Optional[bool] = Query(True, description="Filter by active status"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantListResponse:
    """Get user's plants."""
    try:
        plants, total = await get_user_plants(db, current_user.id, is_active, skip, limit)
        return UserPlantListResponse(
            plants=[UserPlantResponse.from_orm(plant) for plant in plants],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plants"
        )
@router.get(
    "/stats",
    summary="Get plant statistics",
    description="Get statistics about user's plant collection."
)
async def get_my_plant_stats(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Get plant statistics for the current user."""
    try:
        stats = await get_plant_stats(db, current_user.id)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plant statistics"
        )
@router.get(
    "/care-reminders",
    response_model=List[PlantCareReminderResponse],
    summary="Get care reminders",
    description="Get care reminders for user's plants."
)
async def get_my_care_reminders(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[PlantCareReminderResponse]:
    """Get care reminders for user's plants."""
    try:
        reminders = await get_care_reminders(db, current_user.id)
        return [PlantCareReminderResponse(**reminder) for reminder in reminders]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care reminders"
        )
@router.get(
    "/{plant_id}",
    response_model=UserPlantResponse,
    summary="Get plant details",
    description="Get details of a specific plant owned by the user."
)
async def get_user_plant(
    plant_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Get user plant by ID."""
    plant = await get_plant_by_id(db, plant_id, current_user.id)
    if not plant:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant not found"
        )
    return UserPlantResponse.from_orm(plant)
@router.put(
    "/{plant_id}",
    response_model=UserPlantResponse,
    summary="Update plant",
    description="Update plant information."
)
async def update_user_plant(
    plant_id: UUID,
    plant_data: UserPlantUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Update user plant."""
    try:
        plant = await update_plant(db, plant_id, current_user.id, plant_data)
        if not plant:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
        return UserPlantResponse.from_orm(plant)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update plant"
        )
@router.post(
    "/{plant_id}/care",
    summary="Record care activity",
    description="Record a care activity for the plant (watering, fertilizing, etc.)."
)
async def record_care_activity(
    plant_id: UUID,
    care_type: str = Query(..., description="Type of care activity"),
    care_date: Optional[datetime] = Query(None, description="Date of care activity (defaults to now)"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Record care activity for a plant."""
    try:
        success = await update_care_activity(
            db, plant_id, current_user.id, care_type, care_date
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
        return {
            "message": f"Care activity '{care_type}' recorded successfully",
            "plant_id": plant_id,
            "care_type": care_type,
            "care_date": care_date or datetime.utcnow()
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record care activity"
        )
@router.delete(
    "/{plant_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove plant",
    description="Remove plant from user's collection (soft delete)."
)
async def delete_user_plant(
    plant_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete user plant."""
    try:
        success = await delete_plant(db, plant_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete plant"
        )
# Public endpoint for viewing other users' plants (optional)
@router.get(
    "/user/{user_id}",
    response_model=UserPlantListResponse,
    summary="Get user's public plants",
    description="Get public plants owned by a specific user."
)
async def get_user_public_plants(
    user_id: UUID,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> UserPlantListResponse:
    """Get public plants owned by a specific user."""
    try:
        # Only get active plants for public viewing
        plants, total = await get_user_plants(db, user_id, True, skip, limit)
        return UserPlantListResponse(
            plants=[UserPlantResponse.from_orm(plant) for plant in plants],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user plants"
        )
</file>

<file path="app/api/api_v1/endpoints/users.py">
"""User management endpoints.
This module provides endpoints for user profile management,
user discovery, and user-related operations.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.user import UserRead, UserUpdate, UserSearch
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.user_service import (
    get_user_by_id,
    get_user_by_username,
    search_users,
    update_user_profile,
    get_user_stats
)
from app.models.user import User
router = APIRouter()
@router.get("/search", response_model=List[UserSearch])
async def search_users_endpoint(
    q: str = Query(..., min_length=2, description="Search query (username, display name)"),
    limit: int = Query(20, ge=1, le=50, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Search for users by username or display name.
    Args:
        q: Search query string
        limit: Maximum number of results to return
        offset: Number of results to skip for pagination
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of matching users
    """
    users = await search_users(db, query=q, limit=limit, offset=offset, exclude_user_id=current_user.id)
    return [UserSearch.from_orm(user) for user in users]
@router.get("/username/{username}", response_model=UserRead)
async def get_user_by_username_endpoint(
    username: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user profile by username.
    Args:
        username: Username to look up
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: User profile data
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_username(db, username)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserRead.from_orm(user)
@router.get("/{user_id}", response_model=UserRead)
async def get_user_by_id_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user profile by ID.
    Args:
        user_id: User ID to look up
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: User profile data
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserRead.from_orm(user)
@router.put("/{user_id}", response_model=UserRead)
async def update_user_profile_endpoint(
    user_id: str,
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update user profile.
    Args:
        user_id: User ID to update
        user_update: User update data
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: Updated user profile
    Raises:
        HTTPException: If user not found or unauthorized
    """
    # Check if user exists
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # Check if current user can update this profile
    if str(current_user.id) != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to update this profile"
        )
    # Update profile
    updated_user = await update_user_profile(db, user, user_update)
    return UserRead.from_orm(updated_user)
@router.get("/{user_id}/stats")
async def get_user_stats_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user statistics (friends count, stories count, etc.).
    Args:
        user_id: User ID to get stats for
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: User statistics
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    stats = await get_user_stats(db, user_id)
    return stats
@router.get("/discover/suggestions", response_model=List[UserSearch])
async def get_user_suggestions(
    limit: int = Query(10, ge=1, le=20, description="Maximum number of suggestions"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user suggestions for friend recommendations.
    Args:
        limit: Maximum number of suggestions to return
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of suggested users
    Note: This is a basic implementation. In production, this would
    use more sophisticated algorithms based on mutual friends,
    interests, location, etc.
    """
    # For now, return random users excluding current user and existing friends
    # TODO: Implement sophisticated recommendation algorithm
    users = await search_users(
        db, 
        query="", 
        limit=limit, 
        offset=0, 
        exclude_user_id=current_user.id,
        random_order=True
    )
    return [UserSearch.from_orm(user) for user in users]
@router.post("/{user_id}/block")
async def block_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Block a user.
    Args:
        user_id: User ID to block
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or trying to block self
    """
    if str(current_user.id) == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot block yourself"
        )
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # TODO: Implement blocking logic in friendship service
    return {"message": f"User {user.username} has been blocked"}
@router.delete("/{user_id}/block")
async def unblock_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unblock a user.
    Args:
        user_id: User ID to unblock
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # TODO: Implement unblocking logic in friendship service
    return {"message": f"User {user.username} has been unblocked"}
@router.get("/blocked/list", response_model=List[UserSearch])
async def get_blocked_users(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of blocked users.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of blocked users
    """
    # TODO: Implement get blocked users logic
    return []
</file>

<file path="app/api/api_v1/endpoints/websocket.py">
"""WebSocket endpoints.
This module provides WebSocket endpoints for real-time communication,
including messaging, typing indicators, and live updates.
"""
import json
from typing import Dict, Any
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.websocket import websocket_manager as manager
from app.services.auth_service import get_current_user_from_token
from app.services.message_service import create_message
from app.services.friendship_service import check_friendship_status
from app.schemas.message import MessageCreate
from app.schemas.message import MessageType
router = APIRouter()
@router.websocket("/connect/{token}")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """WebSocket connection endpoint for real-time communication.
    Args:
        websocket: WebSocket connection
        token: Authentication token
        db: Database session
    Note: This endpoint handles real-time messaging, typing indicators,
    and other live updates between users.
    """
    # Authenticate user
    try:
        user = await get_current_user_from_token(token, db)
        if not user:
            await websocket.close(code=4001, reason="Invalid token")
            return
    except Exception:
        await websocket.close(code=4001, reason="Authentication failed")
        return
    # Accept connection and add to manager
    await websocket.accept()
    await manager.connect(websocket, str(user.id))
    try:
        # Send connection confirmation
        await manager.send_personal_message(
            {
                "type": "connection_established",
                "user_id": str(user.id),
                "message": "Connected successfully"
            },
            str(user.id)
        )
        # Listen for messages
        while True:
            # Receive message from client
            data = await websocket.receive_text()
            try:
                message_data = json.loads(data)
                await handle_websocket_message(message_data, user.id, db)
            except json.JSONDecodeError:
                await manager.send_personal_message(
                    {
                        "type": "error",
                        "message": "Invalid JSON format"
                    },
                    str(user.id)
                )
            except Exception as e:
                await manager.send_personal_message(
                    {
                        "type": "error",
                        "message": f"Error processing message: {str(e)}"
                    },
                    str(user.id)
                )
    except WebSocketDisconnect:
        # Handle disconnection
        await manager.disconnect(str(user.id))
        print(f"User {user.username} disconnected")
    except Exception as e:
        # Handle other errors
        print(f"WebSocket error for user {user.username}: {str(e)}")
        await manager.disconnect(str(user.id))
async def handle_websocket_message(
    message_data: Dict[str, Any],
    user_id: str,
    db: AsyncSession
):
    """Handle incoming WebSocket messages.
    Args:
        message_data: Parsed message data from client
        user_id: ID of the user sending the message
        db: Database session
    """
    message_type = message_data.get("type")
    if message_type == "send_message":
        await handle_send_message(message_data, user_id, db)
    elif message_type == "typing_start":
        await handle_typing_indicator(message_data, user_id, True)
    elif message_type == "typing_stop":
        await handle_typing_indicator(message_data, user_id, False)
    elif message_type == "message_read":
        await handle_message_read(message_data, user_id, db)
    elif message_type == "ping":
        await handle_ping(user_id)
    else:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": f"Unknown message type: {message_type}"
            },
            user_id
        )
async def handle_send_message(
    message_data: Dict[str, Any],
    sender_id: str,
    db: AsyncSession
):
    """Handle sending a message through WebSocket.
    Args:
        message_data: Message data from client
        sender_id: ID of the user sending the message
        db: Database session
    """
    try:
        recipient_id = message_data.get("recipient_id")
        content = message_data.get("content")
        if not recipient_id or not content:
            await manager.send_personal_message(
                {
                    "type": "error",
                    "message": "Missing recipient_id or content"
                },
                sender_id
            )
            return
        # Check if users are friends
        friendship_status = await check_friendship_status(db, sender_id, recipient_id)
        if friendship_status != "accepted":
            await manager.send_personal_message(
                {
                    "type": "error",
                    "message": "Can only send messages to friends"
                },
                sender_id
            )
            return
        # Create message in database
        message_create = MessageCreate(
            recipient_id=recipient_id,
            content_type=MessageType.TEXT,
            content=content,
            disappears_at=message_data.get("disappears_at")
        )
        message = await create_message(db, sender_id, message_create)
        # Send message to recipient if online
        await manager.send_personal_message(
            {
                "type": "new_message",
                "message": message.to_dict()
            },
            recipient_id
        )
        # Send confirmation to sender
        await manager.send_personal_message(
            {
                "type": "message_sent",
                "message": message.to_dict()
            },
            sender_id
        )
    except Exception as e:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": f"Failed to send message: {str(e)}"
            },
            sender_id
        )
async def handle_typing_indicator(
    message_data: Dict[str, Any],
    user_id: str,
    is_typing: bool
):
    """Handle typing indicators.
    Args:
        message_data: Message data from client
        user_id: ID of the user typing
        is_typing: Whether user is typing or stopped typing
    """
    recipient_id = message_data.get("recipient_id")
    if not recipient_id:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": "Missing recipient_id for typing indicator"
            },
            user_id
        )
        return
    # Send typing indicator to recipient
    await manager.send_personal_message(
        {
            "type": "typing_indicator",
            "user_id": user_id,
            "is_typing": is_typing
        },
        recipient_id
    )
async def handle_message_read(
    message_data: Dict[str, Any],
    user_id: str,
    db: AsyncSession
):
    """Handle message read receipts.
    Args:
        message_data: Message data from client
        user_id: ID of the user who read the message
        db: Database session
    """
    message_id = message_data.get("message_id")
    if not message_id:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": "Missing message_id for read receipt"
            },
            user_id
        )
        return
    # TODO: Update message read status in database
    # For now, just send read receipt to sender
    sender_id = message_data.get("sender_id")
    if sender_id:
        await manager.send_personal_message(
            {
                "type": "message_read",
                "message_id": message_id,
                "read_by": user_id
            },
            sender_id
        )
async def handle_ping(user_id: str):
    """Handle ping messages for connection health check.
    Args:
        user_id: ID of the user sending ping
    """
    await manager.send_personal_message(
        {
            "type": "pong",
            "timestamp": manager.get_current_timestamp()
        },
        user_id
    )
@router.get("/active-users")
async def get_active_users():
    """Get list of currently active users.
    Returns:
        dict: List of active user IDs
    Note: This endpoint is for debugging/monitoring purposes.
    In production, you might want to restrict access.
    """
    active_users = list(manager.active_connections.keys())
    return {
        "active_users": active_users,
        "total_connections": len(active_users)
    }
@router.post("/broadcast")
async def broadcast_message(
    message: str,
    user_ids: list = None
):
    """Broadcast a message to specific users or all connected users.
    Args:
        message: Message to broadcast
        user_ids: Optional list of user IDs to send to (if None, sends to all)
    Returns:
        dict: Success message
    Note: This endpoint is for admin/system messages.
    In production, you'd want proper authentication and authorization.
    """
    broadcast_data = {
        "type": "system_message",
        "message": message,
        "timestamp": manager.get_current_timestamp()
    }
    if user_ids:
        # Send to specific users
        for user_id in user_ids:
            await manager.send_personal_message(broadcast_data, user_id)
    else:
        # Send to all connected users
        await manager.broadcast(broadcast_data)
    return {"message": "Broadcast sent successfully"}
</file>

<file path="app/core/config.py">
"""Application configuration settings.
This module defines all configuration settings for the FastAPI application,
including database connections, authentication, and external service settings.
"""
import secrets
from typing import Any, Dict, List, Optional, Union
from pydantic import AnyHttpUrl, EmailStr, HttpUrl, PostgresDsn, field_validator
from pydantic_settings import BaseSettings
class Settings(BaseSettings):
    """Application settings loaded from environment variables."""
    # Basic app settings
    PROJECT_NAME: str = "Plant Social API"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    SECRET_KEY: str = secrets.token_urlsafe(32)
    # Security settings
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8  # 8 days
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 30 days
    ALGORITHM: str = "HS256"
    # CORS settings
    BACKEND_CORS_ORIGINS: str = "http://localhost:3000,http://localhost:8000,http://localhost:8080,http://127.0.0.1:3000"
    ALLOWED_HOSTS: str = "localhost,127.0.0.1"
    def get_cors_origins(self) -> List[str]:
        """Parse CORS origins from string."""
        if isinstance(self.BACKEND_CORS_ORIGINS, str):
            return [origin.strip() for origin in self.BACKEND_CORS_ORIGINS.split(",") if origin.strip()]
        return []
    def get_allowed_hosts(self) -> List[str]:
        """Parse allowed hosts from string."""
        if isinstance(self.ALLOWED_HOSTS, str):
            return [host.strip() for host in self.ALLOWED_HOSTS.split(",") if host.strip()]
        return []
    # Database settings
    POSTGRES_SERVER: str = "localhost"
    POSTGRES_USER: str = "postgres"
    POSTGRES_PASSWORD: str = "password"
    POSTGRES_DB: str = "plant_social_db"
    POSTGRES_PORT: str = "5432"
    SQLALCHEMY_DATABASE_URI: Optional[PostgresDsn] = None
    @field_validator("SQLALCHEMY_DATABASE_URI", mode="before")
    @classmethod
    def assemble_db_connection(cls, v: Optional[str], info) -> Any:
        """Assemble database connection string."""
        if isinstance(v, str):
            return v
        values = info.data if hasattr(info, 'data') else {}
        # Construct URL manually to avoid PostgresDsn issues
        user = values.get("POSTGRES_USER", "postgres")
        password = values.get("POSTGRES_PASSWORD", "password")
        host = values.get("POSTGRES_SERVER", "localhost")
        port = values.get("POSTGRES_PORT", "5432")
        db = values.get("POSTGRES_DB", "plant_social_db")
        return f"postgresql+asyncpg://{user}:{password}@{host}:{port}/{db}"
    # Redis settings
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    REDIS_PASSWORD: Optional[str] = None
    # AWS S3 settings
    AWS_ACCESS_KEY_ID: Optional[str] = None
    AWS_SECRET_ACCESS_KEY: Optional[str] = None
    AWS_REGION: str = "us-east-1"
    AWS_ENDPOINT_URL: Optional[str] = None
    S3_BUCKET_NAME: Optional[str] = None
    CLOUDFRONT_DOMAIN: Optional[str] = None
    # OpenAI settings (for future phases)
    OPENAI_API_KEY: Optional[str] = None
    # Email settings (for future use)
    SMTP_TLS: bool = True
    SMTP_PORT: Optional[int] = None
    SMTP_HOST: Optional[str] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None
    EMAILS_FROM_EMAIL: Optional[EmailStr] = None
    EMAILS_FROM_NAME: Optional[str] = None
    # Testing
    TESTING: bool = False
    model_config = {
        "case_sensitive": True,
        "env_file": ".env"
    }
settings = Settings()
</file>

<file path="app/core/database.py">
"""Database configuration and session management.
This module sets up the SQLAlchemy async engine, session factory,
and base model class for the application.
"""
from sqlalchemy import MetaData, text
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import NullPool
from app.core.config import settings
# Create base model class with naming convention
convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}
metadata = MetaData(naming_convention=convention)
Base = declarative_base(metadata=metadata)
# Note: Model imports are handled in app/models/__init__.py to avoid circular imports
# Create async engine
engine = create_async_engine(
    str(settings.SQLALCHEMY_DATABASE_URI),
    poolclass=NullPool,
    echo=True,  # Enable SQL query logging for debugging
)
# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)
async def get_db() -> AsyncSession:
    """Dependency to get database session.
    Yields:
        AsyncSession: Database session instance
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
async def init_db() -> None:
    """Initialize database tables.
    This function creates all tables defined in the models.
    Should be called during application startup.
    """
    async with engine.begin() as conn:
        # Enable vector extension
        await conn.execute(text('CREATE EXTENSION IF NOT EXISTS vector;'))
        # Create all tables
        await conn.run_sync(Base.metadata.create_all)
async def close_db() -> None:
    """Close database connections.
    Should be called during application shutdown.
    """
    await engine.dispose()
</file>

<file path="app/core/websocket.py">
"""WebSocket connection manager for real-time messaging.
This module handles WebSocket connections, message broadcasting,
and real-time communication between users.
"""
import json
import logging
from typing import Dict, List, Optional
from uuid import UUID
from fastapi import WebSocket, WebSocketDisconnect
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import AsyncSessionLocal
from app.models.user import User
from app.services.auth_service import get_current_user_from_token
logger = logging.getLogger(__name__)
class ConnectionManager:
    """Manages WebSocket connections for real-time messaging."""
    def __init__(self):
        # Store active connections: {user_id: websocket}
        self.active_connections: Dict[str, WebSocket] = {}
        # Store user sessions: {websocket: user_id}
        self.user_sessions: Dict[WebSocket, str] = {}
    async def connect(self, websocket: WebSocket, user_id: str) -> bool:
        """Accept a WebSocket connection and register the user.
        Args:
            websocket: The WebSocket connection
            user_id: The authenticated user's ID
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            await websocket.accept()
            # Disconnect existing connection for this user if any
            if user_id in self.active_connections:
                old_websocket = self.active_connections[user_id]
                await self.disconnect(old_websocket)
            # Register new connection
            self.active_connections[user_id] = websocket
            self.user_sessions[websocket] = user_id
            logger.info(f"User {user_id} connected via WebSocket")
            # Send connection confirmation
            await self.send_personal_message(
                {
                    "type": "connection_established",
                    "message": "Connected successfully",
                    "user_id": user_id
                },
                websocket
            )
            return True
        except Exception as e:
            logger.error(f"Error connecting user {user_id}: {e}")
            return False
    async def disconnect(self, websocket: WebSocket) -> None:
        """Disconnect a WebSocket and clean up.
        Args:
            websocket: The WebSocket connection to disconnect
        """
        try:
            user_id = self.user_sessions.get(websocket)
            if user_id:
                # Remove from active connections
                self.active_connections.pop(user_id, None)
                self.user_sessions.pop(websocket, None)
                logger.info(f"User {user_id} disconnected from WebSocket")
            # Close the connection
            await websocket.close()
        except Exception as e:
            logger.error(f"Error disconnecting WebSocket: {e}")
    async def send_personal_message(self, message: dict, websocket: WebSocket) -> bool:
        """Send a message to a specific WebSocket connection.
        Args:
            message: The message data to send
            websocket: The target WebSocket connection
        Returns:
            bool: True if message sent successfully, False otherwise
        """
        try:
            await websocket.send_text(json.dumps(message))
            return True
        except Exception as e:
            logger.error(f"Error sending message: {e}")
            # Connection might be broken, clean it up
            await self.disconnect(websocket)
            return False
    async def send_message_to_user(self, message: dict, user_id: str) -> bool:
        """Send a message to a specific user by user ID.
        Args:
            message: The message data to send
            user_id: The target user's ID
        Returns:
            bool: True if message sent successfully, False otherwise
        """
        websocket = self.active_connections.get(user_id)
        if websocket:
            return await self.send_personal_message(message, websocket)
        return False
    async def broadcast_to_users(self, message: dict, user_ids: List[str]) -> int:
        """Broadcast a message to multiple users.
        Args:
            message: The message data to send
            user_ids: List of user IDs to send the message to
        Returns:
            int: Number of users who received the message
        """
        sent_count = 0
        for user_id in user_ids:
            if await self.send_message_to_user(message, user_id):
                sent_count += 1
        return sent_count
    def get_connected_users(self) -> List[str]:
        """Get list of currently connected user IDs.
        Returns:
            List[str]: List of connected user IDs
        """
        return list(self.active_connections.keys())
    def is_user_connected(self, user_id: str) -> bool:
        """Check if a user is currently connected.
        Args:
            user_id: The user ID to check
        Returns:
            bool: True if user is connected, False otherwise
        """
        return user_id in self.active_connections
    async def handle_message(self, websocket: WebSocket, data: str) -> None:
        """Handle incoming WebSocket message.
        Args:
            websocket: The WebSocket connection
            data: The raw message data
        """
        try:
            message = json.loads(data)
            user_id = self.user_sessions.get(websocket)
            if not user_id:
                await self.send_personal_message(
                    {"type": "error", "message": "User not authenticated"},
                    websocket
                )
                return
            message_type = message.get("type")
            if message_type == "ping":
                await self.send_personal_message(
                    {"type": "pong", "timestamp": message.get("timestamp")},
                    websocket
                )
            elif message_type == "typing":
                # Handle typing indicators
                recipient_id = message.get("recipient_id")
                if recipient_id:
                    await self.send_message_to_user(
                        {
                            "type": "typing",
                            "sender_id": user_id,
                            "is_typing": message.get("is_typing", False)
                        },
                        recipient_id
                    )
            else:
                logger.warning(f"Unknown message type: {message_type}")
        except json.JSONDecodeError:
            await self.send_personal_message(
                {"type": "error", "message": "Invalid JSON format"},
                websocket
            )
        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await self.send_personal_message(
                {"type": "error", "message": "Internal server error"},
                websocket
            )
# Global connection manager instance
websocket_manager = ConnectionManager()
</file>

<file path="app/main.py">
"""Main FastAPI application entry point.
This module initializes the FastAPI app with all necessary middleware,
routers, and configurations for the plant social platform.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
from pathlib import Path
from app.core.config import settings
from app.core.database import engine
from app.api.api_v1.api import api_router
from app.core.websocket import websocket_manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager for startup and shutdown events."""
    # Startup
    print("Starting Plant Social API...")
    # Initialize database tables
    from app.core.database import init_db
    await init_db()
    print("Database initialized successfully")
    yield
    # Shutdown
    print("Shutting down Plant Social API...")
    from app.core.database import close_db
    await close_db()
def create_application() -> FastAPI:
    """Create and configure the FastAPI application.
    Returns:
        FastAPI: Configured FastAPI application instance
    """
    app = FastAPI(
        title=settings.PROJECT_NAME,
        version=settings.VERSION,
        description="AI-Enhanced Plant Care Community API",
        openapi_url=f"{settings.API_V1_STR}/openapi.json",
        lifespan=lifespan,
    )
    # Set all CORS enabled origins
    cors_origins = settings.get_cors_origins()
    if cors_origins:
        app.add_middleware(
            CORSMiddleware,
            allow_origins=cors_origins,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    # Add trusted host middleware
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=settings.get_allowed_hosts(),
    )
    # Include API router
    app.include_router(api_router, prefix=settings.API_V1_STR)
    # Mount static files for media uploads
    uploads_dir = Path("uploads")
    uploads_dir.mkdir(exist_ok=True)
    app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")
    return app
app = create_application()
@app.get("/")
async def root():
    """Root endpoint for health check."""
    return {
        "message": "Plant Social API",
        "version": settings.VERSION,
        "status": "healthy"
    }
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}
</file>

<file path="app/models/__init__.py">
"""Models package initialization.
This module imports all database models to ensure they are
registered with SQLAlchemy when the package is imported.
"""
from app.models.user import User
from app.models.message import Message
from app.models.story import Story, StoryView
from app.models.friendship import Friendship, FriendshipStatus
from app.models.plant_species import PlantSpecies
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_photo import PlantPhoto
from app.models.plant_identification import PlantIdentification
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_question import PlantQuestion, PlantAnswer
from app.models.plant_achievement import PlantAchievement, UserAchievement, PlantMilestone, UserStats
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent, UserNurseryFavorite
__all__ = [
    "User",
    "Message", 
    "Story",
    "StoryView",
    "Friendship",
    "FriendshipStatus",
    "PlantSpecies",
    "UserPlant",
    "PlantCareLog",
    "PlantPhoto",
    "PlantIdentification",
    "PlantTrade",
    "TradeStatus",
    "TradeType",
    "PlantQuestion",
    "PlantAnswer",
    "PlantAchievement",
    "UserAchievement", 
    "PlantMilestone",
    "UserStats",
    "LocalNursery",
    "NurseryReview",
    "NurseryEvent",
    "UserNurseryFavorite",
]
</file>

<file path="app/models/friendship.py">
"""Friendship model for managing user relationships.
This module defines the Friendship model for handling friend requests,
connections, and social relationships between users.
"""
import uuid
from datetime import datetime
from enum import Enum
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, String, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class FriendshipStatus(str, Enum):
    """Enumeration of friendship statuses."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    BLOCKED = "blocked"
class Friendship(Base):
    """Friendship model for managing user relationships.
    Handles friend requests, accepted friendships, and blocking.
    Each friendship is directional but creates bidirectional relationships.
    """
    __tablename__ = "friendships"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationships
    requester_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    addressee_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Friendship status
    status = Column(String(20), default=FriendshipStatus.PENDING, nullable=False)
    # Metadata
    is_close_friend = Column(Boolean, default=False)  # For story privacy
    is_blocked = Column(Boolean, default=False)
    blocked_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    accepted_at = Column(DateTime, nullable=True)
    blocked_at = Column(DateTime, nullable=True)
    # Relationships
    requester = relationship("User", foreign_keys=[requester_id], backref="sent_friend_requests")
    addressee = relationship("User", foreign_keys=[addressee_id], backref="received_friend_requests")
    blocked_by = relationship("User", foreign_keys=[blocked_by_id])
    # Ensure unique friendship pairs
    __table_args__ = (
        UniqueConstraint('requester_id', 'addressee_id', name='unique_friendship'),
    )
    def __repr__(self) -> str:
        """String representation of the friendship."""
        return f"<Friendship(requester={self.requester_id}, addressee={self.addressee_id}, status={self.status})>"
    @property
    def is_pending(self) -> bool:
        """Check if friendship request is pending.
        Returns:
            bool: True if status is pending, False otherwise
        """
        return self.status == FriendshipStatus.PENDING
    @property
    def is_accepted(self) -> bool:
        """Check if friendship is accepted.
        Returns:
            bool: True if status is accepted, False otherwise
        """
        return self.status == FriendshipStatus.ACCEPTED
    @property
    def is_declined(self) -> bool:
        """Check if friendship request was declined.
        Returns:
            bool: True if status is declined, False otherwise
        """
        return self.status == FriendshipStatus.DECLINED
    def accept(self) -> None:
        """Accept the friendship request."""
        self.status = FriendshipStatus.ACCEPTED
        self.accepted_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    def decline(self) -> None:
        """Decline the friendship request."""
        self.status = FriendshipStatus.DECLINED
        self.updated_at = datetime.utcnow()
    def block(self, blocked_by_user_id: uuid.UUID) -> None:
        """Block the user relationship.
        Args:
            blocked_by_user_id: ID of the user who initiated the block
        """
        self.status = FriendshipStatus.BLOCKED
        self.is_blocked = True
        self.blocked_by_id = blocked_by_user_id
        self.blocked_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    def unblock(self) -> None:
        """Unblock the user relationship."""
        self.is_blocked = False
        self.blocked_by_id = None
        self.blocked_at = None
        self.status = FriendshipStatus.DECLINED  # Reset to declined state
        self.updated_at = datetime.utcnow()
    def toggle_close_friend(self) -> None:
        """Toggle close friend status."""
        self.is_close_friend = not self.is_close_friend
        self.updated_at = datetime.utcnow()
    def get_other_user_id(self, current_user_id: uuid.UUID) -> uuid.UUID:
        """Get the other user's ID in the friendship.
        Args:
            current_user_id: ID of the current user
        Returns:
            UUID: ID of the other user in the friendship
        """
        if current_user_id == self.requester_id:
            return self.addressee_id
        return self.requester_id
    def is_user_involved(self, user_id: uuid.UUID) -> bool:
        """Check if a user is involved in this friendship.
        Args:
            user_id: ID of the user to check
        Returns:
            bool: True if user is involved, False otherwise
        """
        return user_id in [self.requester_id, self.addressee_id]
    def to_dict(self, current_user_id: Optional[uuid.UUID] = None) -> dict:
        """Convert friendship to dictionary for API responses.
        Args:
            current_user_id: ID of the current user viewing the friendship
        Returns:
            dict: Friendship data
        """
        data = {
            "id": str(self.id),
            "requester_id": str(self.requester_id),
            "addressee_id": str(self.addressee_id),
            "status": self.status,
            "is_close_friend": self.is_close_friend,
            "is_blocked": self.is_blocked,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "accepted_at": self.accepted_at.isoformat() if self.accepted_at else None,
        }
        # Add context for current user
        if current_user_id:
            data["other_user_id"] = str(self.get_other_user_id(current_user_id))
            data["is_requester"] = current_user_id == self.requester_id
            data["can_accept"] = (
                current_user_id == self.addressee_id and 
                self.status == FriendshipStatus.PENDING
            )
        return data
    @classmethod
    def create_friendship_request(
        cls, 
        requester_id: uuid.UUID, 
        addressee_id: uuid.UUID
    ) -> "Friendship":
        """Create a new friendship request.
        Args:
            requester_id: ID of the user sending the request
            addressee_id: ID of the user receiving the request
        Returns:
            Friendship: New friendship instance
        """
        return cls(
            requester_id=requester_id,
            addressee_id=addressee_id,
            status=FriendshipStatus.PENDING
        )
</file>

<file path="app/models/local_nursery.py">
"""Local nursery database model.
This module defines models for local nurseries and garden centers.
"""
from datetime import datetime, time
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, Float, JSON, Time, Integer, ForeignKey
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class LocalNursery(Base):
    """Local nursery model for garden centers and plant shops."""
    __tablename__ = "local_nurseries"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    name = Column(String(200), nullable=False)
    description = Column(Text)
    # Location information
    address = Column(String(500))
    city = Column(String(100))
    state = Column(String(50))
    country = Column(String(50))
    postal_code = Column(String(20))
    latitude = Column(Float)
    longitude = Column(Float)
    # Contact information
    phone = Column(String(20))
    email = Column(String(100))
    website = Column(String(200))
    # Business information
    business_type = Column(String(50))  # nursery, garden_center, plant_shop, greenhouse
    specialties = Column(JSON)  # List of specialties like ["houseplants", "succulents", "native_plants"]
    services = Column(JSON)  # List of services like ["delivery", "consultation", "repotting"]
    # Operating hours (JSON format for flexibility)
    operating_hours = Column(JSON)  # {"monday": {"open": "08:00", "close": "18:00"}, ...}
    # Ratings and verification
    average_rating = Column(Float, default=0.0)
    total_reviews = Column(Integer, default=0)
    is_verified = Column(Boolean, default=False)
    verified_at = Column(DateTime)
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    reviews = relationship("NurseryReview", back_populates="nursery")
    events = relationship("NurseryEvent", back_populates="nursery")
    def __repr__(self) -> str:
        return f"<LocalNursery(id={self.id}, name='{self.name}', city='{self.city}')>"
class NurseryReview(Base):
    """Nursery review model for user feedback."""
    __tablename__ = "nursery_reviews"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    rating = Column(Integer, nullable=False)  # 1-5 stars
    title = Column(String(200))
    review_text = Column(Text)
    # Review categories
    plant_quality_rating = Column(Integer)  # 1-5
    service_rating = Column(Integer)  # 1-5
    price_rating = Column(Integer)  # 1-5
    selection_rating = Column(Integer)  # 1-5
    # Tags for categorization
    tags = Column(JSON)  # ["helpful_staff", "good_prices", "wide_selection"]
    # Verification
    is_verified_purchase = Column(Boolean, default=False)
    visit_date = Column(DateTime)
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    nursery = relationship("LocalNursery", back_populates="reviews")
    user = relationship("User", back_populates="nursery_reviews")
    def __repr__(self) -> str:
        return f"<NurseryReview(id={self.id}, nursery_id={self.nursery_id}, rating={self.rating})>"
class NurseryEvent(Base):
    """Nursery event model for workshops and special events."""
    __tablename__ = "nursery_events"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    event_type = Column(String(50))  # workshop, sale, plant_swap, consultation
    # Scheduling
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime)
    start_time = Column(Time)
    end_time = Column(Time)
    is_recurring = Column(Boolean, default=False)
    recurrence_pattern = Column(JSON)  # For recurring events
    # Event details
    max_participants = Column(Integer)
    current_participants = Column(Integer, default=0)
    price = Column(Float, default=0.0)
    skill_level = Column(String(20))  # beginner, intermediate, advanced, all
    # Requirements and materials
    requirements = Column(Text)  # What participants should bring
    materials_provided = Column(Text)  # What the nursery provides
    # Registration
    requires_registration = Column(Boolean, default=True)
    registration_deadline = Column(DateTime)
    contact_info = Column(String(200))
    # Status
    is_active = Column(Boolean, default=True)
    is_cancelled = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    nursery = relationship("LocalNursery", back_populates="events")
    def __repr__(self) -> str:
        return f"<NurseryEvent(id={self.id}, title='{self.title}', start_date={self.start_date})>"
class UserNurseryFavorite(Base):
    """User favorite nurseries model."""
    __tablename__ = "user_nursery_favorites"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    notes = Column(Text)  # Personal notes about the nursery
    last_visited = Column(DateTime)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="favorite_nurseries")
    nursery = relationship("LocalNursery")
    def __repr__(self) -> str:
        return f"<UserNurseryFavorite(id={self.id}, user_id={self.user_id}, nursery_id={self.nursery_id})>"
</file>

<file path="app/models/message.py">
"""Message model for real-time messaging system.
This module defines the Message model for handling ephemeral
and persistent messages between users.
"""
import uuid
from datetime import datetime
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class Message(Base):
    """Message model for user-to-user communication.
    Supports both text messages and media messages with
    disappearing functionality similar to Snapchat.
    """
    __tablename__ = "messages"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationships
    sender_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    recipient_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Message content
    content_type = Column(String(20), nullable=False)  # text, image, video, audio
    text_content = Column(Text, nullable=True)  # For text messages
    media_url = Column(String(500), nullable=True)  # For media messages
    media_thumbnail_url = Column(String(500), nullable=True)  # Thumbnail for videos
    # Message metadata
    caption = Column(Text, nullable=True)  # Caption for media messages
    duration = Column(Integer, nullable=True)  # Duration for video/audio in seconds
    file_size = Column(Integer, nullable=True)  # File size in bytes
    # Disappearing message settings
    disappear_after = Column(Integer, nullable=True)  # Seconds after viewing
    is_disappearing = Column(Boolean, default=False)
    # Message status
    is_delivered = Column(Boolean, default=False)
    is_viewed = Column(Boolean, default=False)
    is_deleted = Column(Boolean, default=False)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    delivered_at = Column(DateTime, nullable=True)
    viewed_at = Column(DateTime, nullable=True)
    expires_at = Column(DateTime, nullable=True)  # When message should be deleted
    deleted_at = Column(DateTime, nullable=True)
    # Relationships
    sender = relationship("User", foreign_keys=[sender_id], backref="sent_messages")
    recipient = relationship("User", foreign_keys=[recipient_id], backref="received_messages")
    def __repr__(self) -> str:
        """String representation of the message."""
        return f"<Message(id={self.id}, sender={self.sender_id}, type={self.content_type})>"
    @property
    def is_expired(self) -> bool:
        """Check if the message has expired.
        Returns:
            bool: True if message has expired, False otherwise
        """
        if not self.expires_at:
            return False
        return datetime.utcnow() > self.expires_at
    @property
    def is_media(self) -> bool:
        """Check if the message contains media.
        Returns:
            bool: True if message is media type, False otherwise
        """
        return self.content_type in ["image", "video", "audio"]
    def mark_as_delivered(self) -> None:
        """Mark the message as delivered."""
        if not self.is_delivered:
            self.is_delivered = True
            self.delivered_at = datetime.utcnow()
    def mark_as_viewed(self) -> None:
        """Mark the message as viewed and set expiration if disappearing."""
        if not self.is_viewed:
            self.is_viewed = True
            self.viewed_at = datetime.utcnow()
            # Set expiration time for disappearing messages
            if self.is_disappearing and self.disappear_after:
                from datetime import timedelta
                self.expires_at = datetime.utcnow() + timedelta(seconds=self.disappear_after)
    def soft_delete(self) -> None:
        """Soft delete the message."""
        self.is_deleted = True
        self.deleted_at = datetime.utcnow()
    def to_dict(self, include_content: bool = True) -> dict:
        """Convert message to dictionary for API responses.
        Args:
            include_content: Whether to include message content
        Returns:
            dict: Message data
        """
        data = {
            "id": str(self.id),
            "sender_id": str(self.sender_id),
            "recipient_id": str(self.recipient_id),
            "content_type": self.content_type,
            "is_disappearing": self.is_disappearing,
            "disappear_after": self.disappear_after,
            "is_delivered": self.is_delivered,
            "is_viewed": self.is_viewed,
            "is_deleted": self.is_deleted,
            "created_at": self.created_at.isoformat(),
            "delivered_at": self.delivered_at.isoformat() if self.delivered_at else None,
            "viewed_at": self.viewed_at.isoformat() if self.viewed_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
        }
        # Include content only if not expired and requested
        if include_content and not self.is_expired and not self.is_deleted:
            data.update({
                "text_content": self.text_content,
                "media_url": self.media_url,
                "media_thumbnail_url": self.media_thumbnail_url,
                "caption": self.caption,
                "duration": self.duration,
                "file_size": self.file_size,
            })
        return data
    def to_notification_dict(self) -> dict:
        """Convert message to dictionary for push notifications.
        Returns:
            dict: Notification data
        """
        return {
            "id": str(self.id),
            "sender_id": str(self.sender_id),
            "content_type": self.content_type,
            "preview": self._get_preview_text(),
            "created_at": self.created_at.isoformat(),
        }
    def _get_preview_text(self) -> str:
        """Get preview text for notifications.
        Returns:
            str: Preview text based on message type
        """
        if self.content_type == "text":
            return self.text_content[:50] + "..." if len(self.text_content or "") > 50 else self.text_content or ""
        elif self.content_type == "image":
            return " Photo"
        elif self.content_type == "video":
            return " Video"
        elif self.content_type == "audio":
            return " Audio"
        else:
            return "Message"
</file>

<file path="app/models/plant_achievement.py">
"""Plant achievement database model.
This module defines models for tracking user achievements and milestones
in their plant care journey.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, ForeignKey, Integer, JSON
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantAchievement(Base):
    """Plant achievement model for tracking user milestones."""
    __tablename__ = "plant_achievements"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    achievement_type = Column(String(50), nullable=False)  # care_streak, plant_collection, identification, etc.
    title = Column(String(100), nullable=False)
    description = Column(Text)
    icon = Column(String(50))  # emoji or icon name
    badge_color = Column(String(20), default="green")
    points = Column(Integer, default=0)
    unlock_criteria = Column(JSON)  # JSON criteria for unlocking
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user_achievements = relationship("UserAchievement", back_populates="achievement")
    def __repr__(self) -> str:
        return f"<PlantAchievement(id={self.id}, title='{self.title}', type='{self.achievement_type}')>"
class UserAchievement(Base):
    """User achievement model for tracking earned achievements."""
    __tablename__ = "user_achievements"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    achievement_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_achievements.id"), nullable=False)
    earned_at = Column(DateTime, default=datetime.utcnow)
    progress_data = Column(JSON)  # JSON data for tracking progress
    is_featured = Column(Boolean, default=False)  # Whether to feature on profile
    # Relationships
    user = relationship("User", back_populates="achievements")
    achievement = relationship("PlantAchievement", back_populates="user_achievements")
    def __repr__(self) -> str:
        return f"<UserAchievement(id={self.id}, user_id={self.user_id}, achievement_id={self.achievement_id})>"
class PlantMilestone(Base):
    """Plant milestone model for tracking plant-specific achievements."""
    __tablename__ = "plant_milestones"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    milestone_type = Column(String(50), nullable=False)  # first_flower, one_year_old, propagated, etc.
    title = Column(String(100), nullable=False)
    description = Column(Text)
    achieved_at = Column(DateTime, default=datetime.utcnow)
    photo_url = Column(String(500))  # Optional photo of the milestone
    notes = Column(Text)
    # Relationships
    plant = relationship("UserPlant", back_populates="milestones")
    def __repr__(self) -> str:
        return f"<PlantMilestone(id={self.id}, plant_id={self.plant_id}, type='{self.milestone_type}')>"
class UserStats(Base):
    """User statistics model for tracking overall plant care stats."""
    __tablename__ = "user_stats"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, unique=True)
    # Plant collection stats
    total_plants = Column(Integer, default=0)
    active_plants = Column(Integer, default=0)
    plants_identified = Column(Integer, default=0)
    # Care activity stats
    total_care_logs = Column(Integer, default=0)
    care_streak_days = Column(Integer, default=0)
    longest_care_streak = Column(Integer, default=0)
    last_care_activity = Column(DateTime)
    # Community stats
    questions_asked = Column(Integer, default=0)
    questions_answered = Column(Integer, default=0)
    helpful_answers = Column(Integer, default=0)
    trades_completed = Column(Integer, default=0)
    # Achievement stats
    total_achievements = Column(Integer, default=0)
    total_points = Column(Integer, default=0)
    level = Column(Integer, default=1)
    # Timestamps
    last_updated = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="stats")
    def __repr__(self) -> str:
        return f"<UserStats(id={self.id}, user_id={self.user_id}, level={self.level})>"
</file>

<file path="app/models/plant_care_log.py">
"""Plant care log database model.
This module defines the PlantCareLog model for tracking care activities
performed on user plants.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantCareLog(Base):
    """Plant care log model for tracking care activities."""
    __tablename__ = "plant_care_logs"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    care_type = Column(String(50), nullable=False)  # watering, fertilizing, repotting, pruning, etc.
    notes = Column(Text)
    performed_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    plant = relationship("UserPlant", back_populates="care_logs")
    def __repr__(self) -> str:
        return f"<PlantCareLog(id={self.id}, care_type='{self.care_type}', plant_id={self.plant_id})>"
</file>

<file path="app/models/plant_identification.py">
"""Plant identification database model.
This module defines the PlantIdentification model for storing
AI-powered plant identification results.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Float, Boolean
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantIdentification(Base):
    """Plant identification model for AI identification results."""
    __tablename__ = "plant_identifications"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=True)
    image_path = Column(String(500), nullable=False)
    confidence_score = Column(Float)
    identified_name = Column(String(255))
    is_verified = Column(Boolean, default=False)
    verification_notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User")
    species = relationship("PlantSpecies", back_populates="identifications")
    def __repr__(self) -> str:
        return f"<PlantIdentification(id={self.id}, identified_name='{self.identified_name}', confidence={self.confidence_score})>"
</file>

<file path="app/models/plant_photo.py">
"""Plant photo database model.
This module defines the PlantPhoto model for storing plant images
and progress photos.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantPhoto(Base):
    """Plant photo model for storing plant images."""
    __tablename__ = "plant_photos"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    file_path = Column(String(500), nullable=False)
    caption = Column(Text)
    is_progress_photo = Column(Boolean, default=False)
    taken_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    plant = relationship("UserPlant", back_populates="photos")
    def __repr__(self) -> str:
        return f"<PlantPhoto(id={self.id}, plant_id={self.plant_id}, file_path='{self.file_path}')>"
</file>

<file path="app/models/plant_question.py">
"""Plant question database model.
This module defines the PlantQuestion and PlantAnswer models
for the Q&A community functionality.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean, Integer
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantQuestion(Base):
    """Plant question model for Q&A functionality."""
    __tablename__ = "plant_questions"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=True)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    image_paths = Column(Text)  # JSON array of image paths
    tags = Column(Text)  # JSON array of tags
    is_solved = Column(Boolean, default=False)
    view_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    user = relationship("User")
    species = relationship("PlantSpecies", back_populates="questions")
    answers = relationship("PlantAnswer", back_populates="question")
    def __repr__(self) -> str:
        return f"<PlantQuestion(id={self.id}, title='{self.title}', user_id={self.user_id})>"
class PlantAnswer(Base):
    """Plant answer model for Q&A functionality."""
    __tablename__ = "plant_answers"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    question_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_questions.id"), nullable=False)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    is_accepted = Column(Boolean, default=False)
    upvotes = Column(Integer, default=0)
    downvotes = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    question = relationship("PlantQuestion", back_populates="answers")
    user = relationship("User")
    def __repr__(self) -> str:
        return f"<PlantAnswer(id={self.id}, question_id={self.question_id}, user_id={self.user_id})>"
</file>

<file path="app/models/plant_species.py">
"""Plant species database model.
This module defines the PlantSpecies model for storing plant species information
including care requirements, toxicity info, and other plant characteristics.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Integer, Text, DateTime, Boolean, ARRAY
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantSpecies(Base):
    """Plant species model for storing plant information."""
    __tablename__ = "plant_species"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    scientific_name = Column(String(255), nullable=False, unique=True)
    common_names = Column(ARRAY(String), nullable=False, default=[])
    family = Column(String(100))
    care_level = Column(String(20))  # easy, moderate, difficult
    light_requirements = Column(String(50))
    water_frequency_days = Column(Integer)
    humidity_preference = Column(String(20))
    temperature_range = Column(String(50))
    toxicity_info = Column(Text)
    care_notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user_plants = relationship("UserPlant", back_populates="species")
    identifications = relationship("PlantIdentification", back_populates="species")
    trades = relationship("PlantTrade", back_populates="species")
    questions = relationship("PlantQuestion", back_populates="species")
    def __repr__(self) -> str:
        return f"<PlantSpecies(id={self.id}, scientific_name='{self.scientific_name}')>"
</file>

<file path="app/models/plant_trade.py">
"""Plant trade database model.
This module defines the PlantTrade model for the plant trading
marketplace functionality.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from enum import Enum
from app.core.database import Base
class TradeStatus(str, Enum):
    """Trade status enumeration."""
    AVAILABLE = "available"
    PENDING = "pending"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
class TradeType(str, Enum):
    """Trade type enumeration."""
    TRADE = "trade"
    SELL = "sell"
    GIVE_AWAY = "give_away"
class PlantTrade(Base):
    """Plant trade model for marketplace functionality."""
    __tablename__ = "plant_trades"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    owner_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    trade_type = Column(SQLEnum(TradeType), nullable=False)
    status = Column(SQLEnum(TradeStatus), default=TradeStatus.AVAILABLE)
    location = Column(String(100))
    price = Column(String(50))  # Can be "Free", "$10", "Trade only", etc.
    image_paths = Column(Text)  # JSON array of image paths
    interested_user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    completed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    owner = relationship("User", foreign_keys=[owner_id])
    interested_user = relationship("User", foreign_keys=[interested_user_id])
    species = relationship("PlantSpecies", back_populates="trades")
    def __repr__(self) -> str:
        return f"<PlantTrade(id={self.id}, title='{self.title}', trade_type='{self.trade_type}')>"
</file>

<file path="app/models/story.py">
"""Story model for ephemeral content sharing.
This module defines the Story model for 24-hour disappearing
content similar to Snapchat stories.
"""
import uuid
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class Story(Base):
    """Story model for 24-hour ephemeral content.
    Stories are visible to friends for 24 hours and then
    automatically expire and are deleted.
    """
    __tablename__ = "stories"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationship
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Content
    content_type = Column(String(20), nullable=False)  # image, video
    media_url = Column(String(500), nullable=False)
    thumbnail_url = Column(String(500), nullable=True)
    caption = Column(Text, nullable=True)
    # Media metadata
    duration = Column(Integer, nullable=True)  # For videos, in seconds
    file_size = Column(Integer, nullable=True)  # File size in bytes
    # Privacy settings
    privacy_level = Column(String(20), default="friends")  # friends, public, custom
    # Story status
    is_active = Column(Boolean, default=True)
    is_archived = Column(Boolean, default=False)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    archived_at = Column(DateTime, nullable=True)
    # Relationships
    user = relationship("User", backref="stories")
    views = relationship("StoryView", back_populates="story", cascade="all, delete-orphan")
    def __init__(self, **kwargs):
        """Initialize story with automatic expiration time."""
        super().__init__(**kwargs)
        if not self.expires_at:
            self.expires_at = datetime.utcnow() + timedelta(hours=24)
    def __repr__(self) -> str:
        """String representation of the story."""
        return f"<Story(id={self.id}, user={self.user_id}, type={self.content_type})>"
    @property
    def is_expired(self) -> bool:
        """Check if the story has expired.
        Returns:
            bool: True if story has expired, False otherwise
        """
        return datetime.utcnow() > self.expires_at
    @property
    def view_count(self) -> int:
        """Get the number of views for this story.
        Returns:
            int: Number of unique views
        """
        return len(self.views)
    @property
    def time_remaining(self) -> Optional[timedelta]:
        """Get time remaining before story expires.
        Returns:
            timedelta: Time remaining, or None if expired
        """
        if self.is_expired:
            return None
        return self.expires_at - datetime.utcnow()
    def archive(self) -> None:
        """Archive the story."""
        self.is_archived = True
        self.archived_at = datetime.utcnow()
    def deactivate(self) -> None:
        """Deactivate the story (soft delete)."""
        self.is_active = False
    def to_dict(self, viewer_id: Optional[str] = None) -> dict:
        """Convert story to dictionary for API responses.
        Args:
            viewer_id: ID of the user viewing the story
        Returns:
            dict: Story data
        """
        data = {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "content_type": self.content_type,
            "media_url": self.media_url,
            "thumbnail_url": self.thumbnail_url,
            "caption": self.caption,
            "duration": self.duration,
            "privacy_level": self.privacy_level,
            "view_count": self.view_count,
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat(),
            "time_remaining_seconds": int(self.time_remaining.total_seconds()) if self.time_remaining else 0,
            "is_expired": self.is_expired,
        }
        # Add viewer-specific information
        if viewer_id:
            data["has_viewed"] = any(view.viewer_id == uuid.UUID(viewer_id) for view in self.views)
        return data
class StoryView(Base):
    """Story view tracking model.
    Tracks when users view stories for analytics
    and to show view status to story creators.
    """
    __tablename__ = "story_views"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Relationships
    story_id = Column(UUID(as_uuid=True), ForeignKey("stories.id"), nullable=False)
    viewer_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Timestamps
    viewed_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    # Relationships
    story = relationship("Story", back_populates="views")
    viewer = relationship("User", backref="story_views")
    def __repr__(self) -> str:
        """String representation of the story view."""
        return f"<StoryView(story={self.story_id}, viewer={self.viewer_id})>"
    def to_dict(self) -> dict:
        """Convert story view to dictionary.
        Returns:
            dict: Story view data
        """
        return {
            "id": str(self.id),
            "story_id": str(self.story_id),
            "viewer_id": str(self.viewer_id),
            "viewed_at": self.viewed_at.isoformat(),
        }
</file>

<file path="app/models/user_plant.py">
"""User plant database model.
This module defines the UserPlant model for tracking individual plants
owned by users, including care schedules and plant health status.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class UserPlant(Base):
    """User plant model for tracking individual plants."""
    __tablename__ = "user_plants"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=False)
    nickname = Column(String(100))
    location = Column(String(100))  # e.g., "Living room window", "Bedroom"
    acquired_date = Column(DateTime)
    last_watered = Column(DateTime)
    last_fertilized = Column(DateTime)
    last_repotted = Column(DateTime)
    health_status = Column(String(20), default="healthy")  # healthy, sick, recovering, dead
    notes = Column(Text)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="plants")
    species = relationship("PlantSpecies", back_populates="user_plants")
    care_logs = relationship("PlantCareLog", back_populates="plant")
    photos = relationship("PlantPhoto", back_populates="plant")
    milestones = relationship("PlantMilestone", back_populates="plant")
    def __repr__(self) -> str:
        return f"<UserPlant(id={self.id}, nickname='{self.nickname}', user_id={self.user_id})>"
</file>

<file path="app/models/user.py">
"""User model and authentication setup.
This module defines the User model and integrates with FastAPI-Users
for authentication and user management.
"""
import uuid
from datetime import datetime
from typing import Optional
from fastapi_users.db import SQLAlchemyBaseUserTableUUID
from sqlalchemy import Boolean, Column, DateTime, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class User(SQLAlchemyBaseUserTableUUID, Base):
    """User model with authentication and profile information.
    Extends FastAPI-Users base user table with additional fields
    for the plant social platform.
    """
    __tablename__ = "users"
    # Additional profile fields
    username = Column(String(50), unique=True, nullable=False, index=True)
    display_name = Column(String(100), nullable=True)
    bio = Column(Text, nullable=True)
    profile_picture_url = Column(String(500), nullable=True)
    # Plant-specific profile fields
    gardening_experience = Column(String(20), nullable=True)  # beginner, intermediate, expert
    favorite_plants = Column(Text, nullable=True)  # JSON array of plant names
    location = Column(String(100), nullable=True)
    # Privacy and preferences
    is_private = Column(Boolean, default=False)
    allow_plant_identification = Column(Boolean, default=True)
    allow_friend_requests = Column(Boolean, default=True)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_active = Column(DateTime, nullable=True)
    # Relationships (will be defined in other models)
    # sent_messages = relationship("Message", foreign_keys="Message.sender_id", back_populates="sender")
    # received_messages = relationship("Message", foreign_keys="Message.recipient_id", back_populates="recipient")
    # stories = relationship("Story", back_populates="user")
    # sent_friend_requests = relationship("Friendship", foreign_keys="Friendship.requester_id")
    # received_friend_requests = relationship("Friendship", foreign_keys="Friendship.addressee_id")
    # Plant-related relationships
    plants = relationship("UserPlant", back_populates="user")
    achievements = relationship("UserAchievement", back_populates="user")
    stats = relationship("UserStats", back_populates="user", uselist=False)
    nursery_reviews = relationship("NurseryReview", back_populates="user")
    favorite_nurseries = relationship("UserNurseryFavorite", back_populates="user")
    def __repr__(self) -> str:
        """String representation of the user."""
        return f"<User(id={self.id}, username={self.username}, email={self.email})>"
    @property
    def full_name(self) -> str:
        """Get the user's display name or username."""
        return self.display_name or self.username
    def to_dict(self) -> dict:
        """Convert user to dictionary for API responses.
        Returns:
            dict: User data excluding sensitive information
        """
        return {
            "id": str(self.id),
            "username": self.username,
            "display_name": self.display_name,
            "bio": self.bio,
            "profile_picture_url": self.profile_picture_url,
            "gardening_experience": self.gardening_experience,
            "location": self.location,
            "is_private": self.is_private,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_active": self.last_active.isoformat() if self.last_active else None,
        }
    def to_public_dict(self) -> dict:
        """Convert user to public dictionary (limited information).
        Returns:
            dict: Public user data for display to other users
        """
        return {
            "id": str(self.id),
            "username": self.username,
            "display_name": self.display_name,
            "profile_picture_url": self.profile_picture_url,
            "gardening_experience": self.gardening_experience,
            "location": self.location if not self.is_private else None,
        }
</file>

<file path="app/schemas/__init__.py">
"""Schemas package.
This module makes all Pydantic schemas available for import.
"""
from .auth import (
    UserBase,
    UserCreate,
    UserUpdate,
    UserRead,
    UserInDB,
    Token,
    TokenData,
    PasswordReset,
    PasswordResetConfirm,
    EmailVerification,
    ChangePassword,
    LoginRequest,
    RefreshTokenRequest,
    LogoutRequest,
)
from .user import (
    UserBase as UserSchemaBase,
    UserRead as UserSchemaRead,
    UserSearch,
    UserPublicResponse,
    UserUpdate as UserSchemaUpdate,
    UserProfile,
    UserStats,
    UserPreferences,
    UserActivity,
    UserBlock,
    UserReport,
    UserSearchFilters,
    UserBatchOperation,
)
from .message import (
    MessageType,
    MessageStatus,
    MessageBase,
    MessageCreate,
    MessageUpdate,
    MessageRead,
    MessageThread,
    MessageReaction,
    MessageReactionCreate,
    MessageSearch,
    MessageDeliveryStatus,
    MessageBatch,
    PlantIdentificationMessage,
    PlantCareMessage,
    MessageAnalytics,
)
from .story import (
    StoryType,
    StoryPrivacyLevel,
    StoryBase,
    StoryCreate,
    StoryUpdate,
    StoryRead,
    StoryViewCreate,
    StoryView,
    StoryFeed,
    StoryHighlight,
    StoryHighlightCreate,
    StoryHighlightUpdate,
    PlantStoryData,
    StoryAnalytics,
    StorySearch,
    StoryBatch,
)
from .friendship import (
    FriendshipStatus,
    FriendshipBase,
    FriendRequestCreate,
    FriendshipRead,
    FriendshipUpdate,
    FriendProfile,
    FriendsList,
    FriendRequestsList,
    MutualFriends,
    FriendshipStats,
    FriendSuggestion,
    FriendActivity,
    BlockedUser,
    FriendshipSearch,
    FriendshipBatch,
    FriendshipNotification,
    FriendshipAnalytics,
)
from .plant_species import (
    PlantSpeciesBase,
    PlantSpeciesCreate,
    PlantSpeciesUpdate,
    PlantSpeciesResponse,
    PlantSpeciesListResponse,
)
from .user_plant import (
    UserPlantBase,
    UserPlantCreate,
    UserPlantUpdate,
    UserPlantResponse,
    UserPlantListResponse,
    PlantCareReminderResponse,
)
from .plant_care_log import (
    PlantCareLogBase,
    PlantCareLogCreate,
    PlantCareLogUpdate,
    PlantCareLogResponse,
    PlantCareLogListResponse,
    CareTypeStatsResponse,
)
from .plant_identification import (
    PlantIdentificationBase,
    PlantIdentificationCreate,
    PlantIdentificationUpdate,
    PlantIdentificationResponse,
    PlantIdentificationListResponse,
    PlantIdentificationResultResponse,
)
from .plant_trade import (
    PlantTradeBase,
    PlantTradeCreate,
    PlantTradeUpdate,
    PlantTradeResponse,
    PlantTradeListResponse,
    PlantTradeSearchRequest,
    PlantTradeInterestRequest,
)
from .plant_question import (
    PlantQuestionBase,
    PlantQuestionCreate,
    PlantQuestionUpdate,
    PlantAnswerBase,
    PlantAnswerCreate,
    PlantAnswerUpdate,
    PlantAnswerResponse,
    PlantQuestionResponse,
    PlantQuestionListResponse,
    PlantQuestionSearchRequest,
    PlantAnswerVoteRequest,
)
__all__ = [
    # Auth schemas
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserRead",
    "UserInDB",
    "Token",
    "TokenData",
    "PasswordReset",
    "PasswordResetConfirm",
    "EmailVerification",
    "ChangePassword",
    "LoginRequest",
    "RefreshTokenRequest",
    "LogoutRequest",
    # User schemas
    "UserSchemaBase",
    "UserSchemaRead",
    "UserSearch",
    "UserPublicResponse",
    "UserSchemaUpdate",
    "UserProfile",
    "UserStats",
    "UserPreferences",
    "UserActivity",
    "UserBlock",
    "UserReport",
    "UserSearchFilters",
    "UserBatchOperation",
    # Message schemas
    "MessageType",
    "MessageStatus",
    "MessageBase",
    "MessageCreate",
    "MessageUpdate",
    "MessageRead",
    "MessageThread",
    "MessageReaction",
    "MessageReactionCreate",
    "MessageSearch",
    "MessageDeliveryStatus",
    "MessageBatch",
    "PlantIdentificationMessage",
    "PlantCareMessage",
    "MessageAnalytics",
    # Story schemas
    "StoryType",
    "StoryPrivacyLevel",
    "StoryBase",
    "StoryCreate",
    "StoryUpdate",
    "StoryRead",
    "StoryViewCreate",
    "StoryView",
    "StoryFeed",
    "StoryHighlight",
    "StoryHighlightCreate",
    "StoryHighlightUpdate",
    "PlantStoryData",
    "StoryAnalytics",
    "StorySearch",
    "StoryBatch",
    # Friendship schemas
    "FriendshipStatus",
    "FriendshipBase",
    "FriendRequestCreate",
    "FriendshipRead",
    "FriendshipUpdate",
    "FriendProfile",
    "FriendsList",
    "FriendRequestsList",
    "MutualFriends",
    "FriendshipStats",
    "FriendSuggestion",
    "FriendActivity",
    "BlockedUser",
    "FriendshipSearch",
    "FriendshipBatch",
    "FriendshipNotification",
    "FriendshipAnalytics",
    # Plant species schemas
    "PlantSpeciesBase",
    "PlantSpeciesCreate",
    "PlantSpeciesUpdate",
    "PlantSpeciesResponse",
    "PlantSpeciesListResponse",
    # User plant schemas
    "UserPlantBase",
    "UserPlantCreate",
    "UserPlantUpdate",
    "UserPlantResponse",
    "UserPlantListResponse",
    "PlantCareReminderResponse",
    # Plant care log schemas
    "PlantCareLogBase",
    "PlantCareLogCreate",
    "PlantCareLogUpdate",
    "PlantCareLogResponse",
    "PlantCareLogListResponse",
    "CareTypeStatsResponse",
    # Plant identification schemas
    "PlantIdentificationBase",
    "PlantIdentificationCreate",
    "PlantIdentificationUpdate",
    "PlantIdentificationResponse",
    "PlantIdentificationListResponse",
    "PlantIdentificationResultResponse",
    # Plant trade schemas
    "PlantTradeBase",
    "PlantTradeCreate",
    "PlantTradeUpdate",
    "PlantTradeResponse",
    "PlantTradeListResponse",
    "PlantTradeSearchRequest",
    "PlantTradeInterestRequest",
    # Plant question schemas
    "PlantQuestionBase",
    "PlantQuestionCreate",
    "PlantQuestionUpdate",
    "PlantAnswerBase",
    "PlantAnswerCreate",
    "PlantAnswerUpdate",
    "PlantAnswerResponse",
    "PlantQuestionResponse",
    "PlantQuestionListResponse",
    "PlantQuestionSearchRequest",
    "PlantAnswerVoteRequest",
]
</file>

<file path="app/schemas/achievement.py">
"""Achievement schemas."""
from datetime import datetime
from typing import Optional, Dict, Any, List
from uuid import UUID
from pydantic import BaseModel, Field
class PlantAchievementBase(BaseModel):
    """Base schema for plant achievements."""
    achievement_type: str = Field(..., max_length=50)
    title: str = Field(..., max_length=100)
    description: Optional[str] = None
    icon: Optional[str] = Field(None, max_length=50)
    badge_color: str = Field(default="green", max_length=20)
    points: int = Field(default=0, ge=0)
    unlock_criteria: Optional[Dict[str, Any]] = None
class PlantAchievementResponse(PlantAchievementBase):
    """Achievement response schema."""
    id: UUID
    is_active: bool
    created_at: datetime
    class Config:
        from_attributes = True
class UserAchievementResponse(BaseModel):
    """User achievement response schema."""
    id: UUID
    user_id: UUID
    achievement_id: UUID
    earned_at: datetime
    progress_data: Optional[Dict[str, Any]] = None
    is_featured: bool
    achievement: PlantAchievementResponse
    class Config:
        from_attributes = True
class PlantMilestoneBase(BaseModel):
    """Base schema for plant milestones."""
    milestone_type: str = Field(..., max_length=50)
    title: str = Field(..., max_length=100)
    description: Optional[str] = None
    photo_url: Optional[str] = Field(None, max_length=500)
    notes: Optional[str] = None
class PlantMilestoneCreate(PlantMilestoneBase):
    """Schema for creating plant milestones."""
    pass
class PlantMilestoneResponse(PlantMilestoneBase):
    """Plant milestone response schema."""
    id: UUID
    plant_id: UUID
    achieved_at: datetime
    class Config:
        from_attributes = True
class UserStatsResponse(BaseModel):
    """User statistics response schema."""
    id: UUID
    user_id: UUID
    # Plant collection stats
    total_plants: int
    active_plants: int
    plants_identified: int
    # Care activity stats
    total_care_logs: int
    care_streak_days: int
    longest_care_streak: int
    last_care_activity: Optional[datetime]
    # Community stats
    questions_asked: int
    questions_answered: int
    helpful_answers: int
    trades_completed: int
    # Achievement stats
    total_achievements: int
    total_points: int
    level: int
    # Timestamps
    last_updated: datetime
    created_at: datetime
    class Config:
        from_attributes = True
class AchievementProgress(BaseModel):
    """Schema for tracking achievement progress."""
    achievement_id: UUID
    current_progress: Dict[str, Any]
    completion_percentage: float = Field(..., ge=0.0, le=100.0)
    is_completed: bool = False
class LeaderboardEntry(BaseModel):
    """Schema for leaderboard entries."""
    user_id: UUID
    username: str
    display_name: Optional[str]
    profile_picture_url: Optional[str]
    total_points: int
    level: int
    rank: int
</file>

<file path="app/schemas/auth.py">
"""Authentication schemas.
This module defines Pydantic schemas for authentication-related
data validation and serialization.
"""
from typing import Optional
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
class UserBase(BaseModel):
    """Base user schema with common fields."""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=30, pattern=r"^[a-zA-Z0-9_]+$")
    display_name: str = Field(..., min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: bool = False
    show_location: bool = True
    allow_plant_id_requests: bool = True
class UserCreate(UserBase):
    """Schema for user registration."""
    password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Passwords do not match')
        return v
    @field_validator('username')
    @classmethod
    def username_alphanumeric(cls, v):
        if not v.replace('_', '').isalnum():
            raise ValueError('Username must contain only letters, numbers, and underscores')
        return v.lower()
    @field_validator('email')
    @classmethod
    def email_lowercase(cls, v):
        return v.lower()
class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    display_name: Optional[str] = Field(None, min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: Optional[bool] = None
    show_location: Optional[bool] = None
    allow_plant_id_requests: Optional[bool] = None
class UserRead(UserBase):
    """Schema for reading user data."""
    id: str
    is_verified: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime
    model_config = {"from_attributes": True}
class UserInDB(UserRead):
    """Schema for user data stored in database (includes sensitive fields)."""
    hashed_password: str
class Token(BaseModel):
    """Schema for authentication tokens."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: Optional[int] = None
class TokenData(BaseModel):
    """Schema for token payload data."""
    user_id: Optional[str] = None
    username: Optional[str] = None
    exp: Optional[datetime] = None
class PasswordReset(BaseModel):
    """Schema for password reset request."""
    email: EmailStr
    @field_validator('email')
    @classmethod
    def email_lowercase(cls, v):
        return v.lower()
class PasswordResetConfirm(BaseModel):
    """Schema for password reset confirmation."""
    token: str
    new_password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v
class EmailVerification(BaseModel):
    """Schema for email verification."""
    token: str
class ChangePassword(BaseModel):
    """Schema for changing password."""
    current_password: str
    new_password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v
class LoginRequest(BaseModel):
    """Schema for login request."""
    username_or_email: str = Field(..., min_length=3)
    password: str = Field(..., min_length=1)
    remember_me: bool = False
class RefreshTokenRequest(BaseModel):
    """Schema for refresh token request."""
    refresh_token: str
class LogoutRequest(BaseModel):
    """Schema for logout request."""
    refresh_token: Optional[str] = None
    logout_all_devices: bool = False
</file>

<file path="app/schemas/friendship.py">
"""Friendship schemas.
This module defines Pydantic schemas for friendship-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class FriendshipStatus(str, Enum):
    """Enum for friendship status."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    BLOCKED = "blocked"
class FriendshipBase(BaseModel):
    """Base friendship schema with common fields."""
    status: FriendshipStatus
    is_close_friend: bool = False
    created_at: datetime
    updated_at: datetime
class FriendRequestCreate(BaseModel):
    """Schema for creating a friend request."""
    user_id: str
    message: Optional[str] = Field(None, max_length=200)  # Optional message with request
    @validator('message')
    def validate_message(cls, v):
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v
class FriendshipRead(FriendshipBase):
    """Schema for reading friendship data."""
    id: str
    requester_id: str
    addressee_id: str
    # User information for display
    requester_username: Optional[str] = None
    requester_display_name: Optional[str] = None
    requester_avatar_url: Optional[str] = None
    addressee_username: Optional[str] = None
    addressee_display_name: Optional[str] = None
    addressee_avatar_url: Optional[str] = None
    # Request metadata
    request_message: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipUpdate(BaseModel):
    """Schema for updating friendship data."""
    status: Optional[FriendshipStatus] = None
    is_close_friend: Optional[bool] = None
    @validator('status')
    def validate_status_transition(cls, v):
        # Add business logic for valid status transitions if needed
        return v
class FriendProfile(BaseModel):
    """Schema for friend profile information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    # Plant-specific info
    gardening_experience: Optional[str] = None
    favorite_plants: Optional[str] = None
    location: Optional[str] = None
    # Friendship info
    friendship_id: str
    is_close_friend: bool = False
    friends_since: datetime
    # Activity info
    last_active: Optional[datetime] = None
    is_online: bool = False
    # Statistics
    mutual_friends_count: int = 0
    stories_count: int = 0
    class Config:
        from_attributes = True
class FriendsList(BaseModel):
    """Schema for friends list with pagination."""
    friends: List[FriendProfile]
    total_count: int
    close_friends_count: int
    online_friends_count: int
    class Config:
        from_attributes = True
class FriendRequestsList(BaseModel):
    """Schema for friend requests list."""
    pending_requests: List[FriendshipRead]
    sent_requests: List[FriendshipRead]
    total_pending: int
    total_sent: int
    class Config:
        from_attributes = True
class MutualFriends(BaseModel):
    """Schema for mutual friends information."""
    user_id: str
    mutual_friends: List[FriendProfile]
    mutual_friends_count: int
    total_friends_count: int  # Total friends of the user
    class Config:
        from_attributes = True
class FriendshipStats(BaseModel):
    """Schema for friendship statistics."""
    user_id: str
    total_friends: int = 0
    close_friends: int = 0
    pending_requests_received: int = 0
    pending_requests_sent: int = 0
    blocked_users: int = 0
    # Activity stats
    friend_requests_sent_this_week: int = 0
    friend_requests_accepted_this_week: int = 0
    new_friends_this_month: int = 0
    # Plant community stats
    plant_enthusiast_friends: int = 0
    friends_by_experience: dict = {}  # beginner, intermediate, advanced, expert
    friends_by_location: dict = {}
    class Config:
        from_attributes = True
class FriendSuggestion(BaseModel):
    """Schema for friend suggestions."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    # Plant-specific info
    gardening_experience: Optional[str] = None
    favorite_plants: Optional[str] = None
    location: Optional[str] = None
    # Suggestion reasoning
    suggestion_reason: str  # mutual_friends, location, interests, etc.
    mutual_friends_count: int = 0
    compatibility_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    # Additional context
    mutual_friends_preview: Optional[List[str]] = None  # List of mutual friend usernames
    shared_interests: Optional[List[str]] = None
    class Config:
        from_attributes = True
class FriendActivity(BaseModel):
    """Schema for friend activity information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    # Activity info
    activity_type: str  # posted_story, sent_message, plant_identification, etc.
    activity_description: str
    activity_timestamp: datetime
    # Activity data
    story_id: Optional[str] = None
    message_preview: Optional[str] = None
    plant_name: Optional[str] = None
    class Config:
        from_attributes = True
class BlockedUser(BaseModel):
    """Schema for blocked user information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    # Block info
    blocked_at: datetime
    block_reason: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipSearch(BaseModel):
    """Schema for searching friends."""
    query: str = Field(..., min_length=1, max_length=100)
    status: Optional[FriendshipStatus] = None
    is_close_friend: Optional[bool] = None
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    is_online: Optional[bool] = None
    # Sorting options
    sort_by: str = Field("display_name", pattern=r"^(display_name|username|friends_since|last_active)$")
    sort_order: str = Field("asc", pattern=r"^(asc|desc)$")
    @validator('sort_by')
    def validate_sort_by(cls, v):
        valid_options = ['display_name', 'username', 'friends_since', 'last_active']
        if v not in valid_options:
            raise ValueError(f'Invalid sort_by option. Must be one of: {valid_options}')
        return v
class FriendshipBatch(BaseModel):
    """Schema for batch friendship operations."""
    user_ids: List[str] = Field(..., min_items=1, max_items=50)
    operation: str = Field(..., pattern=r"^(add_to_close_friends|remove_from_close_friends|block|unblock|remove_friend)$")
    @validator('user_ids')
    def validate_unique_user_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('user_ids must be unique')
        return v
    @validator('operation')
    def validate_operation(cls, v):
        valid_operations = [
            'add_to_close_friends', 'remove_from_close_friends', 
            'block', 'unblock', 'remove_friend'
        ]
        if v not in valid_operations:
            raise ValueError(f'Invalid operation. Must be one of: {valid_operations}')
        return v
class FriendshipNotification(BaseModel):
    """Schema for friendship-related notifications."""
    id: str
    user_id: str  # User who will receive the notification
    from_user_id: str  # User who triggered the notification
    notification_type: str  # friend_request, friend_accepted, etc.
    # User info for display
    from_username: str
    from_display_name: str
    from_avatar_url: Optional[str] = None
    # Notification content
    title: str
    message: str
    # Metadata
    is_read: bool = False
    created_at: datetime
    # Related data
    friendship_id: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipAnalytics(BaseModel):
    """Schema for friendship analytics."""
    user_id: str
    # Growth metrics
    friends_gained_this_week: int = 0
    friends_gained_this_month: int = 0
    friends_lost_this_month: int = 0
    # Engagement metrics
    messages_sent_to_friends: int = 0
    stories_shared_with_friends: int = 0
    friend_stories_viewed: int = 0
    # Network metrics
    network_size: int = 0
    network_density: Optional[float] = None  # How interconnected friend network is
    most_connected_friend: Optional[str] = None  # Friend with most mutual connections
    # Plant community metrics
    plant_friends_percentage: Optional[float] = None
    plant_knowledge_exchanges: int = 0
    class Config:
        from_attributes = True
</file>

<file path="app/schemas/message.py">
"""Message schemas.
This module defines Pydantic schemas for message-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class MessageType(str, Enum):
    """Enum for message content types."""
    TEXT = "text"
    IMAGE = "image"
    VIDEO = "video"
    AUDIO = "audio"
    PLANT_ID = "plant_id"  # Plant identification request/response
    PLANT_CARE = "plant_care"  # Plant care tip
    LOCATION = "location"
class MessageStatus(str, Enum):
    """Enum for message status."""
    SENT = "sent"
    DELIVERED = "delivered"
    READ = "read"
    DELETED = "deleted"
    EXPIRED = "expired"
class MessageBase(BaseModel):
    """Base message schema with common fields."""
    content_type: MessageType
    content: Optional[str] = Field(None, max_length=2000)
    media_url: Optional[str] = None
    caption: Optional[str] = Field(None, max_length=500)
    # Media metadata
    file_size: Optional[int] = Field(None, ge=0)
    duration: Optional[float] = Field(None, ge=0)  # For audio/video in seconds
    # Disappearing message settings
    disappears_at: Optional[int] = Field(None, ge=1, le=604800)  # 1 second to 1 week
    # Plant-specific fields
    plant_data: Optional[dict] = None  # For plant identification results
    care_tip_category: Optional[str] = None  # watering, lighting, fertilizing, etc.
class MessageCreate(MessageBase):
    """Schema for creating a new message."""
    recipient_id: str
    @validator('content')
    def validate_content(cls, v, values):
        content_type = values.get('content_type')
        if content_type == MessageType.TEXT and not v:
            raise ValueError('Text messages must have content')
        return v
    @validator('media_url')
    def validate_media_url(cls, v, values):
        content_type = values.get('content_type')
        if content_type in [MessageType.IMAGE, MessageType.VIDEO, MessageType.AUDIO] and not v:
            raise ValueError(f'{content_type.value} messages must have media_url')
        return v
    @validator('plant_data')
    def validate_plant_data(cls, v, values):
        content_type = values.get('content_type')
        if content_type == MessageType.PLANT_ID and not v:
            raise ValueError('Plant identification messages must have plant_data')
        return v
class MessageUpdate(BaseModel):
    """Schema for updating a message (limited fields)."""
    content: Optional[str] = Field(None, max_length=2000)
    caption: Optional[str] = Field(None, max_length=500)
    status: Optional[MessageStatus] = None
class MessageRead(MessageBase):
    """Schema for reading message data."""
    id: str
    sender_id: str
    recipient_id: str
    status: MessageStatus
    created_at: datetime
    updated_at: datetime
    read_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    # Sender information (for display)
    sender_username: Optional[str] = None
    sender_display_name: Optional[str] = None
    sender_avatar_url: Optional[str] = None
    # Recipient information (for display)
    recipient_username: Optional[str] = None
    recipient_display_name: Optional[str] = None
    recipient_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class MessageThread(BaseModel):
    """Schema for message thread/conversation."""
    participant_id: str
    participant_username: str
    participant_display_name: str
    participant_avatar_url: Optional[str] = None
    # Latest message info
    latest_message: Optional[MessageRead] = None
    latest_message_at: Optional[datetime] = None
    # Thread statistics
    total_messages: int = 0
    unread_count: int = 0
    # Thread settings
    is_muted: bool = False
    is_archived: bool = False
    class Config:
        from_attributes = True
class MessageReaction(BaseModel):
    """Schema for message reactions."""
    message_id: str
    user_id: str
    reaction_type: str = Field(..., pattern=r"^(like|love|laugh|wow|sad|angry|plant)$")
    created_at: datetime
    # User info for display
    user_username: Optional[str] = None
    user_display_name: Optional[str] = None
    user_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class MessageReactionCreate(BaseModel):
    """Schema for creating a message reaction."""
    reaction_type: str = Field(..., pattern=r"^(like|love|laugh|wow|sad|angry|plant)$")
    @validator('reaction_type')
    def validate_reaction_type(cls, v):
        valid_reactions = ['like', 'love', 'laugh', 'wow', 'sad', 'angry', 'plant']
        if v not in valid_reactions:
            raise ValueError(f'Invalid reaction type. Must be one of: {valid_reactions}')
        return v
class MessageSearch(BaseModel):
    """Schema for message search parameters."""
    query: str = Field(..., min_length=1, max_length=100)
    content_type: Optional[MessageType] = None
    sender_id: Optional[str] = None
    date_from: Optional[datetime] = None
    date_to: Optional[datetime] = None
    has_media: Optional[bool] = None
    @validator('date_to')
    def validate_date_range(cls, v, values):
        if v is not None and 'date_from' in values and values['date_from'] is not None:
            if v < values['date_from']:
                raise ValueError('date_to must be after date_from')
        return v
class MessageDeliveryStatus(BaseModel):
    """Schema for message delivery status."""
    message_id: str
    status: MessageStatus
    delivered_at: Optional[datetime] = None
    read_at: Optional[datetime] = None
    failed_reason: Optional[str] = None
    class Config:
        from_attributes = True
class MessageBatch(BaseModel):
    """Schema for batch message operations."""
    message_ids: List[str] = Field(..., min_items=1, max_items=100)
    operation: str = Field(..., pattern=r"^(mark_read|delete|archive)$")
    @validator('message_ids')
    def validate_unique_message_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('message_ids must be unique')
        return v
class PlantIdentificationMessage(BaseModel):
    """Schema for plant identification messages."""
    image_url: str
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    plant_name: Optional[str] = None
    scientific_name: Optional[str] = None
    plant_family: Optional[str] = None
    care_difficulty: Optional[str] = Field(None, pattern=r"^(easy|moderate|difficult)$")
    care_tips: Optional[List[str]] = None
    common_issues: Optional[List[str]] = None
    class Config:
        from_attributes = True
class PlantCareMessage(BaseModel):
    """Schema for plant care tip messages."""
    plant_name: Optional[str] = None
    care_category: str = Field(..., pattern=r"^(watering|lighting|fertilizing|pruning|repotting|pest_control|general)$")
    tip_content: str = Field(..., min_length=10, max_length=1000)
    difficulty_level: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced)$")
    season_specific: Optional[str] = Field(None, pattern=r"^(spring|summer|fall|winter|year_round)$")
    @validator('care_category')
    def validate_care_category(cls, v):
        valid_categories = ['watering', 'lighting', 'fertilizing', 'pruning', 'repotting', 'pest_control', 'general']
        if v not in valid_categories:
            raise ValueError(f'Invalid care category. Must be one of: {valid_categories}')
        return v
class MessageAnalytics(BaseModel):
    """Schema for message analytics."""
    user_id: str
    total_messages_sent: int = 0
    total_messages_received: int = 0
    messages_by_type: dict = {}
    average_response_time_minutes: Optional[float] = None
    most_active_conversation: Optional[str] = None
    plant_messages_sent: int = 0
    plant_identifications_requested: int = 0
    care_tips_shared: int = 0
    class Config:
        from_attributes = True
</file>

<file path="app/schemas/nursery.py">
"""Nursery schemas."""
from datetime import datetime, time
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field
class LocalNurseryBase(BaseModel):
    """Base schema for local nurseries."""
    name: str = Field(..., max_length=200)
    description: Optional[str] = None
    address: Optional[str] = Field(None, max_length=500)
    city: Optional[str] = Field(None, max_length=100)
    state: Optional[str] = Field(None, max_length=50)
    country: Optional[str] = Field(None, max_length=50)
    postal_code: Optional[str] = Field(None, max_length=20)
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    phone: Optional[str] = Field(None, max_length=20)
    email: Optional[str] = Field(None, max_length=100)
    website: Optional[str] = Field(None, max_length=200)
    business_type: Optional[str] = Field(None, max_length=50)
    specialties: Optional[List[str]] = None
    services: Optional[List[str]] = None
    operating_hours: Optional[Dict[str, Any]] = None
class LocalNurseryCreate(LocalNurseryBase):
    """Schema for creating local nurseries."""
    pass
class LocalNurseryResponse(LocalNurseryBase):
    """Local nursery response schema."""
    id: UUID
    average_rating: float
    total_reviews: int
    is_verified: bool
    verified_at: Optional[datetime]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurseryReviewBase(BaseModel):
    """Base schema for nursery reviews."""
    rating: int = Field(..., ge=1, le=5)
    title: Optional[str] = Field(None, max_length=200)
    review_text: Optional[str] = None
    plant_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    service_rating: Optional[int] = Field(None, ge=1, le=5)
    price_rating: Optional[int] = Field(None, ge=1, le=5)
    selection_rating: Optional[int] = Field(None, ge=1, le=5)
    tags: Optional[List[str]] = None
    is_verified_purchase: bool = False
    visit_date: Optional[datetime] = None
class NurseryReviewCreate(NurseryReviewBase):
    """Schema for creating nursery reviews."""
    pass
class NurseryReviewResponse(NurseryReviewBase):
    """Nursery review response schema."""
    id: UUID
    nursery_id: UUID
    user_id: UUID
    is_active: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurseryEventBase(BaseModel):
    """Base schema for nursery events."""
    title: str = Field(..., max_length=200)
    description: Optional[str] = None
    event_type: Optional[str] = Field(None, max_length=50)
    start_date: datetime
    end_date: Optional[datetime] = None
    start_time: Optional[time] = None
    end_time: Optional[time] = None
    max_participants: Optional[int] = None
    current_participants: int = 0
    price: float = 0.0
    skill_level: Optional[str] = Field(None, max_length=20)
    requirements: Optional[str] = None
    materials_provided: Optional[str] = None
    requires_registration: bool = True
    registration_deadline: Optional[datetime] = None
    contact_info: Optional[str] = Field(None, max_length=200)
class NurseryEventResponse(NurseryEventBase):
    """Nursery event response schema."""
    id: UUID
    nursery_id: UUID
    is_recurring: bool
    recurrence_pattern: Optional[Dict[str, Any]]
    is_active: bool
    is_cancelled: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurserySearchFilters(BaseModel):
    """Schema for nursery search filters."""
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    radius_km: float = 50
    business_type: Optional[str] = None
    specialties: Optional[List[str]] = None
class UserNurseryFavoriteResponse(BaseModel):
    """User nursery favorite response schema."""
    id: UUID
    user_id: UUID
    nursery_id: UUID
    notes: Optional[str] = None
    last_visited: Optional[datetime] = None
    created_at: datetime
    nursery: LocalNurseryResponse
    class Config:
        from_attributes = True
</file>

<file path="app/schemas/plant_care_log.py">
"""Plant care log Pydantic schemas.
This module defines the Pydantic schemas for plant care log data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
class PlantCareLogBase(BaseModel):
    """Base plant care log schema with common fields."""
    care_type: str = Field(..., min_length=1, max_length=50)
    notes: Optional[str] = None
    performed_at: Optional[datetime] = None
class PlantCareLogCreate(PlantCareLogBase):
    """Schema for creating a new plant care log entry."""
    plant_id: UUID
class PlantCareLogUpdate(BaseModel):
    """Schema for updating a plant care log entry."""
    care_type: Optional[str] = Field(None, min_length=1, max_length=50)
    notes: Optional[str] = None
    performed_at: Optional[datetime] = None
class PlantCareLogResponse(PlantCareLogBase):
    """Schema for plant care log API responses."""
    id: UUID
    plant_id: UUID
    created_at: datetime
    class Config:
        from_attributes = True
class PlantCareLogListResponse(BaseModel):
    """Schema for paginated plant care log list responses."""
    items: List[PlantCareLogResponse]
    total: int
    page: int
    size: int
    pages: int
class CareTypeStatsResponse(BaseModel):
    """Schema for care type statistics responses."""
    care_type: str
    count: int
    last_performed: Optional[datetime]
    average_frequency_days: Optional[float]
</file>

<file path="app/schemas/plant_identification.py">
"""Plant identification Pydantic schemas.
This module defines the Pydantic schemas for plant identification data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
class PlantIdentificationBase(BaseModel):
    """Base plant identification schema with common fields."""
    image_path: str = Field(..., min_length=1, max_length=500)
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    identified_name: Optional[str] = Field(None, max_length=255)
    is_verified: bool = False
    verification_notes: Optional[str] = None
class PlantIdentificationCreate(BaseModel):
    """Schema for creating a new plant identification request."""
    image_path: str = Field(..., min_length=1, max_length=500)
class PlantIdentificationUpdate(BaseModel):
    """Schema for updating a plant identification."""
    species_id: Optional[UUID] = None
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    identified_name: Optional[str] = Field(None, max_length=255)
    is_verified: Optional[bool] = None
    verification_notes: Optional[str] = None
class PlantIdentificationResponse(PlantIdentificationBase):
    """Schema for plant identification API responses."""
    id: UUID
    user_id: UUID
    species_id: Optional[UUID] = None
    species: Optional[PlantSpeciesResponse] = None
    created_at: datetime
    class Config:
        from_attributes = True
class PlantIdentificationListResponse(BaseModel):
    """Schema for paginated plant identification list responses."""
    items: List[PlantIdentificationResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantIdentificationResultResponse(BaseModel):
    """Schema for AI identification result responses."""
    identified_name: str
    confidence_score: float
    species_suggestions: List[PlantSpeciesResponse]
    care_recommendations: Optional[str] = None
</file>

<file path="app/schemas/plant_question.py">
"""Plant question Pydantic schemas.
This module defines the Pydantic schemas for plant question and answer data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
from app.schemas.user import UserPublicResponse
class PlantQuestionBase(BaseModel):
    """Base plant question schema with common fields."""
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=1)
    species_id: Optional[UUID] = None
    image_paths: Optional[str] = None  # JSON array of image paths
    tags: Optional[str] = None  # JSON array of tags
class PlantQuestionCreate(PlantQuestionBase):
    """Schema for creating a new plant question."""
    pass
class PlantQuestionUpdate(BaseModel):
    """Schema for updating a plant question."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    content: Optional[str] = Field(None, min_length=1)
    species_id: Optional[UUID] = None
    image_paths: Optional[str] = None
    tags: Optional[str] = None
    is_solved: Optional[bool] = None
class PlantAnswerBase(BaseModel):
    """Base plant answer schema with common fields."""
    content: str = Field(..., min_length=1)
class PlantAnswerCreate(PlantAnswerBase):
    """Schema for creating a new plant answer."""
    question_id: UUID
class PlantAnswerUpdate(BaseModel):
    """Schema for updating a plant answer."""
    content: Optional[str] = Field(None, min_length=1)
    is_accepted: Optional[bool] = None
class PlantAnswerResponse(PlantAnswerBase):
    """Schema for plant answer API responses."""
    id: UUID
    question_id: UUID
    user_id: UUID
    user: Optional[UserPublicResponse] = None
    is_accepted: bool
    upvotes: int
    downvotes: int
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantQuestionResponse(PlantQuestionBase):
    """Schema for plant question API responses."""
    id: UUID
    user_id: UUID
    user: Optional[UserPublicResponse] = None
    species: Optional[PlantSpeciesResponse] = None
    is_solved: bool
    view_count: int
    answers: List[PlantAnswerResponse] = []
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantQuestionListResponse(BaseModel):
    """Schema for paginated plant question list responses."""
    items: List[PlantQuestionResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantQuestionSearchRequest(BaseModel):
    """Schema for plant question search requests."""
    query: Optional[str] = None
    species_id: Optional[UUID] = None
    tags: Optional[List[str]] = None
    is_solved: Optional[bool] = None
    user_id: Optional[UUID] = None
    page: int = Field(default=1, ge=1)
    size: int = Field(default=20, ge=1, le=100)
class PlantAnswerVoteRequest(BaseModel):
    """Schema for voting on plant answers."""
    vote_type: str = Field(..., pattern="^(upvote|downvote)$")
</file>

<file path="app/schemas/plant_species.py">
"""Plant species Pydantic schemas.
This module defines the Pydantic schemas for plant species data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
class PlantSpeciesBase(BaseModel):
    """Base plant species schema with common fields."""
    scientific_name: str = Field(..., min_length=1, max_length=255)
    common_names: List[str] = Field(default_factory=list)
    family: Optional[str] = Field(None, max_length=100)
    care_level: Optional[str] = Field(None, pattern="^(easy|moderate|difficult)$")
    light_requirements: Optional[str] = Field(None, max_length=50)
    water_frequency_days: Optional[int] = Field(None, ge=1, le=365)
    humidity_preference: Optional[str] = Field(None, max_length=20)
    temperature_range: Optional[str] = Field(None, max_length=50)
    toxicity_info: Optional[str] = None
    care_notes: Optional[str] = None
class PlantSpeciesCreate(PlantSpeciesBase):
    """Schema for creating a new plant species."""
    pass
class PlantSpeciesUpdate(BaseModel):
    """Schema for updating a plant species."""
    scientific_name: Optional[str] = Field(None, min_length=1, max_length=255)
    common_names: Optional[List[str]] = None
    family: Optional[str] = Field(None, max_length=100)
    care_level: Optional[str] = Field(None, pattern="^(easy|moderate|difficult)$")
    light_requirements: Optional[str] = Field(None, max_length=50)
    water_frequency_days: Optional[int] = Field(None, ge=1, le=365)
    humidity_preference: Optional[str] = Field(None, max_length=20)
    temperature_range: Optional[str] = Field(None, max_length=50)
    toxicity_info: Optional[str] = None
    care_notes: Optional[str] = None
class PlantSpeciesResponse(PlantSpeciesBase):
    """Schema for plant species API responses."""
    id: UUID
    created_at: datetime
    class Config:
        from_attributes = True
class PlantSpeciesListResponse(BaseModel):
    """Schema for paginated plant species list responses."""
    items: List[PlantSpeciesResponse]
    total: int
    page: int
    size: int
    pages: int
</file>

<file path="app/schemas/plant_trade.py">
"""Plant trade Pydantic schemas.
This module defines the Pydantic schemas for plant trade data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.models.plant_trade import TradeStatus, TradeType
from app.schemas.plant_species import PlantSpeciesResponse
from app.schemas.user import UserPublicResponse
class PlantTradeBase(BaseModel):
    """Base plant trade schema with common fields."""
    species_id: UUID
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = None
    trade_type: TradeType
    location: Optional[str] = Field(None, max_length=100)
    price: Optional[str] = Field(None, max_length=50)
    image_paths: Optional[str] = None  # JSON array of image paths
class PlantTradeCreate(PlantTradeBase):
    """Schema for creating a new plant trade listing."""
    pass
class PlantTradeUpdate(BaseModel):
    """Schema for updating a plant trade listing."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    trade_type: Optional[TradeType] = None
    status: Optional[TradeStatus] = None
    location: Optional[str] = Field(None, max_length=100)
    price: Optional[str] = Field(None, max_length=50)
    image_paths: Optional[str] = None
    interested_user_id: Optional[UUID] = None
class PlantTradeResponse(PlantTradeBase):
    """Schema for plant trade API responses."""
    id: UUID
    owner_id: UUID
    owner: Optional[UserPublicResponse] = None
    species: Optional[PlantSpeciesResponse] = None
    status: TradeStatus
    interested_user_id: Optional[UUID] = None
    interested_user: Optional[UserPublicResponse] = None
    completed_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantTradeListResponse(BaseModel):
    """Schema for paginated plant trade list responses."""
    items: List[PlantTradeResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantTradeSearchRequest(BaseModel):
    """Schema for plant trade search requests."""
    query: Optional[str] = None
    trade_type: Optional[TradeType] = None
    location: Optional[str] = None
    species_id: Optional[UUID] = None
    max_price: Optional[float] = None
    page: int = Field(default=1, ge=1)
    size: int = Field(default=20, ge=1, le=100)
class PlantTradeInterestRequest(BaseModel):
    """Schema for expressing interest in a plant trade."""
    message: Optional[str] = Field(None, max_length=500)
</file>

<file path="app/schemas/story.py">
"""Story schemas.
This module defines Pydantic schemas for story-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class StoryType(str, Enum):
    """Enum for story content types."""
    IMAGE = "image"
    VIDEO = "video"
    PLANT_SHOWCASE = "plant_showcase"  # Special plant-focused story
    PLANT_TIMELAPSE = "plant_timelapse"  # Plant growth timelapse
    GARDEN_TOUR = "garden_tour"  # Garden/collection showcase
class StoryPrivacyLevel(str, Enum):
    """Enum for story privacy levels."""
    PUBLIC = "public"
    FRIENDS = "friends"
    CLOSE_FRIENDS = "close_friends"
    PLANT_COMMUNITY = "plant_community"  # Visible to plant enthusiasts
class StoryBase(BaseModel):
    """Base story schema with common fields."""
    content_type: StoryType
    media_url: str
    caption: Optional[str] = Field(None, max_length=500)
    # Media metadata
    file_size: Optional[int] = Field(None, ge=0)
    duration: Optional[float] = Field(None, ge=0)  # For videos in seconds
    # Privacy settings
    privacy_level: StoryPrivacyLevel = StoryPrivacyLevel.FRIENDS
    # Plant-specific fields
    plant_data: Optional[dict] = None  # Plant identification/info
    plant_tags: Optional[List[str]] = None  # Plant-related hashtags
    care_tip: Optional[str] = Field(None, max_length=200)  # Quick care tip
    location_tag: Optional[str] = Field(None, max_length=100)  # Garden location
class StoryCreate(StoryBase):
    """Schema for creating a new story."""
    @validator('media_url')
    def validate_media_url(cls, v):
        if not v or not v.strip():
            raise ValueError('media_url is required')
        return v
    @validator('duration')
    def validate_duration(cls, v, values):
        content_type = values.get('content_type')
        if content_type == StoryType.VIDEO and v is None:
            raise ValueError('Video stories must have duration')
        if v is not None and v > 60:  # Max 60 seconds for stories
            raise ValueError('Story duration cannot exceed 60 seconds')
        return v
    @validator('plant_tags')
    def validate_plant_tags(cls, v):
        if v is not None:
            if len(v) > 10:
                raise ValueError('Maximum 10 plant tags allowed')
            for tag in v:
                if len(tag) > 30:
                    raise ValueError('Plant tags must be 30 characters or less')
        return v
class StoryUpdate(BaseModel):
    """Schema for updating a story (limited fields)."""
    caption: Optional[str] = Field(None, max_length=500)
    privacy_level: Optional[StoryPrivacyLevel] = None
    plant_tags: Optional[List[str]] = None
    care_tip: Optional[str] = Field(None, max_length=200)
    @validator('plant_tags')
    def validate_plant_tags(cls, v):
        if v is not None:
            if len(v) > 10:
                raise ValueError('Maximum 10 plant tags allowed')
            for tag in v:
                if len(tag) > 30:
                    raise ValueError('Plant tags must be 30 characters or less')
        return v
class StoryRead(StoryBase):
    """Schema for reading story data."""
    id: str
    user_id: str
    created_at: datetime
    expires_at: datetime
    is_active: bool
    view_count: int = 0
    # User information (for display)
    user_username: Optional[str] = None
    user_display_name: Optional[str] = None
    user_avatar_url: Optional[str] = None
    # Viewer-specific data
    has_viewed: Optional[bool] = None
    viewed_at: Optional[datetime] = None
    # Story analytics (for owner)
    unique_viewers: Optional[int] = None
    total_screenshots: Optional[int] = None
    class Config:
        from_attributes = True
class StoryViewCreate(BaseModel):
    """Schema for creating a story view."""
    story_id: str
    # Optional metadata
    view_duration: Optional[float] = Field(None, ge=0)  # How long they viewed
    screenshot_taken: bool = False
class StoryView(BaseModel):
    """Schema for story view data."""
    id: str
    story_id: str
    viewer_id: str
    viewed_at: datetime
    view_duration: Optional[float] = None
    screenshot_taken: bool = False
    # Viewer information (for story owner)
    viewer_username: Optional[str] = None
    viewer_display_name: Optional[str] = None
    viewer_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class StoryFeed(BaseModel):
    """Schema for story feed data."""
    user_id: str
    user_username: str
    user_display_name: str
    user_avatar_url: Optional[str] = None
    # Story ring info
    has_unviewed_stories: bool = False
    total_stories: int = 0
    latest_story_at: Optional[datetime] = None
    # Stories list (if expanded)
    stories: Optional[List[StoryRead]] = None
    class Config:
        from_attributes = True
class StoryHighlight(BaseModel):
    """Schema for story highlights (saved stories)."""
    id: str
    user_id: str
    title: str = Field(..., min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: List[str] = Field(..., min_items=1, max_items=100)
    created_at: datetime
    updated_at: datetime
    # Display info
    story_count: int = 0
    class Config:
        from_attributes = True
class StoryHighlightCreate(BaseModel):
    """Schema for creating a story highlight."""
    title: str = Field(..., min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: List[str] = Field(..., min_items=1, max_items=100)
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
class StoryHighlightUpdate(BaseModel):
    """Schema for updating a story highlight."""
    title: Optional[str] = Field(None, min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: Optional[List[str]] = Field(None, min_items=1, max_items=100)
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if v is not None and len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
class PlantStoryData(BaseModel):
    """Schema for plant-specific story data."""
    plant_name: Optional[str] = None
    scientific_name: Optional[str] = None
    plant_age: Optional[str] = None  # "2 months", "1 year", etc.
    growth_stage: Optional[str] = Field(None, pattern=r"^(seedling|juvenile|mature|flowering|fruiting)$")
    care_difficulty: Optional[str] = Field(None, pattern=r"^(easy|moderate|difficult)$")
    # Care information
    watering_frequency: Optional[str] = None
    light_requirements: Optional[str] = None
    soil_type: Optional[str] = None
    # Progress tracking
    is_before_after: bool = False
    progress_description: Optional[str] = Field(None, max_length=200)
    class Config:
        from_attributes = True
class StoryAnalytics(BaseModel):
    """Schema for story analytics."""
    story_id: str
    total_views: int = 0
    unique_viewers: int = 0
    view_completion_rate: Optional[float] = None  # Percentage who watched full video
    screenshots_taken: int = 0
    shares_count: int = 0
    # Viewer demographics
    viewers_by_experience: dict = {}  # beginner, intermediate, advanced, expert
    viewers_by_location: dict = {}
    # Engagement metrics
    average_view_duration: Optional[float] = None
    peak_viewing_time: Optional[datetime] = None
    class Config:
        from_attributes = True
class StorySearch(BaseModel):
    """Schema for story search parameters."""
    query: Optional[str] = Field(None, min_length=1, max_length=100)
    content_type: Optional[StoryType] = None
    privacy_level: Optional[StoryPrivacyLevel] = None
    plant_tags: Optional[List[str]] = None
    user_id: Optional[str] = None
    date_from: Optional[datetime] = None
    date_to: Optional[datetime] = None
    has_plant_data: Optional[bool] = None
    @validator('date_to')
    def validate_date_range(cls, v, values):
        if v is not None and 'date_from' in values and values['date_from'] is not None:
            if v < values['date_from']:
                raise ValueError('date_to must be after date_from')
        return v
class StoryBatch(BaseModel):
    """Schema for batch story operations."""
    story_ids: List[str] = Field(..., min_items=1, max_items=50)
    operation: str = Field(..., pattern=r"^(delete|archive|add_to_highlight)$")
    highlight_id: Optional[str] = None  # Required for add_to_highlight operation
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
    @validator('highlight_id')
    def validate_highlight_id(cls, v, values):
        operation = values.get('operation')
        if operation == 'add_to_highlight' and not v:
            raise ValueError('highlight_id is required for add_to_highlight operation')
        return v
</file>

<file path="app/schemas/user_plant.py">
"""User plant Pydantic schemas.
This module defines the Pydantic schemas for user plant data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
class UserPlantBase(BaseModel):
    """Base user plant schema with common fields."""
    species_id: UUID
    nickname: Optional[str] = Field(None, max_length=100)
    location: Optional[str] = Field(None, max_length=100)
    acquired_date: Optional[datetime] = None
    last_watered: Optional[datetime] = None
    last_fertilized: Optional[datetime] = None
    last_repotted: Optional[datetime] = None
    health_status: str = Field(default="healthy", pattern="^(healthy|sick|recovering|dead)$")
    notes: Optional[str] = None
    is_active: bool = True
class UserPlantCreate(UserPlantBase):
    """Schema for creating a new user plant."""
    pass
class UserPlantUpdate(BaseModel):
    """Schema for updating a user plant."""
    nickname: Optional[str] = Field(None, max_length=100)
    location: Optional[str] = Field(None, max_length=100)
    acquired_date: Optional[datetime] = None
    last_watered: Optional[datetime] = None
    last_fertilized: Optional[datetime] = None
    last_repotted: Optional[datetime] = None
    health_status: Optional[str] = Field(None, pattern="^(healthy|sick|recovering|dead)$")
    notes: Optional[str] = None
    is_active: Optional[bool] = None
class UserPlantResponse(UserPlantBase):
    """Schema for user plant API responses."""
    id: UUID
    user_id: UUID
    species: Optional[PlantSpeciesResponse] = None
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class UserPlantListResponse(BaseModel):
    """Schema for paginated user plant list responses."""
    items: List[UserPlantResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantCareReminderResponse(BaseModel):
    """Schema for plant care reminder responses."""
    plant_id: UUID
    plant_nickname: Optional[str]
    species_name: str
    care_type: str
    days_overdue: int
    last_care_date: Optional[datetime]
    recommended_frequency_days: Optional[int]
</file>

<file path="app/schemas/user.py">
"""User schemas.
This module defines Pydantic schemas for user-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
class UserBase(BaseModel):
    """Base user schema with common fields."""
    username: str = Field(..., min_length=3, max_length=30)
    display_name: str = Field(..., min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: bool = False
    show_location: bool = True
    allow_plant_id_requests: bool = True
class UserRead(UserBase):
    """Schema for reading user data (public view)."""
    id: str
    email: str  # Only shown to the user themselves or friends
    is_verified: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime
    # Statistics (computed fields)
    friends_count: Optional[int] = None
    stories_count: Optional[int] = None
    class Config:
        from_attributes = True
class UserSearch(BaseModel):
    """Schema for user search results (limited public info)."""
    id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    gardening_experience: Optional[str] = None
    is_verified: bool = False
    is_private: bool = False
    # Friendship status (computed field)
    friendship_status: Optional[str] = None  # none, pending, accepted, blocked
    is_close_friend: Optional[bool] = None
    class Config:
        from_attributes = True
class UserPublicResponse(BaseModel):
    """Schema for public user information in API responses."""
    id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    is_verified: bool = False
    class Config:
        from_attributes = True
class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    display_name: Optional[str] = Field(None, min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: Optional[bool] = None
    show_location: Optional[bool] = None
    allow_plant_id_requests: Optional[bool] = None
    @validator('gardening_experience')
    def validate_experience(cls, v):
        if v is not None:
            valid_levels = ['beginner', 'intermediate', 'advanced', 'expert']
            if v not in valid_levels:
                raise ValueError(f'Invalid gardening experience. Must be one of: {valid_levels}')
        return v
class UserProfile(UserRead):
    """Schema for detailed user profile (includes private info for owner)."""
    email: str
    phone_number: Optional[str] = None
    # Additional statistics
    total_messages_sent: Optional[int] = None
    total_stories_posted: Optional[int] = None
    account_created_days_ago: Optional[int] = None
    # Privacy and security
    two_factor_enabled: bool = False
    email_notifications: bool = True
    push_notifications: bool = True
    class Config:
        from_attributes = True
class UserStats(BaseModel):
    """Schema for user statistics."""
    user_id: str
    friends_count: int = 0
    close_friends_count: int = 0
    stories_count: int = 0
    active_stories_count: int = 0
    total_messages_sent: int = 0
    total_messages_received: int = 0
    account_age_days: int = 0
    last_active: Optional[datetime] = None
    # Plant-specific stats
    plants_identified: int = 0
    plant_care_tips_shared: int = 0
    plant_photos_shared: int = 0
class UserPreferences(BaseModel):
    """Schema for user preferences and settings."""
    # Notification preferences
    email_notifications: bool = True
    push_notifications: bool = True
    friend_request_notifications: bool = True
    message_notifications: bool = True
    story_notifications: bool = True
    # Privacy preferences
    discoverable_by_email: bool = True
    discoverable_by_username: bool = True
    show_online_status: bool = True
    # Plant-specific preferences
    auto_plant_identification: bool = True
    share_plant_care_tips: bool = True
    receive_plant_recommendations: bool = True
    # Content preferences
    content_language: str = "en"
    timezone: str = "UTC"
    class Config:
        from_attributes = True
class UserActivity(BaseModel):
    """Schema for user activity tracking."""
    user_id: str
    activity_type: str  # login, logout, message_sent, story_posted, etc.
    activity_data: Optional[dict] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    timestamp: datetime
    class Config:
        from_attributes = True
class UserBlock(BaseModel):
    """Schema for user blocking information."""
    blocked_user_id: str
    blocked_user: UserSearch
    blocked_at: datetime
    reason: Optional[str] = None
    class Config:
        from_attributes = True
class UserReport(BaseModel):
    """Schema for reporting users."""
    reported_user_id: str
    reason: str = Field(..., min_length=1, max_length=500)
    category: str = Field(..., pattern=r"^(spam|harassment|inappropriate_content|fake_account|other)$")
    additional_info: Optional[str] = Field(None, max_length=1000)
    @validator('category')
    def validate_category(cls, v):
        valid_categories = ['spam', 'harassment', 'inappropriate_content', 'fake_account', 'other']
        if v not in valid_categories:
            raise ValueError(f'Invalid report category. Must be one of: {valid_categories}')
        return v
class UserSearchFilters(BaseModel):
    """Schema for user search filters."""
    query: str = Field(..., min_length=2, max_length=100)
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    has_avatar: Optional[bool] = None
    is_verified: Optional[bool] = None
    min_friends_count: Optional[int] = Field(None, ge=0)
    max_friends_count: Optional[int] = Field(None, ge=0)
    @validator('max_friends_count')
    def validate_friends_count_range(cls, v, values):
        if v is not None and 'min_friends_count' in values and values['min_friends_count'] is not None:
            if v < values['min_friends_count']:
                raise ValueError('max_friends_count must be greater than or equal to min_friends_count')
        return v
class UserBatchOperation(BaseModel):
    """Schema for batch operations on users."""
    user_ids: List[str] = Field(..., min_items=1, max_items=100)
    operation: str = Field(..., pattern=r"^(block|unblock|add_friend|remove_friend)$")
    @validator('user_ids')
    def validate_unique_user_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('user_ids must be unique')
        return v
</file>

<file path="app/services/__init__.py">
"""Services package.
This package contains business logic services for the application.
"""
# Plant services
from .plant_species_service import (
    PlantSpeciesService,
    get_species_by_id,
    get_species_by_scientific_name,
    search_species,
    create_species,
    update_species,
    get_popular_species
)
from .user_plant_service import (
    UserPlantService,
    get_plant_by_id,
    get_user_plants,
    create_plant,
    update_plant,
    get_care_reminders,
    update_care_activity,
    get_plant_stats
)
from .plant_care_log_service import (
    PlantCareLogService,
    create_care_log,
    get_care_log_by_id,
    get_plant_care_logs,
    get_user_care_logs,
    get_care_statistics
)
from .plant_identification_service import (
    PlantIdentificationService,
    create_identification,
    get_identification_by_id,
    get_user_identifications,
    verify_identification,
    get_pending_verifications,
    get_identification_statistics
)
from .plant_trade_service import (
    PlantTradeService,
    create_trade,
    get_trade_by_id,
    search_trades,
    express_interest,
    get_trade_statistics
)
from .plant_question_service import (
    PlantQuestionService,
    PlantAnswerService,
    create_question,
    get_question_by_id,
    search_questions,
    create_answer,
    vote_answer,
    mark_question_solved
)
__all__ = [
    # Plant species
    "PlantSpeciesService",
    "get_species_by_id",
    "get_species_by_scientific_name",
    "search_species",
    "create_species",
    "update_species",
    "get_popular_species",
    # User plants
    "UserPlantService",
    "get_plant_by_id",
    "get_user_plants",
    "create_plant",
    "update_plant",
    "get_care_reminders",
    "update_care_activity",
    "get_plant_stats",
    # Plant care logs
    "PlantCareLogService",
    "create_care_log",
    "get_care_log_by_id",
    "get_plant_care_logs",
    "get_user_care_logs",
    "get_care_statistics",
    # Plant identification
    "PlantIdentificationService",
    "create_identification",
    "get_identification_by_id",
    "get_user_identifications",
    "verify_identification",
    "get_pending_verifications",
    "get_identification_statistics",
    # Plant trades
    "PlantTradeService",
    "create_trade",
    "get_trade_by_id",
    "search_trades",
    "express_interest",
    "get_trade_statistics",
    # Plant questions and answers
    "PlantQuestionService",
    "PlantAnswerService",
    "create_question",
    "get_question_by_id",
    "search_questions",
    "create_answer",
    "vote_answer",
    "mark_question_solved",
]
</file>

<file path="app/services/auth_service.py">
"""Authentication service.
This module provides authentication and user management services
using FastAPI-Users and custom business logic.
"""
import uuid
from typing import Optional, Dict, Any, AsyncGenerator
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from fastapi_users import BaseUserManager, UUIDIDMixin
from fastapi_users.db import SQLAlchemyUserDatabase
from fastapi_users.password import PasswordHelper
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from jose import JWTError, jwt
from passlib.context import CryptContext
import redis.asyncio as redis
from app.core.config import settings
from app.core.database import AsyncSessionLocal
from app.models.user import User
from app.schemas.auth import UserCreate, UserUpdate
class UserManager(UUIDIDMixin, BaseUserManager[User, uuid.UUID]):
    """Custom user manager for handling user operations."""
    reset_password_token_secret = settings.SECRET_KEY
    verification_token_secret = settings.SECRET_KEY
    async def on_after_register(self, user: User, request: Optional[Any] = None):
        """Called after user registration."""
        print(f"User {user.id} has registered.")
        # Here you can add logic like sending welcome email,
        # creating default user preferences, etc.
    async def on_after_login(
        self,
        user: User,
        request: Optional[Any] = None,
        response: Optional[Any] = None,
    ):
        """Called after user login."""
        print(f"User {user.id} logged in.")
        # Update last login timestamp
        user.last_login = datetime.utcnow()
        # Note: You'll need to commit this change in the calling code
    async def on_after_update(
        self,
        user: User,
        update_dict: Dict[str, Any],
        request: Optional[Any] = None,
    ):
        """Called after user update."""
        print(f"User {user.id} has been updated with {update_dict}.")
    async def on_after_request_verify(
        self, user: User, token: str, request: Optional[Any] = None
    ):
        """Called after verification request."""
        print(f"Verification requested for user {user.id}. Token: {token}")
        # Here you would send verification email
    async def on_after_verify(
        self, user: User, request: Optional[Any] = None
    ):
        """Called after user verification."""
        print(f"User {user.id} has been verified")
    async def validate_password(
        self,
        password: str,
        user: UserCreate | User,
    ) -> None:
        """Validate password strength."""
        if len(password) < 8:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must be at least 8 characters long"
            )
        # Check for at least one uppercase letter
        if not any(c.isupper() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one uppercase letter"
            )
        # Check for at least one lowercase letter
        if not any(c.islower() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one lowercase letter"
            )
        # Check for at least one digit
        if not any(c.isdigit() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one digit"
            )
        # Check if password contains user's email or username
        if hasattr(user, 'email') and user.email:
            if user.email.lower() in password.lower():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Password cannot contain your email address"
                )
        if hasattr(user, 'username') and user.username:
            if user.username.lower() in password.lower():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Password cannot contain your username"
                )
async def get_user_db() -> AsyncGenerator[SQLAlchemyUserDatabase, None]:
    """Get user database dependency."""
    async with AsyncSessionLocal() as session:
        yield SQLAlchemyUserDatabase(session, User)
async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):
    """Get user manager dependency."""
    yield UserManager(user_db)
class AuthService:
    """Authentication service for custom auth operations."""
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.redis_client = None
    async def get_redis_client(self):
        """Get Redis client for session management."""
        if not self.redis_client:
            self.redis_client = redis.from_url(
                settings.REDIS_URL,
                encoding="utf-8",
                decode_responses=True
            )
        return self.redis_client
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash."""
        return self.pwd_context.verify(plain_password, hashed_password)
    def get_password_hash(self, password: str) -> str:
        """Hash a password."""
        return self.pwd_context.hash(password)
    def create_access_token(
        self, 
        data: dict, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """Create JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(
            to_encode, 
            settings.SECRET_KEY, 
            algorithm=settings.ALGORITHM
        )
        return encoded_jwt
    def create_refresh_token(
        self, 
        data: dict, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """Create JWT refresh token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(days=7)  # Refresh tokens last 7 days
        to_encode.update({"exp": expire, "type": "refresh"})
        encoded_jwt = jwt.encode(
            to_encode, 
            settings.SECRET_KEY, 
            algorithm=settings.ALGORITHM
        )
        return encoded_jwt
    async def verify_token(self, token: str) -> Optional[dict]:
        """Verify and decode JWT token."""
        try:
            payload = jwt.decode(
                token, 
                settings.SECRET_KEY, 
                algorithms=[settings.ALGORITHM]
            )
            return payload
        except JWTError:
            return None
    async def store_refresh_token(
        self, 
        user_id: str, 
        refresh_token: str, 
        expires_in: int = 7 * 24 * 60 * 60  # 7 days in seconds
    ):
        """Store refresh token in Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        await redis_client.setex(key, expires_in, refresh_token)
    async def get_stored_refresh_token(self, user_id: str) -> Optional[str]:
        """Get stored refresh token from Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        return await redis_client.get(key)
    async def revoke_refresh_token(self, user_id: str):
        """Revoke refresh token by deleting from Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        await redis_client.delete(key)
    async def store_user_session(
        self, 
        user_id: str, 
        session_data: dict, 
        expires_in: int = 24 * 60 * 60  # 24 hours
    ):
        """Store user session data in Redis."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        await redis_client.setex(key, expires_in, str(session_data))
    async def get_user_session(self, user_id: str) -> Optional[dict]:
        """Get user session data from Redis."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        session_data = await redis_client.get(key)
        if session_data:
            try:
                return eval(session_data)  # Note: In production, use json.loads
            except:
                return None
        return None
    async def revoke_user_session(self, user_id: str):
        """Revoke user session."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        await redis_client.delete(key)
    async def is_user_online(self, user_id: str) -> bool:
        """Check if user is currently online."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        return await redis_client.exists(key) > 0
    async def set_user_online(
        self, 
        user_id: str, 
        expires_in: int = 5 * 60  # 5 minutes
    ):
        """Mark user as online."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        await redis_client.setex(key, expires_in, "1")
    async def set_user_offline(self, user_id: str):
        """Mark user as offline."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        await redis_client.delete(key)
    async def get_user_by_email(
        self, 
        email: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by email address."""
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()
    async def get_user_by_username(
        self, 
        username: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by username."""
        result = await session.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()
    async def check_username_availability(
        self, 
        username: str, 
        session: AsyncSession,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if username is available."""
        query = select(User).where(User.username == username)
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        result = await session.execute(query)
        return result.scalar_one_or_none() is None
    async def check_email_availability(
        self, 
        email: str, 
        session: AsyncSession,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if email is available."""
        query = select(User).where(User.email == email)
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        result = await session.execute(query)
        return result.scalar_one_or_none() is None
    async def update_last_active(
        self, 
        user_id: str, 
        session: AsyncSession
    ):
        """Update user's last active timestamp."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if user:
            user.last_active = datetime.utcnow()
            await session.commit()
    async def authenticate_user(
        self, 
        username: str, 
        password: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Authenticate user with username/email and password."""
        # Try to find user by username or email
        user = await self.get_user_by_username(username, session)
        if not user:
            user = await self.get_user_by_email(username, session)
        if not user:
            return None
        if not self.verify_password(password, user.hashed_password):
            return None
        return user
    async def get_current_user(
        self, 
        token: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get current user from JWT token."""
        payload = await self.verify_token(token)
        if not payload:
            return None
        user_id = payload.get("sub")
        if not user_id:
            return None
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()
    async def verify_refresh_token(
        self, 
        token: str
    ) -> Optional[dict]:
        """Verify refresh token and return payload."""
        payload = await self.verify_token(token)
        if not payload or payload.get("type") != "refresh":
            return None
        return payload
    async def get_current_user_from_token(self, token: str, session: AsyncSession) -> Optional[User]:
        """Get current user from token without Bearer prefix."""
        return await self.get_current_user(token, session)
    async def close(self):
        """Close Redis connection."""
        if self.redis_client:
            await self.redis_client.close()
# Global auth service instance
auth_service = AuthService()
async def get_auth_service() -> AuthService:
    """Get auth service dependency."""
    return auth_service
async def get_current_user_from_token(token: str, session: AsyncSession) -> Optional[User]:
    """Get current user from token without Bearer prefix."""
    return await auth_service.get_current_user_from_token(token, session)
</file>

<file path="app/services/file_service.py">
"""File upload and media management service.
This module handles file uploads, media processing, and storage
for the messaging and story features.
"""
import os
import uuid
import mimetypes
from typing import Optional, Tuple
from pathlib import Path
from fastapi import UploadFile, HTTPException, status
from PIL import Image
import aiofiles
from app.core.config import settings
class FileService:
    """Service for handling file uploads and media processing."""
    def __init__(self):
        self.upload_dir = Path("uploads")
        self.max_file_size = 50 * 1024 * 1024  # 50MB
        self.allowed_image_types = {"image/jpeg", "image/png", "image/gif", "image/webp"}
        self.allowed_video_types = {"video/mp4", "video/quicktime", "video/x-msvideo"}
        self.allowed_audio_types = {"audio/mpeg", "audio/wav", "audio/ogg"}
        # Create upload directories
        self._create_upload_directories()
    def _create_upload_directories(self) -> None:
        """Create necessary upload directories."""
        directories = [
            self.upload_dir / "images",
            self.upload_dir / "videos", 
            self.upload_dir / "audio",
            self.upload_dir / "thumbnails"
        ]
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
    async def upload_media_file(
        self, 
        file: UploadFile
    ) -> Tuple[str, int, Optional[int]]:
        """Upload a media file and return URL, file size, and duration.
        Args:
            file: The uploaded file
        Returns:
            Tuple of (media_url, file_size, duration)
        Raises:
            HTTPException: If file validation fails
        """
        # Validate file
        await self._validate_file(file)
        # Generate unique filename
        file_extension = Path(file.filename).suffix.lower()
        unique_filename = f"{uuid.uuid4()}{file_extension}"
        # Determine file type and subdirectory
        content_type = file.content_type
        if content_type in self.allowed_image_types:
            subdirectory = "images"
        elif content_type in self.allowed_video_types:
            subdirectory = "videos"
        elif content_type in self.allowed_audio_types:
            subdirectory = "audio"
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Unsupported file type"
            )
        # Save file
        file_path = self.upload_dir / subdirectory / unique_filename
        file_size = await self._save_file(file, file_path)
        # Process file based on type
        duration = None
        if content_type in self.allowed_image_types:
            await self._process_image(file_path)
        elif content_type in self.allowed_video_types:
            duration = await self._process_video(file_path)
        elif content_type in self.allowed_audio_types:
            duration = await self._process_audio(file_path)
        # Return relative URL for the file
        media_url = f"/uploads/{subdirectory}/{unique_filename}"
        return media_url, file_size, duration
    async def _validate_file(self, file: UploadFile) -> None:
        """Validate uploaded file.
        Args:
            file: The uploaded file
        Raises:
            HTTPException: If validation fails
        """
        if not file.filename:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No file provided"
            )
        # Check file size
        file.file.seek(0, 2)  # Seek to end
        file_size = file.file.tell()
        file.file.seek(0)  # Reset to beginning
        if file_size > self.max_file_size:
            raise HTTPException(
                status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
                detail=f"File too large. Maximum size is {self.max_file_size // (1024*1024)}MB"
            )
        # Check content type
        content_type = file.content_type
        allowed_types = (
            self.allowed_image_types | 
            self.allowed_video_types | 
            self.allowed_audio_types
        )
        if content_type not in allowed_types:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Unsupported file type: {content_type}"
            )
    async def _save_file(self, file: UploadFile, file_path: Path) -> int:
        """Save uploaded file to disk.
        Args:
            file: The uploaded file
            file_path: Path where to save the file
        Returns:
            File size in bytes
        """
        file_size = 0
        async with aiofiles.open(file_path, 'wb') as f:
            while chunk := await file.read(8192):  # Read in 8KB chunks
                await f.write(chunk)
                file_size += len(chunk)
        return file_size
    async def _process_image(self, file_path: Path) -> None:
        """Process uploaded image (resize, optimize).
        Args:
            file_path: Path to the image file
        """
        try:
            with Image.open(file_path) as img:
                # Convert to RGB if necessary
                if img.mode in ('RGBA', 'LA', 'P'):
                    img = img.convert('RGB')
                # Resize if too large (max 1920x1920)
                max_size = (1920, 1920)
                if img.size[0] > max_size[0] or img.size[1] > max_size[1]:
                    img.thumbnail(max_size, Image.Resampling.LANCZOS)
                # Save optimized version
                img.save(file_path, optimize=True, quality=85)
                # Create thumbnail
                thumbnail_path = (
                    self.upload_dir / "thumbnails" / 
                    f"thumb_{file_path.name}"
                )
                img.thumbnail((300, 300), Image.Resampling.LANCZOS)
                img.save(thumbnail_path, optimize=True, quality=80)
        except Exception as e:
            # If image processing fails, keep original file
            print(f"Image processing failed for {file_path}: {e}")
    async def _process_video(self, file_path: Path) -> Optional[int]:
        """Process uploaded video (get duration, create thumbnail).
        Args:
            file_path: Path to the video file
        Returns:
            Video duration in seconds
        """
        # For now, return None as duration
        # In a production app, you'd use ffmpeg to get duration and create thumbnails
        return None
    async def _process_audio(self, file_path: Path) -> Optional[int]:
        """Process uploaded audio (get duration).
        Args:
            file_path: Path to the audio file
        Returns:
            Audio duration in seconds
        """
        # For now, return None as duration
        # In a production app, you'd use ffmpeg or similar to get duration
        return None
    async def delete_file(self, file_url: str) -> bool:
        """Delete a file from storage.
        Args:
            file_url: URL of the file to delete
        Returns:
            True if file was deleted, False otherwise
        """
        try:
            # Convert URL to file path
            if file_url.startswith("/uploads/"):
                relative_path = file_url[1:]  # Remove leading slash
                file_path = Path(relative_path)
                if file_path.exists():
                    file_path.unlink()
                    # Also delete thumbnail if it exists
                    if file_path.parent.name in ["images", "videos"]:
                        thumbnail_path = (
                            self.upload_dir / "thumbnails" / 
                            f"thumb_{file_path.name}"
                        )
                        if thumbnail_path.exists():
                            thumbnail_path.unlink()
                    return True
            return False
        except Exception as e:
            print(f"Error deleting file {file_url}: {e}")
            return False
# Global instance
file_service = FileService()
# Convenience functions for backward compatibility
async def upload_media_file(file: UploadFile) -> Tuple[str, int, Optional[int]]:
    """Upload a media file.
    Args:
        file: The uploaded file
    Returns:
        Tuple of (media_url, file_size, duration)
    """
    return await file_service.upload_media_file(file)
async def delete_media_file(file_url: str) -> bool:
    """Delete a media file.
    Args:
        file_url: URL of the file to delete
    Returns:
        True if file was deleted, False otherwise
    """
    return await file_service.delete_file(file_url)
</file>

<file path="app/services/friendship_service.py">
"""Friendship service.
This module provides friendship management services including
friend requests, friend management, and social features.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.friendship import Friendship, FriendshipStatus
from app.models.user import User
from app.schemas.friendship import (
    FriendRequestCreate, FriendshipUpdate, FriendProfile,
    FriendsList, FriendRequestsList, MutualFriends,
    FriendshipStats, FriendSuggestion, FriendActivity
)
from app.core.websocket import websocket_manager
class FriendshipService:
    """Service for friendship management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def send_friend_request(
        self,
        requester_id: str,
        request_data: FriendRequestCreate,
        session: AsyncSession
    ) -> Optional[Friendship]:
        """Send a friend request."""
        addressee_id = request_data.user_id
        # Check if trying to add self
        if requester_id == addressee_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You cannot send a friend request to yourself"
            )
        # Check if addressee exists
        addressee = await session.get(User, addressee_id)
        if not addressee or not addressee.is_active:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        # Check if friendship already exists
        existing_friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == requester_id,
                        Friendship.addressee_id == addressee_id
                    ),
                    and_(
                        Friendship.requester_id == addressee_id,
                        Friendship.addressee_id == requester_id
                    )
                )
            )
        )
        existing_friendship = existing_friendship.scalar_one_or_none()
        if existing_friendship:
            if existing_friendship.status == FriendshipStatus.ACCEPTED:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="You are already friends with this user"
                )
            elif existing_friendship.status == FriendshipStatus.PENDING:
                if existing_friendship.requester_id == requester_id:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Friend request already sent"
                    )
                else:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="This user has already sent you a friend request"
                    )
            elif existing_friendship.status == FriendshipStatus.BLOCKED:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Cannot send friend request to this user"
                )
            elif existing_friendship.status == FriendshipStatus.DECLINED:
                # Allow sending new request after decline
                existing_friendship.status = FriendshipStatus.PENDING
                existing_friendship.requester_id = requester_id
                existing_friendship.addressee_id = addressee_id
                existing_friendship.updated_at = datetime.utcnow()
                await session.commit()
                await session.refresh(existing_friendship)
                # Send notification
                await self._send_friend_request_notification(
                    existing_friendship, request_data.message, session
                )
                return existing_friendship
        # Create new friend request
        friendship = Friendship(
            requester_id=requester_id,
            addressee_id=addressee_id,
            status=FriendshipStatus.PENDING
        )
        session.add(friendship)
        await session.commit()
        await session.refresh(friendship)
        # Send notification
        await self._send_friend_request_notification(
            friendship, request_data.message, session
        )
        return friendship
    async def accept_friend_request(
        self,
        friendship_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Accept a friend request."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.id == friendship_id,
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friend request not found"
            )
        # Accept the request
        friendship.status = FriendshipStatus.ACCEPTED
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        # Send acceptance notification
        await self._send_friend_request_accepted_notification(friendship, session)
        return True
    async def decline_friend_request(
        self,
        friendship_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Decline a friend request."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.id == friendship_id,
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friend request not found"
            )
        # Decline the request
        friendship.status = FriendshipStatus.DECLINED
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        return True
    async def remove_friend(
        self,
        user_id: str,
        friend_id: str,
        session: AsyncSession
    ) -> bool:
        """Remove a friend."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user_id,
                            Friendship.addressee_id == friend_id
                        ),
                        and_(
                            Friendship.requester_id == friend_id,
                            Friendship.addressee_id == user_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friendship not found"
            )
        # Remove the friendship
        await session.delete(friendship)
        await session.commit()
        return True
    async def get_friends_list(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 50,
        offset: int = 0,
        close_friends_only: bool = False
    ) -> FriendsList:
        """Get user's friends list."""
        # Build query for friends
        friends_query = (
            select(
                Friendship,
                User,
                func.case(
                    (Friendship.requester_id == user_id, Friendship.addressee_id),
                    else_=Friendship.requester_id
                ).label("friend_id")
            )
            .join(
                User,
                User.id == func.case(
                    (Friendship.requester_id == user_id, Friendship.addressee_id),
                    else_=Friendship.requester_id
                )
            )
            .where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    User.is_active == True
                )
            )
        )
        if close_friends_only:
            friends_query = friends_query.where(Friendship.is_close_friend == True)
        # Get total count
        count_query = select(func.count()).select_from(friends_query.subquery())
        total_count = await session.scalar(count_query) or 0
        # Add pagination and ordering
        friends_query = (
            friends_query
            .order_by(asc(User.display_name))
            .offset(offset)
            .limit(limit)
        )
        result = await session.execute(friends_query)
        friends_data = result.all()
        # Convert to FriendProfile format
        friends = []
        for friendship, user, friend_id in friends_data:
            # Get mutual friends count
            mutual_count = await self._get_mutual_friends_count(user_id, str(friend_id), session)
            friend_profile = FriendProfile(
                user_id=str(user.id),
                username=user.username,
                display_name=user.display_name,
                avatar_url=user.avatar_url,
                bio=user.bio,
                gardening_experience=user.gardening_experience,
                favorite_plants=user.favorite_plants,
                location=user.location,
                friendship_id=str(friendship.id),
                is_close_friend=friendship.is_close_friend,
                friends_since=friendship.created_at,
                last_active=user.last_active,
                is_online=False,  # Will be updated with real-time data
                mutual_friends_count=mutual_count,
                stories_count=0  # Could be calculated if needed
            )
            friends.append(friend_profile)
        # Get additional counts
        close_friends_count = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        ) or 0
        return FriendsList(
            friends=friends,
            total_count=total_count,
            close_friends_count=close_friends_count,
            online_friends_count=0  # Would need real-time data
        )
    async def get_friend_requests(
        self,
        user_id: str,
        session: AsyncSession
    ) -> FriendRequestsList:
        """Get pending friend requests for a user."""
        # Received requests
        received_query = (
            select(Friendship, User)
            .join(User, User.id == Friendship.requester_id)
            .where(
                and_(
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
            .order_by(desc(Friendship.created_at))
        )
        # Sent requests
        sent_query = (
            select(Friendship, User)
            .join(User, User.id == Friendship.addressee_id)
            .where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
            .order_by(desc(Friendship.created_at))
        )
        received_result = await session.execute(received_query)
        sent_result = await session.execute(sent_query)
        # Convert to FriendshipRead format
        from app.schemas.friendship import FriendshipRead
        pending_requests = []
        for friendship, user in received_result:
            request = FriendshipRead(
                id=str(friendship.id),
                requester_id=str(friendship.requester_id),
                addressee_id=str(friendship.addressee_id),
                status=friendship.status,
                is_close_friend=friendship.is_close_friend,
                created_at=friendship.created_at,
                updated_at=friendship.updated_at,
                requester_username=user.username,
                requester_display_name=user.display_name,
                requester_avatar_url=user.avatar_url
            )
            pending_requests.append(request)
        sent_requests = []
        for friendship, user in sent_result:
            request = FriendshipRead(
                id=str(friendship.id),
                requester_id=str(friendship.requester_id),
                addressee_id=str(friendship.addressee_id),
                status=friendship.status,
                is_close_friend=friendship.is_close_friend,
                created_at=friendship.created_at,
                updated_at=friendship.updated_at,
                addressee_username=user.username,
                addressee_display_name=user.display_name,
                addressee_avatar_url=user.avatar_url
            )
            sent_requests.append(request)
        return FriendRequestsList(
            pending_requests=pending_requests,
            sent_requests=sent_requests,
            total_pending=len(pending_requests),
            total_sent=len(sent_requests)
        )
    async def toggle_close_friend(
        self,
        user_id: str,
        friend_id: str,
        session: AsyncSession
    ) -> bool:
        """Toggle close friend status."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user_id,
                            Friendship.addressee_id == friend_id
                        ),
                        and_(
                            Friendship.requester_id == friend_id,
                            Friendship.addressee_id == user_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friendship not found"
            )
        # Toggle close friend status
        friendship.is_close_friend = not friendship.is_close_friend
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        return friendship.is_close_friend
    async def block_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Block a user."""
        if blocker_id == blocked_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You cannot block yourself"
            )
        # Check if user exists
        blocked_user = await session.get(User, blocked_id)
        if not blocked_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        # Check existing friendship
        existing_friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == blocker_id,
                        Friendship.addressee_id == blocked_id
                    ),
                    and_(
                        Friendship.requester_id == blocked_id,
                        Friendship.addressee_id == blocker_id
                    )
                )
            )
        )
        existing_friendship = existing_friendship.scalar_one_or_none()
        if existing_friendship:
            # Update existing relationship to blocked
            existing_friendship.status = FriendshipStatus.BLOCKED
            existing_friendship.requester_id = blocker_id  # Blocker becomes requester
            existing_friendship.addressee_id = blocked_id
            existing_friendship.is_close_friend = False
            existing_friendship.updated_at = datetime.utcnow()
        else:
            # Create new blocked relationship
            friendship = Friendship(
                requester_id=blocker_id,
                addressee_id=blocked_id,
                status=FriendshipStatus.BLOCKED
            )
            session.add(friendship)
        await session.commit()
        return True
    async def unblock_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Unblock a user."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.requester_id == blocker_id,
                    Friendship.addressee_id == blocked_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Block relationship not found"
            )
        # Remove the block
        await session.delete(friendship)
        await session.commit()
        return True
    async def get_friendship_status(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> str:
        """Get friendship status between two users."""
        if user1_id == user2_id:
            return "self"
        result = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == user1_id,
                        Friendship.addressee_id == user2_id
                    ),
                    and_(
                        Friendship.requester_id == user2_id,
                        Friendship.addressee_id == user1_id
                    )
                )
            )
        )
        friendship = result.scalar_one_or_none()
        if not friendship:
            return "none"
        if friendship.status == FriendshipStatus.BLOCKED:
            if friendship.requester_id == user1_id:
                return "blocked_by_you"
            else:
                return "blocked_by_them"
        elif friendship.status == FriendshipStatus.PENDING:
            if friendship.requester_id == user1_id:
                return "pending_sent"
            else:
                return "pending_received"
        elif friendship.status == FriendshipStatus.ACCEPTED:
            return "friends"
        elif friendship.status == FriendshipStatus.DECLINED:
            return "declined"
        return "none"
    async def get_mutual_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession,
        limit: int = 10
    ) -> MutualFriends:
        """Get mutual friends between two users."""
        # This is a complex query - simplified implementation
        mutual_friends = []  # Would implement actual mutual friends logic
        return MutualFriends(
            user_id=user2_id,
            mutual_friends=mutual_friends,
            mutual_friends_count=len(mutual_friends),
            total_friends_count=0  # Would calculate actual count
        )
    async def get_friendship_stats(
        self,
        user_id: str,
        session: AsyncSession
    ) -> FriendshipStats:
        """Get friendship statistics for a user."""
        # Total friends
        total_friends = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        ) or 0
        # Close friends
        close_friends = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        ) or 0
        # Pending requests received
        pending_received = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        ) or 0
        # Pending requests sent
        pending_sent = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        ) or 0
        # Blocked users
        blocked_users = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        ) or 0
        return FriendshipStats(
            user_id=user_id,
            total_friends=total_friends,
            close_friends=close_friends,
            pending_requests_received=pending_received,
            pending_requests_sent=pending_sent,
            blocked_users=blocked_users
        )
    async def _get_mutual_friends_count(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> int:
        """Get count of mutual friends between two users."""
        # Simplified implementation - would need complex query for actual mutual friends
        return 0
    async def _send_friend_request_notification(
        self,
        friendship: Friendship,
        message: Optional[str],
        session: AsyncSession
    ):
        """Send friend request notification."""
        requester = await session.get(User, friendship.requester_id)
        if requester:
            notification_data = {
                "type": "friend_request",
                "friendship_id": str(friendship.id),
                "requester_id": str(friendship.requester_id),
                "requester_username": requester.username,
                "requester_display_name": requester.display_name,
                "requester_avatar_url": requester.avatar_url,
                "message": message,
                "timestamp": friendship.created_at.isoformat()
            }
            await self.connection_manager.send_personal_message(
                str(friendship.addressee_id),
                notification_data
            )
    async def _send_friend_request_accepted_notification(
        self,
        friendship: Friendship,
        session: AsyncSession
    ):
        """Send friend request accepted notification."""
        addressee = await session.get(User, friendship.addressee_id)
        if addressee:
            notification_data = {
                "type": "friend_request_accepted",
                "friendship_id": str(friendship.id),
                "accepter_id": str(friendship.addressee_id),
                "accepter_username": addressee.username,
                "accepter_display_name": addressee.display_name,
                "accepter_avatar_url": addressee.avatar_url,
                "timestamp": friendship.updated_at.isoformat()
            }
            await self.connection_manager.send_personal_message(
                str(friendship.requester_id),
                notification_data
            )
# Global friendship service instance
friendship_service = FriendshipService()
# Convenience functions for backward compatibility
async def check_friendship_status(
    user_id: str,
    other_user_id: str,
    session: AsyncSession
) -> Optional[str]:
    """Check friendship status between two users."""
    friendship = await session.execute(
        select(Friendship).where(
            or_(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == other_user_id
                ),
                and_(
                    Friendship.requester_id == other_user_id,
                    Friendship.addressee_id == user_id
                )
            )
        )
    )
    friendship = friendship.scalar_one_or_none()
    if not friendship:
        return None
    return friendship.status.value
async def send_friend_request(
    requester_id: str,
    addressee_id: str,
    session: AsyncSession
) -> dict:
    """Send a friend request."""
    return await friendship_service.send_friend_request(requester_id, addressee_id, session)
async def accept_friend_request(
    request_id: str,
    user_id: str,
    session: AsyncSession
) -> dict:
    """Accept a friend request."""
    return await friendship_service.accept_friend_request(request_id, user_id, session)
async def decline_friend_request(
    request_id: str,
    user_id: str,
    session: AsyncSession
) -> dict:
    """Decline a friend request."""
    return await friendship_service.decline_friend_request(request_id, user_id, session)
async def remove_friend(
    user_id: str,
    friend_id: str,
    session: AsyncSession
) -> dict:
    """Remove a friend."""
    return await friendship_service.remove_friend(user_id, friend_id, session)
async def block_user(
    user_id: str,
    blocked_user_id: str,
    session: AsyncSession
) -> dict:
    """Block a user."""
    return await friendship_service.block_user(user_id, blocked_user_id, session)
async def unblock_user(
    user_id: str,
    blocked_user_id: str,
    session: AsyncSession
) -> dict:
    """Unblock a user."""
    return await friendship_service.unblock_user(user_id, blocked_user_id, session)
async def get_friends_list(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get friends list."""
    return await friendship_service.get_friends_list(user_id, session)
async def get_pending_requests(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get pending friend requests."""
    return await friendship_service.get_pending_requests(user_id, session)
async def get_sent_requests(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get sent friend requests."""
    return await friendship_service.get_sent_requests(user_id, session)
async def get_blocked_users(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get blocked users."""
    return await friendship_service.get_blocked_users(user_id, session)
async def toggle_close_friend(
    user_id: str,
    friend_id: str,
    session: AsyncSession
) -> dict:
    """Toggle close friend status."""
    return await friendship_service.toggle_close_friend(user_id, friend_id, session)
async def get_close_friends(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get close friends."""
    return await friendship_service.get_close_friends(user_id, session)
async def get_friendship_service() -> FriendshipService:
    """Get friendship service dependency."""
    return friendship_service
</file>

<file path="app/services/local_nursery_service.py">
"""Local nursery service.
This module provides business logic for local nursery and garden center operations.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
import math
from sqlalchemy import select, func, desc, and_, or_, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent, UserNurseryFavorite
from app.schemas.nursery import LocalNurseryCreate, NurseryReviewCreate, NurserySearchFilters
class LocalNurseryService:
    """Service for managing local nurseries and garden centers."""
    @staticmethod
    async def search_nurseries(
        db: AsyncSession,
        filters: NurserySearchFilters,
        limit: int = 20,
        offset: int = 0
    ) -> List[LocalNursery]:
        """Search for nurseries based on location and filters."""
        query = select(LocalNursery).where(LocalNursery.is_active == True)
        # Add location-based filtering if coordinates provided
        if filters.latitude and filters.longitude:
            # Use Haversine formula for distance calculation
            distance_query = func.acos(
                func.cos(func.radians(filters.latitude)) *
                func.cos(func.radians(LocalNursery.latitude)) *
                func.cos(func.radians(LocalNursery.longitude) - func.radians(filters.longitude)) +
                func.sin(func.radians(filters.latitude)) *
                func.sin(func.radians(LocalNursery.latitude))
            ) * 6371  # Earth's radius in km
            query = query.where(distance_query <= filters.radius_km)
        # Add business type filter
        if filters.business_type:
            query = query.where(LocalNursery.business_type == filters.business_type)
        # Add specialties filter
        if filters.specialties:
            # Check if any of the specialties match
            specialty_conditions = []
            for specialty in filters.specialties:
                specialty_conditions.append(
                    LocalNursery.specialties.op('@>')([specialty])
                )
            query = query.where(or_(*specialty_conditions))
        # Order by rating and distance
        query = query.order_by(desc(LocalNursery.average_rating))
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
    @staticmethod
    async def get_nursery_by_id(
        db: AsyncSession,
        nursery_id: UUID
    ) -> Optional[LocalNursery]:
        """Get nursery by ID."""
        result = await db.execute(
            select(LocalNursery).where(LocalNursery.id == nursery_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def create_nursery(
        db: AsyncSession,
        nursery_data: LocalNurseryCreate
    ) -> LocalNursery:
        """Create a new nursery."""
        nursery = LocalNursery(**nursery_data.model_dump())
        db.add(nursery)
        await db.commit()
        await db.refresh(nursery)
        return nursery
    @staticmethod
    async def get_nursery_reviews(
        db: AsyncSession,
        nursery_id: UUID,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryReview]:
        """Get reviews for a nursery."""
        result = await db.execute(
            select(NurseryReview).options(
                selectinload(NurseryReview.user)
            ).where(
                and_(
                    NurseryReview.nursery_id == nursery_id,
                    NurseryReview.is_active == True
                )
            ).order_by(desc(NurseryReview.created_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def create_review(
        db: AsyncSession,
        nursery_id: UUID,
        user_id: UUID,
        review_data: NurseryReviewCreate
    ) -> NurseryReview:
        """Create a new nursery review."""
        review = NurseryReview(
            nursery_id=nursery_id,
            user_id=user_id,
            **review_data.model_dump()
        )
        db.add(review)
        # Update nursery rating
        await LocalNurseryService._update_nursery_rating(db, nursery_id)
        await db.commit()
        await db.refresh(review, ['user'])
        return review
    @staticmethod
    async def _update_nursery_rating(
        db: AsyncSession,
        nursery_id: UUID
    ):
        """Update the average rating for a nursery."""
        result = await db.execute(
            select(
                func.avg(NurseryReview.rating).label('avg_rating'),
                func.count(NurseryReview.id).label('total_reviews')
            ).where(
                and_(
                    NurseryReview.nursery_id == nursery_id,
                    NurseryReview.is_active == True
                )
            )
        )
        stats = result.first()
        if stats:
            # Update nursery with new stats
            nursery_result = await db.execute(
                select(LocalNursery).where(LocalNursery.id == nursery_id)
            )
            nursery = nursery_result.scalar_one_or_none()
            if nursery:
                nursery.average_rating = float(stats.avg_rating or 0.0)
                nursery.total_reviews = int(stats.total_reviews or 0)
    @staticmethod
    async def get_nursery_events(
        db: AsyncSession,
        nursery_id: UUID,
        upcoming_only: bool = True,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryEvent]:
        """Get events for a nursery."""
        query = select(NurseryEvent).where(
            and_(
                NurseryEvent.nursery_id == nursery_id,
                NurseryEvent.is_active == True,
                NurseryEvent.is_cancelled == False
            )
        )
        if upcoming_only:
            query = query.where(NurseryEvent.start_date >= datetime.utcnow())
        query = query.order_by(NurseryEvent.start_date)
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
    @staticmethod
    async def toggle_favorite(
        db: AsyncSession,
        user_id: UUID,
        nursery_id: UUID
    ) -> bool:
        """Toggle nursery favorite status for user."""
        # Check if already favorited
        result = await db.execute(
            select(UserNurseryFavorite).where(
                and_(
                    UserNurseryFavorite.user_id == user_id,
                    UserNurseryFavorite.nursery_id == nursery_id
                )
            )
        )
        existing_favorite = result.scalar_one_or_none()
        if existing_favorite:
            # Remove from favorites
            await db.delete(existing_favorite)
            await db.commit()
            return False
        else:
            # Add to favorites
            favorite = UserNurseryFavorite(
                user_id=user_id,
                nursery_id=nursery_id
            )
            db.add(favorite)
            await db.commit()
            return True
    @staticmethod
    async def get_user_favorites(
        db: AsyncSession,
        user_id: UUID
    ) -> List[LocalNursery]:
        """Get user's favorite nurseries."""
        result = await db.execute(
            select(LocalNursery).join(UserNurseryFavorite).where(
                UserNurseryFavorite.user_id == user_id
            ).order_by(UserNurseryFavorite.created_at)
        )
        return result.scalars().all()
    @staticmethod
    async def get_nearby_events(
        db: AsyncSession,
        latitude: Optional[float],
        longitude: Optional[float],
        radius_km: float = 50,
        event_type: Optional[str] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryEvent]:
        """Get nearby nursery events."""
        query = select(NurseryEvent).options(
            selectinload(NurseryEvent.nursery)
        ).join(LocalNursery).where(
            and_(
                NurseryEvent.is_active == True,
                NurseryEvent.is_cancelled == False,
                NurseryEvent.start_date >= datetime.utcnow(),
                LocalNursery.is_active == True
            )
        )
        # Add location filter if coordinates provided
        if latitude and longitude:
            distance_query = func.acos(
                func.cos(func.radians(latitude)) *
                func.cos(func.radians(LocalNursery.latitude)) *
                func.cos(func.radians(LocalNursery.longitude) - func.radians(longitude)) +
                func.sin(func.radians(latitude)) *
                func.sin(func.radians(LocalNursery.latitude))
            ) * 6371
            query = query.where(distance_query <= radius_km)
        # Add event type filter
        if event_type:
            query = query.where(NurseryEvent.event_type == event_type)
        query = query.order_by(NurseryEvent.start_date)
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
</file>

<file path="app/services/message_service.py">
"""Message service.
This module provides messaging services including
sending, receiving, and managing messages.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.message import Message
from app.schemas.message import MessageType, MessageStatus
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.schemas.message import (
    MessageCreate, MessageUpdate, MessageRead, MessageThread,
    MessageSearch, MessageAnalytics
)
from app.core.websocket import websocket_manager
class MessageService:
    """Service for message management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def send_message(
        self,
        sender_id: str,
        message_data: MessageCreate,
        session: AsyncSession
    ) -> Optional[Message]:
        """Send a message to another user."""
        # Check if users are friends
        if not await self._are_users_friends(sender_id, message_data.recipient_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only send messages to friends"
            )
        # Check if recipient exists and is active
        recipient = await session.execute(
            select(User).where(
                and_(
                    User.id == message_data.recipient_id,
                    User.is_active == True
                )
            )
        )
        recipient = recipient.scalar_one_or_none()
        if not recipient:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Recipient not found"
            )
        # Validate message content based on type
        await self._validate_message_content(message_data)
        # Create message
        message = Message(
            sender_id=sender_id,
            recipient_id=message_data.recipient_id,
            content_type=message_data.content_type,
            content=message_data.content,
            media_url=message_data.media_url,
            caption=message_data.caption,
            duration=message_data.duration,
            file_size=message_data.file_size,
            disappears_at=message_data.disappears_at,
            status=MessageStatus.SENT
        )
        session.add(message)
        await session.commit()
        await session.refresh(message)
        # Send real-time notification
        await self._send_real_time_notification(message, session)
        return message
    async def get_message_by_id(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession
    ) -> Optional[Message]:
        """Get message by ID if user has access."""
        result = await session.execute(
            select(Message).where(
                and_(
                    Message.id == message_id,
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    )
                )
            )
        )
        return result.scalar_one_or_none()
    async def get_conversation(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession,
        limit: int = 50,
        offset: int = 0,
        before_message_id: Optional[str] = None
    ) -> List[MessageRead]:
        """Get conversation between two users."""
        # Check if users are friends
        if not await self._are_users_friends(user1_id, user2_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only view conversations with friends"
            )
        # Build query
        query = select(Message).where(
            and_(
                or_(
                    and_(
                        Message.sender_id == user1_id,
                        Message.recipient_id == user2_id
                    ),
                    and_(
                        Message.sender_id == user2_id,
                        Message.recipient_id == user1_id
                    )
                ),
                Message.status != MessageStatus.DELETED
            )
        )
        # Add before_message_id filter for pagination
        if before_message_id:
            before_message = await self.get_message_by_id(before_message_id, user1_id, session)
            if before_message:
                query = query.where(Message.created_at < before_message.created_at)
        # Add ordering and pagination
        query = query.order_by(desc(Message.created_at)).offset(offset).limit(limit)
        result = await session.execute(query)
        messages = result.scalars().all()
        # Convert to MessageRead format
        message_reads = []
        for message in messages:
            # Get sender and recipient info
            sender = await session.get(User, message.sender_id)
            recipient = await session.get(User, message.recipient_id)
            message_read = MessageRead(
                id=str(message.id),
                sender_id=str(message.sender_id),
                recipient_id=str(message.recipient_id),
                content_type=message.content_type,
                content=message.content,
                media_url=message.media_url,
                caption=message.caption,
                duration=message.duration,
                file_size=message.file_size,
                status=message.status,
                created_at=message.created_at,
                updated_at=message.updated_at,
                delivered_at=message.delivered_at,
                read_at=message.read_at,
                disappears_at=message.disappears_at,
                sender_username=sender.username if sender else None,
                sender_display_name=sender.display_name if sender else None,
                sender_avatar_url=sender.avatar_url if sender else None,
                recipient_username=recipient.username if recipient else None,
                recipient_display_name=recipient.display_name if recipient else None,
                recipient_avatar_url=recipient.avatar_url if recipient else None
            )
            message_reads.append(message_read)
        return message_reads
    async def get_user_conversations(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 20,
        offset: int = 0
    ) -> List[MessageThread]:
        """Get list of user's conversations with latest message."""
        # Get latest message for each conversation
        subquery = (
            select(
                func.max(Message.id).label("latest_message_id"),
                func.case(
                    (Message.sender_id == user_id, Message.recipient_id),
                    else_=Message.sender_id
                ).label("other_user_id")
            )
            .where(
                and_(
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    ),
                    Message.status != MessageStatus.DELETED
                )
            )
            .group_by("other_user_id")
            .subquery()
        )
        # Get the actual latest messages
        query = (
            select(Message, User)
            .join(subquery, Message.id == subquery.c.latest_message_id)
            .join(User, User.id == subquery.c.other_user_id)
            .order_by(desc(Message.created_at))
            .offset(offset)
            .limit(limit)
        )
        result = await session.execute(query)
        conversations = []
        for message, other_user in result:
            # Count unread messages
            unread_count = await session.scalar(
                select(func.count(Message.id)).where(
                    and_(
                        Message.sender_id == str(other_user.id),
                        Message.recipient_id == user_id,
                        Message.read_at.is_(None),
                        Message.status != MessageStatus.DELETED
                    )
                )
            ) or 0
            conversation = MessageThread(
                other_user_id=str(other_user.id),
                other_user_username=other_user.username,
                other_user_display_name=other_user.display_name,
                other_user_avatar_url=other_user.avatar_url,
                latest_message_id=str(message.id),
                latest_message_content=message.content,
                latest_message_type=message.content_type,
                latest_message_timestamp=message.created_at,
                unread_count=unread_count,
                is_other_user_online=False  # Will be updated with real-time data
            )
            conversations.append(conversation)
        return conversations
    async def mark_message_as_read(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Mark a message as read."""
        message = await session.execute(
            select(Message).where(
                and_(
                    Message.id == message_id,
                    Message.recipient_id == user_id,
                    Message.read_at.is_(None)
                )
            )
        )
        message = message.scalar_one_or_none()
        if message:
            message.read_at = datetime.utcnow()
            message.status = MessageStatus.READ
            await session.commit()
            # Send read receipt notification
            await self._send_read_receipt(message)
            return True
        return False
    async def mark_conversation_as_read(
        self,
        user_id: str,
        other_user_id: str,
        session: AsyncSession
    ) -> int:
        """Mark all messages in a conversation as read."""
        # Get unread messages
        result = await session.execute(
            select(Message).where(
                and_(
                    Message.sender_id == other_user_id,
                    Message.recipient_id == user_id,
                    Message.read_at.is_(None),
                    Message.status != MessageStatus.DELETED
                )
            )
        )
        messages = result.scalars().all()
        # Mark as read
        read_count = 0
        for message in messages:
            message.read_at = datetime.utcnow()
            message.status = MessageStatus.READ
            read_count += 1
        if read_count > 0:
            await session.commit()
            # Send read receipt for the latest message
            if messages:
                latest_message = max(messages, key=lambda m: m.created_at)
                await self._send_read_receipt(latest_message)
        return read_count
    async def delete_message(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession,
        delete_for_everyone: bool = False
    ) -> bool:
        """Delete a message."""
        message = await self.get_message_by_id(message_id, user_id, session)
        if not message:
            return False
        # Check permissions
        if delete_for_everyone and message.sender_id != user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only delete your own messages for everyone"
            )
        if delete_for_everyone:
            # Delete for everyone
            message.status = MessageStatus.DELETED
            message.content = "This message was deleted"
            message.media_url = None
            message.caption = None
        else:
            # For now, we'll implement soft delete for everyone
            # In a real app, you might want user-specific deletion
            message.status = MessageStatus.DELETED
        message.updated_at = datetime.utcnow()
        await session.commit()
        # Send deletion notification
        await self._send_message_deletion_notification(message)
        return True
    async def search_messages(
        self,
        user_id: str,
        search_params: MessageSearch,
        session: AsyncSession
    ) -> List[MessageRead]:
        """Search messages for a user."""
        query = select(Message).where(
            and_(
                or_(
                    Message.sender_id == user_id,
                    Message.recipient_id == user_id
                ),
                Message.status != MessageStatus.DELETED
            )
        )
        # Add search filters
        if search_params.query:
            query = query.where(
                or_(
                    Message.content.ilike(f"%{search_params.query}%"),
                    Message.caption.ilike(f"%{search_params.query}%")
                )
            )
        if search_params.content_type:
            query = query.where(Message.content_type == search_params.content_type)
        if search_params.sender_id:
            query = query.where(Message.sender_id == search_params.sender_id)
        if search_params.start_date:
            query = query.where(Message.created_at >= search_params.start_date)
        if search_params.end_date:
            query = query.where(Message.created_at <= search_params.end_date)
        # Add ordering and pagination
        query = query.order_by(desc(Message.created_at)).limit(50)
        result = await session.execute(query)
        messages = result.scalars().all()
        # Convert to MessageRead format (simplified)
        message_reads = []
        for message in messages:
            message_read = MessageRead(
                id=str(message.id),
                sender_id=str(message.sender_id),
                recipient_id=str(message.recipient_id),
                content_type=message.content_type,
                content=message.content,
                media_url=message.media_url,
                caption=message.caption,
                duration=message.duration,
                file_size=message.file_size,
                status=message.status,
                created_at=message.created_at,
                updated_at=message.updated_at,
                delivered_at=message.delivered_at,
                read_at=message.read_at,
                disappears_at=message.disappears_at
            )
            message_reads.append(message_read)
        return message_reads
    async def get_message_analytics(
        self,
        user_id: str,
        session: AsyncSession,
        days: int = 30
    ) -> MessageAnalytics:
        """Get message analytics for a user."""
        start_date = datetime.utcnow() - timedelta(days=days)
        # Messages sent
        messages_sent = await session.scalar(
            select(func.count(Message.id)).where(
                and_(
                    Message.sender_id == user_id,
                    Message.created_at >= start_date
                )
            )
        ) or 0
        # Messages received
        messages_received = await session.scalar(
            select(func.count(Message.id)).where(
                and_(
                    Message.recipient_id == user_id,
                    Message.created_at >= start_date
                )
            )
        ) or 0
        # Active conversations
        active_conversations = await session.scalar(
            select(func.count(func.distinct(
                func.case(
                    (Message.sender_id == user_id, Message.recipient_id),
                    else_=Message.sender_id
                )
            ))).where(
                and_(
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    ),
                    Message.created_at >= start_date
                )
            )
        ) or 0
        return MessageAnalytics(
            user_id=user_id,
            messages_sent=messages_sent,
            messages_received=messages_received,
            total_messages=messages_sent + messages_received,
            active_conversations=active_conversations,
            period_days=days
        )
    async def _are_users_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _validate_message_content(self, message_data: MessageCreate):
        """Validate message content based on type."""
        if message_data.content_type == MessageType.TEXT:
            if not message_data.content or len(message_data.content.strip()) == 0:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Text messages must have content"
                )
        elif message_data.content_type in [MessageType.IMAGE, MessageType.VIDEO, MessageType.AUDIO]:
            if not message_data.media_url:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"{message_data.content_type.value} messages must have media_url"
                )
    async def _send_real_time_notification(self, message: Message, session: AsyncSession):
        """Send real-time notification for new message."""
        # Get recipient info
        recipient = await session.get(User, message.recipient_id)
        sender = await session.get(User, message.sender_id)
        if recipient and sender:
            notification_data = {
                "type": "new_message",
                "message_id": str(message.id),
                "sender_id": str(message.sender_id),
                "sender_username": sender.username,
                "sender_display_name": sender.display_name,
                "content_type": message.content_type.value,
                "content": message.content if message.content_type == MessageType.TEXT else None,
                "timestamp": message.created_at.isoformat()
            }
            await websocket_manager.send_personal_message(
                str(message.recipient_id),
                notification_data
            )
    async def _send_read_receipt(self, message: Message):
        """Send read receipt notification."""
        notification_data = {
            "type": "message_read",
            "message_id": str(message.id),
            "read_at": message.read_at.isoformat() if message.read_at else None
        }
        await websocket_manager.send_personal_message(
            str(message.sender_id),
            notification_data
        )
    async def _send_message_deletion_notification(self, message: Message):
        """Send message deletion notification."""
        notification_data = {
            "type": "message_deleted",
            "message_id": str(message.id)
        }
        # Notify both sender and recipient
        await self.connection_manager.send_personal_message(
            str(message.sender_id),
            notification_data
        )
        await self.connection_manager.send_personal_message(
            str(message.recipient_id),
            notification_data
        )
# Global message service instance
message_service = MessageService()
# Convenience functions for backward compatibility
async def create_message(
    sender_id: str,
    message_data: MessageCreate,
    session: AsyncSession
) -> Optional[Message]:
    """Create a new message."""
    return await message_service.send_message(sender_id, message_data, session)
async def get_conversation_messages(
    user_id: str,
    other_user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> List[MessageRead]:
    """Get messages in a conversation."""
    return await message_service.get_conversation_messages(
        user_id, other_user_id, session, limit, offset
    )
async def get_user_conversations(
    user_id: str,
    session: AsyncSession
) -> List[MessageThread]:
    """Get user's conversations."""
    return await message_service.get_user_conversations(user_id, session)
async def mark_message_as_read(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Mark a message as read."""
    return await message_service.mark_message_as_read(message_id, user_id, session)
async def delete_message(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Delete a message."""
    return await message_service.delete_message(message_id, user_id, session)
async def get_message_by_id(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> Optional[MessageRead]:
    """Get a message by ID."""
    return await message_service.get_message_by_id(message_id, user_id, session)
async def get_message_service() -> MessageService:
    """Get message service dependency."""
    return message_service
</file>

<file path="app/services/plant_achievement_service.py">
"""Plant achievement service.
This module provides business logic for plant achievements and milestone tracking.
"""
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, func, desc, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app.models.plant_achievement import PlantAchievement, UserAchievement, PlantMilestone, UserStats
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_identification import PlantIdentification
from app.models.plant_question import PlantQuestion, PlantAnswer
class PlantAchievementService:
    """Service for managing plant achievements."""
    @staticmethod
    async def get_user_achievements(
        db: AsyncSession,
        user_id: UUID,
        limit: int = 50,
        offset: int = 0
    ) -> List[UserAchievement]:
        """Get user's earned achievements."""
        result = await db.execute(
            select(UserAchievement).options(
                selectinload(UserAchievement.achievement)
            ).where(
                UserAchievement.user_id == user_id
            ).order_by(desc(UserAchievement.earned_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def get_available_achievements(
        db: AsyncSession,
        user_id: UUID
    ) -> List[PlantAchievement]:
        """Get achievements available to unlock."""
        # Get achievements user hasn't earned yet
        earned_achievement_ids = await db.execute(
            select(UserAchievement.achievement_id).where(
                UserAchievement.user_id == user_id
            )
        )
        earned_ids = [row[0] for row in earned_achievement_ids.fetchall()]
        result = await db.execute(
            select(PlantAchievement).where(
                and_(
                    PlantAchievement.is_active == True,
                    ~PlantAchievement.id.in_(earned_ids) if earned_ids else True
                )
            ).order_by(PlantAchievement.points)
        )
        return result.scalars().all()
    @staticmethod
    async def check_and_award_achievements(
        db: AsyncSession,
        user_id: UUID
    ) -> List[UserAchievement]:
        """Check and award any newly earned achievements."""
        newly_earned = []
        # Get user stats
        user_stats = await PlantAchievementService.get_or_create_user_stats(db, user_id)
        # Get available achievements
        available_achievements = await PlantAchievementService.get_available_achievements(db, user_id)
        for achievement in available_achievements:
            if await PlantAchievementService._check_achievement_criteria(db, user_id, achievement, user_stats):
                # Award the achievement
                user_achievement = UserAchievement(
                    user_id=user_id,
                    achievement_id=achievement.id,
                    earned_at=datetime.utcnow()
                )
                db.add(user_achievement)
                # Update user stats
                user_stats.total_achievements += 1
                user_stats.total_points += achievement.points
                user_stats.level = PlantAchievementService._calculate_level(user_stats.total_points)
                newly_earned.append(user_achievement)
        if newly_earned:
            await db.commit()
            # Reload with relationships
            for ua in newly_earned:
                await db.refresh(ua, ['achievement'])
        return newly_earned
    @staticmethod
    async def _check_achievement_criteria(
        db: AsyncSession,
        user_id: UUID,
        achievement: PlantAchievement,
        user_stats: UserStats
    ) -> bool:
        """Check if user meets achievement criteria."""
        criteria = achievement.unlock_criteria or {}
        if achievement.achievement_type == "care_streak":
            required_days = criteria.get("days", 7)
            return user_stats.care_streak_days >= required_days
        elif achievement.achievement_type == "plant_collection":
            required_count = criteria.get("count", 5)
            return user_stats.active_plants >= required_count
        elif achievement.achievement_type == "identification":
            required_count = criteria.get("count", 10)
            return user_stats.plants_identified >= required_count
        elif achievement.achievement_type == "community_helper":
            required_answers = criteria.get("helpful_answers", 5)
            return user_stats.helpful_answers >= required_answers
        elif achievement.achievement_type == "plant_age":
            required_days = criteria.get("days", 365)
            # Check if user has any plants older than required days
            result = await db.execute(
                select(func.count(UserPlant.id)).where(
                    and_(
                        UserPlant.user_id == user_id,
                        UserPlant.is_active == True,
                        UserPlant.acquired_date <= datetime.utcnow() - timedelta(days=required_days)
                    )
                )
            )
            count = result.scalar()
            return count > 0
        return False
    @staticmethod
    def _calculate_level(total_points: int) -> int:
        """Calculate user level based on total points."""
        if total_points < 100:
            return 1
        elif total_points < 300:
            return 2
        elif total_points < 600:
            return 3
        elif total_points < 1000:
            return 4
        elif total_points < 1500:
            return 5
        else:
            return min(10, 5 + (total_points - 1500) // 500)
    @staticmethod
    async def get_or_create_user_stats(
        db: AsyncSession,
        user_id: UUID
    ) -> UserStats:
        """Get or create user statistics."""
        result = await db.execute(
            select(UserStats).where(UserStats.user_id == user_id)
        )
        user_stats = result.scalar_one_or_none()
        if not user_stats:
            user_stats = UserStats(user_id=user_id)
            db.add(user_stats)
            await db.commit()
            await db.refresh(user_stats)
        return user_stats
    @staticmethod
    async def update_user_stats(
        db: AsyncSession,
        user_id: UUID,
        stat_updates: Dict[str, Any]
    ) -> UserStats:
        """Update user statistics."""
        user_stats = await PlantAchievementService.get_or_create_user_stats(db, user_id)
        for key, value in stat_updates.items():
            if hasattr(user_stats, key):
                setattr(user_stats, key, value)
        user_stats.last_updated = datetime.utcnow()
        await db.commit()
        await db.refresh(user_stats)
        return user_stats
class PlantMilestoneService:
    """Service for managing plant milestones."""
    @staticmethod
    async def create_milestone(
        db: AsyncSession,
        plant_id: UUID,
        milestone_type: str,
        title: str,
        description: Optional[str] = None,
        photo_url: Optional[str] = None,
        notes: Optional[str] = None
    ) -> PlantMilestone:
        """Create a new plant milestone."""
        milestone = PlantMilestone(
            plant_id=plant_id,
            milestone_type=milestone_type,
            title=title,
            description=description,
            photo_url=photo_url,
            notes=notes
        )
        db.add(milestone)
        await db.commit()
        await db.refresh(milestone)
        return milestone
    @staticmethod
    async def get_plant_milestones(
        db: AsyncSession,
        plant_id: UUID
    ) -> List[PlantMilestone]:
        """Get milestones for a specific plant."""
        result = await db.execute(
            select(PlantMilestone).where(
                PlantMilestone.plant_id == plant_id
            ).order_by(desc(PlantMilestone.achieved_at))
        )
        return result.scalars().all()
    @staticmethod
    async def get_user_milestones(
        db: AsyncSession,
        user_id: UUID,
        limit: int = 50,
        offset: int = 0
    ) -> List[PlantMilestone]:
        """Get all milestones for user's plants."""
        result = await db.execute(
            select(PlantMilestone).options(
                selectinload(PlantMilestone.plant)
            ).join(UserPlant).where(
                UserPlant.user_id == user_id
            ).order_by(desc(PlantMilestone.achieved_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def check_automatic_milestones(
        db: AsyncSession,
        plant_id: UUID
    ) -> List[PlantMilestone]:
        """Check and create automatic milestones for a plant."""
        newly_created = []
        # Get plant info
        result = await db.execute(
            select(UserPlant).where(UserPlant.id == plant_id)
        )
        plant = result.scalar_one_or_none()
        if not plant or not plant.acquired_date:
            return newly_created
        # Get existing milestones
        existing_milestones = await PlantMilestoneService.get_plant_milestones(db, plant_id)
        existing_types = {m.milestone_type for m in existing_milestones}
        # Check age-based milestones
        age_days = (datetime.utcnow().date() - plant.acquired_date).days
        age_milestones = [
            (30, "one_month", "One Month Together", "Your plant has been with you for a month!"),
            (90, "three_months", "Three Months Strong", "Quarter of a year of plant parenthood!"),
            (365, "one_year", "One Year Anniversary", "A full year of growth and care!"),
            (730, "two_years", "Two Years Together", "Two amazing years with your plant companion!"),
        ]
        for days, milestone_type, title, description in age_milestones:
            if age_days >= days and milestone_type not in existing_types:
                milestone = await PlantMilestoneService.create_milestone(
                    db, plant_id, milestone_type, title, description
                )
                newly_created.append(milestone)
        return newly_created
# Initialize default achievements
DEFAULT_ACHIEVEMENTS = [
    {
        "achievement_type": "care_streak",
        "title": "Consistent Caregiver",
        "description": "Care for your plants 7 days in a row",
        "icon": "",
        "badge_color": "gold",
        "points": 50,
        "unlock_criteria": {"days": 7}
    },
    {
        "achievement_type": "care_streak",
        "title": "Plant Parent Pro",
        "description": "Maintain a 30-day care streak",
        "icon": "",
        "badge_color": "gold",
        "points": 200,
        "unlock_criteria": {"days": 30}
    },
    {
        "achievement_type": "plant_collection",
        "title": "Green Thumb",
        "description": "Grow your collection to 5 plants",
        "icon": "",
        "badge_color": "green",
        "points": 100,
        "unlock_criteria": {"count": 5}
    },
    {
        "achievement_type": "plant_collection",
        "title": "Plant Collector",
        "description": "Manage 15 plants in your collection",
        "icon": "",
        "badge_color": "green",
        "points": 300,
        "unlock_criteria": {"count": 15}
    },
    {
        "achievement_type": "identification",
        "title": "Plant Detective",
        "description": "Identify 10 different plant species",
        "icon": "",
        "badge_color": "blue",
        "points": 75,
        "unlock_criteria": {"count": 10}
    },
    {
        "achievement_type": "community_helper",
        "title": "Helpful Gardener",
        "description": "Receive 5 helpful votes on your answers",
        "icon": "",
        "badge_color": "purple",
        "points": 150,
        "unlock_criteria": {"helpful_answers": 5}
    },
    {
        "achievement_type": "plant_age",
        "title": "Long-term Commitment",
        "description": "Keep a plant alive for one full year",
        "icon": "",
        "badge_color": "gold",
        "points": 250,
        "unlock_criteria": {"days": 365}
    }
]
async def initialize_default_achievements(db: AsyncSession):
    """Initialize default achievements in the database."""
    for achievement_data in DEFAULT_ACHIEVEMENTS:
        # Check if achievement already exists
        result = await db.execute(
            select(PlantAchievement).where(
                and_(
                    PlantAchievement.achievement_type == achievement_data["achievement_type"],
                    PlantAchievement.title == achievement_data["title"]
                )
            )
        )
        if not result.scalar_one_or_none():
            achievement = PlantAchievement(**achievement_data)
            db.add(achievement)
    await db.commit()
</file>

<file path="app/services/plant_care_log_service.py">
"""Plant care log service.
This module provides business logic for managing plant care logs,
including CRUD operations and care statistics.
"""
from datetime import datetime, timedelta
from typing import List, Optional, Dict
from uuid import UUID
from sqlalchemy import and_, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_care_log import PlantCareLog
from app.models.user_plant import UserPlant
from app.schemas.plant_care_log import PlantCareLogCreate, PlantCareLogUpdate
class PlantCareLogService:
    """Service for managing plant care logs."""
    @staticmethod
    async def create_care_log(
        db: AsyncSession,
        user_id: UUID,
        log_data: PlantCareLogCreate
    ) -> Optional[PlantCareLog]:
        """Create a new care log entry.
        Args:
            db: Database session
            user_id: User ID (for ownership verification)
            log_data: Care log creation data
        Returns:
            Created care log if plant is owned by user, None otherwise
        """
        # Verify plant ownership
        plant_result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == log_data.plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = plant_result.scalar_one_or_none()
        if not plant:
            return None
        # Create care log
        care_log = PlantCareLog(**log_data.dict())
        db.add(care_log)
        # Update plant's last care timestamp
        if log_data.care_type == "watering":
            plant.last_watered = log_data.performed_at or datetime.utcnow()
        elif log_data.care_type == "fertilizing":
            plant.last_fertilized = log_data.performed_at or datetime.utcnow()
        elif log_data.care_type == "repotting":
            plant.last_repotted = log_data.performed_at or datetime.utcnow()
        plant.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(care_log)
        return care_log
    @staticmethod
    async def get_care_log_by_id(
        db: AsyncSession,
        log_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[PlantCareLog]:
        """Get care log by ID.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: Optional user ID for ownership check
        Returns:
            Care log if found and accessible, None otherwise
        """
        query = select(PlantCareLog).options(
            selectinload(PlantCareLog.plant)
        ).where(PlantCareLog.id == log_id)
        result = await db.execute(query)
        care_log = result.scalar_one_or_none()
        # Check ownership if user_id provided
        if care_log and user_id:
            if care_log.plant.user_id != user_id:
                return None
        return care_log
    @staticmethod
    async def get_plant_care_logs(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        care_type: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantCareLog], int]:
        """Get care logs for a specific plant.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: User ID (for ownership verification)
            care_type: Optional care type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (care logs list, total count)
        """
        # Verify plant ownership
        plant_result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = plant_result.scalar_one_or_none()
        if not plant:
            return [], 0
        # Build base query
        base_query = select(PlantCareLog).where(
            PlantCareLog.plant_id == plant_id
        )
        count_query = select(func.count(PlantCareLog.id)).where(
            PlantCareLog.plant_id == plant_id
        )
        # Apply filters
        if care_type:
            base_query = base_query.where(PlantCareLog.care_type == care_type)
            count_query = count_query.where(PlantCareLog.care_type == care_type)
        if start_date:
            base_query = base_query.where(PlantCareLog.performed_at >= start_date)
            count_query = count_query.where(PlantCareLog.performed_at >= start_date)
        if end_date:
            base_query = base_query.where(PlantCareLog.performed_at <= end_date)
            count_query = count_query.where(PlantCareLog.performed_at <= end_date)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantCareLog.performed_at))
            .offset(skip)
            .limit(limit)
        )
        logs = result.scalars().all()
        return list(logs), total
    @staticmethod
    async def get_user_care_logs(
        db: AsyncSession,
        user_id: UUID,
        care_type: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantCareLog], int]:
        """Get care logs for all user's plants.
        Args:
            db: Database session
            user_id: User ID
            care_type: Optional care type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (care logs list, total count)
        """
        # Build base query with join to user plants
        base_query = select(PlantCareLog).options(
            selectinload(PlantCareLog.plant)
        ).join(UserPlant).where(UserPlant.user_id == user_id)
        count_query = select(func.count(PlantCareLog.id)).join(UserPlant).where(
            UserPlant.user_id == user_id
        )
        # Apply filters
        if care_type:
            base_query = base_query.where(PlantCareLog.care_type == care_type)
            count_query = count_query.where(PlantCareLog.care_type == care_type)
        if start_date:
            base_query = base_query.where(PlantCareLog.performed_at >= start_date)
            count_query = count_query.where(PlantCareLog.performed_at >= start_date)
        if end_date:
            base_query = base_query.where(PlantCareLog.performed_at <= end_date)
            count_query = count_query.where(PlantCareLog.performed_at <= end_date)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantCareLog.performed_at))
            .offset(skip)
            .limit(limit)
        )
        logs = result.scalars().all()
        return list(logs), total
    @staticmethod
    async def update_care_log(
        db: AsyncSession,
        log_id: UUID,
        user_id: UUID,
        log_data: PlantCareLogUpdate
    ) -> Optional[PlantCareLog]:
        """Update care log.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: User ID (for ownership verification)
            log_data: Update data
        Returns:
            Updated care log if found and owned by user, None otherwise
        """
        # Get care log with plant info
        result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).where(PlantCareLog.id == log_id)
        )
        care_log = result.scalar_one_or_none()
        if not care_log or care_log.plant.user_id != user_id:
            return None
        # Update fields
        update_data = log_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(care_log, field, value)
        care_log.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(care_log)
        return care_log
    @staticmethod
    async def delete_care_log(
        db: AsyncSession,
        log_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete care log.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: User ID (for ownership verification)
        Returns:
            True if deleted, False if not found or not owned
        """
        # Get care log with plant info
        result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).where(PlantCareLog.id == log_id)
        )
        care_log = result.scalar_one_or_none()
        if not care_log or care_log.plant.user_id != user_id:
            return False
        await db.delete(care_log)
        await db.commit()
        return True
    @staticmethod
    async def get_care_statistics(
        db: AsyncSession,
        user_id: UUID,
        plant_id: Optional[UUID] = None,
        days: int = 30
    ) -> Dict[str, any]:
        """Get care statistics for user's plants.
        Args:
            db: Database session
            user_id: User ID
            plant_id: Optional specific plant ID
            days: Number of days to look back
        Returns:
            Dictionary with care statistics
        """
        start_date = datetime.utcnow() - timedelta(days=days)
        # Build base query
        base_query = select(
            PlantCareLog.care_type,
            func.count(PlantCareLog.id).label('count')
        ).join(UserPlant).where(
            and_(
                UserPlant.user_id == user_id,
                PlantCareLog.performed_at >= start_date
            )
        )
        if plant_id:
            base_query = base_query.where(PlantCareLog.plant_id == plant_id)
        # Get care type statistics
        result = await db.execute(
            base_query.group_by(PlantCareLog.care_type)
        )
        care_type_stats = {care_type: count for care_type, count in result.all()}
        # Get total care activities
        total_result = await db.execute(
            select(func.count(PlantCareLog.id)).join(UserPlant).where(
                and_(
                    UserPlant.user_id == user_id,
                    PlantCareLog.performed_at >= start_date,
                    PlantCareLog.plant_id == plant_id if plant_id else True
                )
            )
        )
        total_activities = total_result.scalar()
        # Get most recent activity
        recent_result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).join(UserPlant).where(
                and_(
                    UserPlant.user_id == user_id,
                    PlantCareLog.plant_id == plant_id if plant_id else True
                )
            ).order_by(desc(PlantCareLog.performed_at)).limit(1)
        )
        recent_activity = recent_result.scalar_one_or_none()
        return {
            "period_days": days,
            "total_activities": total_activities,
            "care_type_breakdown": care_type_stats,
            "most_recent_activity": {
                "care_type": recent_activity.care_type if recent_activity else None,
                "performed_at": recent_activity.performed_at if recent_activity else None,
                "plant_nickname": recent_activity.plant.nickname if recent_activity else None
            } if recent_activity else None,
            "average_activities_per_day": round(total_activities / days, 2) if days > 0 else 0
        }
# Convenience functions for dependency injection
async def create_care_log(
    db: AsyncSession,
    user_id: UUID,
    log_data: PlantCareLogCreate
) -> Optional[PlantCareLog]:
    """Create a new care log entry."""
    return await PlantCareLogService.create_care_log(db, user_id, log_data)
async def get_care_log_by_id(
    db: AsyncSession,
    log_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[PlantCareLog]:
    """Get care log by ID."""
    return await PlantCareLogService.get_care_log_by_id(db, log_id, user_id)
async def get_plant_care_logs(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    care_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    skip: int = 0,
    limit: int = 50
) -> tuple[List[PlantCareLog], int]:
    """Get care logs for a specific plant."""
    return await PlantCareLogService.get_plant_care_logs(
        db, plant_id, user_id, care_type, start_date, end_date, skip, limit
    )
async def get_user_care_logs(
    db: AsyncSession,
    user_id: UUID,
    care_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    skip: int = 0,
    limit: int = 50
) -> tuple[List[PlantCareLog], int]:
    """Get care logs for all user's plants."""
    return await PlantCareLogService.get_user_care_logs(
        db, user_id, care_type, start_date, end_date, skip, limit
    )
async def get_care_statistics(
    db: AsyncSession,
    user_id: UUID,
    plant_id: Optional[UUID] = None,
    days: int = 30
) -> Dict[str, any]:
    """Get care statistics for user's plants."""
    return await PlantCareLogService.get_care_statistics(db, user_id, plant_id, days)
async def update_care_log(
    db: AsyncSession,
    log_id: UUID,
    user_id: UUID,
    log_data: PlantCareLogUpdate
) -> Optional[PlantCareLog]:
    """Update care log."""
    return await PlantCareLogService.update_care_log(db, log_id, user_id, log_data)
async def delete_care_log(db: AsyncSession, log_id: UUID, user_id: UUID) -> bool:
    """Delete care log."""
    return await PlantCareLogService.delete_care_log(db, log_id, user_id)
</file>

<file path="app/services/plant_identification_service.py">
"""Plant identification service.
This module provides business logic for AI-powered plant identification,
including image processing, species matching, and verification.
"""
import os
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_identification import PlantIdentification
from app.models.plant_species import PlantSpecies
from app.schemas.plant_identification import PlantIdentificationCreate, PlantIdentificationUpdate
class PlantIdentificationService:
    """Service for managing plant identification."""
    @staticmethod
    async def create_identification(
        db: AsyncSession,
        user_id: UUID,
        identification_data: PlantIdentificationCreate
    ) -> PlantIdentification:
        """Create a new plant identification record.
        Args:
            db: Database session
            user_id: User ID
            identification_data: Identification creation data
        Returns:
            Created identification record
        """
        identification = PlantIdentification(
            user_id=user_id,
            **identification_data.dict()
        )
        db.add(identification)
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def get_identification_by_id(
        db: AsyncSession,
        identification_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[PlantIdentification]:
        """Get identification by ID.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: Optional user ID for ownership check
        Returns:
            Identification if found and accessible, None otherwise
        """
        query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species),
            selectinload(PlantIdentification.user)
        ).where(PlantIdentification.id == identification_id)
        if user_id:
            query = query.where(PlantIdentification.user_id == user_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_identifications(
        db: AsyncSession,
        user_id: UUID,
        verified_only: Optional[bool] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantIdentification], int]:
        """Get identifications by user.
        Args:
            db: Database session
            user_id: User ID
            verified_only: Filter by verification status
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (identifications list, total count)
        """
        # Build base query
        base_query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species)
        ).where(PlantIdentification.user_id == user_id)
        count_query = select(func.count(PlantIdentification.id)).where(
            PlantIdentification.user_id == user_id
        )
        if verified_only is not None:
            base_query = base_query.where(PlantIdentification.is_verified == verified_only)
            count_query = count_query.where(PlantIdentification.is_verified == verified_only)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantIdentification.created_at))
            .offset(skip)
            .limit(limit)
        )
        identifications = result.scalars().all()
        return list(identifications), total
    @staticmethod
    async def update_identification(
        db: AsyncSession,
        identification_id: UUID,
        user_id: UUID,
        identification_data: PlantIdentificationUpdate
    ) -> Optional[PlantIdentification]:
        """Update identification record.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: User ID (for ownership verification)
            identification_data: Update data
        Returns:
            Updated identification if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantIdentification).where(
                and_(
                    PlantIdentification.id == identification_id,
                    PlantIdentification.user_id == user_id
                )
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return None
        # Update fields
        update_data = identification_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(identification, field, value)
        identification.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def verify_identification(
        db: AsyncSession,
        identification_id: UUID,
        verified_by_user_id: UUID,
        is_correct: bool,
        correct_species_id: Optional[UUID] = None
    ) -> Optional[PlantIdentification]:
        """Verify an identification (community verification).
        Args:
            db: Database session
            identification_id: Identification ID
            verified_by_user_id: User ID of verifier
            is_correct: Whether the identification is correct
            correct_species_id: Correct species ID if identification was wrong
        Returns:
            Updated identification if found, None otherwise
        """
        result = await db.execute(
            select(PlantIdentification).where(
                PlantIdentification.id == identification_id
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return None
        # Update verification status
        identification.is_verified = True
        identification.verified_at = datetime.utcnow()
        identification.verified_by_user_id = verified_by_user_id
        # If identification was incorrect, update with correct species
        if not is_correct and correct_species_id:
            identification.species_id = correct_species_id
            identification.confidence_score = 1.0  # Human verification is 100% confident
        identification.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def delete_identification(
        db: AsyncSession,
        identification_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete identification record.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: User ID (for ownership verification)
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantIdentification).where(
                and_(
                    PlantIdentification.id == identification_id,
                    PlantIdentification.user_id == user_id
                )
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return False
        # Delete image file if it exists
        if identification.image_path and os.path.exists(identification.image_path):
            try:
                os.remove(identification.image_path)
            except OSError:
                pass  # File might already be deleted
        await db.delete(identification)
        await db.commit()
        return True
    @staticmethod
    async def get_pending_verifications(
        db: AsyncSession,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantIdentification], int]:
        """Get identifications pending verification.
        Args:
            db: Database session
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (identifications list, total count)
        """
        # Build query for unverified identifications
        base_query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species),
            selectinload(PlantIdentification.user)
        ).where(PlantIdentification.is_verified == False)
        count_query = select(func.count(PlantIdentification.id)).where(
            PlantIdentification.is_verified == False
        )
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results, ordered by confidence score (lowest first for review)
        result = await db.execute(
            base_query.order_by(PlantIdentification.confidence_score.asc())
            .offset(skip)
            .limit(limit)
        )
        identifications = result.scalars().all()
        return list(identifications), total
    @staticmethod
    async def get_identification_statistics(
        db: AsyncSession,
        user_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Get identification statistics.
        Args:
            db: Database session
            user_id: Optional user ID for user-specific stats
        Returns:
            Dictionary with identification statistics
        """
        base_query = select(PlantIdentification)
        if user_id:
            base_query = base_query.where(PlantIdentification.user_id == user_id)
        # Total identifications
        total_result = await db.execute(
            select(func.count(PlantIdentification.id)).where(
                PlantIdentification.user_id == user_id if user_id else True
            )
        )
        total_identifications = total_result.scalar()
        # Verified identifications
        verified_result = await db.execute(
            select(func.count(PlantIdentification.id)).where(
                and_(
                    PlantIdentification.is_verified == True,
                    PlantIdentification.user_id == user_id if user_id else True
                )
            )
        )
        verified_identifications = verified_result.scalar()
        # Average confidence score
        avg_confidence_result = await db.execute(
            select(func.avg(PlantIdentification.confidence_score)).where(
                PlantIdentification.user_id == user_id if user_id else True
            )
        )
        avg_confidence = avg_confidence_result.scalar() or 0.0
        # Most identified species
        species_result = await db.execute(
            select(
                PlantIdentification.species_id,
                func.count(PlantIdentification.id).label('count')
            ).where(
                PlantIdentification.user_id == user_id if user_id else True
            ).group_by(PlantIdentification.species_id)
            .order_by(desc('count'))
            .limit(5)
        )
        top_species = species_result.all()
        # Get species names for top species
        top_species_with_names = []
        for species_id, count in top_species:
            if species_id:
                species_result = await db.execute(
                    select(PlantSpecies).where(PlantSpecies.id == species_id)
                )
                species = species_result.scalar_one_or_none()
                if species:
                    top_species_with_names.append({
                        "species_id": species_id,
                        "scientific_name": species.scientific_name,
                        "common_names": species.common_names,
                        "count": count
                    })
        return {
            "total_identifications": total_identifications,
            "verified_identifications": verified_identifications,
            "pending_verification": total_identifications - verified_identifications,
            "verification_rate": round(
                (verified_identifications / total_identifications * 100) if total_identifications > 0 else 0, 2
            ),
            "average_confidence_score": round(float(avg_confidence), 3),
            "top_identified_species": top_species_with_names
        }
    @staticmethod
    async def search_similar_identifications(
        db: AsyncSession,
        species_id: UUID,
        confidence_threshold: float = 0.8,
        limit: int = 10
    ) -> List[PlantIdentification]:
        """Search for similar identifications of the same species.
        Args:
            db: Database session
            species_id: Species ID to search for
            confidence_threshold: Minimum confidence score
            limit: Maximum number of results
        Returns:
            List of similar identifications
        """
        result = await db.execute(
            select(PlantIdentification).options(
                selectinload(PlantIdentification.user)
            ).where(
                and_(
                    PlantIdentification.species_id == species_id,
                    PlantIdentification.confidence_score >= confidence_threshold,
                    PlantIdentification.is_verified == True
                )
            ).order_by(desc(PlantIdentification.confidence_score))
            .limit(limit)
        )
        return list(result.scalars().all())
# Convenience functions for dependency injection
async def create_identification(
    db: AsyncSession,
    user_id: UUID,
    identification_data: PlantIdentificationCreate
) -> PlantIdentification:
    """Create a new plant identification record."""
    return await PlantIdentificationService.create_identification(
        db, user_id, identification_data
    )
async def get_identification_by_id(
    db: AsyncSession,
    identification_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[PlantIdentification]:
    """Get identification by ID."""
    return await PlantIdentificationService.get_identification_by_id(
        db, identification_id, user_id
    )
async def get_user_identifications(
    db: AsyncSession,
    user_id: UUID,
    verified_only: Optional[bool] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantIdentification], int]:
    """Get identifications by user."""
    return await PlantIdentificationService.get_user_identifications(
        db, user_id, verified_only, skip, limit
    )
async def verify_identification(
    db: AsyncSession,
    identification_id: UUID,
    verified_by_user_id: UUID,
    is_correct: bool,
    correct_species_id: Optional[UUID] = None
) -> Optional[PlantIdentification]:
    """Verify an identification."""
    return await PlantIdentificationService.verify_identification(
        db, identification_id, verified_by_user_id, is_correct, correct_species_id
    )
async def get_pending_verifications(
    db: AsyncSession,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantIdentification], int]:
    """Get identifications pending verification."""
    return await PlantIdentificationService.get_pending_verifications(db, skip, limit)
async def get_identification_statistics(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get identification statistics."""
    return await PlantIdentificationService.get_identification_statistics(db, user_id)
async def update_identification(
    db: AsyncSession,
    identification_id: UUID,
    user_id: UUID,
    identification_data: PlantIdentificationUpdate
) -> Optional[PlantIdentification]:
    """Update identification record."""
    return await PlantIdentificationService.update_identification(
        db, identification_id, user_id, identification_data
    )
async def delete_identification(
    db: AsyncSession,
    identification_id: UUID,
    user_id: UUID
) -> bool:
    """Delete identification record."""
    return await PlantIdentificationService.delete_identification(
        db, identification_id, user_id
    )
</file>

<file path="app/services/plant_question_service.py">
"""Plant question service.
This module provides business logic for the plant Q&A community,
including questions, answers, voting, and moderation.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_question import PlantQuestion, PlantAnswer
from app.models.plant_species import PlantSpecies
from app.schemas.plant_question import (
    PlantQuestionCreate, PlantQuestionUpdate,
    PlantAnswerCreate, PlantAnswerUpdate,
    PlantQuestionSearchRequest
)
class PlantQuestionService:
    """Service for managing plant questions."""
    @staticmethod
    async def create_question(
        db: AsyncSession,
        user_id: UUID,
        question_data: PlantQuestionCreate
    ) -> PlantQuestion:
        """Create a new plant question.
        Args:
            db: Database session
            user_id: Author user ID
            question_data: Question creation data
        Returns:
            Created question
        """
        question = PlantQuestion(
            author_id=user_id,
            **question_data.dict()
        )
        db.add(question)
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def get_question_by_id(
        db: AsyncSession,
        question_id: UUID,
        include_answers: bool = True
    ) -> Optional[PlantQuestion]:
        """Get question by ID.
        Args:
            db: Database session
            question_id: Question ID
            include_answers: Whether to include answers
        Returns:
            Question if found, None otherwise
        """
        query = select(PlantQuestion).options(
            selectinload(PlantQuestion.author),
            selectinload(PlantQuestion.species)
        )
        if include_answers:
            query = query.options(
                selectinload(PlantQuestion.answers).selectinload(PlantAnswer.author)
            )
        query = query.where(PlantQuestion.id == question_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def search_questions(
        db: AsyncSession,
        search_params: PlantQuestionSearchRequest,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantQuestion], int]:
        """Search plant questions with filters.
        Args:
            db: Database session
            search_params: Search parameters
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (questions list, total count)
        """
        # Build base query
        base_query = select(PlantQuestion).options(
            selectinload(PlantQuestion.author),
            selectinload(PlantQuestion.species)
        )
        count_query = select(func.count(PlantQuestion.id))
        # Apply search filters
        filters = []
        if search_params.query:
            search_filter = or_(
                PlantQuestion.title.ilike(f"%{search_params.query}%"),
                PlantQuestion.content.ilike(f"%{search_params.query}%")
            )
            filters.append(search_filter)
        if search_params.species_id:
            filters.append(PlantQuestion.species_id == search_params.species_id)
        if search_params.tags:
            # Search for questions that have any of the specified tags
            tag_filters = []
            for tag in search_params.tags:
                tag_filters.append(PlantQuestion.tags.contains([tag]))
            if tag_filters:
                filters.append(or_(*tag_filters))
        if search_params.is_solved is not None:
            filters.append(PlantQuestion.is_solved == search_params.is_solved)
        if search_params.author_id:
            filters.append(PlantQuestion.author_id == search_params.author_id)
        # Apply filters to queries
        if filters:
            filter_condition = and_(*filters)
            base_query = base_query.where(filter_condition)
            count_query = count_query.where(filter_condition)
        # Apply sorting
        if search_params.sort_by == "newest":
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        elif search_params.sort_by == "oldest":
            base_query = base_query.order_by(asc(PlantQuestion.created_at))
        elif search_params.sort_by == "most_answers":
            # Count answers for each question
            base_query = base_query.outerjoin(PlantAnswer).group_by(PlantQuestion.id)
            base_query = base_query.order_by(desc(func.count(PlantAnswer.id)))
        elif search_params.sort_by == "unsolved":
            base_query = base_query.where(PlantQuestion.is_solved == False)
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        else:  # Default to newest
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.offset(skip).limit(limit)
        )
        questions = result.scalars().all()
        return list(questions), total
    @staticmethod
    async def update_question(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID,
        question_data: PlantQuestionUpdate
    ) -> Optional[PlantQuestion]:
        """Update question.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
            question_data: Update data
        Returns:
            Updated question if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return None
        # Update fields
        update_data = question_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(question, field, value)
        question.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def mark_question_solved(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID,
        accepted_answer_id: Optional[UUID] = None
    ) -> Optional[PlantQuestion]:
        """Mark question as solved.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
            accepted_answer_id: Optional accepted answer ID
        Returns:
            Updated question if successful, None otherwise
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return None
        # Mark as solved
        question.is_solved = True
        question.solved_at = datetime.utcnow()
        question.updated_at = datetime.utcnow()
        # Mark accepted answer if provided
        if accepted_answer_id:
            answer_result = await db.execute(
                select(PlantAnswer).where(
                    and_(
                        PlantAnswer.id == accepted_answer_id,
                        PlantAnswer.question_id == question_id
                    )
                )
            )
            answer = answer_result.scalar_one_or_none()
            if answer:
                answer.is_accepted = True
                answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def delete_question(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete question.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return False
        # Delete associated answers first
        await db.execute(
            select(PlantAnswer).where(PlantAnswer.question_id == question_id)
        )
        await db.delete(question)
        await db.commit()
        return True
class PlantAnswerService:
    """Service for managing plant answers."""
    @staticmethod
    async def create_answer(
        db: AsyncSession,
        user_id: UUID,
        answer_data: PlantAnswerCreate
    ) -> Optional[PlantAnswer]:
        """Create a new answer.
        Args:
            db: Database session
            user_id: Author user ID
            answer_data: Answer creation data
        Returns:
            Created answer if question exists, None otherwise
        """
        # Verify question exists
        question_result = await db.execute(
            select(PlantQuestion).where(PlantQuestion.id == answer_data.question_id)
        )
        question = question_result.scalar_one_or_none()
        if not question:
            return None
        answer = PlantAnswer(
            author_id=user_id,
            **answer_data.dict()
        )
        db.add(answer)
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def get_answer_by_id(
        db: AsyncSession,
        answer_id: UUID
    ) -> Optional[PlantAnswer]:
        """Get answer by ID.
        Args:
            db: Database session
            answer_id: Answer ID
        Returns:
            Answer if found, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).options(
                selectinload(PlantAnswer.author),
                selectinload(PlantAnswer.question)
            ).where(PlantAnswer.id == answer_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def get_question_answers(
        db: AsyncSession,
        question_id: UUID,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantAnswer], int]:
        """Get answers for a question.
        Args:
            db: Database session
            question_id: Question ID
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (answers list, total count)
        """
        # Build base query
        base_query = select(PlantAnswer).options(
            selectinload(PlantAnswer.author)
        ).where(PlantAnswer.question_id == question_id)
        count_query = select(func.count(PlantAnswer.id)).where(
            PlantAnswer.question_id == question_id
        )
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results, ordered by accepted first, then by votes
        result = await db.execute(
            base_query.order_by(
                desc(PlantAnswer.is_accepted),
                desc(PlantAnswer.upvotes - PlantAnswer.downvotes),
                asc(PlantAnswer.created_at)
            ).offset(skip).limit(limit)
        )
        answers = result.scalars().all()
        return list(answers), total
    @staticmethod
    async def update_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID,
        answer_data: PlantAnswerUpdate
    ) -> Optional[PlantAnswer]:
        """Update answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Author user ID
            answer_data: Update data
        Returns:
            Updated answer if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id == user_id
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return None
        # Update fields
        update_data = answer_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(answer, field, value)
        answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def vote_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID,
        is_upvote: bool
    ) -> Optional[PlantAnswer]:
        """Vote on an answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Voter user ID
            is_upvote: True for upvote, False for downvote
        Returns:
            Updated answer if found, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id != user_id  # Can't vote on own answer
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return None
        # Update vote counts
        if is_upvote:
            answer.upvotes += 1
        else:
            answer.downvotes += 1
        answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def delete_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Author user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id == user_id
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return False
        await db.delete(answer)
        await db.commit()
        return True
# Convenience functions for dependency injection
async def create_question(
    db: AsyncSession,
    user_id: UUID,
    question_data: PlantQuestionCreate
) -> PlantQuestion:
    """Create a new plant question."""
    return await PlantQuestionService.create_question(db, user_id, question_data)
async def get_question_by_id(
    db: AsyncSession,
    question_id: UUID,
    include_answers: bool = True
) -> Optional[PlantQuestion]:
    """Get question by ID."""
    return await PlantQuestionService.get_question_by_id(db, question_id, include_answers)
async def search_questions(
    db: AsyncSession,
    search_params: PlantQuestionSearchRequest,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantQuestion], int]:
    """Search plant questions."""
    return await PlantQuestionService.search_questions(db, search_params, skip, limit)
async def create_answer(
    db: AsyncSession,
    user_id: UUID,
    answer_data: PlantAnswerCreate
) -> Optional[PlantAnswer]:
    """Create a new answer."""
    return await PlantAnswerService.create_answer(db, user_id, answer_data)
async def vote_answer(
    db: AsyncSession,
    answer_id: UUID,
    user_id: UUID,
    is_upvote: bool
) -> Optional[PlantAnswer]:
    """Vote on an answer."""
    return await PlantAnswerService.vote_answer(db, answer_id, user_id, is_upvote)
async def mark_question_solved(
    db: AsyncSession,
    question_id: UUID,
    user_id: UUID,
    accepted_answer_id: Optional[UUID] = None
) -> Optional[PlantQuestion]:
    """Mark question as solved."""
    return await PlantQuestionService.mark_question_solved(
        db, question_id, user_id, accepted_answer_id
    )
def get_plant_question_service() -> PlantQuestionService:
    """Get plant question service instance."""
    return PlantQuestionService()
def get_plant_answer_service() -> PlantAnswerService:
    """Get plant answer service instance."""
    return PlantAnswerService()
</file>

<file path="app/services/plant_species_service.py">
"""Plant species service.
This module provides business logic for managing plant species data,
including CRUD operations and search functionality.
"""
from typing import List, Optional
from uuid import UUID
from sqlalchemy import and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_species import PlantSpecies
from app.schemas.plant_species import PlantSpeciesCreate, PlantSpeciesUpdate
class PlantSpeciesService:
    """Service for managing plant species."""
    @staticmethod
    async def create_species(
        db: AsyncSession,
        species_data: PlantSpeciesCreate
    ) -> PlantSpecies:
        """Create a new plant species.
        Args:
            db: Database session
            species_data: Plant species creation data
        Returns:
            Created plant species
        """
        species = PlantSpecies(**species_data.dict())
        db.add(species)
        await db.commit()
        await db.refresh(species)
        return species
    @staticmethod
    async def get_species_by_id(
        db: AsyncSession,
        species_id: UUID
    ) -> Optional[PlantSpecies]:
        """Get plant species by ID.
        Args:
            db: Database session
            species_id: Species ID
        Returns:
            Plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def get_species_by_scientific_name(
        db: AsyncSession,
        scientific_name: str
    ) -> Optional[PlantSpecies]:
        """Get plant species by scientific name.
        Args:
            db: Database session
            scientific_name: Scientific name
        Returns:
            Plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(
                PlantSpecies.scientific_name.ilike(f"%{scientific_name}%")
            )
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def search_species(
        db: AsyncSession,
        query: Optional[str] = None,
        care_level: Optional[str] = None,
        family: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantSpecies], int]:
        """Search plant species with filters.
        Args:
            db: Database session
            query: Search query for name matching
            care_level: Filter by care level
            family: Filter by plant family
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (species list, total count)
        """
        # Build base query
        base_query = select(PlantSpecies)
        count_query = select(func.count(PlantSpecies.id))
        # Apply filters
        conditions = []
        if query:
            search_condition = or_(
                PlantSpecies.scientific_name.ilike(f"%{query}%"),
                PlantSpecies.common_names.op("@>")(f'["{query}"]'),
                PlantSpecies.family.ilike(f"%{query}%")
            )
            conditions.append(search_condition)
        if care_level:
            conditions.append(PlantSpecies.care_level == care_level)
        if family:
            conditions.append(PlantSpecies.family.ilike(f"%{family}%"))
        if conditions:
            base_query = base_query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(PlantSpecies.scientific_name)
            .offset(skip)
            .limit(limit)
        )
        species = result.scalars().all()
        return list(species), total
    @staticmethod
    async def update_species(
        db: AsyncSession,
        species_id: UUID,
        species_data: PlantSpeciesUpdate
    ) -> Optional[PlantSpecies]:
        """Update plant species.
        Args:
            db: Database session
            species_id: Species ID
            species_data: Update data
        Returns:
            Updated plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        species = result.scalar_one_or_none()
        if not species:
            return None
        # Update fields
        update_data = species_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(species, field, value)
        await db.commit()
        await db.refresh(species)
        return species
    @staticmethod
    async def delete_species(
        db: AsyncSession,
        species_id: UUID
    ) -> bool:
        """Delete plant species.
        Args:
            db: Database session
            species_id: Species ID
        Returns:
            True if deleted, False if not found
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        species = result.scalar_one_or_none()
        if not species:
            return False
        await db.delete(species)
        await db.commit()
        return True
    @staticmethod
    async def get_popular_species(
        db: AsyncSession,
        limit: int = 10
    ) -> List[PlantSpecies]:
        """Get most popular plant species based on user plants.
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular plant species
        """
        # This would require a join with user_plants table
        # For now, return species ordered by creation date
        result = await db.execute(
            select(PlantSpecies)
            .order_by(PlantSpecies.created_at.desc())
            .limit(limit)
        )
        return list(result.scalars().all())
# Convenience functions for dependency injection
async def get_species_by_id(db: AsyncSession, species_id: UUID) -> Optional[PlantSpecies]:
    """Get plant species by ID."""
    return await PlantSpeciesService.get_species_by_id(db, species_id)
async def get_species_by_scientific_name(db: AsyncSession, scientific_name: str) -> Optional[PlantSpecies]:
    """Get plant species by scientific name."""
    return await PlantSpeciesService.get_species_by_scientific_name(db, scientific_name)
async def search_species(
    db: AsyncSession,
    query: Optional[str] = None,
    care_level: Optional[str] = None,
    family: Optional[str] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantSpecies], int]:
    """Search plant species."""
    return await PlantSpeciesService.search_species(
        db, query, care_level, family, skip, limit
    )
async def create_species(db: AsyncSession, species_data: PlantSpeciesCreate) -> PlantSpecies:
    """Create a new plant species."""
    return await PlantSpeciesService.create_species(db, species_data)
async def update_species(
    db: AsyncSession,
    species_id: UUID,
    species_data: PlantSpeciesUpdate
) -> Optional[PlantSpecies]:
    """Update plant species."""
    return await PlantSpeciesService.update_species(db, species_id, species_data)
async def delete_species(db: AsyncSession, species_id: UUID) -> bool:
    """Delete plant species."""
    return await PlantSpeciesService.delete_species(db, species_id)
async def get_popular_species(db: AsyncSession, limit: int = 10) -> List[PlantSpecies]:
    """Get popular plant species."""
    return await PlantSpeciesService.get_popular_species(db, limit)
</file>

<file path="app/services/plant_trade_service.py">
"""Plant trade service.
This module provides business logic for the plant trading marketplace,
including CRUD operations, search, and trade management.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_species import PlantSpecies
from app.schemas.plant_trade import PlantTradeCreate, PlantTradeUpdate, PlantTradeSearchRequest
class PlantTradeService:
    """Service for managing plant trades."""
    @staticmethod
    async def create_trade(
        db: AsyncSession,
        user_id: UUID,
        trade_data: PlantTradeCreate
    ) -> PlantTrade:
        """Create a new plant trade listing.
        Args:
            db: Database session
            user_id: Owner user ID
            trade_data: Trade creation data
        Returns:
            Created trade listing
        """
        trade = PlantTrade(
            owner_id=user_id,
            **trade_data.dict()
        )
        db.add(trade)
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def get_trade_by_id(
        db: AsyncSession,
        trade_id: UUID,
        include_inactive: bool = False
    ) -> Optional[PlantTrade]:
        """Get trade by ID.
        Args:
            db: Database session
            trade_id: Trade ID
            include_inactive: Whether to include inactive trades
        Returns:
            Trade if found, None otherwise
        """
        query = select(PlantTrade).options(
            selectinload(PlantTrade.owner),
            selectinload(PlantTrade.species),
            selectinload(PlantTrade.interested_user)
        ).where(PlantTrade.id == trade_id)
        if not include_inactive:
            query = query.where(PlantTrade.is_active == True)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_trades(
        db: AsyncSession,
        user_id: UUID,
        status: Optional[TradeStatus] = None,
        trade_type: Optional[TradeType] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantTrade], int]:
        """Get trades owned by a user.
        Args:
            db: Database session
            user_id: User ID
            status: Optional status filter
            trade_type: Optional trade type filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (trades list, total count)
        """
        # Build base query
        base_query = select(PlantTrade).options(
            selectinload(PlantTrade.species),
            selectinload(PlantTrade.interested_user)
        ).where(
            and_(
                PlantTrade.owner_id == user_id,
                PlantTrade.is_active == True
            )
        )
        count_query = select(func.count(PlantTrade.id)).where(
            and_(
                PlantTrade.owner_id == user_id,
                PlantTrade.is_active == True
            )
        )
        # Apply filters
        if status:
            base_query = base_query.where(PlantTrade.status == status)
            count_query = count_query.where(PlantTrade.status == status)
        if trade_type:
            base_query = base_query.where(PlantTrade.trade_type == trade_type)
            count_query = count_query.where(PlantTrade.trade_type == trade_type)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantTrade.created_at))
            .offset(skip)
            .limit(limit)
        )
        trades = result.scalars().all()
        return list(trades), total
    @staticmethod
    async def search_trades(
        db: AsyncSession,
        search_params: PlantTradeSearchRequest,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantTrade], int]:
        """Search plant trades with filters.
        Args:
            db: Database session
            search_params: Search parameters
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (trades list, total count)
        """
        # Build base query
        base_query = select(PlantTrade).options(
            selectinload(PlantTrade.owner),
            selectinload(PlantTrade.species)
        ).where(
            and_(
                PlantTrade.is_active == True,
                PlantTrade.status == TradeStatus.AVAILABLE
            )
        )
        count_query = select(func.count(PlantTrade.id)).where(
            and_(
                PlantTrade.is_active == True,
                PlantTrade.status == TradeStatus.AVAILABLE
            )
        )
        # Apply search filters
        if search_params.query:
            search_filter = or_(
                PlantTrade.title.ilike(f"%{search_params.query}%"),
                PlantTrade.description.ilike(f"%{search_params.query}%")
            )
            base_query = base_query.where(search_filter)
            count_query = count_query.where(search_filter)
        if search_params.trade_type:
            base_query = base_query.where(PlantTrade.trade_type == search_params.trade_type)
            count_query = count_query.where(PlantTrade.trade_type == search_params.trade_type)
        if search_params.species_id:
            base_query = base_query.where(PlantTrade.species_id == search_params.species_id)
            count_query = count_query.where(PlantTrade.species_id == search_params.species_id)
        if search_params.location:
            base_query = base_query.where(
                PlantTrade.location.ilike(f"%{search_params.location}%")
            )
            count_query = count_query.where(
                PlantTrade.location.ilike(f"%{search_params.location}%")
            )
        if search_params.max_price is not None:
            base_query = base_query.where(
                or_(
                    PlantTrade.price <= search_params.max_price,
                    PlantTrade.price.is_(None)  # Include free items
                )
            )
            count_query = count_query.where(
                or_(
                    PlantTrade.price <= search_params.max_price,
                    PlantTrade.price.is_(None)
                )
            )
        # Apply sorting
        if search_params.sort_by == "price_low":
            base_query = base_query.order_by(asc(PlantTrade.price.nulls_first()))
        elif search_params.sort_by == "price_high":
            base_query = base_query.order_by(desc(PlantTrade.price.nulls_last()))
        elif search_params.sort_by == "newest":
            base_query = base_query.order_by(desc(PlantTrade.created_at))
        else:  # Default to newest
            base_query = base_query.order_by(desc(PlantTrade.created_at))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.offset(skip).limit(limit)
        )
        trades = result.scalars().all()
        return list(trades), total
    @staticmethod
    async def update_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID,
        trade_data: PlantTradeUpdate
    ) -> Optional[PlantTrade]:
        """Update trade listing.
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Owner user ID
            trade_data: Update data
        Returns:
            Updated trade if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == user_id
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Update fields
        update_data = trade_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(trade, field, value)
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def express_interest(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> Optional[PlantTrade]:
        """Express interest in a trade.
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Interested user ID
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.status == TradeStatus.AVAILABLE,
                    PlantTrade.is_active == True,
                    PlantTrade.owner_id != user_id  # Can't be interested in own trade
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Update trade status and interested user
        trade.status = TradeStatus.PENDING
        trade.interested_user_id = user_id
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def accept_trade(
        db: AsyncSession,
        trade_id: UUID,
        owner_id: UUID
    ) -> Optional[PlantTrade]:
        """Accept a trade (mark as completed).
        Args:
            db: Database session
            trade_id: Trade ID
            owner_id: Owner user ID
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == owner_id,
                    PlantTrade.status == TradeStatus.PENDING
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Mark trade as completed
        trade.status = TradeStatus.COMPLETED
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def cancel_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> Optional[PlantTrade]:
        """Cancel a trade (owner can cancel, interested user can withdraw).
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: User ID (owner or interested user)
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    or_(
                        PlantTrade.owner_id == user_id,
                        PlantTrade.interested_user_id == user_id
                    )
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # If owner cancels, mark as cancelled
        # If interested user withdraws, reset to available
        if trade.owner_id == user_id:
            trade.status = TradeStatus.CANCELLED
        else:
            trade.status = TradeStatus.AVAILABLE
            trade.interested_user_id = None
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def delete_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete trade listing (soft delete).
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Owner user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == user_id
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return False
        trade.is_active = False
        trade.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_trade_statistics(
        db: AsyncSession,
        user_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Get trade statistics.
        Args:
            db: Database session
            user_id: Optional user ID for user-specific stats
        Returns:
            Dictionary with trade statistics
        """
        base_filter = PlantTrade.is_active == True
        if user_id:
            base_filter = and_(base_filter, PlantTrade.owner_id == user_id)
        # Total active trades
        total_result = await db.execute(
            select(func.count(PlantTrade.id)).where(base_filter)
        )
        total_trades = total_result.scalar()
        # Trades by status
        status_result = await db.execute(
            select(
                PlantTrade.status,
                func.count(PlantTrade.id)
            ).where(base_filter)
            .group_by(PlantTrade.status)
        )
        status_stats = {status.value: count for status, count in status_result.all()}
        # Trades by type
        type_result = await db.execute(
            select(
                PlantTrade.trade_type,
                func.count(PlantTrade.id)
            ).where(base_filter)
            .group_by(PlantTrade.trade_type)
        )
        type_stats = {trade_type.value: count for trade_type, count in type_result.all()}
        # Average price for sell trades
        avg_price_result = await db.execute(
            select(func.avg(PlantTrade.price)).where(
                and_(
                    base_filter,
                    PlantTrade.trade_type == TradeType.SELL,
                    PlantTrade.price.is_not(None)
                )
            )
        )
        avg_price = avg_price_result.scalar() or 0.0
        return {
            "total_trades": total_trades,
            "status_breakdown": status_stats,
            "type_breakdown": type_stats,
            "available_trades": status_stats.get(TradeStatus.AVAILABLE.value, 0),
            "completed_trades": status_stats.get(TradeStatus.COMPLETED.value, 0),
            "average_sell_price": round(float(avg_price), 2) if avg_price else 0.0
        }
    @staticmethod
    async def get_popular_species(
        db: AsyncSession,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get most popular species in trades.
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular species with trade counts
        """
        result = await db.execute(
            select(
                PlantTrade.species_id,
                func.count(PlantTrade.id).label('trade_count')
            ).join(PlantSpecies)
            .where(
                and_(
                    PlantTrade.is_active == True,
                    PlantTrade.status == TradeStatus.AVAILABLE
                )
            )
            .group_by(PlantTrade.species_id)
            .order_by(desc('trade_count'))
            .limit(limit)
        )
        popular_species = []
        for species_id, count in result.all():
            # Get species details
            species_result = await db.execute(
                select(PlantSpecies).where(PlantSpecies.id == species_id)
            )
            species = species_result.scalar_one_or_none()
            if species:
                popular_species.append({
                    "species_id": species_id,
                    "scientific_name": species.scientific_name,
                    "common_names": species.common_names,
                    "trade_count": count
                })
        return popular_species
    @staticmethod
    async def get_popular_species_in_trades(
        db: AsyncSession,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get most popular species in trades (alias for get_popular_species).
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular species with trade counts
        """
        return await PlantTradeService.get_popular_species(db, limit)
# Convenience functions for dependency injection
async def create_trade(
    db: AsyncSession,
    user_id: UUID,
    trade_data: PlantTradeCreate
) -> PlantTrade:
    """Create a new plant trade listing."""
    return await PlantTradeService.create_trade(db, user_id, trade_data)
async def get_trade_by_id(
    db: AsyncSession,
    trade_id: UUID,
    include_inactive: bool = False
) -> Optional[PlantTrade]:
    """Get trade by ID."""
    return await PlantTradeService.get_trade_by_id(db, trade_id, include_inactive)
async def search_trades(
    db: AsyncSession,
    search_params: PlantTradeSearchRequest,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantTrade], int]:
    """Search plant trades."""
    return await PlantTradeService.search_trades(db, search_params, skip, limit)
async def express_interest(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Express interest in a trade."""
    return await PlantTradeService.express_interest(db, trade_id, user_id)
async def get_trade_statistics(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get trade statistics."""
    return await PlantTradeService.get_trade_statistics(db, user_id)
async def get_user_trades(
    db: AsyncSession,
    user_id: UUID,
    status: Optional[TradeStatus] = None,
    trade_type: Optional[TradeType] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantTrade], int]:
    """Get trades owned by a user."""
    return await PlantTradeService.get_user_trades(
        db, user_id, status, trade_type, skip, limit
    )
async def update_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID,
    trade_data: PlantTradeUpdate
) -> Optional[PlantTrade]:
    """Update trade listing."""
    return await PlantTradeService.update_trade(db, trade_id, user_id, trade_data)
async def accept_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Accept a trade offer."""
    return await PlantTradeService.accept_trade(db, trade_id, user_id)
async def cancel_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Cancel a trade."""
    return await PlantTradeService.cancel_trade(db, trade_id, user_id)
async def delete_trade(db: AsyncSession, trade_id: UUID, user_id: UUID) -> bool:
    """Delete trade listing (soft delete)."""
    return await PlantTradeService.delete_trade(db, trade_id, user_id)
async def get_popular_species_in_trades(
    db: AsyncSession,
    limit: int = 10
) -> List[Dict[str, Any]]:
    """Get popular species in trades."""
    return await PlantTradeService.get_popular_species_in_trades(db, limit)
async def get_trade_stats(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get trade statistics."""
    return await PlantTradeService.get_trade_statistics(db, user_id)
async def get_popular_trade_species(
    db: AsyncSession,
    limit: int = 10
) -> List[Dict[str, Any]]:
    """Get popular species in trades."""
    return await PlantTradeService.get_popular_species(db, limit)
</file>

<file path="app/services/story_service.py">
"""Story service.
This module provides story management services including
creating, viewing, and managing ephemeral content.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.story import Story, StoryView
from app.schemas.story import StoryType, StoryPrivacyLevel
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.schemas.story import (
    StoryCreate, StoryUpdate, StoryRead, StoryFeed,
    StoryViewCreate, StoryView, StoryAnalytics, StorySearch
)
from app.core.websocket import websocket_manager
class StoryService:
    """Service for story management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def create_story(
        self,
        user_id: str,
        story_data: StoryCreate,
        session: AsyncSession
    ) -> Optional[Story]:
        """Create a new story."""
        # Validate story content
        await self._validate_story_content(story_data)
        # Calculate expiration time (24 hours from now)
        expires_at = datetime.utcnow() + timedelta(hours=24)
        # Create story
        story = Story(
            user_id=user_id,
            content_type=story_data.content_type,
            media_url=story_data.media_url,
            caption=story_data.caption,
            duration=story_data.duration,
            file_size=story_data.file_size,
            privacy_level=story_data.privacy_level,
            expires_at=expires_at,
            plant_tags=story_data.plant_tags,
            location=story_data.location
        )
        session.add(story)
        await session.commit()
        await session.refresh(story)
        # Send real-time notification to friends
        await self._notify_friends_of_new_story(story, session)
        return story
    async def get_story_by_id(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> Optional[StoryRead]:
        """Get story by ID if viewer has access."""
        # Get story with user info
        result = await session.execute(
            select(Story, User).join(User, User.id == Story.user_id).where(
                and_(
                    Story.id == story_id,
                    Story.is_active == True,
                    Story.expires_at > datetime.utcnow()
                )
            )
        )
        story_user = result.first()
        if not story_user:
            return None
        story, user = story_user
        # Check if viewer has access to this story
        if not await self._can_view_story(story, viewer_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to view this story"
            )
        # Check if viewer has already viewed this story
        has_viewed = await self._has_user_viewed_story(story_id, viewer_id, session)
        # Get view count
        view_count = await session.scalar(
            select(func.count(StoryView.id)).where(StoryView.story_id == story_id)
        ) or 0
        # Convert to StoryRead
        story_read = StoryRead(
            id=str(story.id),
            user_id=str(story.user_id),
            content_type=story.content_type,
            media_url=story.media_url,
            caption=story.caption,
            duration=story.duration,
            file_size=story.file_size,
            privacy_level=story.privacy_level,
            created_at=story.created_at,
            expires_at=story.expires_at,
            plant_tags=story.plant_tags,
            location=story.location,
            user_username=user.username,
            user_display_name=user.display_name,
            user_avatar_url=user.avatar_url,
            view_count=view_count,
            has_viewed=has_viewed
        )
        return story_read
    async def get_user_stories(
        self,
        user_id: str,
        viewer_id: str,
        session: AsyncSession,
        include_expired: bool = False
    ) -> List[StoryRead]:
        """Get all stories for a specific user."""
        # Build query
        query = select(Story, User).join(User, User.id == Story.user_id).where(
            and_(
                Story.user_id == user_id,
                Story.is_active == True
            )
        )
        if not include_expired:
            query = query.where(Story.expires_at > datetime.utcnow())
        # Check if viewer can see this user's stories
        if viewer_id != user_id:
            can_view = await self._can_view_user_stories(user_id, viewer_id, session)
            if not can_view:
                return []
        query = query.order_by(desc(Story.created_at))
        result = await session.execute(query)
        stories_users = result.all()
        story_reads = []
        for story, user in stories_users:
            # Check individual story permissions
            if await self._can_view_story(story, viewer_id, session):
                has_viewed = await self._has_user_viewed_story(str(story.id), viewer_id, session)
                view_count = await session.scalar(
                    select(func.count(StoryView.id)).where(StoryView.story_id == str(story.id))
                ) or 0
                story_read = StoryRead(
                    id=str(story.id),
                    user_id=str(story.user_id),
                    content_type=story.content_type,
                    media_url=story.media_url,
                    caption=story.caption,
                    duration=story.duration,
                    file_size=story.file_size,
                    privacy_level=story.privacy_level,
                    created_at=story.created_at,
                    expires_at=story.expires_at,
                    plant_tags=story.plant_tags,
                    location=story.location,
                    user_username=user.username,
                    user_display_name=user.display_name,
                    user_avatar_url=user.avatar_url,
                    view_count=view_count,
                    has_viewed=has_viewed
                )
                story_reads.append(story_read)
        return story_reads
    async def get_stories_feed(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 50
    ) -> List[StoryFeed]:
        """Get stories feed for a user (friends' stories)."""
        # Get user's friends
        friends_query = select(
            func.case(
                (Friendship.requester_id == user_id, Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == user_id
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        friends_result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in friends_result]
        if not friend_ids:
            return []
        # Get active stories from friends
        stories_query = (
            select(Story, User)
            .join(User, User.id == Story.user_id)
            .where(
                and_(
                    Story.user_id.in_(friend_ids),
                    Story.is_active == True,
                    Story.expires_at > datetime.utcnow(),
                    or_(
                        Story.privacy_level == StoryPrivacyLevel.FRIENDS,
                        Story.privacy_level == StoryPrivacyLevel.PUBLIC
                    )
                )
            )
            .order_by(desc(Story.created_at))
            .limit(limit)
        )
        result = await session.execute(stories_query)
        stories_users = result.all()
        # Group stories by user
        user_stories = {}
        for story, user in stories_users:
            user_key = str(user.id)
            if user_key not in user_stories:
                user_stories[user_key] = {
                    "user": user,
                    "stories": []
                }
            user_stories[user_key]["stories"].append(story)
        # Convert to StoryFeed format
        story_feeds = []
        for user_key, data in user_stories.items():
            user = data["user"]
            stories = data["stories"]
            # Check if user has viewed any stories from this user
            has_unviewed = False
            for story in stories:
                if not await self._has_user_viewed_story(str(story.id), user_id, session):
                    has_unviewed = True
                    break
            story_feed = StoryFeed(
                user_id=str(user.id),
                user_username=user.username,
                user_display_name=user.display_name,
                user_avatar_url=user.avatar_url,
                stories_count=len(stories),
                latest_story_timestamp=max(story.created_at for story in stories),
                has_unviewed_stories=has_unviewed
            )
            story_feeds.append(story_feed)
        # Sort by latest story timestamp
        story_feeds.sort(key=lambda x: x.latest_story_timestamp, reverse=True)
        return story_feeds
    async def view_story(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Mark a story as viewed by a user."""
        # Check if story exists and is accessible
        story_read = await self.get_story_by_id(story_id, viewer_id, session)
        if not story_read:
            return False
        # Check if already viewed
        if await self._has_user_viewed_story(story_id, viewer_id, session):
            return True  # Already viewed
        # Create story view record
        story_view = StoryView(
            story_id=story_id,
            viewer_id=viewer_id
        )
        session.add(story_view)
        await session.commit()
        # Send view notification to story owner (if not viewing own story)
        if story_read.user_id != viewer_id:
            await self._send_story_view_notification(story_read, viewer_id, session)
        return True
    async def delete_story(
        self,
        story_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Delete a story (only by owner)."""
        story = await session.execute(
            select(Story).where(
                and_(
                    Story.id == story_id,
                    Story.user_id == user_id
                )
            )
        )
        story = story.scalar_one_or_none()
        if not story:
            return False
        # Soft delete
        story.is_active = False
        story.updated_at = datetime.utcnow()
        await session.commit()
        return True
    async def get_story_analytics(
        self,
        story_id: str,
        user_id: str,
        session: AsyncSession
    ) -> Optional[StoryAnalytics]:
        """Get analytics for a story (only for owner)."""
        # Verify ownership
        story = await session.execute(
            select(Story).where(
                and_(
                    Story.id == story_id,
                    Story.user_id == user_id
                )
            )
        )
        story = story.scalar_one_or_none()
        if not story:
            return None
        # Get view analytics
        total_views = await session.scalar(
            select(func.count(StoryView.id)).where(StoryView.story_id == story_id)
        ) or 0
        unique_viewers = await session.scalar(
            select(func.count(func.distinct(StoryView.viewer_id))).where(
                StoryView.story_id == story_id
            )
        ) or 0
        # Get viewers list (recent viewers)
        recent_viewers_query = (
            select(StoryView, User)
            .join(User, User.id == StoryView.viewer_id)
            .where(StoryView.story_id == story_id)
            .order_by(desc(StoryView.viewed_at))
            .limit(10)
        )
        result = await session.execute(recent_viewers_query)
        recent_viewers = []
        for view, user in result:
            recent_viewers.append({
                "user_id": str(user.id),
                "username": user.username,
                "display_name": user.display_name,
                "avatar_url": user.avatar_url,
                "viewed_at": view.viewed_at
            })
        return StoryAnalytics(
            story_id=story_id,
            total_views=total_views,
            unique_viewers=unique_viewers,
            recent_viewers=recent_viewers,
            created_at=story.created_at,
            expires_at=story.expires_at
        )
    async def search_stories(
        self,
        user_id: str,
        search_params: StorySearch,
        session: AsyncSession
    ) -> List[StoryRead]:
        """Search stories accessible to the user."""
        # Get user's friends for privacy filtering
        friends_query = select(
            func.case(
                (Friendship.requester_id == user_id, Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == user_id
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        friends_result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in friends_result]
        friend_ids.append(user_id)  # Include own stories
        # Build search query
        query = select(Story, User).join(User, User.id == Story.user_id).where(
            and_(
                Story.is_active == True,
                Story.expires_at > datetime.utcnow(),
                or_(
                    Story.privacy_level == StoryPrivacyLevel.PUBLIC,
                    and_(
                        Story.privacy_level == StoryPrivacyLevel.FRIENDS,
                        Story.user_id.in_(friend_ids)
                    ),
                    Story.user_id == user_id  # Own stories
                )
            )
        )
        # Apply search filters
        if search_params.query:
            query = query.where(
                or_(
                    Story.caption.ilike(f"%{search_params.query}%"),
                    Story.plant_tags.ilike(f"%{search_params.query}%")
                )
            )
        if search_params.content_type:
            query = query.where(Story.content_type == search_params.content_type)
        if search_params.user_id:
            query = query.where(Story.user_id == search_params.user_id)
        if search_params.start_date:
            query = query.where(Story.created_at >= search_params.start_date)
        if search_params.end_date:
            query = query.where(Story.created_at <= search_params.end_date)
        # Add ordering and limit
        query = query.order_by(desc(Story.created_at)).limit(50)
        result = await session.execute(query)
        stories_users = result.all()
        # Convert to StoryRead format
        story_reads = []
        for story, user in stories_users:
            has_viewed = await self._has_user_viewed_story(str(story.id), user_id, session)
            view_count = await session.scalar(
                select(func.count(StoryView.id)).where(StoryView.story_id == str(story.id))
            ) or 0
            story_read = StoryRead(
                id=str(story.id),
                user_id=str(story.user_id),
                content_type=story.content_type,
                media_url=story.media_url,
                caption=story.caption,
                duration=story.duration,
                file_size=story.file_size,
                privacy_level=story.privacy_level,
                created_at=story.created_at,
                expires_at=story.expires_at,
                plant_tags=story.plant_tags,
                location=story.location,
                user_username=user.username,
                user_display_name=user.display_name,
                user_avatar_url=user.avatar_url,
                view_count=view_count,
                has_viewed=has_viewed
            )
            story_reads.append(story_read)
        return story_reads
    async def cleanup_expired_stories(self, session: AsyncSession) -> int:
        """Clean up expired stories (background task)."""
        result = await session.execute(
            select(Story).where(
                and_(
                    Story.is_active == True,
                    Story.expires_at <= datetime.utcnow()
                )
            )
        )
        expired_stories = result.scalars().all()
        count = 0
        for story in expired_stories:
            story.is_active = False
            story.updated_at = datetime.utcnow()
            count += 1
        if count > 0:
            await session.commit()
        return count
    async def _validate_story_content(self, story_data: StoryCreate):
        """Validate story content."""
        if story_data.content_type in [StoryType.IMAGE, StoryType.VIDEO]:
            if not story_data.media_url:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"{story_data.content_type.value} stories must have media_url"
                )
        if story_data.duration and story_data.duration > 60:  # Max 60 seconds
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Story duration cannot exceed 60 seconds"
            )
    async def _can_view_story(
        self,
        story: Story,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can access this story."""
        # Owner can always view
        if str(story.user_id) == viewer_id:
            return True
        # Public stories
        if story.privacy_level == StoryPrivacyLevel.PUBLIC:
            return True
        # Friends only stories
        if story.privacy_level == StoryPrivacyLevel.FRIENDS:
            return await self._are_users_friends(str(story.user_id), viewer_id, session)
        # Close friends stories
        if story.privacy_level == StoryPrivacyLevel.CLOSE_FRIENDS:
            return await self._are_close_friends(str(story.user_id), viewer_id, session)
        return False
    async def _can_view_user_stories(
        self,
        user_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can see user's stories in general."""
        if user_id == viewer_id:
            return True
        # Check if they are friends
        return await self._are_users_friends(user_id, viewer_id, session)
    async def _are_users_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _are_close_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are close friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _has_user_viewed_story(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if user has viewed a story."""
        result = await session.execute(
            select(StoryView).where(
                and_(
                    StoryView.story_id == story_id,
                    StoryView.viewer_id == viewer_id
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _notify_friends_of_new_story(self, story: Story, session: AsyncSession):
        """Send notifications to friends about new story."""
        # Get friends based on privacy level
        if story.privacy_level == StoryPrivacyLevel.PUBLIC:
            # For public stories, we might not notify everyone
            # This could be a setting or limited to close friends
            return
        friends_query = select(
            func.case(
                (Friendship.requester_id == str(story.user_id), Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == str(story.user_id),
                    Friendship.addressee_id == str(story.user_id)
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        if story.privacy_level == StoryPrivacyLevel.CLOSE_FRIENDS:
            friends_query = friends_query.where(Friendship.is_close_friend == True)
        result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in result]
        # Get story owner info
        owner = await session.get(User, story.user_id)
        if owner and friend_ids:
            notification_data = {
                "type": "new_story",
                "story_id": str(story.id),
                "user_id": str(story.user_id),
                "username": owner.username,
                "display_name": owner.display_name,
                "content_type": story.content_type.value,
                "timestamp": story.created_at.isoformat()
            }
            # Send to all friends
            await self.connection_manager.broadcast_to_users(
                friend_ids,
                notification_data
            )
    async def _send_story_view_notification(
        self,
        story: StoryRead,
        viewer_id: str,
        session: AsyncSession
    ):
        """Send notification to story owner about view."""
        viewer = await session.get(User, viewer_id)
        if viewer:
            notification_data = {
                "type": "story_viewed",
                "story_id": story.id,
                "viewer_id": str(viewer.id),
                "viewer_username": viewer.username,
                "viewer_display_name": viewer.display_name,
                "timestamp": datetime.utcnow().isoformat()
            }
            await self.connection_manager.send_personal_message(
                story.user_id,
                notification_data
            )
# Global story service instance
story_service = StoryService()
# Convenience functions for backward compatibility
async def create_story(
    user_id: str,
    story_data: StoryCreate,
    session: AsyncSession
) -> Optional[Story]:
    """Create a new story."""
    return await story_service.create_story(user_id, story_data, session)
async def get_user_stories(
    user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> List[StoryRead]:
    """Get user's stories."""
    return await story_service.get_user_stories(user_id, session, limit, offset)
async def get_friends_stories(
    user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> StoryFeed:
    """Get friends' stories."""
    return await story_service.get_friends_stories(user_id, session, limit, offset)
async def get_story_by_id(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> Optional[StoryRead]:
    """Get a story by ID."""
    return await story_service.get_story_by_id(story_id, user_id, session)
async def view_story(
    story_id: str,
    viewer_id: str,
    session: AsyncSession
) -> bool:
    """View a story."""
    return await story_service.view_story(story_id, viewer_id, session)
async def delete_story(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Delete a story."""
    return await story_service.delete_story(story_id, user_id, session)
async def get_story_views(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> List[StoryView]:
    """Get story views."""
    return await story_service.get_story_views(story_id, user_id, session)
async def get_story_service() -> StoryService:
    """Get story service dependency."""
    return story_service
</file>

<file path="app/services/user_plant_service.py">
"""User plant service.
This module provides business logic for managing user plants,
including CRUD operations, care tracking, and reminders.
"""
from datetime import datetime, timedelta
from typing import List, Optional
from uuid import UUID
from sqlalchemy import and_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.user_plant import UserPlant
from app.models.plant_species import PlantSpecies
from app.models.plant_care_log import PlantCareLog
from app.schemas.user_plant import UserPlantCreate, UserPlantUpdate
class UserPlantService:
    """Service for managing user plants."""
    @staticmethod
    async def create_plant(
        db: AsyncSession,
        user_id: UUID,
        plant_data: UserPlantCreate
    ) -> UserPlant:
        """Create a new user plant.
        Args:
            db: Database session
            user_id: Owner user ID
            plant_data: Plant creation data
        Returns:
            Created user plant
        """
        plant = UserPlant(
            user_id=user_id,
            **plant_data.dict()
        )
        db.add(plant)
        await db.commit()
        await db.refresh(plant)
        return plant
    @staticmethod
    async def get_plant_by_id(
        db: AsyncSession,
        plant_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[UserPlant]:
        """Get user plant by ID.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Optional user ID for ownership check
        Returns:
            User plant if found, None otherwise
        """
        query = select(UserPlant).options(
            selectinload(UserPlant.species)
        ).where(UserPlant.id == plant_id)
        if user_id:
            query = query.where(UserPlant.user_id == user_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_plants(
        db: AsyncSession,
        user_id: UUID,
        is_active: Optional[bool] = True,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[UserPlant], int]:
        """Get plants owned by a user.
        Args:
            db: Database session
            user_id: User ID
            is_active: Filter by active status
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (plants list, total count)
        """
        # Build base query
        base_query = select(UserPlant).options(
            selectinload(UserPlant.species)
        ).where(UserPlant.user_id == user_id)
        count_query = select(func.count(UserPlant.id)).where(
            UserPlant.user_id == user_id
        )
        if is_active is not None:
            base_query = base_query.where(UserPlant.is_active == is_active)
            count_query = count_query.where(UserPlant.is_active == is_active)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(UserPlant.created_at.desc())
            .offset(skip)
            .limit(limit)
        )
        plants = result.scalars().all()
        return list(plants), total
    @staticmethod
    async def update_plant(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        plant_data: UserPlantUpdate
    ) -> Optional[UserPlant]:
        """Update user plant.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
            plant_data: Update data
        Returns:
            Updated plant if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return None
        # Update fields
        update_data = plant_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(plant, field, value)
        plant.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(plant)
        return plant
    @staticmethod
    async def delete_plant(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete user plant (soft delete by setting is_active=False).
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return False
        plant.is_active = False
        plant.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_care_reminders(
        db: AsyncSession,
        user_id: UUID
    ) -> List[dict]:
        """Get care reminders for user's plants.
        Args:
            db: Database session
            user_id: User ID
        Returns:
            List of care reminder data
        """
        # Get plants with species info
        result = await db.execute(
            select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            )
        )
        plants = result.scalars().all()
        reminders = []
        current_time = datetime.utcnow()
        for plant in plants:
            if not plant.species or not plant.species.water_frequency_days:
                continue
            # Check watering reminder
            if plant.last_watered:
                days_since_watered = (current_time - plant.last_watered).days
                if days_since_watered >= plant.species.water_frequency_days:
                    reminders.append({
                        "plant_id": plant.id,
                        "plant_nickname": plant.nickname,
                        "species_name": plant.species.scientific_name,
                        "care_type": "watering",
                        "days_overdue": days_since_watered - plant.species.water_frequency_days,
                        "last_care_date": plant.last_watered,
                        "recommended_frequency_days": plant.species.water_frequency_days
                    })
        return reminders
    @staticmethod
    async def update_care_activity(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        care_type: str,
        care_date: Optional[datetime] = None
    ) -> bool:
        """Update plant care activity timestamp.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
            care_type: Type of care (watering, fertilizing, etc.)
            care_date: Date of care activity
        Returns:
            True if updated, False if plant not found or not owned
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return False
        if care_date is None:
            care_date = datetime.utcnow()
        # Update appropriate timestamp
        if care_type == "watering":
            plant.last_watered = care_date
        elif care_type == "fertilizing":
            plant.last_fertilized = care_date
        elif care_type == "repotting":
            plant.last_repotted = care_date
        plant.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_plant_stats(
        db: AsyncSession,
        user_id: UUID
    ) -> dict:
        """Get plant statistics for a user.
        Args:
            db: Database session
            user_id: User ID
        Returns:
            Dictionary with plant statistics
        """
        # Get total plants count
        total_result = await db.execute(
            select(func.count(UserPlant.id)).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            )
        )
        total_plants = total_result.scalar()
        # Get plants by health status
        health_result = await db.execute(
            select(
                UserPlant.health_status,
                func.count(UserPlant.id)
            ).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            ).group_by(UserPlant.health_status)
        )
        health_stats = {status: count for status, count in health_result.all()}
        return {
            "total_plants": total_plants,
            "health_distribution": health_stats,
            "healthy_plants": health_stats.get("healthy", 0),
            "sick_plants": health_stats.get("sick", 0),
            "recovering_plants": health_stats.get("recovering", 0)
        }
# Convenience functions for dependency injection
async def get_plant_by_id(
    db: AsyncSession,
    plant_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[UserPlant]:
    """Get user plant by ID."""
    return await UserPlantService.get_plant_by_id(db, plant_id, user_id)
async def get_user_plants(
    db: AsyncSession,
    user_id: UUID,
    is_active: Optional[bool] = True,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[UserPlant], int]:
    """Get user's plants."""
    return await UserPlantService.get_user_plants(db, user_id, is_active, skip, limit)
async def create_plant(
    db: AsyncSession,
    user_id: UUID,
    plant_data: UserPlantCreate
) -> UserPlant:
    """Create a new user plant."""
    return await UserPlantService.create_plant(db, user_id, plant_data)
async def update_plant(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    plant_data: UserPlantUpdate
) -> Optional[UserPlant]:
    """Update user plant."""
    return await UserPlantService.update_plant(db, plant_id, user_id, plant_data)
async def get_care_reminders(db: AsyncSession, user_id: UUID) -> List[dict]:
    """Get care reminders for user's plants."""
    return await UserPlantService.get_care_reminders(db, user_id)
async def update_care_activity(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    care_type: str,
    care_date: Optional[datetime] = None
) -> bool:
    """Update plant care activity."""
    return await UserPlantService.update_care_activity(
        db, plant_id, user_id, care_type, care_date
    )
async def get_plant_stats(db: AsyncSession, user_id: UUID) -> dict:
    """Get plant statistics for a user."""
    return await UserPlantService.get_plant_stats(db, user_id)
async def delete_plant(db: AsyncSession, plant_id: UUID, user_id: UUID) -> bool:
    """Delete user plant (soft delete)."""
    return await UserPlantService.delete_plant(db, plant_id, user_id)
</file>

<file path="app/services/user_service.py">
"""User service.
This module provides user management services including
profile management, search, and user statistics.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.models.message import Message
from app.models.story import Story
from app.schemas.user import (
    UserUpdate, UserSearch, UserStats, UserSearchFilters,
    UserActivity, UserPreferences
)
from app.schemas.auth import UserCreate
from app.schemas.friendship import FriendProfile
from app.services.auth_service import auth_service
class UserService:
    """Service for user management operations."""
    def __init__(self):
        self.auth_service = auth_service
    async def create_user(
        self, 
        user_data: UserCreate, 
        session: AsyncSession
    ) -> User:
        """Create a new user."""
        # Hash the password
        hashed_password = self.auth_service.get_password_hash(user_data.password)
        # Create user instance
        user = User(
            email=user_data.email,
            username=user_data.username,
            display_name=user_data.display_name or user_data.username,
            hashed_password=hashed_password,
            bio=user_data.bio,
            location=user_data.location,
            gardening_experience=user_data.gardening_experience
        )
        session.add(user)
        await session.commit()
        await session.refresh(user)
        return user
    async def get_user_by_id(
        self, 
        user_id: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by ID."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()
    async def get_user_by_username(
        self, 
        username: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by username."""
        result = await session.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()
    async def get_user_by_email(
        self, 
        email: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by email."""
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()
    async def search_users(
        self,
        query: str,
        current_user_id: str,
        session: AsyncSession,
        filters: Optional[UserSearchFilters] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[UserSearch]:
        """Search for users with optional filters."""
        # Base query
        base_query = select(User).where(
            and_(
                User.id != current_user_id,  # Exclude current user
                User.is_active == True,
                or_(
                    User.username.ilike(f"%{query}%"),
                    User.display_name.ilike(f"%{query}%"),
                    User.bio.ilike(f"%{query}%")
                )
            )
        )
        # Apply filters if provided
        if filters:
            if filters.gardening_experience:
                base_query = base_query.where(
                    User.gardening_experience == filters.gardening_experience
                )
            if filters.location:
                base_query = base_query.where(
                    User.location.ilike(f"%{filters.location}%")
                )
            if filters.has_avatar is not None:
                if filters.has_avatar:
                    base_query = base_query.where(User.avatar_url.isnot(None))
                else:
                    base_query = base_query.where(User.avatar_url.is_(None))
        # Add pagination
        base_query = base_query.offset(offset).limit(limit)
        # Execute query
        result = await session.execute(base_query)
        users = result.scalars().all()
        # Get friendship status for each user
        user_searches = []
        for user in users:
            friendship_status = await self._get_friendship_status(
                current_user_id, str(user.id), session
            )
            user_search = UserSearch(
                id=str(user.id),
                username=user.username,
                display_name=user.display_name,
                avatar_url=user.avatar_url,
                bio=user.bio,
                gardening_experience=user.gardening_experience,
                location=user.location,
                is_verified=user.is_verified,
                friendship_status=friendship_status,
                mutual_friends_count=await self._get_mutual_friends_count(
                    current_user_id, str(user.id), session
                )
            )
            user_searches.append(user_search)
        return user_searches
    async def get_user_profile(
        self,
        user_id: str,
        current_user_id: str,
        session: AsyncSession
    ) -> Optional[Dict[str, Any]]:
        """Get detailed user profile."""
        user = await self.get_user_by_id(user_id, session)
        if not user:
            return None
        # Check if current user can view this profile
        can_view_full_profile = await self._can_view_full_profile(
            current_user_id, user_id, session
        )
        # Get friendship status
        friendship_status = await self._get_friendship_status(
            current_user_id, user_id, session
        )
        # Get user statistics
        stats = await self.get_user_stats(user_id, session)
        # Build profile data
        profile_data = {
            "id": str(user.id),
            "username": user.username,
            "display_name": user.display_name,
            "avatar_url": user.avatar_url,
            "bio": user.bio if can_view_full_profile else None,
            "gardening_experience": user.gardening_experience,
            "favorite_plants": user.favorite_plants if can_view_full_profile else None,
            "location": user.location if can_view_full_profile or user.show_location else None,
            "is_verified": user.is_verified,
            "created_at": user.created_at,
            "last_active": user.last_active if can_view_full_profile else None,
            "friendship_status": friendship_status,
            "stats": stats,
            "is_online": await self.auth_service.is_user_online(user_id)
        }
        # Add mutual friends count if not the same user
        if current_user_id != user_id:
            profile_data["mutual_friends_count"] = await self._get_mutual_friends_count(
                current_user_id, user_id, session
            )
        return profile_data
    async def update_user_profile(
        self,
        user_id: str,
        update_data: UserUpdate,
        session: AsyncSession
    ) -> Optional[User]:
        """Update user profile."""
        user = await self.get_user_by_id(user_id, session)
        if not user:
            return None
        # Check username availability if being updated
        if update_data.username and update_data.username != user.username:
            is_available = await self.auth_service.check_username_availability(
                update_data.username, session, exclude_user_id=user_id
            )
            if not is_available:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Username is already taken"
                )
        # Update fields
        update_dict = update_data.dict(exclude_unset=True)
        for field, value in update_dict.items():
            if hasattr(user, field):
                setattr(user, field, value)
        user.updated_at = datetime.utcnow()
        await session.commit()
        await session.refresh(user)
        return user
    async def get_user_stats(
        self,
        user_id: str,
        session: AsyncSession
    ) -> UserStats:
        """Get user statistics."""
        # Count friends
        friends_count = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        ) or 0
        # Count stories
        stories_count = await session.scalar(
            select(func.count(Story.id)).where(
                and_(
                    Story.user_id == user_id,
                    Story.is_active == True
                )
            )
        ) or 0
        # Count messages sent
        messages_sent = await session.scalar(
            select(func.count(Message.id)).where(
                Message.sender_id == user_id
            )
        ) or 0
        # Count messages received
        messages_received = await session.scalar(
            select(func.count(Message.id)).where(
                Message.recipient_id == user_id
            )
        ) or 0
        return UserStats(
            user_id=user_id,
            friends_count=friends_count,
            stories_count=stories_count,
            messages_sent=messages_sent,
            messages_received=messages_received,
            total_messages=messages_sent + messages_received
        )
    async def get_user_suggestions(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 10
    ) -> List[UserSearch]:
        """Get user suggestions based on mutual friends and interests."""
        # Get users who are friends of friends but not direct friends
        mutual_friends_query = """
        SELECT DISTINCT u.id, u.username, u.display_name, u.avatar_url, u.bio,
               u.gardening_experience, u.location, u.is_verified,
               COUNT(mf.friend_id) as mutual_count
        FROM users u
        JOIN (
            SELECT CASE 
                WHEN f1.requester_id = :user_id THEN f1.addressee_id
                ELSE f1.requester_id
            END as friend_id
            FROM friendships f1
            WHERE (f1.requester_id = :user_id OR f1.addressee_id = :user_id)
            AND f1.status = 'accepted'
        ) mf ON (
            (u.id IN (
                SELECT CASE 
                    WHEN f2.requester_id = mf.friend_id THEN f2.addressee_id
                    ELSE f2.requester_id
                END
                FROM friendships f2
                WHERE (f2.requester_id = mf.friend_id OR f2.addressee_id = mf.friend_id)
                AND f2.status = 'accepted'
            ))
        )
        WHERE u.id != :user_id
        AND u.is_active = true
        AND u.id NOT IN (
            SELECT CASE 
                WHEN f3.requester_id = :user_id THEN f3.addressee_id
                ELSE f3.requester_id
            END
            FROM friendships f3
            WHERE (f3.requester_id = :user_id OR f3.addressee_id = :user_id)
        )
        GROUP BY u.id, u.username, u.display_name, u.avatar_url, u.bio,
                 u.gardening_experience, u.location, u.is_verified
        ORDER BY mutual_count DESC, u.created_at DESC
        LIMIT :limit
        """
        result = await session.execute(
            mutual_friends_query,
            {"user_id": user_id, "limit": limit}
        )
        suggestions = []
        for row in result:
            suggestion = UserSearch(
                id=str(row.id),
                username=row.username,
                display_name=row.display_name,
                avatar_url=row.avatar_url,
                bio=row.bio,
                gardening_experience=row.gardening_experience,
                location=row.location,
                is_verified=row.is_verified,
                friendship_status="none",
                mutual_friends_count=row.mutual_count
            )
            suggestions.append(suggestion)
        return suggestions
    async def block_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Block a user."""
        # Check if friendship exists
        friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == blocker_id,
                        Friendship.addressee_id == blocked_id
                    ),
                    and_(
                        Friendship.requester_id == blocked_id,
                        Friendship.addressee_id == blocker_id
                    )
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if friendship:
            # Update existing friendship to blocked
            friendship.status = FriendshipStatus.BLOCKED
            friendship.updated_at = datetime.utcnow()
        else:
            # Create new blocked relationship
            new_friendship = Friendship(
                requester_id=blocker_id,
                addressee_id=blocked_id,
                status=FriendshipStatus.BLOCKED
            )
            session.add(new_friendship)
        await session.commit()
        return True
    async def unblock_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Unblock a user."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.requester_id == blocker_id,
                    Friendship.addressee_id == blocked_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if friendship:
            await session.delete(friendship)
            await session.commit()
            return True
        return False
    async def get_blocked_users(
        self,
        user_id: str,
        session: AsyncSession
    ) -> List[Dict[str, Any]]:
        """Get list of blocked users."""
        result = await session.execute(
            select(Friendship, User).join(
                User, User.id == Friendship.addressee_id
            ).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        blocked_users = []
        for friendship, user in result:
            blocked_users.append({
                "user_id": str(user.id),
                "username": user.username,
                "display_name": user.display_name,
                "avatar_url": user.avatar_url,
                "blocked_at": friendship.created_at
            })
        return blocked_users
    async def _get_friendship_status(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> str:
        """Get friendship status between two users."""
        if user1_id == user2_id:
            return "self"
        result = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == user1_id,
                        Friendship.addressee_id == user2_id
                    ),
                    and_(
                        Friendship.requester_id == user2_id,
                        Friendship.addressee_id == user1_id
                    )
                )
            )
        )
        friendship = result.scalar_one_or_none()
        if not friendship:
            return "none"
        if friendship.status == FriendshipStatus.BLOCKED:
            return "blocked"
        elif friendship.status == FriendshipStatus.PENDING:
            if friendship.requester_id == user1_id:
                return "pending_sent"
            else:
                return "pending_received"
        elif friendship.status == FriendshipStatus.ACCEPTED:
            return "friends"
        elif friendship.status == FriendshipStatus.DECLINED:
            return "declined"
        return "none"
    async def _get_mutual_friends_count(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> int:
        """Get count of mutual friends between two users."""
        # This is a complex query - for now return 0
        # In a real implementation, you'd query for mutual friends
        return 0
    async def _can_view_full_profile(
        self,
        viewer_id: str,
        profile_user_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can see full profile details."""
        if viewer_id == profile_user_id:
            return True
        # Check if they are friends
        friendship_status = await self._get_friendship_status(
            viewer_id, profile_user_id, session
        )
        return friendship_status == "friends"
# Global user service instance
user_service = UserService()
async def get_user_by_id(
    user_id: str,
    session: AsyncSession
) -> Optional[User]:
    """Get user by ID."""
    return await user_service.get_user_by_id(user_id, session)
async def get_user_by_username(
    username: str,
    session: AsyncSession
) -> Optional[User]:
    """Get user by username."""
    return await user_service.get_user_by_username(username, session)
async def search_users(
    query: str,
    current_user_id: str,
    session: AsyncSession,
    limit: int = 20
) -> List[dict]:
    """Search users."""
    return await user_service.search_users(query, current_user_id, session, limit)
async def update_user_profile(
    user_id: str,
    profile_data: dict,
    session: AsyncSession
) -> User:
    """Update user profile."""
    return await user_service.update_user_profile(user_id, profile_data, session)
async def get_user_stats(
    user_id: str,
    session: AsyncSession
) -> dict:
    """Get user stats."""
    return await user_service.get_user_stats(user_id, session)
async def get_user_service() -> UserService:
    """Get user service dependency."""
    return user_service
</file>

<file path="database/init.sql">
-- Database initialization script for Plant Social platform
-- This script sets up the database with necessary extensions
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-- Enable pgvector extension for future RAG features
CREATE EXTENSION IF NOT EXISTS vector;
-- Create indexes for better performance (will be created by Alembic migrations)
-- This file serves as documentation for manual setup if needed
-- Grant necessary permissions
GRANT ALL PRIVILEGES ON DATABASE plant_social_db TO postgres;
-- Set timezone
SET timezone = 'UTC';
-- Create custom types that might be needed
DO $$
BEGIN
    -- Create enum types if they don't exist
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'friendship_status') THEN
        CREATE TYPE friendship_status AS ENUM ('pending', 'accepted', 'declined', 'blocked');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_type') THEN
        CREATE TYPE message_type AS ENUM ('text', 'image', 'video', 'audio', 'plant_id', 'plant_care', 'location');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_status') THEN
        CREATE TYPE message_status AS ENUM ('sent', 'delivered', 'read', 'deleted', 'expired');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'story_type') THEN
        CREATE TYPE story_type AS ENUM ('image', 'video', 'plant_showcase', 'plant_timelapse', 'garden_tour');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'story_privacy_level') THEN
        CREATE TYPE story_privacy_level AS ENUM ('public', 'friends', 'close_friends', 'plant_community');
    END IF;
END$$;
</file>

<file path="Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create upload directories
RUN mkdir -p uploads/images uploads/thumbnails uploads/videos uploads/audio

# Set environment variables
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
</file>

<file path="Dockerfile.postgres">
FROM postgres:15

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    git \
    postgresql-server-dev-15 \
    && rm -rf /var/lib/apt/lists/*

# Clone and install pgvector
RUN git clone --branch v0.5.1 https://github.com/pgvector/pgvector.git \
    && cd pgvector \
    && make \
    && make install

# Add initialization script
COPY database/init.sql /docker-entrypoint-initdb.d/
</file>

<file path="README.md">
# Plant Social API Backend

FastAPI-based backend for the Plant Social platform with real-time messaging, stories, and AI-enhanced plant care features.

## Features

- **Authentication & User Management**: JWT-based auth with FastAPI-Users
- **Real-time Messaging**: WebSocket-based chat with disappearing messages
- **Stories System**: 24-hour ephemeral content sharing
- **Friend Management**: Friend requests, blocking, and social connections
- **File Storage**: AWS S3 integration with LocalStack for development
- **Database**: PostgreSQL with async SQLAlchemy and pgvector for future RAG
- **Caching**: Redis for sessions and real-time features

## Quick Start

### Prerequisites

- Python 3.11+
- Docker and Docker Compose
- PostgreSQL (or use Docker)
- Redis (or use Docker)

### Development Setup

1. **Clone and navigate to backend**:
   ```bash
   cd backend
   ```

2. **Install dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

3. **Set up environment**:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. **Start services with Docker**:
   ```bash
   # From project root
   docker-compose up postgres redis localstack
   ```

5. **Run database migrations**:
   ```bash
   # Initialize Alembic (first time only)
   alembic revision --autogenerate -m "Initial migration"
   
   # Apply migrations
   alembic upgrade head
   ```

6. **Start the API server**:
   ```bash
   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
   ```

### Using Docker (Full Stack)

```bash
# Start all services including backend
docker-compose --profile full up
```

## API Documentation

Once running, visit:
- **Interactive API Docs**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc
- **OpenAPI JSON**: http://localhost:8000/api/v1/openapi.json

## Project Structure

```
backend/
 app/
    api/                 # API routes and endpoints
       api_v1/
           endpoints/   # Individual endpoint modules
           api.py       # Main API router
    core/                # Core configuration
       config.py        # Settings and configuration
       database.py      # Database setup
       websocket.py     # WebSocket manager
    models/              # SQLAlchemy models
    schemas/             # Pydantic schemas
    services/            # Business logic
    main.py              # FastAPI application
 alembic/                 # Database migrations
 database/                # Database scripts
 .env                     # Environment variables
 requirements.txt         # Python dependencies
 Dockerfile              # Container configuration
```

## API Endpoints

### Authentication
- `POST /api/v1/auth/register` - User registration
- `POST /api/v1/auth/login` - User login
- `POST /api/v1/auth/refresh` - Refresh access token
- `GET /api/v1/auth/me` - Get current user info
- `PUT /api/v1/auth/me` - Update user profile
- `POST /api/v1/auth/logout` - Logout user

### Users
- `GET /api/v1/users/search` - Search users
- `GET /api/v1/users/{username}` - Get user profile
- `GET /api/v1/users/{user_id}/profile` - Get user by ID
- `PUT /api/v1/users/profile` - Update profile
- `GET /api/v1/users/stats` - Get user statistics
- `GET /api/v1/users/suggestions` - Get friend suggestions

### Messages
- `POST /api/v1/messages/send` - Send message
- `GET /api/v1/messages/conversations` - Get conversations
- `GET /api/v1/messages/conversation/{user_id}` - Get conversation
- `PUT /api/v1/messages/{message_id}/read` - Mark as read
- `DELETE /api/v1/messages/{message_id}` - Delete message

### Stories
- `POST /api/v1/stories/create` - Create story
- `GET /api/v1/stories/feed` - Get stories feed
- `GET /api/v1/stories/user/{user_id}` - Get user stories
- `GET /api/v1/stories/my` - Get own stories
- `PUT /api/v1/stories/{story_id}/view` - Mark story as viewed
- `DELETE /api/v1/stories/{story_id}` - Delete story

### Friends
- `POST /api/v1/friends/request` - Send friend request
- `PUT /api/v1/friends/accept/{request_id}` - Accept request
- `PUT /api/v1/friends/decline/{request_id}` - Decline request
- `DELETE /api/v1/friends/{friend_id}` - Remove friend
- `GET /api/v1/friends/list` - Get friends list
- `POST /api/v1/friends/block/{user_id}` - Block user

### WebSocket
- `WS /api/v1/ws/connect` - WebSocket connection for real-time messaging

## Database Schema

The application uses PostgreSQL with the following main tables:

- **users**: User accounts and profiles
- **messages**: Chat messages with disappearing functionality
- **stories**: 24-hour ephemeral content
- **story_views**: Story view tracking
- **friendships**: Friend relationships and requests

## Environment Variables

Key environment variables (see `.env.example`):

```bash
# Database
POSTGRES_SERVER=localhost
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_DB=plant_social_db

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Security
SECRET_KEY=your-secret-key
ACCESS_TOKEN_EXPIRE_MINUTES=11520

# AWS S3 (LocalStack for dev)
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
S3_BUCKET_NAME=plant-social-media
```

## Development Commands

```bash
# Database migrations
alembic revision --autogenerate -m "Description"
alembic upgrade head
alembic downgrade -1

# Code formatting
black app/
isort app/
flake8 app/

# Testing
pytest
pytest --cov=app

# Run with auto-reload
uvicorn app.main:app --reload
```

## WebSocket Usage

Connect to WebSocket for real-time features:

```javascript
const ws = new WebSocket('ws://localhost:8000/api/v1/ws/connect?token=YOUR_JWT_TOKEN');

// Send message
ws.send(JSON.stringify({
  type: 'send_message',
  data: {
    recipient_id: 'user-uuid',
    content: 'Hello!',
    message_type: 'text'
  }
}));

// Handle incoming messages
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  console.log('Received:', message);
};
```

## Production Deployment

1. **Environment Setup**:
   - Set production environment variables
   - Configure real AWS S3 credentials
   - Set strong SECRET_KEY
   - Configure production database

2. **Database**:
   - Run migrations: `alembic upgrade head`
   - Set up database backups
   - Configure connection pooling

3. **Security**:
   - Enable HTTPS
   - Configure CORS properly
   - Set up rate limiting
   - Enable security headers

4. **Monitoring**:
   - Set up logging
   - Configure health checks
   - Monitor database performance
   - Track API metrics

## Troubleshooting

### Common Issues

1. **Database Connection Error**:
   - Ensure PostgreSQL is running
   - Check connection string in `.env`
   - Verify database exists

2. **Redis Connection Error**:
   - Ensure Redis is running
   - Check Redis host/port configuration

3. **Migration Issues**:
   - Check Alembic configuration
   - Ensure models are imported in `env.py`
   - Verify database permissions

4. **WebSocket Connection Issues**:
   - Check JWT token validity
   - Verify WebSocket URL
   - Check CORS configuration

### Logs

```bash
# View application logs
docker-compose logs backend

# View database logs
docker-compose logs postgres

# View Redis logs
docker-compose logs redis
```

## Contributing

1. Follow the existing code style
2. Add tests for new features
3. Update documentation
4. Run linting before committing
5. Create meaningful commit messages

## License

This project is part of the Plant Social platform development challenge.
</file>

<file path="requirements.txt">
# Core FastAPI dependencies
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.23
asyncpg==0.29.0
psycopg2==2.9.9
alembic==1.12.1

# Authentication
fastapi-users[sqlalchemy]==12.1.2
fastapi-users[oauth]==12.1.2
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# Redis for caching and real-time
redis==5.0.1
aioredis==2.0.1

# WebSocket support
websockets==12.0

# File handling and AWS
boto3==1.34.0
pillow==10.1.0
python-magic==0.4.27

# Environment and configuration
python-dotenv==1.0.0
pydantic-settings==2.1.0

# Development and testing
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2
black==23.11.0
isort==5.12.0
flake8==6.1.0

# Vector database for future RAG
pgvector==0.2.4

# AI/ML (for future phases)
openai==1.3.7
numpy==1.25.2
</file>

<file path="test_config.py">
#!/usr/bin/env python3
"""
Simple test script to verify configuration loading.
"""
try:
    from app.core.config import settings
    print(" Configuration loaded successfully")
    print(f"Project: {settings.PROJECT_NAME}")
    print(f"CORS Origins: {settings.BACKEND_CORS_ORIGINS}")
    print(f"Database URI: {settings.SQLALCHEMY_DATABASE_URI}")
except Exception as e:
    print(f" Configuration failed: {e}")
    import traceback
    traceback.print_exc()
</file>

</files>
</file>

<file path="backend/alembic/versions/2c0d0c4c83cb_add_achievements_and_nursery_models.py">
"""add_achievements_and_nursery_models
Revision ID: 2c0d0c4c83cb
Revises: eca90a7d28b5
Create Date: 2025-06-28 23:42:52.212689
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = '2c0d0c4c83cb'
down_revision = 'eca90a7d28b5'
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('local_nurseries',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(length=200), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('address', sa.String(length=500), nullable=True),
    sa.Column('city', sa.String(length=100), nullable=True),
    sa.Column('state', sa.String(length=50), nullable=True),
    sa.Column('country', sa.String(length=50), nullable=True),
    sa.Column('postal_code', sa.String(length=20), nullable=True),
    sa.Column('latitude', sa.Float(), nullable=True),
    sa.Column('longitude', sa.Float(), nullable=True),
    sa.Column('phone', sa.String(length=20), nullable=True),
    sa.Column('email', sa.String(length=100), nullable=True),
    sa.Column('website', sa.String(length=200), nullable=True),
    sa.Column('business_type', sa.String(length=50), nullable=True),
    sa.Column('specialties', sa.JSON(), nullable=True),
    sa.Column('services', sa.JSON(), nullable=True),
    sa.Column('operating_hours', sa.JSON(), nullable=True),
    sa.Column('average_rating', sa.Float(), nullable=True),
    sa.Column('total_reviews', sa.Integer(), nullable=True),
    sa.Column('is_verified', sa.Boolean(), nullable=True),
    sa.Column('verified_at', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_local_nurseries'))
    )
    op.create_table('plant_achievements',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('achievement_type', sa.String(length=50), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('icon', sa.String(length=50), nullable=True),
    sa.Column('badge_color', sa.String(length=20), nullable=True),
    sa.Column('points', sa.Integer(), nullable=True),
    sa.Column('unlock_criteria', sa.JSON(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_achievements'))
    )
    op.create_table('nursery_events',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('title', sa.String(length=200), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('event_type', sa.String(length=50), nullable=True),
    sa.Column('start_date', sa.DateTime(), nullable=False),
    sa.Column('end_date', sa.DateTime(), nullable=True),
    sa.Column('start_time', sa.Time(), nullable=True),
    sa.Column('end_time', sa.Time(), nullable=True),
    sa.Column('is_recurring', sa.Boolean(), nullable=True),
    sa.Column('recurrence_pattern', sa.JSON(), nullable=True),
    sa.Column('max_participants', sa.Integer(), nullable=True),
    sa.Column('current_participants', sa.Integer(), nullable=True),
    sa.Column('price', sa.Float(), nullable=True),
    sa.Column('skill_level', sa.String(length=20), nullable=True),
    sa.Column('requirements', sa.Text(), nullable=True),
    sa.Column('materials_provided', sa.Text(), nullable=True),
    sa.Column('requires_registration', sa.Boolean(), nullable=True),
    sa.Column('registration_deadline', sa.DateTime(), nullable=True),
    sa.Column('contact_info', sa.String(length=200), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('is_cancelled', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_nursery_events_nursery_id_local_nurseries')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_nursery_events'))
    )
    op.create_table('nursery_reviews',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=200), nullable=True),
    sa.Column('review_text', sa.Text(), nullable=True),
    sa.Column('plant_quality_rating', sa.Integer(), nullable=True),
    sa.Column('service_rating', sa.Integer(), nullable=True),
    sa.Column('price_rating', sa.Integer(), nullable=True),
    sa.Column('selection_rating', sa.Integer(), nullable=True),
    sa.Column('tags', sa.JSON(), nullable=True),
    sa.Column('is_verified_purchase', sa.Boolean(), nullable=True),
    sa.Column('visit_date', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_nursery_reviews_nursery_id_local_nurseries')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_nursery_reviews_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_nursery_reviews'))
    )
    op.create_table('user_achievements',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('achievement_id', sa.UUID(), nullable=False),
    sa.Column('earned_at', sa.DateTime(), nullable=True),
    sa.Column('progress_data', sa.JSON(), nullable=True),
    sa.Column('is_featured', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['achievement_id'], ['plant_achievements.id'], name=op.f('fk_user_achievements_achievement_id_plant_achievements')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_achievements_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_achievements'))
    )
    op.create_table('user_nursery_favorites',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('nursery_id', sa.UUID(), nullable=False),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.Column('last_visited', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['nursery_id'], ['local_nurseries.id'], name=op.f('fk_user_nursery_favorites_nursery_id_local_nurseries')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_nursery_favorites_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_nursery_favorites'))
    )
    op.create_table('user_stats',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('total_plants', sa.Integer(), nullable=True),
    sa.Column('active_plants', sa.Integer(), nullable=True),
    sa.Column('plants_identified', sa.Integer(), nullable=True),
    sa.Column('total_care_logs', sa.Integer(), nullable=True),
    sa.Column('care_streak_days', sa.Integer(), nullable=True),
    sa.Column('longest_care_streak', sa.Integer(), nullable=True),
    sa.Column('last_care_activity', sa.DateTime(), nullable=True),
    sa.Column('questions_asked', sa.Integer(), nullable=True),
    sa.Column('questions_answered', sa.Integer(), nullable=True),
    sa.Column('helpful_answers', sa.Integer(), nullable=True),
    sa.Column('trades_completed', sa.Integer(), nullable=True),
    sa.Column('total_achievements', sa.Integer(), nullable=True),
    sa.Column('total_points', sa.Integer(), nullable=True),
    sa.Column('level', sa.Integer(), nullable=True),
    sa.Column('last_updated', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_stats_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_stats')),
    sa.UniqueConstraint('user_id', name=op.f('uq_user_stats_user_id'))
    )
    op.create_table('plant_milestones',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('plant_id', sa.UUID(), nullable=False),
    sa.Column('milestone_type', sa.String(length=50), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('achieved_at', sa.DateTime(), nullable=True),
    sa.Column('photo_url', sa.String(length=500), nullable=True),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['plant_id'], ['user_plants.id'], name=op.f('fk_plant_milestones_plant_id_user_plants')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_milestones'))
    )
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('plant_milestones')
    op.drop_table('user_stats')
    op.drop_table('user_nursery_favorites')
    op.drop_table('user_achievements')
    op.drop_table('nursery_reviews')
    op.drop_table('nursery_events')
    op.drop_table('plant_achievements')
    op.drop_table('local_nurseries')
    # ### end Alembic commands ###
</file>

<file path="backend/alembic/versions/88316ca546cb_add_rag_system_models.py">
"""add_rag_system_models
Revision ID: 88316ca546cb
Revises: 2c0d0c4c83cb
Create Date: 2025-06-29 00:31:46.491001
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
import pgvector.sqlalchemy
# revision identifiers, used by Alembic.
revision = '88316ca546cb'
down_revision = '2c0d0c4c83cb'
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('plant_content_embeddings',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('content_type', sa.String(length=50), nullable=False),
    sa.Column('content_id', sa.UUID(), nullable=False),
    sa.Column('embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=False),
    sa.Column('meta_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_content_embeddings'))
    )
    op.create_index('ix_plant_content_embeddings_content_id', 'plant_content_embeddings', ['content_id'], unique=False)
    op.create_index('ix_plant_content_embeddings_type', 'plant_content_embeddings', ['content_type'], unique=False)
    op.create_index('ix_plant_content_embeddings_vector', 'plant_content_embeddings', ['embedding'], unique=False, postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'})
    op.create_table('semantic_search_cache',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('query_hash', sa.String(length=64), nullable=False),
    sa.Column('query_embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=False),
    sa.Column('results', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('filters_hash', sa.String(length=64), nullable=True),
    sa.Column('hit_count', sa.Integer(), nullable=True),
    sa.Column('expires_at', sa.DateTime(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('last_accessed', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_semantic_search_cache')),
    sa.UniqueConstraint('query_hash', name=op.f('uq_semantic_search_cache_query_hash'))
    )
    op.create_index('ix_semantic_search_cache_expires', 'semantic_search_cache', ['expires_at'], unique=False)
    op.create_index('ix_semantic_search_cache_query_hash', 'semantic_search_cache', ['query_hash'], unique=False)
    op.create_table('plant_knowledge_base',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('title', sa.String(length=200), nullable=False),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('content_type', sa.String(length=50), nullable=False),
    sa.Column('plant_species_id', sa.UUID(), nullable=True),
    sa.Column('difficulty_level', sa.String(length=20), nullable=True),
    sa.Column('season', sa.String(length=20), nullable=True),
    sa.Column('climate_zones', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('tags', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('source', sa.String(length=100), nullable=True),
    sa.Column('author_id', sa.UUID(), nullable=True),
    sa.Column('verified', sa.String(length=20), nullable=True),
    sa.Column('view_count', sa.Integer(), nullable=True),
    sa.Column('helpful_count', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('updated_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['author_id'], ['users.id'], name=op.f('fk_plant_knowledge_base_author_id_users')),
    sa.ForeignKeyConstraint(['plant_species_id'], ['plant_species.id'], name=op.f('fk_plant_knowledge_base_plant_species_id_plant_species')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_plant_knowledge_base'))
    )
    op.create_index('ix_plant_knowledge_base_difficulty', 'plant_knowledge_base', ['difficulty_level'], unique=False)
    op.create_index('ix_plant_knowledge_base_species', 'plant_knowledge_base', ['plant_species_id'], unique=False)
    op.create_index('ix_plant_knowledge_base_type', 'plant_knowledge_base', ['content_type'], unique=False)
    op.create_index('ix_plant_knowledge_base_verified', 'plant_knowledge_base', ['verified'], unique=False)
    op.create_table('rag_interactions',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('interaction_type', sa.String(length=50), nullable=False),
    sa.Column('query_text', sa.Text(), nullable=True),
    sa.Column('query_embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=True),
    sa.Column('retrieved_documents', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('generated_response', sa.Text(), nullable=True),
    sa.Column('user_feedback', sa.Integer(), nullable=True),
    sa.Column('response_time_ms', sa.Integer(), nullable=True),
    sa.Column('confidence_score', sa.DECIMAL(precision=3, scale=2), nullable=True),
    sa.Column('meta_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_rag_interactions_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_rag_interactions'))
    )
    op.create_index('ix_rag_interactions_created', 'rag_interactions', ['created_at'], unique=False)
    op.create_index('ix_rag_interactions_type', 'rag_interactions', ['interaction_type'], unique=False)
    op.create_index('ix_rag_interactions_user', 'rag_interactions', ['user_id'], unique=False)
    op.create_index('ix_rag_interactions_vector', 'rag_interactions', ['query_embedding'], unique=False, postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'query_embedding': 'vector_cosine_ops'})
    op.create_table('user_preference_embeddings',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('preference_type', sa.String(length=50), nullable=False),
    sa.Column('embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=False),
    sa.Column('confidence_score', sa.DECIMAL(precision=3, scale=2), nullable=True),
    sa.Column('meta_data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('last_updated', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_user_preference_embeddings_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_user_preference_embeddings'))
    )
    op.create_index('ix_user_preference_embeddings_type', 'user_preference_embeddings', ['preference_type'], unique=False)
    op.create_index('ix_user_preference_embeddings_user', 'user_preference_embeddings', ['user_id'], unique=False)
    op.create_index('ix_user_preference_embeddings_vector', 'user_preference_embeddings', ['embedding'], unique=False, postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'})
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_user_preference_embeddings_vector', table_name='user_preference_embeddings', postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'})
    op.drop_index('ix_user_preference_embeddings_user', table_name='user_preference_embeddings')
    op.drop_index('ix_user_preference_embeddings_type', table_name='user_preference_embeddings')
    op.drop_table('user_preference_embeddings')
    op.drop_index('ix_rag_interactions_vector', table_name='rag_interactions', postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'query_embedding': 'vector_cosine_ops'})
    op.drop_index('ix_rag_interactions_user', table_name='rag_interactions')
    op.drop_index('ix_rag_interactions_type', table_name='rag_interactions')
    op.drop_index('ix_rag_interactions_created', table_name='rag_interactions')
    op.drop_table('rag_interactions')
    op.drop_index('ix_plant_knowledge_base_verified', table_name='plant_knowledge_base')
    op.drop_index('ix_plant_knowledge_base_type', table_name='plant_knowledge_base')
    op.drop_index('ix_plant_knowledge_base_species', table_name='plant_knowledge_base')
    op.drop_index('ix_plant_knowledge_base_difficulty', table_name='plant_knowledge_base')
    op.drop_table('plant_knowledge_base')
    op.drop_index('ix_semantic_search_cache_query_hash', table_name='semantic_search_cache')
    op.drop_index('ix_semantic_search_cache_expires', table_name='semantic_search_cache')
    op.drop_table('semantic_search_cache')
    op.drop_index('ix_plant_content_embeddings_vector', table_name='plant_content_embeddings', postgresql_using='ivfflat', postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'})
    op.drop_index('ix_plant_content_embeddings_type', table_name='plant_content_embeddings')
    op.drop_index('ix_plant_content_embeddings_content_id', table_name='plant_content_embeddings')
    op.drop_table('plant_content_embeddings')
    # ### end Alembic commands ###
</file>

<file path="backend/alembic/versions/e7c4ed08f749_initial_schema_with_all_models.py">
"""Initial schema with all models
Revision ID: e7c4ed08f749
Revises: 
Create Date: 2025-06-28 23:06:01.414661
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = 'e7c4ed08f749'
down_revision = None
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
</file>

<file path="backend/alembic/versions/eca90a7d28b5_create_initial_schema_with_all_models.py">
"""Create initial schema with all models
Revision ID: eca90a7d28b5
Revises: e7c4ed08f749
Create Date: 2025-06-28 23:06:41.078273
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = 'eca90a7d28b5'
down_revision = 'e7c4ed08f749'
branch_labels = None
depends_on = None
def upgrade() -> None:
    """Upgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
def downgrade() -> None:
    """Downgrade database schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
</file>

<file path="backend/app/api/api_v1/endpoints/achievements.py">
"""Achievement endpoints."""
from typing import List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.services.plant_achievement_service import PlantAchievementService, PlantMilestoneService
from app.models.plant_achievement import UserAchievement, PlantMilestone, UserStats
from app.schemas.achievement import (
    UserAchievementResponse,
    PlantMilestoneResponse,
    UserStatsResponse,
    PlantMilestoneCreate
)
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
router = APIRouter()
@router.get("/achievements", response_model=List[UserAchievementResponse])
async def get_user_achievements(
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's earned achievements."""
    achievements = await PlantAchievementService.get_user_achievements(
        db, current_user.id, limit, offset
    )
    return achievements
@router.post("/achievements/check")
async def check_achievements(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Check and award any newly earned achievements."""
    newly_earned = await PlantAchievementService.check_and_award_achievements(
        db, current_user.id
    )
    return {
        "newly_earned_count": len(newly_earned),
        "achievements": newly_earned
    }
@router.get("/stats", response_model=UserStatsResponse)
async def get_user_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's plant care statistics."""
    stats = await PlantAchievementService.get_or_create_user_stats(db, current_user.id)
    return stats
@router.get("/milestones", response_model=List[PlantMilestoneResponse])
async def get_user_milestones(
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's plant milestones."""
    milestones = await PlantMilestoneService.get_user_milestones(
        db, current_user.id, limit, offset
    )
    return milestones
@router.get("/plants/{plant_id}/milestones", response_model=List[PlantMilestoneResponse])
async def get_plant_milestones(
    plant_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get milestones for a specific plant."""
    # TODO: Add authorization check to ensure user owns the plant
    milestones = await PlantMilestoneService.get_plant_milestones(db, plant_id)
    return milestones
@router.post("/plants/{plant_id}/milestones", response_model=PlantMilestoneResponse)
async def create_plant_milestone(
    plant_id: UUID,
    milestone_data: PlantMilestoneCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new plant milestone."""
    # TODO: Add authorization check to ensure user owns the plant
    milestone = await PlantMilestoneService.create_milestone(
        db=db,
        plant_id=plant_id,
        milestone_type=milestone_data.milestone_type,
        title=milestone_data.title,
        description=milestone_data.description,
        photo_url=milestone_data.photo_url,
        notes=milestone_data.notes
    )
    return milestone
@router.post("/plants/{plant_id}/milestones/check")
async def check_automatic_milestones(
    plant_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Check and create automatic milestones for a plant."""
    # TODO: Add authorization check to ensure user owns the plant
    newly_created = await PlantMilestoneService.check_automatic_milestones(db, plant_id)
    return {
        "newly_created_count": len(newly_created),
        "milestones": newly_created
    }
</file>

<file path="backend/app/api/api_v1/endpoints/content_generation.py">
"""Content generation API endpoints."""
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, status, Query, Body
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.services.content_generation_service import ContentGenerationService, GeneratedContent
from app.services.rag_service import RAGService
from app.services.embedding_service import EmbeddingService
from app.services.vector_database_service import VectorDatabaseService
from pydantic import BaseModel
router = APIRouter()
# Initialize services
embedding_service = EmbeddingService()
vector_service = VectorDatabaseService(embedding_service)
rag_service = RAGService(vector_service, embedding_service)
content_service = ContentGenerationService(rag_service, embedding_service, vector_service)
class ImageContext(BaseModel):
    """Image context for caption generation."""
    plant_type: Optional[str] = None
    setting: Optional[str] = None  # indoor, outdoor, greenhouse
    lighting: Optional[str] = None  # bright, low, natural
    plant_health: Optional[str] = None  # healthy, struggling, thriving
    special_features: Optional[List[str]] = None  # new_growth, flowers, etc.
class CaptionRequest(BaseModel):
    """Request for caption generation."""
    image_context: ImageContext
    plant_id: Optional[str] = None
    tone: Optional[str] = "friendly"  # friendly, professional, casual, educational
    include_hashtags: bool = True
class TipRequest(BaseModel):
    """Request for plant care tip generation."""
    plant_id: Optional[str] = None
    topic: Optional[str] = None  # watering, fertilizing, pruning, etc.
    urgency: Optional[str] = "normal"  # urgent, normal, seasonal
class DescriptionRequest(BaseModel):
    """Request for plant description generation."""
    plant_species_id: str
    context_type: str = "identification"  # identification, care_guide, social_post
    detail_level: str = "medium"  # brief, medium, detailed
@router.post("/caption", response_model=GeneratedContent)
async def generate_plant_caption(
    request: CaptionRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate personalized caption for plant photo."""
    try:
        # Convert request to image context dict
        image_context = {
            "plant_type": request.image_context.plant_type,
            "setting": request.image_context.setting,
            "lighting": request.image_context.lighting,
            "plant_health": request.image_context.plant_health,
            "special_features": request.image_context.special_features or [],
            "tone": request.tone,
            "include_hashtags": request.include_hashtags
        }
        caption = await content_service.generate_plant_caption(
            db=db,
            user_id=str(current_user.id),
            image_context=image_context,
            plant_id=request.plant_id
        )
        return caption
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating caption: {str(e)}"
        )
@router.post("/tip", response_model=GeneratedContent)
async def generate_plant_tip(
    request: TipRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate personalized plant care tip."""
    try:
        tip = await content_service.generate_personalized_plant_tip(
            db=db,
            user_id=str(current_user.id),
            plant_id=request.plant_id,
            topic=request.topic
        )
        return tip
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating tip: {str(e)}"
        )
@router.get("/story-suggestions", response_model=List[GeneratedContent])
async def get_story_suggestions(
    limit: int = Query(5, ge=1, le=20),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get personalized story content suggestions."""
    try:
        suggestions = await content_service.generate_story_suggestions(
            db=db,
            user_id=str(current_user.id),
            limit=limit
        )
        return suggestions
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating story suggestions: {str(e)}"
        )
@router.post("/plant-description", response_model=GeneratedContent)
async def generate_plant_description(
    request: DescriptionRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate context-aware plant description."""
    try:
        description = await content_service.generate_plant_description(
            db=db,
            user_id=str(current_user.id),
            plant_species_id=request.plant_species_id,
            context_type=request.context_type
        )
        return description
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating plant description: {str(e)}"
        )
@router.get("/seasonal-content")
async def get_seasonal_content(
    content_types: List[str] = Query(["tip", "story_suggestion"]),
    limit: int = Query(10, ge=1, le=50),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get seasonal content recommendations for user."""
    try:
        seasonal_content = []
        for content_type in content_types:
            if content_type == "tip":
                # Generate seasonal plant tips
                tip = await content_service.generate_personalized_plant_tip(
                    db=db,
                    user_id=str(current_user.id),
                    topic="seasonal"
                )
                seasonal_content.append(tip)
            elif content_type == "story_suggestion":
                # Generate seasonal story suggestions
                suggestions = await content_service.generate_story_suggestions(
                    db=db,
                    user_id=str(current_user.id),
                    limit=3
                )
                # Filter for seasonal content
                seasonal_suggestions = [
                    s for s in suggestions 
                    if "seasonal" in s.personalization_factors or "season" in s.tags
                ]
                seasonal_content.extend(seasonal_suggestions[:2])
        # Limit total results
        return seasonal_content[:limit]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating seasonal content: {str(e)}"
        )
@router.get("/content-analytics")
async def get_content_analytics(
    days: int = Query(30, ge=1, le=365),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get content generation analytics for user."""
    try:
        # This would typically query RAGInteraction logs
        # For now, return mock analytics
        analytics = {
            "total_generated": 45,
            "content_types": {
                "captions": 20,
                "tips": 15,
                "story_suggestions": 8,
                "descriptions": 2
            },
            "avg_confidence": 0.82,
            "avg_engagement_score": 0.75,
            "top_personalization_factors": [
                "experience_level",
                "plant_collection",
                "seasonal_context",
                "location"
            ],
            "most_used_hashtags": [
                "#PlantParent",
                "#IndoorPlants",
                "#PlantCare",
                "#GreenThumb",
                "#PlantLife"
            ]
        }
        return analytics
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting content analytics: {str(e)}"
        )
@router.post("/feedback")
async def provide_content_feedback(
    content_id: str,
    feedback: Dict[str, Any] = Body(...),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Provide feedback on generated content for improvement."""
    try:
        # Store feedback for learning
        # This would typically update RAGInteraction records
        feedback_data = {
            "user_id": str(current_user.id),
            "content_id": content_id,
            "rating": feedback.get("rating", 3),
            "helpful": feedback.get("helpful", True),
            "used": feedback.get("used", False),
            "comments": feedback.get("comments", ""),
            "timestamp": "2025-06-29T00:00:00Z"
        }
        # In a real implementation, this would:
        # 1. Store the feedback in the database
        # 2. Update user preference embeddings
        # 3. Improve future content generation
        return {
            "message": "Feedback received successfully",
            "feedback_id": f"feedback_{current_user.id}_{content_id}",
            "status": "processed"
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing feedback: {str(e)}"
        )
@router.get("/writing-style")
async def analyze_writing_style(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Analyze user's writing style for better content personalization."""
    try:
        # This would typically analyze user's past posts/comments
        # For now, return mock analysis
        writing_style = {
            "tone": "friendly",
            "formality": "casual",
            "emoji_usage": "moderate",
            "hashtag_preference": "selective",
            "content_length": "medium",
            "topics_of_interest": [
                "plant_care",
                "indoor_gardening",
                "plant_health",
                "seasonal_care"
            ],
            "vocabulary_level": "intermediate",
            "engagement_patterns": {
                "best_posting_times": ["morning", "evening"],
                "preferred_content_types": ["tips", "progress_photos"],
                "interaction_style": "supportive"
            }
        }
        return writing_style
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error analyzing writing style: {str(e)}"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/discovery_feed.py">
"""Discovery feed API endpoints for personalized content curation."""
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_async_session
from app.services.contextual_discovery_service import ContextualDiscoveryService, DiscoveryItem
from app.services.vector_database_service import VectorDatabaseService
from app.services.embedding_service import EmbeddingService
from pydantic import BaseModel
router = APIRouter()
# Initialize services
embedding_service = EmbeddingService()
vector_service = VectorDatabaseService(embedding_service)
discovery_service = ContextualDiscoveryService(vector_service, embedding_service)
class FeedResponse(BaseModel):
    """Response model for discovery feed."""
    items: List[Dict[str, Any]]
    total_count: int
    has_more: bool
    next_offset: Optional[int]
@router.get("/feed/{user_id}", response_model=FeedResponse)
async def get_personalized_feed(
    user_id: str,
    feed_type: str = Query("home", description="Type of feed: home, explore, trending"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_async_session)
):
    """Get personalized discovery feed for user."""
    try:
        # Generate personalized feed
        feed_items = await discovery_service.generate_personalized_feed(
            db=db,
            user_id=user_id,
            feed_type=feed_type,
            limit=limit + 1  # Get one extra to check if there are more
        )
        # Check if there are more items
        has_more = len(feed_items) > limit
        if has_more:
            feed_items = feed_items[:limit]
        # Convert to response format
        items = []
        for item in feed_items:
            items.append({
                "id": item.id,
                "content_type": item.content_type.value,
                "title": item.title,
                "content": item.content,
                "author_id": item.author_id,
                "author_name": item.author_name,
                "relevance_score": item.relevance_score,
                "engagement_score": item.engagement_score,
                "personalization_factors": item.personalization_factors,
                "tags": item.tags,
                "plant_species": item.plant_species,
                "created_at": item.created_at.isoformat(),
                "metadata": item.metadata
            })
        return FeedResponse(
            items=items,
            total_count=len(items),
            has_more=has_more,
            next_offset=offset + limit if has_more else None
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating personalized feed: {str(e)}"
        )
@router.get("/behavior-analysis/{user_id}")
async def analyze_user_behavior(
    user_id: str,
    days: int = Query(30, ge=1, le=365),
    db: AsyncSession = Depends(get_async_session)
):
    """Analyze user behavior patterns for personalization insights."""
    try:
        behavior_analysis = await discovery_service.analyze_user_behavior(
            db=db,
            user_id=user_id,
            days=days
        )
        return behavior_analysis
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error analyzing user behavior: {str(e)}"
        )
@router.get("/trending-topics")
async def get_trending_topics(
    time_window: str = Query("week", description="Time window: day, week, month"),
    limit: int = Query(10, ge=1, le=50),
    db: AsyncSession = Depends(get_async_session)
):
    """Get trending topics in the plant community."""
    try:
        trending_topics = await discovery_service.get_trending_topics(
            db=db,
            time_window=time_window,
            limit=limit
        )
        return {
            "trending_topics": trending_topics,
            "time_window": time_window,
            "generated_at": "2025-06-29T00:00:00Z"
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting trending topics: {str(e)}"
        )
@router.get("/contextual-recommendations/{user_id}")
async def get_contextual_recommendations(
    user_id: str,
    context: str = Query("general", description="Context: general, plant_problem, seasonal, beginner"),
    plant_issue: Optional[str] = Query(None, description="Specific plant issue if context is plant_problem"),
    limit: int = Query(10, ge=1, le=30),
    db: AsyncSession = Depends(get_async_session)
):
    """Get contextual recommendations based on user's current situation."""
    try:
        # Build context dictionary
        context_data = {"type": context}
        if plant_issue:
            context_data["plant_issue"] = plant_issue
        # This would use the contextual discovery service
        # For now, return mock recommendations
        recommendations = [
            {
                "id": "rec_1",
                "content_type": "tip",
                "title": "Winter Plant Care Tips",
                "content": "During winter months, reduce watering frequency and ensure adequate humidity...",
                "relevance_score": 0.9,
                "context_match": context,
                "personalization_factors": ["seasonal_context", "user_plants"],
                "recommended_action": "read_and_apply"
            },
            {
                "id": "rec_2",
                "content_type": "knowledge",
                "title": "Common Winter Plant Problems",
                "content": "Learn to identify and solve common issues that arise during winter...",
                "relevance_score": 0.8,
                "context_match": context,
                "personalization_factors": ["seasonal_context", "experience_level"],
                "recommended_action": "bookmark_for_reference"
            }
        ]
        return {
            "recommendations": recommendations[:limit],
            "context": context,
            "user_id": user_id,
            "generated_at": "2025-06-29T00:00:00Z"
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting contextual recommendations: {str(e)}"
        )
@router.get("/feed-stats/{user_id}")
async def get_feed_statistics(
    user_id: str,
    days: int = Query(7, ge=1, le=30),
    db: AsyncSession = Depends(get_async_session)
):
    """Get feed engagement statistics for user."""
    try:
        # This would typically analyze user's feed interactions
        # For now, return mock statistics
        stats = {
            "feed_views": 45,
            "content_interactions": 28,
            "average_session_time": "8.5 minutes",
            "most_engaged_content_types": [
                {"type": "plant_tips", "engagement_rate": 0.75},
                {"type": "stories", "engagement_rate": 0.68},
                {"type": "questions", "engagement_rate": 0.52},
                {"type": "trades", "engagement_rate": 0.35}
            ],
            "personalization_effectiveness": {
                "relevance_score": 0.82,
                "diversity_score": 0.74,
                "freshness_score": 0.89
            },
            "top_interests": [
                "indoor_plants",
                "plant_care",
                "propagation",
                "seasonal_care"
            ],
            "engagement_by_time": {
                "morning": 0.45,
                "afternoon": 0.32,
                "evening": 0.78,
                "night": 0.23
            }
        }
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting feed statistics: {str(e)}"
        )
@router.post("/feed-feedback")
async def provide_feed_feedback(
    user_id: str,
    item_id: str,
    feedback_type: str,
    feedback_data: Dict[str, Any],
    db: AsyncSession = Depends(get_async_session)
):
    """Provide feedback on feed items for algorithm improvement."""
    try:
        # Store feedback for learning
        feedback_record = {
            "user_id": user_id,
            "item_id": item_id,
            "feedback_type": feedback_type,  # like, dislike, not_interested, report
            "feedback_data": feedback_data,
            "timestamp": "2025-06-29T00:00:00Z"
        }
        # In a real implementation, this would:
        # 1. Store the feedback in the database
        # 2. Update user preference embeddings
        # 3. Improve future feed curation
        # 4. Potentially remove or de-rank similar content
        response_message = "Feedback received successfully"
        if feedback_type == "not_interested":
            response_message += ". We'll show you less content like this."
        elif feedback_type == "like":
            response_message += ". We'll show you more content like this."
        elif feedback_type == "report":
            response_message += ". Content has been flagged for review."
        return {
            "message": response_message,
            "feedback_id": f"feedback_{user_id}_{item_id}",
            "status": "processed",
            "impact": "feed_algorithm_updated"
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing feed feedback: {str(e)}"
        )
@router.get("/discovery-insights/{user_id}")
async def get_discovery_insights(
    user_id: str,
    db: AsyncSession = Depends(get_async_session)
):
    """Get insights about user's discovery patterns and preferences."""
    try:
        # This would analyze user's discovery behavior
        # For now, return mock insights
        insights = {
            "discovery_profile": {
                "exploration_tendency": "moderate",  # conservative, moderate, adventurous
                "content_depth_preference": "medium",  # shallow, medium, deep
                "novelty_preference": 0.65,  # 0-1 scale
                "expertise_seeking": 0.78
            },
            "content_preferences": {
                "visual_content": 0.85,
                "text_heavy_content": 0.45,
                "interactive_content": 0.72,
                "expert_content": 0.68,
                "community_content": 0.74
            },
            "discovery_patterns": {
                "peak_discovery_times": ["morning", "evening"],
                "session_patterns": "focused_browsing",
                "content_completion_rate": 0.67,
                "follow_through_rate": 0.52
            },
            "recommendations": [
                "Try exploring more advanced plant care techniques",
                "Engage with community questions to share your expertise",
                "Consider following seasonal plant care guides"
            ]
        }
        return insights
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting discovery insights: {str(e)}"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/nurseries.py">
"""Local nursery endpoints."""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.services.local_nursery_service import LocalNurseryService
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent
from app.schemas.nursery import (
    LocalNurseryResponse,
    LocalNurseryCreate,
    NurseryReviewResponse,
    NurseryReviewCreate,
    NurseryEventResponse,
    NurserySearchFilters
)
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
router = APIRouter()
@router.get("/nurseries", response_model=List[LocalNurseryResponse])
async def search_nurseries(
    latitude: Optional[float] = Query(None, description="User's latitude"),
    longitude: Optional[float] = Query(None, description="User's longitude"),
    radius_km: float = Query(50, ge=1, le=200, description="Search radius in kilometers"),
    business_type: Optional[str] = Query(None, description="Type of business"),
    specialties: Optional[List[str]] = Query(None, description="Plant specialties"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Search for local nurseries and garden centers."""
    filters = NurserySearchFilters(
        latitude=latitude,
        longitude=longitude,
        radius_km=radius_km,
        business_type=business_type,
        specialties=specialties
    )
    nurseries = await LocalNurseryService.search_nurseries(
        db, filters, limit, offset
    )
    return nurseries
@router.get("/nurseries/{nursery_id}", response_model=LocalNurseryResponse)
async def get_nursery(
    nursery_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get details for a specific nursery."""
    nursery = await LocalNurseryService.get_nursery_by_id(db, nursery_id)
    if not nursery:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Nursery not found"
        )
    return nursery
@router.post("/nurseries", response_model=LocalNurseryResponse)
async def create_nursery(
    nursery_data: LocalNurseryCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new nursery listing (admin only for now)."""
    # TODO: Add admin permission check
    nursery = await LocalNurseryService.create_nursery(db, nursery_data)
    return nursery
@router.get("/nurseries/{nursery_id}/reviews", response_model=List[NurseryReviewResponse])
async def get_nursery_reviews(
    nursery_id: UUID,
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get reviews for a nursery."""
    reviews = await LocalNurseryService.get_nursery_reviews(
        db, nursery_id, limit, offset
    )
    return reviews
@router.post("/nurseries/{nursery_id}/reviews", response_model=NurseryReviewResponse)
async def create_nursery_review(
    nursery_id: UUID,
    review_data: NurseryReviewCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a review for a nursery."""
    # Check if nursery exists
    nursery = await LocalNurseryService.get_nursery_by_id(db, nursery_id)
    if not nursery:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Nursery not found"
        )
    review = await LocalNurseryService.create_review(
        db, nursery_id, current_user.id, review_data
    )
    return review
@router.get("/nurseries/{nursery_id}/events", response_model=List[NurseryEventResponse])
async def get_nursery_events(
    nursery_id: UUID,
    upcoming_only: bool = Query(True, description="Show only upcoming events"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get events for a nursery."""
    events = await LocalNurseryService.get_nursery_events(
        db, nursery_id, upcoming_only, limit, offset
    )
    return events
@router.post("/nurseries/{nursery_id}/favorite")
async def toggle_favorite_nursery(
    nursery_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Add or remove nursery from user's favorites."""
    is_favorite = await LocalNurseryService.toggle_favorite(
        db, current_user.id, nursery_id
    )
    return {"is_favorite": is_favorite}
@router.get("/favorites", response_model=List[LocalNurseryResponse])
async def get_favorite_nurseries(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's favorite nurseries."""
    favorites = await LocalNurseryService.get_user_favorites(db, current_user.id)
    return favorites
@router.get("/events/nearby", response_model=List[NurseryEventResponse])
async def get_nearby_events(
    latitude: Optional[float] = Query(None, description="User's latitude"),
    longitude: Optional[float] = Query(None, description="User's longitude"),
    radius_km: float = Query(50, ge=1, le=200),
    event_type: Optional[str] = Query(None, description="Type of event"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_db)
):
    """Get nearby nursery events."""
    events = await LocalNurseryService.get_nearby_events(
        db, latitude, longitude, radius_km, event_type, limit, offset
    )
    return events
</file>

<file path="backend/app/api/api_v1/endpoints/smart_community.py">
"""Smart community matching API endpoints."""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_async_session
from app.services.smart_community_service import SmartCommunityService, UserMatch, ExpertRecommendation
from app.services.vector_database_service import VectorDatabaseService
from app.services.embedding_service import EmbeddingService
router = APIRouter()
# Initialize services
embedding_service = EmbeddingService()
vector_service = VectorDatabaseService(embedding_service)
community_service = SmartCommunityService(vector_service)
@router.get("/users/{user_id}/similar", response_model=List[UserMatch])
async def find_similar_users(
    user_id: str,
    limit: int = Query(10, ge=1, le=50),
    db: AsyncSession = Depends(get_async_session)
):
    """Find users with similar plant interests and experience levels."""
    try:
        similar_users = await community_service.find_similar_users(
            db=db,
            user_id=user_id,
            limit=limit
        )
        return similar_users
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error finding similar users: {str(e)}"
        )
@router.get("/experts/plant-species/{plant_species_id}", response_model=List[ExpertRecommendation])
async def recommend_plant_experts(
    plant_species_id: str,
    limit: int = Query(5, ge=1, le=20),
    db: AsyncSession = Depends(get_async_session)
):
    """Recommend expert users for specific plant species questions."""
    try:
        experts = await community_service.recommend_plant_experts(
            db=db,
            plant_species_id=plant_species_id,
            limit=limit
        )
        return experts
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error recommending plant experts: {str(e)}"
        )
@router.get("/users/{user_id}/trading-matches")
async def find_trading_matches(
    user_id: str,
    limit: int = Query(10, ge=1, le=30),
    db: AsyncSession = Depends(get_async_session)
):
    """Find compatible users for plant trading."""
    try:
        trading_matches = await community_service.find_trading_matches(
            db=db,
            user_id=user_id,
            limit=limit
        )
        return trading_matches
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error finding trading matches: {str(e)}"
        )
@router.get("/users/{user_id}/local-community", response_model=List[UserMatch])
async def discover_local_community(
    user_id: str,
    radius_miles: int = Query(25, ge=1, le=100),
    limit: int = Query(15, ge=1, le=50),
    db: AsyncSession = Depends(get_async_session)
):
    """Discover local plant community members."""
    try:
        local_community = await community_service.discover_local_community(
            db=db,
            user_id=user_id,
            limit=limit
        )
        return local_community
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error discovering local community: {str(e)}"
        )
@router.get("/community-stats/{user_id}")
async def get_community_stats(
    user_id: str,
    db: AsyncSession = Depends(get_async_session)
):
    """Get community statistics for a user."""
    try:
        # Get various community metrics
        similar_users = await community_service.find_similar_users(
            db=db,
            user_id=user_id,
            limit=50
        )
        local_community = await community_service.discover_local_community(
            db=db,
            user_id=user_id,
            limit=50
        )
        trading_matches = await community_service.find_trading_matches(
            db=db,
            user_id=user_id,
            limit=50
        )
        stats = {
            "similar_users_count": len(similar_users),
            "local_community_count": len(local_community),
            "trading_matches_count": len(trading_matches),
            "top_shared_interests": [],
            "expertise_areas": []
        }
        # Calculate top shared interests
        interest_counts = {}
        for user in similar_users:
            for interest in user.shared_interests:
                interest_counts[interest] = interest_counts.get(interest, 0) + 1
        stats["top_shared_interests"] = sorted(
            interest_counts.items(),
            key=lambda x: x[1],
            reverse=True
        )[:5]
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting community stats: {str(e)}"
        )
</file>

<file path="backend/app/models/local_nursery.py">
"""Local nursery database model.
This module defines models for local nurseries and garden centers.
"""
from datetime import datetime, time
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, Float, JSON, Time, Integer, ForeignKey
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class LocalNursery(Base):
    """Local nursery model for garden centers and plant shops."""
    __tablename__ = "local_nurseries"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    name = Column(String(200), nullable=False)
    description = Column(Text)
    # Location information
    address = Column(String(500))
    city = Column(String(100))
    state = Column(String(50))
    country = Column(String(50))
    postal_code = Column(String(20))
    latitude = Column(Float)
    longitude = Column(Float)
    # Contact information
    phone = Column(String(20))
    email = Column(String(100))
    website = Column(String(200))
    # Business information
    business_type = Column(String(50))  # nursery, garden_center, plant_shop, greenhouse
    specialties = Column(JSON)  # List of specialties like ["houseplants", "succulents", "native_plants"]
    services = Column(JSON)  # List of services like ["delivery", "consultation", "repotting"]
    # Operating hours (JSON format for flexibility)
    operating_hours = Column(JSON)  # {"monday": {"open": "08:00", "close": "18:00"}, ...}
    # Ratings and verification
    average_rating = Column(Float, default=0.0)
    total_reviews = Column(Integer, default=0)
    is_verified = Column(Boolean, default=False)
    verified_at = Column(DateTime)
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    reviews = relationship("NurseryReview", back_populates="nursery")
    events = relationship("NurseryEvent", back_populates="nursery")
    def __repr__(self) -> str:
        return f"<LocalNursery(id={self.id}, name='{self.name}', city='{self.city}')>"
class NurseryReview(Base):
    """Nursery review model for user feedback."""
    __tablename__ = "nursery_reviews"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    rating = Column(Integer, nullable=False)  # 1-5 stars
    title = Column(String(200))
    review_text = Column(Text)
    # Review categories
    plant_quality_rating = Column(Integer)  # 1-5
    service_rating = Column(Integer)  # 1-5
    price_rating = Column(Integer)  # 1-5
    selection_rating = Column(Integer)  # 1-5
    # Tags for categorization
    tags = Column(JSON)  # ["helpful_staff", "good_prices", "wide_selection"]
    # Verification
    is_verified_purchase = Column(Boolean, default=False)
    visit_date = Column(DateTime)
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    nursery = relationship("LocalNursery", back_populates="reviews")
    user = relationship("User", back_populates="nursery_reviews")
    def __repr__(self) -> str:
        return f"<NurseryReview(id={self.id}, nursery_id={self.nursery_id}, rating={self.rating})>"
class NurseryEvent(Base):
    """Nursery event model for workshops and special events."""
    __tablename__ = "nursery_events"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    event_type = Column(String(50))  # workshop, sale, plant_swap, consultation
    # Scheduling
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime)
    start_time = Column(Time)
    end_time = Column(Time)
    is_recurring = Column(Boolean, default=False)
    recurrence_pattern = Column(JSON)  # For recurring events
    # Event details
    max_participants = Column(Integer)
    current_participants = Column(Integer, default=0)
    price = Column(Float, default=0.0)
    skill_level = Column(String(20))  # beginner, intermediate, advanced, all
    # Requirements and materials
    requirements = Column(Text)  # What participants should bring
    materials_provided = Column(Text)  # What the nursery provides
    # Registration
    requires_registration = Column(Boolean, default=True)
    registration_deadline = Column(DateTime)
    contact_info = Column(String(200))
    # Status
    is_active = Column(Boolean, default=True)
    is_cancelled = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    nursery = relationship("LocalNursery", back_populates="events")
    def __repr__(self) -> str:
        return f"<NurseryEvent(id={self.id}, title='{self.title}', start_date={self.start_date})>"
class UserNurseryFavorite(Base):
    """User favorite nurseries model."""
    __tablename__ = "user_nursery_favorites"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    nursery_id = Column(PostgresUUID(as_uuid=True), ForeignKey("local_nurseries.id"), nullable=False)
    notes = Column(Text)  # Personal notes about the nursery
    last_visited = Column(DateTime)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="favorite_nurseries")
    nursery = relationship("LocalNursery")
    def __repr__(self) -> str:
        return f"<UserNurseryFavorite(id={self.id}, user_id={self.user_id}, nursery_id={self.nursery_id})>"
</file>

<file path="backend/app/models/plant_achievement.py">
"""Plant achievement database model.
This module defines models for tracking user achievements and milestones
in their plant care journey.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, ForeignKey, Integer, JSON
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantAchievement(Base):
    """Plant achievement model for tracking user milestones."""
    __tablename__ = "plant_achievements"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    achievement_type = Column(String(50), nullable=False)  # care_streak, plant_collection, identification, etc.
    title = Column(String(100), nullable=False)
    description = Column(Text)
    icon = Column(String(50))  # emoji or icon name
    badge_color = Column(String(20), default="green")
    points = Column(Integer, default=0)
    unlock_criteria = Column(JSON)  # JSON criteria for unlocking
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user_achievements = relationship("UserAchievement", back_populates="achievement")
    def __repr__(self) -> str:
        return f"<PlantAchievement(id={self.id}, title='{self.title}', type='{self.achievement_type}')>"
class UserAchievement(Base):
    """User achievement model for tracking earned achievements."""
    __tablename__ = "user_achievements"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    achievement_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_achievements.id"), nullable=False)
    earned_at = Column(DateTime, default=datetime.utcnow)
    progress_data = Column(JSON)  # JSON data for tracking progress
    is_featured = Column(Boolean, default=False)  # Whether to feature on profile
    # Relationships
    user = relationship("User", back_populates="achievements")
    achievement = relationship("PlantAchievement", back_populates="user_achievements")
    def __repr__(self) -> str:
        return f"<UserAchievement(id={self.id}, user_id={self.user_id}, achievement_id={self.achievement_id})>"
class PlantMilestone(Base):
    """Plant milestone model for tracking plant-specific achievements."""
    __tablename__ = "plant_milestones"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    milestone_type = Column(String(50), nullable=False)  # first_flower, one_year_old, propagated, etc.
    title = Column(String(100), nullable=False)
    description = Column(Text)
    achieved_at = Column(DateTime, default=datetime.utcnow)
    photo_url = Column(String(500))  # Optional photo of the milestone
    notes = Column(Text)
    # Relationships
    plant = relationship("UserPlant", back_populates="milestones")
    def __repr__(self) -> str:
        return f"<PlantMilestone(id={self.id}, plant_id={self.plant_id}, type='{self.milestone_type}')>"
class UserStats(Base):
    """User statistics model for tracking overall plant care stats."""
    __tablename__ = "user_stats"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, unique=True)
    # Plant collection stats
    total_plants = Column(Integer, default=0)
    active_plants = Column(Integer, default=0)
    plants_identified = Column(Integer, default=0)
    # Care activity stats
    total_care_logs = Column(Integer, default=0)
    care_streak_days = Column(Integer, default=0)
    longest_care_streak = Column(Integer, default=0)
    last_care_activity = Column(DateTime)
    # Community stats
    questions_asked = Column(Integer, default=0)
    questions_answered = Column(Integer, default=0)
    helpful_answers = Column(Integer, default=0)
    trades_completed = Column(Integer, default=0)
    # Achievement stats
    total_achievements = Column(Integer, default=0)
    total_points = Column(Integer, default=0)
    level = Column(Integer, default=1)
    # Timestamps
    last_updated = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="stats")
    def __repr__(self) -> str:
        return f"<UserStats(id={self.id}, user_id={self.user_id}, level={self.level})>"
</file>

<file path="backend/app/models/rag_models.py">
"""RAG-specific database models for embeddings and interactions."""
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from sqlalchemy import Column, String, Text, DateTime, Integer, ForeignKey, DECIMAL, Index
from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector
from app.core.database import Base
class PlantContentEmbedding(Base):
    """Vector embeddings for plant-related content."""
    __tablename__ = "plant_content_embeddings"
    id = Column(PGUUID, primary_key=True, default=uuid4)
    content_type = Column(String(50), nullable=False)  # species_info, care_guide, user_post, qa_answer
    content_id = Column(PGUUID, nullable=False)  # References to specific content
    embedding = Column(Vector(1536), nullable=False)  # OpenAI embedding dimension
    meta_data = Column(JSONB, nullable=True)  # Additional context (species, difficulty, season, etc.)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Index for vector similarity search
    __table_args__ = (
        Index('ix_plant_content_embeddings_vector', 'embedding', postgresql_using='ivfflat', 
              postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'}),
        Index('ix_plant_content_embeddings_type', 'content_type'),
        Index('ix_plant_content_embeddings_content_id', 'content_id'),
    )
class UserPreferenceEmbedding(Base):
    """User preference embeddings for personalization."""
    __tablename__ = "user_preference_embeddings"
    id = Column(PGUUID, primary_key=True, default=uuid4)
    user_id = Column(PGUUID, ForeignKey("users.id"), nullable=False)
    preference_type = Column(String(50), nullable=False)  # plant_interests, care_style, content_preferences
    embedding = Column(Vector(1536), nullable=False)
    confidence_score = Column(DECIMAL(3, 2), nullable=True)
    meta_data = Column(JSONB, nullable=True)  # Additional preference context
    last_updated = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="preference_embeddings")
    # Index for vector similarity search
    __table_args__ = (
        Index('ix_user_preference_embeddings_vector', 'embedding', postgresql_using='ivfflat', 
              postgresql_with={'lists': 100}, postgresql_ops={'embedding': 'vector_cosine_ops'}),
        Index('ix_user_preference_embeddings_user', 'user_id'),
        Index('ix_user_preference_embeddings_type', 'preference_type'),
    )
class RAGInteraction(Base):
    """Log of RAG interactions for analytics and improvement."""
    __tablename__ = "rag_interactions"
    id = Column(PGUUID, primary_key=True, default=uuid4)
    user_id = Column(PGUUID, ForeignKey("users.id"), nullable=False)
    interaction_type = Column(String(50), nullable=False)  # care_advice, content_generation, recommendation
    query_text = Column(Text, nullable=True)
    query_embedding = Column(Vector(1536), nullable=True)
    retrieved_documents = Column(JSONB, nullable=True)  # Retrieved document metadata
    generated_response = Column(Text, nullable=True)
    user_feedback = Column(Integer, nullable=True)  # 1-5 rating
    response_time_ms = Column(Integer, nullable=True)
    confidence_score = Column(DECIMAL(3, 2), nullable=True)
    meta_data = Column(JSONB, nullable=True)  # Additional interaction context
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="rag_interactions")
    # Index for vector similarity search and analytics
    __table_args__ = (
        Index('ix_rag_interactions_vector', 'query_embedding', postgresql_using='ivfflat', 
              postgresql_with={'lists': 100}, postgresql_ops={'query_embedding': 'vector_cosine_ops'}),
        Index('ix_rag_interactions_user', 'user_id'),
        Index('ix_rag_interactions_type', 'interaction_type'),
        Index('ix_rag_interactions_created', 'created_at'),
    )
class PlantKnowledgeBase(Base):
    """Structured plant knowledge for RAG retrieval."""
    __tablename__ = "plant_knowledge_base"
    id = Column(PGUUID, primary_key=True, default=uuid4)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    content_type = Column(String(50), nullable=False)  # care_guide, species_info, technique, problem_solution
    plant_species_id = Column(PGUUID, ForeignKey("plant_species.id"), nullable=True)
    difficulty_level = Column(String(20), nullable=True)  # beginner, intermediate, advanced
    season = Column(String(20), nullable=True)  # spring, summer, fall, winter, year_round
    climate_zones = Column(JSONB, nullable=True)  # List of applicable climate zones
    tags = Column(JSONB, nullable=True)  # Searchable tags
    source = Column(String(100), nullable=True)  # expert, research, community
    author_id = Column(PGUUID, ForeignKey("users.id"), nullable=True)
    verified = Column(String(20), default='pending')  # pending, verified, rejected
    view_count = Column(Integer, default=0)
    helpful_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    plant_species = relationship("PlantSpecies", back_populates="knowledge_base_entries")
    author = relationship("User", back_populates="knowledge_contributions")
    embedding = relationship("PlantContentEmbedding", 
                           primaryjoin="PlantKnowledgeBase.id == foreign(PlantContentEmbedding.content_id)",
                           uselist=False)
    __table_args__ = (
        Index('ix_plant_knowledge_base_species', 'plant_species_id'),
        Index('ix_plant_knowledge_base_type', 'content_type'),
        Index('ix_plant_knowledge_base_difficulty', 'difficulty_level'),
        Index('ix_plant_knowledge_base_verified', 'verified'),
    )
class SemanticSearchCache(Base):
    """Cache for semantic search results to improve performance."""
    __tablename__ = "semantic_search_cache"
    id = Column(PGUUID, primary_key=True, default=uuid4)
    query_hash = Column(String(64), nullable=False, unique=True)  # SHA-256 of query + filters
    query_embedding = Column(Vector(1536), nullable=False)
    results = Column(JSONB, nullable=False)  # Cached search results
    filters_hash = Column(String(64), nullable=True)  # Hash of applied filters
    hit_count = Column(Integer, default=0)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_accessed = Column(DateTime, default=datetime.utcnow)
    __table_args__ = (
        Index('ix_semantic_search_cache_query_hash', 'query_hash'),
        Index('ix_semantic_search_cache_expires', 'expires_at'),
    )
</file>

<file path="backend/app/schemas/achievement.py">
"""Achievement schemas."""
from datetime import datetime
from typing import Optional, Dict, Any, List
from uuid import UUID
from pydantic import BaseModel, Field
class PlantAchievementBase(BaseModel):
    """Base schema for plant achievements."""
    achievement_type: str = Field(..., max_length=50)
    title: str = Field(..., max_length=100)
    description: Optional[str] = None
    icon: Optional[str] = Field(None, max_length=50)
    badge_color: str = Field(default="green", max_length=20)
    points: int = Field(default=0, ge=0)
    unlock_criteria: Optional[Dict[str, Any]] = None
class PlantAchievementResponse(PlantAchievementBase):
    """Achievement response schema."""
    id: UUID
    is_active: bool
    created_at: datetime
    class Config:
        from_attributes = True
class UserAchievementResponse(BaseModel):
    """User achievement response schema."""
    id: UUID
    user_id: UUID
    achievement_id: UUID
    earned_at: datetime
    progress_data: Optional[Dict[str, Any]] = None
    is_featured: bool
    achievement: PlantAchievementResponse
    class Config:
        from_attributes = True
class PlantMilestoneBase(BaseModel):
    """Base schema for plant milestones."""
    milestone_type: str = Field(..., max_length=50)
    title: str = Field(..., max_length=100)
    description: Optional[str] = None
    photo_url: Optional[str] = Field(None, max_length=500)
    notes: Optional[str] = None
class PlantMilestoneCreate(PlantMilestoneBase):
    """Schema for creating plant milestones."""
    pass
class PlantMilestoneResponse(PlantMilestoneBase):
    """Plant milestone response schema."""
    id: UUID
    plant_id: UUID
    achieved_at: datetime
    class Config:
        from_attributes = True
class UserStatsResponse(BaseModel):
    """User statistics response schema."""
    id: UUID
    user_id: UUID
    # Plant collection stats
    total_plants: int
    active_plants: int
    plants_identified: int
    # Care activity stats
    total_care_logs: int
    care_streak_days: int
    longest_care_streak: int
    last_care_activity: Optional[datetime]
    # Community stats
    questions_asked: int
    questions_answered: int
    helpful_answers: int
    trades_completed: int
    # Achievement stats
    total_achievements: int
    total_points: int
    level: int
    # Timestamps
    last_updated: datetime
    created_at: datetime
    class Config:
        from_attributes = True
class AchievementProgress(BaseModel):
    """Schema for tracking achievement progress."""
    achievement_id: UUID
    current_progress: Dict[str, Any]
    completion_percentage: float = Field(..., ge=0.0, le=100.0)
    is_completed: bool = False
class LeaderboardEntry(BaseModel):
    """Schema for leaderboard entries."""
    user_id: UUID
    username: str
    display_name: Optional[str]
    profile_picture_url: Optional[str]
    total_points: int
    level: int
    rank: int
</file>

<file path="backend/app/schemas/nursery.py">
"""Nursery schemas."""
from datetime import datetime, time
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field
class LocalNurseryBase(BaseModel):
    """Base schema for local nurseries."""
    name: str = Field(..., max_length=200)
    description: Optional[str] = None
    address: Optional[str] = Field(None, max_length=500)
    city: Optional[str] = Field(None, max_length=100)
    state: Optional[str] = Field(None, max_length=50)
    country: Optional[str] = Field(None, max_length=50)
    postal_code: Optional[str] = Field(None, max_length=20)
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    phone: Optional[str] = Field(None, max_length=20)
    email: Optional[str] = Field(None, max_length=100)
    website: Optional[str] = Field(None, max_length=200)
    business_type: Optional[str] = Field(None, max_length=50)
    specialties: Optional[List[str]] = None
    services: Optional[List[str]] = None
    operating_hours: Optional[Dict[str, Any]] = None
class LocalNurseryCreate(LocalNurseryBase):
    """Schema for creating local nurseries."""
    pass
class LocalNurseryResponse(LocalNurseryBase):
    """Local nursery response schema."""
    id: UUID
    average_rating: float
    total_reviews: int
    is_verified: bool
    verified_at: Optional[datetime]
    is_active: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurseryReviewBase(BaseModel):
    """Base schema for nursery reviews."""
    rating: int = Field(..., ge=1, le=5)
    title: Optional[str] = Field(None, max_length=200)
    review_text: Optional[str] = None
    plant_quality_rating: Optional[int] = Field(None, ge=1, le=5)
    service_rating: Optional[int] = Field(None, ge=1, le=5)
    price_rating: Optional[int] = Field(None, ge=1, le=5)
    selection_rating: Optional[int] = Field(None, ge=1, le=5)
    tags: Optional[List[str]] = None
    is_verified_purchase: bool = False
    visit_date: Optional[datetime] = None
class NurseryReviewCreate(NurseryReviewBase):
    """Schema for creating nursery reviews."""
    pass
class NurseryReviewResponse(NurseryReviewBase):
    """Nursery review response schema."""
    id: UUID
    nursery_id: UUID
    user_id: UUID
    is_active: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurseryEventBase(BaseModel):
    """Base schema for nursery events."""
    title: str = Field(..., max_length=200)
    description: Optional[str] = None
    event_type: Optional[str] = Field(None, max_length=50)
    start_date: datetime
    end_date: Optional[datetime] = None
    start_time: Optional[time] = None
    end_time: Optional[time] = None
    max_participants: Optional[int] = None
    current_participants: int = 0
    price: float = 0.0
    skill_level: Optional[str] = Field(None, max_length=20)
    requirements: Optional[str] = None
    materials_provided: Optional[str] = None
    requires_registration: bool = True
    registration_deadline: Optional[datetime] = None
    contact_info: Optional[str] = Field(None, max_length=200)
class NurseryEventResponse(NurseryEventBase):
    """Nursery event response schema."""
    id: UUID
    nursery_id: UUID
    is_recurring: bool
    recurrence_pattern: Optional[Dict[str, Any]]
    is_active: bool
    is_cancelled: bool
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class NurserySearchFilters(BaseModel):
    """Schema for nursery search filters."""
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    radius_km: float = 50
    business_type: Optional[str] = None
    specialties: Optional[List[str]] = None
class UserNurseryFavoriteResponse(BaseModel):
    """User nursery favorite response schema."""
    id: UUID
    user_id: UUID
    nursery_id: UUID
    notes: Optional[str] = None
    last_visited: Optional[datetime] = None
    created_at: datetime
    nursery: LocalNurseryResponse
    class Config:
        from_attributes = True
</file>

<file path="backend/app/services/content_generation_service.py">
"""Intelligent content generation service for personalized plant content."""
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
import json
import re
from openai import AsyncOpenAI
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, desc, func
from sqlalchemy.orm import selectinload
from app.core.config import settings
from app.models.user import User
from app.models.user_plant import UserPlant
from app.models.plant_species import PlantSpecies
from app.models.story import Story
from app.models.rag_models import PlantKnowledgeBase, UserPreferenceEmbedding
from app.services.rag_service import RAGService, UserContext
from app.services.embedding_service import EmbeddingService
from app.services.vector_database_service import VectorDatabaseService
logger = logging.getLogger(__name__)
@dataclass
class ContentGenerationContext:
    """Context for content generation."""
    user_id: str
    content_type: str  # caption, tip, story_suggestion, plant_description
    plant_context: Optional[Dict[str, Any]] = None
    image_context: Optional[Dict[str, Any]] = None
    seasonal_context: Optional[Dict[str, Any]] = None
    user_preferences: Optional[Dict[str, Any]] = None
@dataclass
class GeneratedContent:
    """Generated content with metadata."""
    content: str
    content_type: str
    confidence: float
    tags: List[str]
    engagement_score: float  # predicted engagement potential
    personalization_factors: List[str]
    suggested_hashtags: List[str]
class ContentGenerationService:
    """Service for AI-powered content generation and personalization."""
    def __init__(self, rag_service: RAGService, embedding_service: EmbeddingService, vector_service: VectorDatabaseService):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.rag_service = rag_service
        self.embedding_service = embedding_service
        self.vector_service = vector_service
    async def generate_plant_caption(
        self,
        db: AsyncSession,
        user_id: str,
        image_context: Dict[str, Any],
        plant_id: Optional[str] = None
    ) -> GeneratedContent:
        """Generate personalized caption for plant photo.
        Args:
            db: Database session
            user_id: User ID
            image_context: Context about the image (plant type, setting, etc.)
            plant_id: Optional specific plant ID
        Returns:
            GeneratedContent with personalized caption
        """
        try:
            # Get user context and preferences
            user_context = await self._build_user_context(db, user_id)
            # Get plant context if plant_id provided
            plant_context = None
            if plant_id:
                plant_context = await self._get_plant_context(db, plant_id)
            # Get seasonal context
            seasonal_context = self._get_seasonal_context()
            # Build generation context
            context = ContentGenerationContext(
                user_id=user_id,
                content_type="caption",
                plant_context=plant_context,
                image_context=image_context,
                seasonal_context=seasonal_context,
                user_preferences=user_context.get("preferences", {})
            )
            # Generate caption using RAG
            caption = await self._generate_caption_with_rag(db, context)
            # Enhance with hashtags and engagement optimization
            enhanced_caption = await self._enhance_caption(db, caption, context)
            # Calculate confidence and engagement score
            confidence = self._calculate_content_confidence(enhanced_caption, context)
            engagement_score = self._predict_engagement_score(enhanced_caption, context)
            # Extract personalization factors
            personalization_factors = self._extract_personalization_factors(context)
            # Generate hashtags
            hashtags = self._generate_hashtags(enhanced_caption, context)
            result = GeneratedContent(
                content=enhanced_caption,
                content_type="caption",
                confidence=confidence,
                tags=self._extract_content_tags(enhanced_caption),
                engagement_score=engagement_score,
                personalization_factors=personalization_factors,
                suggested_hashtags=hashtags
            )
            # Log generation for learning
            await self._log_content_generation(db, user_id, context, result)
            logger.info(f"Generated plant caption for user {user_id}")
            return result
        except Exception as e:
            logger.error(f"Error generating plant caption: {str(e)}")
            # Return fallback caption
            return GeneratedContent(
                content="Beautiful plant moment  #PlantParent #GreenThumb",
                content_type="caption",
                confidence=0.3,
                tags=["fallback"],
                engagement_score=0.5,
                personalization_factors=[],
                suggested_hashtags=["#PlantParent", "#GreenThumb"]
            )
    async def generate_personalized_plant_tip(
        self,
        db: AsyncSession,
        user_id: str,
        plant_id: Optional[str] = None,
        topic: Optional[str] = None
    ) -> GeneratedContent:
        """Generate personalized plant care tip.
        Args:
            db: Database session
            user_id: User ID
            plant_id: Optional specific plant ID
            topic: Optional specific topic (watering, fertilizing, etc.)
        Returns:
            GeneratedContent with personalized tip
        """
        try:
            # Get user context
            user_context = await self._build_user_context(db, user_id)
            # Get plant context if specified
            plant_context = None
            if plant_id:
                plant_context = await self._get_plant_context(db, plant_id)
            # Build generation context
            context = ContentGenerationContext(
                user_id=user_id,
                content_type="plant_tip",
                plant_context=plant_context,
                seasonal_context=self._get_seasonal_context(),
                user_preferences=user_context.get("preferences", {})
            )
            # Search for relevant plant knowledge
            search_query = self._build_tip_search_query(context, topic)
            relevant_knowledge = await self.vector_service.search_plant_knowledge(
                db=db,
                query=search_query,
                plant_species_id=plant_context.get("species_id") if plant_context else None,
                difficulty_level=user_context.get("experience_level"),
                limit=3
            )
            # Generate tip using LLM
            tip = await self._generate_tip_with_llm(context, relevant_knowledge, topic)
            # Calculate metrics
            confidence = self._calculate_content_confidence(tip, context)
            engagement_score = self._predict_engagement_score(tip, context)
            result = GeneratedContent(
                content=tip,
                content_type="plant_tip",
                confidence=confidence,
                tags=self._extract_content_tags(tip),
                engagement_score=engagement_score,
                personalization_factors=self._extract_personalization_factors(context),
                suggested_hashtags=self._generate_hashtags(tip, context)
            )
            await self._log_content_generation(db, user_id, context, result)
            logger.info(f"Generated personalized plant tip for user {user_id}")
            return result
        except Exception as e:
            logger.error(f"Error generating plant tip: {str(e)}")
            return GeneratedContent(
                content="Remember to check your plants regularly and adjust care based on the season!",
                content_type="plant_tip",
                confidence=0.3,
                tags=["fallback"],
                engagement_score=0.5,
                personalization_factors=[],
                suggested_hashtags=["#PlantCare"]
            )
    async def generate_story_suggestions(
        self,
        db: AsyncSession,
        user_id: str,
        limit: int = 5
    ) -> List[GeneratedContent]:
        """Generate personalized story content suggestions.
        Args:
            db: Database session
            user_id: User ID
            limit: Number of suggestions to generate
        Returns:
            List of GeneratedContent with story suggestions
        """
        try:
            # Get user context and plant collection
            user_context = await self._build_user_context(db, user_id)
            user_plants = await self._get_user_plants(db, user_id)
            # Get trending topics in plant community
            trending_topics = await self._get_trending_topics(db)
            suggestions = []
            # Generate different types of story suggestions
            suggestion_types = [
                "plant_progress",
                "care_routine",
                "seasonal_tips",
                "plant_personality",
                "care_challenges"
            ]
            for suggestion_type in suggestion_types[:limit]:
                context = ContentGenerationContext(
                    user_id=user_id,
                    content_type="story_suggestion",
                    plant_context={"plants": user_plants},
                    seasonal_context=self._get_seasonal_context(),
                    user_preferences=user_context.get("preferences", {})
                )
                suggestion = await self._generate_story_suggestion(
                    db, context, suggestion_type, trending_topics
                )
                if suggestion:
                    suggestions.append(suggestion)
            logger.info(f"Generated {len(suggestions)} story suggestions for user {user_id}")
            return suggestions
        except Exception as e:
            logger.error(f"Error generating story suggestions: {str(e)}")
            return []
    async def generate_plant_description(
        self,
        db: AsyncSession,
        user_id: str,
        plant_species_id: str,
        context_type: str = "identification"  # identification, care_guide, social_post
    ) -> GeneratedContent:
        """Generate context-aware plant description.
        Args:
            db: Database session
            user_id: User ID
            plant_species_id: Plant species ID
            context_type: Context for the description
        Returns:
            GeneratedContent with plant description
        """
        try:
            # Get plant species information
            stmt = select(PlantSpecies).where(PlantSpecies.id == plant_species_id)
            result = await db.execute(stmt)
            species = result.scalar_one_or_none()
            if not species:
                raise ValueError(f"Plant species {plant_species_id} not found")
            # Get user context
            user_context = await self._build_user_context(db, user_id)
            # Search for relevant plant knowledge
            relevant_knowledge = await self.vector_service.search_plant_knowledge(
                db=db,
                query=f"{species.scientific_name} characteristics care information",
                plant_species_id=plant_species_id,
                content_types=["species_info", "care_guide"],
                limit=3
            )
            # Build context
            context = ContentGenerationContext(
                user_id=user_id,
                content_type="plant_description",
                plant_context={
                    "species": species,
                    "context_type": context_type
                },
                user_preferences=user_context.get("preferences", {})
            )
            # Generate description
            description = await self._generate_plant_description_with_llm(
                context, relevant_knowledge, context_type
            )
            result = GeneratedContent(
                content=description,
                content_type="plant_description",
                confidence=self._calculate_content_confidence(description, context),
                tags=self._extract_content_tags(description),
                engagement_score=self._predict_engagement_score(description, context),
                personalization_factors=self._extract_personalization_factors(context),
                suggested_hashtags=self._generate_hashtags(description, context)
            )
            await self._log_content_generation(db, user_id, context, result)
            logger.info(f"Generated plant description for species {plant_species_id}")
            return result
        except Exception as e:
            logger.error(f"Error generating plant description: {str(e)}")
            raise
    async def _build_user_context(self, db: AsyncSession, user_id: str) -> Dict[str, Any]:
        """Build comprehensive user context for content generation."""
        try:
            # Get user information
            stmt = select(User).where(User.id == user_id)
            result = await db.execute(stmt)
            user = result.scalar_one_or_none()
            if not user:
                return {"experience_level": "beginner", "preferences": {}}
            # Get user preferences
            prefs_stmt = select(UserPreferenceEmbedding).where(
                UserPreferenceEmbedding.user_id == user_id
            )
            prefs_result = await db.execute(prefs_stmt)
            preferences = prefs_result.scalars().all()
            # Combine preferences
            combined_preferences = {}
            for pref in preferences:
                if pref.meta_data:
                    combined_preferences.update(pref.meta_data)
            return {
                "user": user,
                "experience_level": user.gardening_experience or "beginner",
                "location": user.location,
                "preferences": combined_preferences
            }
        except Exception as e:
            logger.error(f"Error building user context: {str(e)}")
            return {"experience_level": "beginner", "preferences": {}}
    async def _get_plant_context(self, db: AsyncSession, plant_id: str) -> Dict[str, Any]:
        """Get context for a specific plant."""
        try:
            stmt = select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(UserPlant.id == plant_id)
            result = await db.execute(stmt)
            plant = result.scalar_one_or_none()
            if not plant:
                return {}
            return {
                "plant": plant,
                "species_id": str(plant.species.id),
                "species_name": plant.species.scientific_name,
                "common_names": plant.species.common_names,
                "nickname": plant.nickname,
                "health_status": plant.health_status,
                "care_level": plant.species.care_level
            }
        except Exception as e:
            logger.error(f"Error getting plant context: {str(e)}")
            return {}
    def _get_seasonal_context(self) -> Dict[str, Any]:
        """Get current seasonal context."""
        now = datetime.utcnow()
        month = now.month
        if month in [12, 1, 2]:
            season = "winter"
            season_mood = "cozy"
            plant_activity = "dormant"
        elif month in [3, 4, 5]:
            season = "spring"
            season_mood = "fresh"
            plant_activity = "growing"
        elif month in [6, 7, 8]:
            season = "summer"
            season_mood = "vibrant"
            plant_activity = "thriving"
        else:
            season = "fall"
            season_mood = "warm"
            plant_activity = "preparing"
        return {
            "season": season,
            "mood": season_mood,
            "plant_activity": plant_activity,
            "month": month
        }
    async def _generate_caption_with_rag(
        self,
        db: AsyncSession,
        context: ContentGenerationContext
    ) -> str:
        """Generate caption using RAG for relevant plant information."""
        try:
            # Build search query based on context
            search_query = "plant photo caption social media engaging"
            if context.plant_context:
                species_name = context.plant_context.get("species_name", "")
                search_query = f"{species_name} {search_query}"
            if context.image_context:
                image_type = context.image_context.get("type", "")
                search_query = f"{search_query} {image_type}"
            # Search for relevant content
            relevant_docs = await self.vector_service.similarity_search(
                db=db,
                query_embedding=await self.embedding_service.generate_text_embedding(search_query),
                content_types=["species_info", "care_guide"],
                limit=2
            )
            # Generate caption with LLM
            prompt = self._build_caption_prompt(context, relevant_docs)
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a creative social media content creator specializing in plant content. Generate engaging, authentic captions that match the user's style and experience level."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.8,
                max_tokens=200
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"Error generating caption with RAG: {str(e)}")
            return "Beautiful plant moment "
    async def _enhance_caption(
        self,
        db: AsyncSession,
        caption: str,
        context: ContentGenerationContext
    ) -> str:
        """Enhance caption with personalization and engagement optimization."""
        try:
            # Add seasonal elements
            if context.seasonal_context:
                season = context.seasonal_context.get("season")
                if season == "winter" and "winter" not in caption.lower():
                    caption += " "
                elif season == "spring" and "spring" not in caption.lower():
                    caption += " "
                elif season == "summer" and "summer" not in caption.lower():
                    caption += " "
                elif season == "fall" and "fall" not in caption.lower():
                    caption += " "
            # Add plant-specific emoji if not present
            if context.plant_context and "" not in caption and "" not in caption:
                caption += " "
            # Ensure caption ends with engaging element
            if not any(char in caption for char in ["!", "?", "", ""]):
                caption += " "
            return caption
        except Exception as e:
            logger.error(f"Error enhancing caption: {str(e)}")
            return caption
    def _build_caption_prompt(
        self,
        context: ContentGenerationContext,
        relevant_docs: List[Dict[str, Any]]
    ) -> str:
        """Build prompt for caption generation."""
        prompt_parts = ["Generate a social media caption for a plant photo."]
        # Add user context
        if context.user_preferences:
            experience = context.user_preferences.get("experience_level", "beginner")
            prompt_parts.append(f"User experience level: {experience}")
            writing_style = context.user_preferences.get("writing_style", "casual")
            prompt_parts.append(f"Writing style: {writing_style}")
        # Add plant context
        if context.plant_context:
            species = context.plant_context.get("species_name", "")
            nickname = context.plant_context.get("nickname", "")
            if species:
                prompt_parts.append(f"Plant: {species}")
            if nickname:
                prompt_parts.append(f"Plant nickname: {nickname}")
        # Add image context
        if context.image_context:
            image_type = context.image_context.get("type", "")
            if image_type:
                prompt_parts.append(f"Photo type: {image_type}")
        # Add seasonal context
        if context.seasonal_context:
            season = context.seasonal_context.get("season")
            prompt_parts.append(f"Season: {season}")
        # Add relevant plant information
        if relevant_docs:
            prompt_parts.append("Relevant plant information:")
            for doc in relevant_docs[:2]:
                content = doc.get("content", "")[:100]
                prompt_parts.append(f"- {content}...")
        prompt_parts.append("Generate an engaging, authentic caption (50-150 characters) that encourages interaction.")
        return "\n".join(prompt_parts)
    async def _generate_tip_with_llm(
        self,
        context: ContentGenerationContext,
        relevant_knowledge: List[Dict[str, Any]],
        topic: Optional[str]
    ) -> str:
        """Generate plant care tip using LLM."""
        try:
            prompt = self._build_tip_prompt(context, relevant_knowledge, topic)
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert plant care advisor. Provide practical, actionable tips that are personalized to the user's experience level and current conditions."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_tokens=300
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"Error generating tip with LLM: {str(e)}")
            return "Check your plants regularly and adjust care based on their needs!"
    def _build_tip_prompt(
        self,
        context: ContentGenerationContext,
        relevant_knowledge: List[Dict[str, Any]],
        topic: Optional[str]
    ) -> str:
        """Build prompt for tip generation."""
        prompt_parts = ["Generate a personalized plant care tip."]
        if topic:
            prompt_parts.append(f"Focus on: {topic}")
        # Add user context
        if context.user_preferences:
            experience = context.user_preferences.get("experience_level", "beginner")
            prompt_parts.append(f"User experience: {experience}")
        # Add plant context
        if context.plant_context:
            species = context.plant_context.get("species_name")
            if species:
                prompt_parts.append(f"Plant species: {species}")
        # Add seasonal context
        if context.seasonal_context:
            season = context.seasonal_context.get("season")
            prompt_parts.append(f"Current season: {season}")
        # Add relevant knowledge
        if relevant_knowledge:
            prompt_parts.append("Relevant information:")
            for knowledge in relevant_knowledge[:2]:
                content = knowledge.get("content", "")[:200]
                prompt_parts.append(f"- {content}...")
        prompt_parts.append("Provide a specific, actionable tip (1-2 sentences) that's appropriate for this user and season.")
        return "\n".join(prompt_parts)
    def _build_tip_search_query(
        self,
        context: ContentGenerationContext,
        topic: Optional[str]
    ) -> str:
        """Build search query for tip generation."""
        query_parts = ["plant care tips"]
        if topic:
            query_parts.append(topic)
        if context.plant_context:
            species = context.plant_context.get("species_name")
            if species:
                query_parts.append(species)
        if context.seasonal_context:
            season = context.seasonal_context.get("season")
            query_parts.append(f"{season} care")
        return " ".join(query_parts)
    async def _get_user_plants(self, db: AsyncSession, user_id: str) -> List[Dict[str, Any]]:
        """Get user's plant collection for context."""
        try:
            stmt = select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(UserPlant.user_id == user_id)
            result = await db.execute(stmt)
            plants = result.scalars().all()
            return [
                {
                    "id": str(plant.id),
                    "nickname": plant.nickname,
                    "species": plant.species.scientific_name,
                    "common_names": plant.species.common_names,
                    "health_status": plant.health_status
                }
                for plant in plants
            ]
        except Exception as e:
            logger.error(f"Error getting user plants: {str(e)}")
            return []
    async def _get_trending_topics(self, db: AsyncSession) -> List[str]:
        """Get trending topics in the plant community."""
        try:
            # Get recent stories and their topics
            recent_date = datetime.utcnow() - timedelta(days=7)
            stmt = select(Story).where(Story.created_at >= recent_date)
            result = await db.execute(stmt)
            stories = result.scalars().all()
            # Extract topics from story content (simplified)
            topics = ["plant care", "new growth", "propagation", "repotting", "seasonal care"]
            return topics
        except Exception as e:
            logger.error(f"Error getting trending topics: {str(e)}")
            return ["plant care", "growth progress", "seasonal tips"]
    async def _generate_story_suggestion(
        self,
        db: AsyncSession,
        context: ContentGenerationContext,
        suggestion_type: str,
        trending_topics: List[str]
    ) -> Optional[GeneratedContent]:
        """Generate a specific type of story suggestion."""
        try:
            prompts = {
                "plant_progress": "Suggest a story idea about showcasing plant growth progress",
                "care_routine": "Suggest a story idea about sharing daily plant care routine",
                "seasonal_tips": "Suggest a story idea about seasonal plant care tips",
                "plant_personality": "Suggest a story idea about plant personality and characteristics",
                "care_challenges": "Suggest a story idea about overcoming plant care challenges"
            }
            base_prompt = prompts.get(suggestion_type, "Suggest an engaging plant-related story idea")
            # Add context
            prompt_parts = [base_prompt]
            if context.plant_context and context.plant_context.get("plants"):
                plants = context.plant_context["plants"]
                if plants:
                    plant_names = [p.get("nickname") or p.get("species", "") for p in plants[:3]]
                    prompt_parts.append(f"User has plants: {', '.join(plant_names)}")
            if context.seasonal_context:
                season = context.seasonal_context.get("season")
                prompt_parts.append(f"Current season: {season}")
            prompt_parts.append("Generate a brief, engaging story suggestion (1-2 sentences).")
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a creative content strategist for plant enthusiasts. Generate engaging story ideas that encourage community interaction."
                    },
                    {
                        "role": "user",
                        "content": "\n".join(prompt_parts)
                    }
                ],
                temperature=0.9,
                max_tokens=150
            )
            suggestion = response.choices[0].message.content.strip()
            return GeneratedContent(
                content=suggestion,
                content_type="story_suggestion",
                confidence=0.8,
                tags=[suggestion_type],
                engagement_score=0.7,
                personalization_factors=["user_plants", "season"],
                suggested_hashtags=[f"#{suggestion_type.replace('_', '')}"]
            )
        except Exception as e:
            logger.error(f"Error generating story suggestion: {str(e)}")
            return None
    async def _generate_plant_description_with_llm(
        self,
        context: ContentGenerationContext,
        relevant_knowledge: List[Dict[str, Any]],
        context_type: str
    ) -> str:
        """Generate plant description using LLM."""
        try:
            species = context.plant_context["species"]
            prompt_parts = [
                f"Generate a {context_type} description for {species.scientific_name}."
            ]
            if species.common_names:
                prompt_parts.append(f"Common names: {', '.join(species.common_names)}")
            # Add context-specific requirements
            if context_type == "identification":
                prompt_parts.append("Focus on distinctive visual characteristics for identification.")
            elif context_type == "care_guide":
                prompt_parts.append("Focus on care requirements and growing conditions.")
            elif context_type == "social_post":
                prompt_parts.append("Write in an engaging, social media friendly tone.")
            # Add relevant knowledge
            if relevant_knowledge:
                prompt_parts.append("Relevant information:")
                for knowledge in relevant_knowledge:
                    content = knowledge.get("content", "")[:200]
                    prompt_parts.append(f"- {content}...")
            prompt_parts.append("Generate a clear, informative description (2-3 sentences).")
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a plant expert providing accurate, helpful plant descriptions."
                    },
                    {
                        "role": "user",
                        "content": "\n".join(prompt_parts)
                    }
                ],
                temperature=0.6,
                max_tokens=250
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"Error generating plant description: {str(e)}")
            return "This is a beautiful plant species with unique characteristics."
    def _calculate_content_confidence(
        self,
        content: str,
        context: ContentGenerationContext
    ) -> float:
        """Calculate confidence score for generated content."""
        base_confidence = 0.7
        # Boost confidence if we have good context
        if context.plant_context:
            base_confidence += 0.1
        if context.user_preferences:
            base_confidence += 0.1
        # Reduce confidence for very short content
        if len(content) < 20:
            base_confidence -= 0.2
        # Boost confidence for content with specific plant information
        if any(word in content.lower() for word in ["care", "water", "light", "soil"]):
            base_confidence += 0.1
        return min(1.0, max(0.1, base_confidence))
    def _predict_engagement_score(
        self,
        content: str,
        context: ContentGenerationContext
    ) -> float:
        """Predict engagement potential of generated content."""
        base_score = 0.5
        # Boost for engaging elements
        if any(char in content for char in ["!", "?", "", "", ""]):
            base_score += 0.2
        # Boost for questions (encourage interaction)
        if "?" in content:
            base_score += 0.1
        # Boost for seasonal relevance
        if context.seasonal_context:
            season = context.seasonal_context.get("season", "")
            if season.lower() in content.lower():
                base_score += 0.1
        # Boost for personalization
        if context.plant_context and context.plant_context.get("nickname"):
            nickname = context.plant_context["nickname"]
            if nickname and nickname.lower() in content.lower():
                base_score += 0.2
        return min(1.0, base_score)
    def _extract_personalization_factors(self, context: ContentGenerationContext) -> List[str]:
        """Extract factors that contributed to personalization."""
        factors = []
        if context.user_preferences:
            factors.append("user_preferences")
        if context.plant_context:
            factors.append("plant_specific")
        if context.seasonal_context:
            factors.append("seasonal")
        if context.image_context:
            factors.append("image_context")
        return factors
    def _extract_content_tags(self, content: str) -> List[str]:
        """Extract relevant tags from content."""
        tags = []
        # Plant-related keywords
        plant_keywords = ["water", "light", "soil", "care", "growth", "leaf", "root", "flower"]
        for keyword in plant_keywords:
            if keyword in content.lower():
                tags.append(keyword)
        # Seasonal keywords
        seasonal_keywords = ["spring", "summer", "fall", "winter", "seasonal"]
        for keyword in seasonal_keywords:
            if keyword in content.lower():
                tags.append(keyword)
        # Care keywords
        care_keywords = ["fertilize", "repot", "prune", "propagate", "humidity"]
        for keyword in care_keywords:
            if keyword in content.lower():
                tags.append(keyword)
        return list(set(tags))  # Remove duplicates
    def _generate_hashtags(
        self,
        content: str,
        context: ContentGenerationContext
    ) -> List[str]:
        """Generate relevant hashtags for content."""
        hashtags = ["#PlantParent", "#GreenThumb", "#PlantCare"]
        # Add plant-specific hashtags
        if context.plant_context:
            species_name = context.plant_context.get("species_name", "")
            if species_name:
                # Create hashtag from species name
                species_hashtag = "#" + species_name.replace(" ", "").replace(".", "")
                hashtags.append(species_hashtag)
        # Add seasonal hashtags
        if context.seasonal_context:
            season = context.seasonal_context.get("season", "")
            if season:
                hashtags.append(f"#{season.capitalize()}Plants")
        # Add content-specific hashtags
        if "tip" in context.content_type:
            hashtags.append("#PlantTips")
        elif "caption" in context.content_type:
            hashtags.append("#PlantLife")
        # Add care-specific hashtags based on content
        if "water" in content.lower():
            hashtags.append("#PlantWatering")
        if "light" in content.lower():
            hashtags.append("#PlantLight")
        if "growth" in content.lower():
            hashtags.append("#PlantGrowth")
        return hashtags[:8]  # Limit to 8 hashtags
    async def _log_content_generation(
        self,
        db: AsyncSession,
        user_id: str,
        context: ContentGenerationContext,
        result: GeneratedContent
    ) -> None:
        """Log content generation for analytics and improvement."""
        try:
            # This could be expanded to store in a dedicated table
            # For now, we'll use the RAG interaction logging
            metadata = {
                "content_type": context.content_type,
                "confidence": result.confidence,
                "engagement_score": result.engagement_score,
                "personalization_factors": result.personalization_factors,
                "hashtags": result.suggested_hashtags
            }
            # Log using RAG service
            await self.rag_service._log_rag_interaction(
                db=db,
                user_id=user_id,
                interaction_type="content_generation",
                query=f"Generate {context.content_type}",
                response=result.content[:500],  # Truncate if too long
                confidence=result.confidence
            )
        except Exception as e:
            logger.error(f"Error logging content generation: {str(e)}")
</file>

<file path="backend/app/services/embedding_service.py">
"""Embedding generation service for RAG system."""
import hashlib
import json
import logging
from typing import List, Dict, Any, Optional, Union
from datetime import datetime, timedelta
import numpy as np
from openai import AsyncOpenAI
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from app.core.config import settings
from app.models.rag_models import PlantContentEmbedding, UserPreferenceEmbedding, SemanticSearchCache
logger = logging.getLogger(__name__)
class EmbeddingService:
    """Service for generating and managing embeddings."""
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.embedding_model = "text-embedding-3-small"
        self.embedding_dimension = 1536
    async def generate_text_embedding(self, text: str) -> List[float]:
        """Generate embedding for text content.
        Args:
            text: Text to embed
        Returns:
            List of embedding values
        """
        try:
            # Clean and prepare text
            cleaned_text = self._clean_text(text)
            response = await self.client.embeddings.create(
                model=self.embedding_model,
                input=cleaned_text,
                encoding_format="float"
            )
            embedding = response.data[0].embedding
            logger.info(f"Generated embedding for text of length {len(text)}")
            return embedding
        except Exception as e:
            logger.error(f"Error generating text embedding: {str(e)}")
            raise
    async def generate_batch_embeddings(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings for multiple texts in batch.
        Args:
            texts: List of texts to embed
        Returns:
            List of embedding lists
        """
        try:
            # Clean texts
            cleaned_texts = [self._clean_text(text) for text in texts]
            response = await self.client.embeddings.create(
                model=self.embedding_model,
                input=cleaned_texts,
                encoding_format="float"
            )
            embeddings = [data.embedding for data in response.data]
            logger.info(f"Generated {len(embeddings)} embeddings in batch")
            return embeddings
        except Exception as e:
            logger.error(f"Error generating batch embeddings: {str(e)}")
            raise
    async def store_content_embedding(
        self,
        db: AsyncSession,
        content_type: str,
        content_id: str,
        text: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PlantContentEmbedding:
        """Generate and store content embedding.
        Args:
            db: Database session
            content_type: Type of content (species_info, care_guide, etc.)
            content_id: ID of the content
            text: Text content to embed
            metadata: Additional metadata
        Returns:
            Created PlantContentEmbedding instance
        """
        try:
            # Generate embedding
            embedding = await self.generate_text_embedding(text)
            # Create embedding record
            content_embedding = PlantContentEmbedding(
                content_type=content_type,
                content_id=content_id,
                embedding=embedding,
                meta_data=metadata or {}
            )
            db.add(content_embedding)
            await db.commit()
            await db.refresh(content_embedding)
            logger.info(f"Stored embedding for {content_type} content {content_id}")
            return content_embedding
        except Exception as e:
            await db.rollback()
            logger.error(f"Error storing content embedding: {str(e)}")
            raise
    async def update_user_preferences(
        self,
        db: AsyncSession,
        user_id: str,
        preference_type: str,
        preference_data: Dict[str, Any],
        confidence_score: Optional[float] = None
    ) -> UserPreferenceEmbedding:
        """Update user preference embeddings.
        Args:
            db: Database session
            user_id: User ID
            preference_type: Type of preference
            preference_data: Preference data to embed
            confidence_score: Confidence in the preference
        Returns:
            Updated UserPreferenceEmbedding instance
        """
        try:
            # Convert preference data to text for embedding
            preference_text = self._preference_to_text(preference_data)
            embedding = await self.generate_text_embedding(preference_text)
            # Check if preference embedding exists
            stmt = select(UserPreferenceEmbedding).where(
                and_(
                    UserPreferenceEmbedding.user_id == user_id,
                    UserPreferenceEmbedding.preference_type == preference_type
                )
            )
            result = await db.execute(stmt)
            existing = result.scalar_one_or_none()
            if existing:
                # Update existing
                existing.embedding = embedding
                existing.confidence_score = confidence_score
                existing.meta_data = preference_data
                existing.last_updated = datetime.utcnow()
                preference_embedding = existing
            else:
                # Create new
                preference_embedding = UserPreferenceEmbedding(
                    user_id=user_id,
                    preference_type=preference_type,
                    embedding=embedding,
                    confidence_score=confidence_score,
                    meta_data=preference_data
                )
                db.add(preference_embedding)
            await db.commit()
            await db.refresh(preference_embedding)
            logger.info(f"Updated {preference_type} preferences for user {user_id}")
            return preference_embedding
        except Exception as e:
            await db.rollback()
            logger.error(f"Error updating user preferences: {str(e)}")
            raise
    async def get_cached_search_results(
        self,
        db: AsyncSession,
        query: str,
        filters: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """Get cached semantic search results.
        Args:
            db: Database session
            query: Search query
            filters: Search filters
        Returns:
            Cached results if available
        """
        try:
            query_hash = self._generate_query_hash(query, filters)
            stmt = select(SemanticSearchCache).where(
                and_(
                    SemanticSearchCache.query_hash == query_hash,
                    SemanticSearchCache.expires_at > datetime.utcnow()
                )
            )
            result = await db.execute(stmt)
            cache_entry = result.scalar_one_or_none()
            if cache_entry:
                # Update access tracking
                cache_entry.hit_count += 1
                cache_entry.last_accessed = datetime.utcnow()
                await db.commit()
                logger.info(f"Retrieved cached search results for query hash {query_hash}")
                return cache_entry.results
            return None
        except Exception as e:
            logger.error(f"Error retrieving cached search results: {str(e)}")
            return None
    async def cache_search_results(
        self,
        db: AsyncSession,
        query: str,
        filters: Optional[Dict[str, Any]],
        results: Dict[str, Any],
        cache_duration_hours: int = 24
    ) -> None:
        """Cache semantic search results.
        Args:
            db: Database session
            query: Search query
            filters: Search filters
            results: Search results to cache
            cache_duration_hours: Cache duration in hours
        """
        try:
            query_hash = self._generate_query_hash(query, filters)
            query_embedding = await self.generate_text_embedding(query)
            cache_entry = SemanticSearchCache(
                query_hash=query_hash,
                query_embedding=query_embedding,
                results=results,
                filters_hash=self._generate_filters_hash(filters),
                expires_at=datetime.utcnow() + timedelta(hours=cache_duration_hours)
            )
            db.add(cache_entry)
            await db.commit()
            logger.info(f"Cached search results for query hash {query_hash}")
        except Exception as e:
            await db.rollback()
            logger.error(f"Error caching search results: {str(e)}")
    def calculate_similarity(self, embedding1: List[float], embedding2: List[float]) -> float:
        """Calculate cosine similarity between two embeddings.
        Args:
            embedding1: First embedding
            embedding2: Second embedding
        Returns:
            Cosine similarity score
        """
        try:
            vec1 = np.array(embedding1)
            vec2 = np.array(embedding2)
            # Calculate cosine similarity
            dot_product = np.dot(vec1, vec2)
            norm1 = np.linalg.norm(vec1)
            norm2 = np.linalg.norm(vec2)
            if norm1 == 0 or norm2 == 0:
                return 0.0
            similarity = dot_product / (norm1 * norm2)
            return float(similarity)
        except Exception as e:
            logger.error(f"Error calculating similarity: {str(e)}")
            return 0.0
    def _clean_text(self, text: str) -> str:
        """Clean text for embedding generation.
        Args:
            text: Raw text
        Returns:
            Cleaned text
        """
        if not text:
            return ""
        # Remove excessive whitespace
        cleaned = " ".join(text.split())
        # Truncate if too long (OpenAI has token limits)
        max_length = 8000  # Conservative limit
        if len(cleaned) > max_length:
            cleaned = cleaned[:max_length] + "..."
        return cleaned
    def _preference_to_text(self, preference_data: Dict[str, Any]) -> str:
        """Convert preference data to text for embedding.
        Args:
            preference_data: Preference data dictionary
        Returns:
            Text representation of preferences
        """
        text_parts = []
        for key, value in preference_data.items():
            if isinstance(value, (list, tuple)):
                text_parts.append(f"{key}: {', '.join(map(str, value))}")
            else:
                text_parts.append(f"{key}: {value}")
        return "; ".join(text_parts)
    def _generate_query_hash(self, query: str, filters: Optional[Dict[str, Any]]) -> str:
        """Generate hash for query and filters.
        Args:
            query: Search query
            filters: Search filters
        Returns:
            SHA-256 hash string
        """
        content = {
            "query": query,
            "filters": filters or {}
        }
        content_str = json.dumps(content, sort_keys=True)
        return hashlib.sha256(content_str.encode()).hexdigest()
    def _generate_filters_hash(self, filters: Optional[Dict[str, Any]]) -> Optional[str]:
        """Generate hash for filters only.
        Args:
            filters: Search filters
        Returns:
            SHA-256 hash string or None
        """
        if not filters:
            return None
        filters_str = json.dumps(filters, sort_keys=True)
        return hashlib.sha256(filters_str.encode()).hexdigest()
</file>

<file path="backend/app/services/local_nursery_service.py">
"""Local nursery service.
This module provides business logic for local nursery and garden center operations.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
import math
from sqlalchemy import select, func, desc, and_, or_, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent, UserNurseryFavorite
from app.schemas.nursery import LocalNurseryCreate, NurseryReviewCreate, NurserySearchFilters
class LocalNurseryService:
    """Service for managing local nurseries and garden centers."""
    @staticmethod
    async def search_nurseries(
        db: AsyncSession,
        filters: NurserySearchFilters,
        limit: int = 20,
        offset: int = 0
    ) -> List[LocalNursery]:
        """Search for nurseries based on location and filters."""
        query = select(LocalNursery).where(LocalNursery.is_active == True)
        # Add location-based filtering if coordinates provided
        if filters.latitude and filters.longitude:
            # Use Haversine formula for distance calculation
            distance_query = func.acos(
                func.cos(func.radians(filters.latitude)) *
                func.cos(func.radians(LocalNursery.latitude)) *
                func.cos(func.radians(LocalNursery.longitude) - func.radians(filters.longitude)) +
                func.sin(func.radians(filters.latitude)) *
                func.sin(func.radians(LocalNursery.latitude))
            ) * 6371  # Earth's radius in km
            query = query.where(distance_query <= filters.radius_km)
        # Add business type filter
        if filters.business_type:
            query = query.where(LocalNursery.business_type == filters.business_type)
        # Add specialties filter
        if filters.specialties:
            # Check if any of the specialties match
            specialty_conditions = []
            for specialty in filters.specialties:
                specialty_conditions.append(
                    LocalNursery.specialties.op('@>')([specialty])
                )
            query = query.where(or_(*specialty_conditions))
        # Order by rating and distance
        query = query.order_by(desc(LocalNursery.average_rating))
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
    @staticmethod
    async def get_nursery_by_id(
        db: AsyncSession,
        nursery_id: UUID
    ) -> Optional[LocalNursery]:
        """Get nursery by ID."""
        result = await db.execute(
            select(LocalNursery).where(LocalNursery.id == nursery_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def create_nursery(
        db: AsyncSession,
        nursery_data: LocalNurseryCreate
    ) -> LocalNursery:
        """Create a new nursery."""
        nursery = LocalNursery(**nursery_data.model_dump())
        db.add(nursery)
        await db.commit()
        await db.refresh(nursery)
        return nursery
    @staticmethod
    async def get_nursery_reviews(
        db: AsyncSession,
        nursery_id: UUID,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryReview]:
        """Get reviews for a nursery."""
        result = await db.execute(
            select(NurseryReview).options(
                selectinload(NurseryReview.user)
            ).where(
                and_(
                    NurseryReview.nursery_id == nursery_id,
                    NurseryReview.is_active == True
                )
            ).order_by(desc(NurseryReview.created_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def create_review(
        db: AsyncSession,
        nursery_id: UUID,
        user_id: UUID,
        review_data: NurseryReviewCreate
    ) -> NurseryReview:
        """Create a new nursery review."""
        review = NurseryReview(
            nursery_id=nursery_id,
            user_id=user_id,
            **review_data.model_dump()
        )
        db.add(review)
        # Update nursery rating
        await LocalNurseryService._update_nursery_rating(db, nursery_id)
        await db.commit()
        await db.refresh(review, ['user'])
        return review
    @staticmethod
    async def _update_nursery_rating(
        db: AsyncSession,
        nursery_id: UUID
    ):
        """Update the average rating for a nursery."""
        result = await db.execute(
            select(
                func.avg(NurseryReview.rating).label('avg_rating'),
                func.count(NurseryReview.id).label('total_reviews')
            ).where(
                and_(
                    NurseryReview.nursery_id == nursery_id,
                    NurseryReview.is_active == True
                )
            )
        )
        stats = result.first()
        if stats:
            # Update nursery with new stats
            nursery_result = await db.execute(
                select(LocalNursery).where(LocalNursery.id == nursery_id)
            )
            nursery = nursery_result.scalar_one_or_none()
            if nursery:
                nursery.average_rating = float(stats.avg_rating or 0.0)
                nursery.total_reviews = int(stats.total_reviews or 0)
    @staticmethod
    async def get_nursery_events(
        db: AsyncSession,
        nursery_id: UUID,
        upcoming_only: bool = True,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryEvent]:
        """Get events for a nursery."""
        query = select(NurseryEvent).where(
            and_(
                NurseryEvent.nursery_id == nursery_id,
                NurseryEvent.is_active == True,
                NurseryEvent.is_cancelled == False
            )
        )
        if upcoming_only:
            query = query.where(NurseryEvent.start_date >= datetime.utcnow())
        query = query.order_by(NurseryEvent.start_date)
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
    @staticmethod
    async def toggle_favorite(
        db: AsyncSession,
        user_id: UUID,
        nursery_id: UUID
    ) -> bool:
        """Toggle nursery favorite status for user."""
        # Check if already favorited
        result = await db.execute(
            select(UserNurseryFavorite).where(
                and_(
                    UserNurseryFavorite.user_id == user_id,
                    UserNurseryFavorite.nursery_id == nursery_id
                )
            )
        )
        existing_favorite = result.scalar_one_or_none()
        if existing_favorite:
            # Remove from favorites
            await db.delete(existing_favorite)
            await db.commit()
            return False
        else:
            # Add to favorites
            favorite = UserNurseryFavorite(
                user_id=user_id,
                nursery_id=nursery_id
            )
            db.add(favorite)
            await db.commit()
            return True
    @staticmethod
    async def get_user_favorites(
        db: AsyncSession,
        user_id: UUID
    ) -> List[LocalNursery]:
        """Get user's favorite nurseries."""
        result = await db.execute(
            select(LocalNursery).join(UserNurseryFavorite).where(
                UserNurseryFavorite.user_id == user_id
            ).order_by(UserNurseryFavorite.created_at)
        )
        return result.scalars().all()
    @staticmethod
    async def get_nearby_events(
        db: AsyncSession,
        latitude: Optional[float],
        longitude: Optional[float],
        radius_km: float = 50,
        event_type: Optional[str] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[NurseryEvent]:
        """Get nearby nursery events."""
        query = select(NurseryEvent).options(
            selectinload(NurseryEvent.nursery)
        ).join(LocalNursery).where(
            and_(
                NurseryEvent.is_active == True,
                NurseryEvent.is_cancelled == False,
                NurseryEvent.start_date >= datetime.utcnow(),
                LocalNursery.is_active == True
            )
        )
        # Add location filter if coordinates provided
        if latitude and longitude:
            distance_query = func.acos(
                func.cos(func.radians(latitude)) *
                func.cos(func.radians(LocalNursery.latitude)) *
                func.cos(func.radians(LocalNursery.longitude) - func.radians(longitude)) +
                func.sin(func.radians(latitude)) *
                func.sin(func.radians(LocalNursery.latitude))
            ) * 6371
            query = query.where(distance_query <= radius_km)
        # Add event type filter
        if event_type:
            query = query.where(NurseryEvent.event_type == event_type)
        query = query.order_by(NurseryEvent.start_date)
        result = await db.execute(query.limit(limit).offset(offset))
        return result.scalars().all()
</file>

<file path="backend/app/services/personalized_plant_care_service.py">
"""Personalized Plant Care AI service for intelligent care recommendations."""
import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass
import json
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, desc, func
from sqlalchemy.orm import selectinload
from app.models.user import User
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_species import PlantSpecies
from app.models.rag_models import PlantKnowledgeBase, UserPreferenceEmbedding
from app.services.rag_service import RAGService, UserContext, PlantData, PlantCareAdvice
from app.services.embedding_service import EmbeddingService
logger = logging.getLogger(__name__)
@dataclass
class EnvironmentalData:
    """Environmental context for plant care recommendations."""
    season: str
    temperature_range: Tuple[int, int]  # (min, max) in Fahrenheit
    humidity_level: str  # low, medium, high
    light_hours: int  # daylight hours
    location: str
    climate_zone: str
@dataclass
class CarePattern:
    """User's care pattern analysis."""
    watering_frequency: float  # days between watering
    consistency_score: float  # 0-1, how consistent the user is
    success_rate: float  # 0-1, how successful their care has been
    preferred_care_times: List[str]  # times of day user typically cares for plants
    care_style: str  # "frequent", "moderate", "minimal"
@dataclass
class PlantHealthPrediction:
    """Prediction of plant health issues."""
    risk_level: str  # low, medium, high
    potential_issues: List[str]
    prevention_tips: List[str]
    check_in_days: int  # when to check again
@dataclass
class PersonalizedCareSchedule:
    """Optimized care schedule for a specific plant and user."""
    plant_id: str
    next_watering: datetime
    next_fertilizing: Optional[datetime]
    next_repotting: Optional[datetime]
    seasonal_adjustments: Dict[str, str]
    care_reminders: List[Dict[str, Any]]
class PersonalizedPlantCareService:
    """Service for AI-powered personalized plant care recommendations."""
    def __init__(self, rag_service: RAGService, embedding_service: EmbeddingService):
        self.rag_service = rag_service
        self.embedding_service = embedding_service
    async def analyze_user_care_patterns(
        self,
        db: AsyncSession,
        user_id: str,
        days_back: int = 90
    ) -> CarePattern:
        """Analyze user's plant care patterns and consistency.
        Args:
            db: Database session
            user_id: User ID to analyze
            days_back: Number of days to look back for analysis
        Returns:
            CarePattern with user's care behavior analysis
        """
        try:
            # Get user's care logs from the specified period
            since_date = datetime.utcnow() - timedelta(days=days_back)
            stmt = select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).where(
                and_(
                    PlantCareLog.user_id == user_id,
                    PlantCareLog.care_date >= since_date
                )
            ).order_by(desc(PlantCareLog.care_date))
            result = await db.execute(stmt)
            care_logs = result.scalars().all()
            if not care_logs:
                # Return default pattern for new users
                return CarePattern(
                    watering_frequency=7.0,
                    consistency_score=0.5,
                    success_rate=0.7,
                    preferred_care_times=["morning"],
                    care_style="moderate"
                )
            # Analyze watering frequency
            watering_logs = [log for log in care_logs if log.care_type == "watering"]
            watering_frequency = self._calculate_watering_frequency(watering_logs)
            # Analyze consistency (how regular the user is with care)
            consistency_score = self._calculate_consistency_score(care_logs)
            # Analyze success rate (based on plant health outcomes)
            success_rate = await self._calculate_success_rate(db, user_id, care_logs)
            # Analyze preferred care times
            preferred_times = self._analyze_care_times(care_logs)
            # Determine care style
            care_style = self._determine_care_style(watering_frequency, len(care_logs), days_back)
            pattern = CarePattern(
                watering_frequency=watering_frequency,
                consistency_score=consistency_score,
                success_rate=success_rate,
                preferred_care_times=preferred_times,
                care_style=care_style
            )
            # Update user preferences with this analysis
            await self._update_care_preferences(db, user_id, pattern)
            logger.info(f"Analyzed care patterns for user {user_id}")
            return pattern
        except Exception as e:
            logger.error(f"Error analyzing care patterns: {str(e)}")
            # Return safe defaults
            return CarePattern(
                watering_frequency=7.0,
                consistency_score=0.5,
                success_rate=0.7,
                preferred_care_times=["morning"],
                care_style="moderate"
            )
    async def get_environmental_context(
        self,
        location: str,
        current_date: Optional[datetime] = None
    ) -> EnvironmentalData:
        """Get environmental context for plant care recommendations.
        Args:
            location: User's location
            current_date: Current date (defaults to now)
        Returns:
            EnvironmentalData with current environmental context
        """
        if current_date is None:
            current_date = datetime.utcnow()
        # Determine season based on date (Northern Hemisphere)
        month = current_date.month
        if month in [12, 1, 2]:
            season = "winter"
            temp_range = (35, 65)
            light_hours = 9
        elif month in [3, 4, 5]:
            season = "spring"
            temp_range = (50, 75)
            light_hours = 12
        elif month in [6, 7, 8]:
            season = "summer"
            temp_range = (70, 85)
            light_hours = 15
        else:  # fall
            season = "fall"
            temp_range = (45, 70)
            light_hours = 11
        # Simple location-based climate zone mapping
        climate_zone = self._determine_climate_zone(location)
        # Humidity based on season and location
        if season == "winter":
            humidity = "low"
        elif season == "summer":
            humidity = "high"
        else:
            humidity = "medium"
        return EnvironmentalData(
            season=season,
            temperature_range=temp_range,
            humidity_level=humidity,
            light_hours=light_hours,
            location=location,
            climate_zone=climate_zone
        )
    async def optimize_care_schedule(
        self,
        db: AsyncSession,
        user_id: str,
        plant_id: str,
        care_pattern: CarePattern,
        environmental_data: EnvironmentalData
    ) -> PersonalizedCareSchedule:
        """Create optimized care schedule for a specific plant and user.
        Args:
            db: Database session
            user_id: User ID
            plant_id: Plant ID
            care_pattern: User's care pattern analysis
            environmental_data: Current environmental context
        Returns:
            PersonalizedCareSchedule with optimized timing
        """
        try:
            # Get plant details
            stmt = select(UserPlant).options(
                selectinload(UserPlant.species),
                selectinload(UserPlant.care_logs)
            ).where(UserPlant.id == plant_id)
            result = await db.execute(stmt)
            plant = result.scalar_one_or_none()
            if not plant:
                raise ValueError(f"Plant {plant_id} not found")
            # Get recent care history
            recent_logs = sorted(plant.care_logs, key=lambda x: x.care_date, reverse=True)[:10]
            # Calculate base watering schedule
            base_frequency = plant.species.water_frequency_days or 7
            # Adjust for user patterns
            user_adjusted_frequency = self._adjust_for_user_pattern(
                base_frequency, care_pattern
            )
            # Adjust for environmental conditions
            env_adjusted_frequency = self._adjust_for_environment(
                user_adjusted_frequency, environmental_data
            )
            # Calculate next care dates
            last_watering = self._get_last_care_date(recent_logs, "watering")
            next_watering = last_watering + timedelta(days=env_adjusted_frequency)
            # Fertilizing schedule (typically monthly during growing season)
            next_fertilizing = None
            if environmental_data.season in ["spring", "summer"]:
                last_fertilizing = self._get_last_care_date(recent_logs, "fertilizing")
                if not last_fertilizing or (datetime.utcnow() - last_fertilizing).days > 30:
                    next_fertilizing = datetime.utcnow() + timedelta(days=7)
            # Repotting schedule (typically yearly)
            next_repotting = None
            if plant.last_repotted:
                months_since_repot = (datetime.utcnow() - plant.last_repotted).days / 30
                if months_since_repot > 12:
                    next_repotting = datetime.utcnow() + timedelta(days=30)
            # Seasonal adjustments
            seasonal_adjustments = self._get_seasonal_adjustments(
                plant.species, environmental_data
            )
            # Generate care reminders
            care_reminders = self._generate_care_reminders(
                plant, care_pattern, environmental_data
            )
            schedule = PersonalizedCareSchedule(
                plant_id=plant_id,
                next_watering=next_watering,
                next_fertilizing=next_fertilizing,
                next_repotting=next_repotting,
                seasonal_adjustments=seasonal_adjustments,
                care_reminders=care_reminders
            )
            logger.info(f"Generated optimized care schedule for plant {plant_id}")
            return schedule
        except Exception as e:
            logger.error(f"Error optimizing care schedule: {str(e)}")
            raise
    async def predict_plant_health_issues(
        self,
        db: AsyncSession,
        plant_id: str,
        care_pattern: CarePattern,
        environmental_data: EnvironmentalData
    ) -> PlantHealthPrediction:
        """Predict potential plant health issues based on care patterns and environment.
        Args:
            db: Database session
            plant_id: Plant ID to analyze
            care_pattern: User's care pattern
            environmental_data: Environmental context
        Returns:
            PlantHealthPrediction with risk assessment
        """
        try:
            # Get plant and recent care history
            stmt = select(UserPlant).options(
                selectinload(UserPlant.species),
                selectinload(UserPlant.care_logs)
            ).where(UserPlant.id == plant_id)
            result = await db.execute(stmt)
            plant = result.scalar_one_or_none()
            if not plant:
                raise ValueError(f"Plant {plant_id} not found")
            # Analyze risk factors
            risk_factors = []
            potential_issues = []
            prevention_tips = []
            # Check watering patterns
            if care_pattern.watering_frequency < (plant.species.water_frequency_days or 7) * 0.5:
                risk_factors.append("overwatering")
                potential_issues.append("Root rot from overwatering")
                prevention_tips.append("Reduce watering frequency and check soil moisture before watering")
            elif care_pattern.watering_frequency > (plant.species.water_frequency_days or 7) * 2:
                risk_factors.append("underwatering")
                potential_issues.append("Dehydration and leaf drop")
                prevention_tips.append("Increase watering frequency and monitor soil moisture")
            # Check consistency
            if care_pattern.consistency_score < 0.3:
                risk_factors.append("inconsistent_care")
                potential_issues.append("Stress from irregular care schedule")
                prevention_tips.append("Set up care reminders to maintain consistent schedule")
            # Check environmental factors
            if environmental_data.season == "winter" and environmental_data.humidity_level == "low":
                risk_factors.append("low_humidity")
                potential_issues.append("Brown leaf tips and pest susceptibility")
                prevention_tips.append("Increase humidity with a humidifier or pebble tray")
            # Check plant-specific issues
            species_risks = await self._get_species_specific_risks(db, plant.species, environmental_data)
            potential_issues.extend(species_risks)
            # Determine overall risk level
            risk_level = self._calculate_risk_level(risk_factors, care_pattern.success_rate)
            # Determine check-in frequency
            if risk_level == "high":
                check_in_days = 3
            elif risk_level == "medium":
                check_in_days = 7
            else:
                check_in_days = 14
            prediction = PlantHealthPrediction(
                risk_level=risk_level,
                potential_issues=potential_issues,
                prevention_tips=prevention_tips,
                check_in_days=check_in_days
            )
            logger.info(f"Generated health prediction for plant {plant_id}")
            return prediction
        except Exception as e:
            logger.error(f"Error predicting plant health: {str(e)}")
            return PlantHealthPrediction(
                risk_level="medium",
                potential_issues=["Unable to assess at this time"],
                prevention_tips=["Continue regular care and monitor plant closely"],
                check_in_days=7
            )
    async def generate_personalized_care_advice(
        self,
        db: AsyncSession,
        user_id: str,
        plant_id: str,
        query: str
    ) -> PlantCareAdvice:
        """Generate personalized care advice using RAG with user context.
        Args:
            db: Database session
            user_id: User ID
            plant_id: Plant ID
            query: User's question or concern
        Returns:
            PlantCareAdvice with personalized recommendations
        """
        try:
            # Get user context
            user_stmt = select(User).where(User.id == user_id)
            user_result = await db.execute(user_stmt)
            user = user_result.scalar_one_or_none()
            # Get plant data
            plant_stmt = select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(UserPlant.id == plant_id)
            plant_result = await db.execute(plant_stmt)
            plant = plant_result.scalar_one_or_none()
            if not user or not plant:
                raise ValueError("User or plant not found")
            # Analyze care patterns
            care_pattern = await self.analyze_user_care_patterns(db, user_id)
            # Get environmental context
            environmental_data = await self.get_environmental_context(user.location or "temperate")
            # Build user context for RAG
            user_context = UserContext(
                user_id=user_id,
                experience_level=user.gardening_experience or "beginner",
                location=user.location,
                preferences={
                    "care_style": care_pattern.care_style,
                    "consistency_score": care_pattern.consistency_score,
                    "success_rate": care_pattern.success_rate
                }
            )
            # Build plant data for RAG
            plant_data = PlantData(
                species_id=str(plant.species.id),
                species_name=plant.species.scientific_name,
                care_level=plant.species.care_level or "intermediate",
                user_plant_id=str(plant.id),
                current_health=plant.health_status
            )
            # Generate advice using RAG
            advice = await self.rag_service.generate_plant_care_advice(
                db=db,
                user_context=user_context,
                plant_data=plant_data,
                query=query
            )
            # Enhance advice with personalized schedule updates
            schedule = await self.optimize_care_schedule(
                db, user_id, plant_id, care_pattern, environmental_data
            )
            advice.care_schedule_updates = {
                "next_watering": schedule.next_watering.isoformat(),
                "seasonal_adjustments": schedule.seasonal_adjustments,
                "care_reminders": schedule.care_reminders
            }
            logger.info(f"Generated personalized care advice for user {user_id}, plant {plant_id}")
            return advice
        except Exception as e:
            logger.error(f"Error generating personalized care advice: {str(e)}")
            raise
    def _calculate_watering_frequency(self, watering_logs: List[PlantCareLog]) -> float:
        """Calculate average days between watering events."""
        if len(watering_logs) < 2:
            return 7.0  # Default weekly
        intervals = []
        for i in range(1, len(watering_logs)):
            days_diff = (watering_logs[i-1].care_date - watering_logs[i].care_date).days
            if 0 < days_diff <= 30:  # Filter out unrealistic intervals
                intervals.append(days_diff)
        return sum(intervals) / len(intervals) if intervals else 7.0
    def _calculate_consistency_score(self, care_logs: List[PlantCareLog]) -> float:
        """Calculate how consistent the user is with their care schedule."""
        if len(care_logs) < 3:
            return 0.5  # Default moderate consistency
        # Group by care type and calculate variance in intervals
        care_by_type = {}
        for log in care_logs:
            if log.care_type not in care_by_type:
                care_by_type[log.care_type] = []
            care_by_type[log.care_type].append(log.care_date)
        consistency_scores = []
        for care_type, dates in care_by_type.items():
            if len(dates) >= 3:
                dates.sort(reverse=True)
                intervals = [(dates[i] - dates[i+1]).days for i in range(len(dates)-1)]
                if intervals:
                    avg_interval = sum(intervals) / len(intervals)
                    variance = sum((x - avg_interval) ** 2 for x in intervals) / len(intervals)
                    # Convert variance to consistency score (lower variance = higher consistency)
                    consistency = max(0, 1 - (variance / (avg_interval ** 2)))
                    consistency_scores.append(consistency)
        return sum(consistency_scores) / len(consistency_scores) if consistency_scores else 0.5
    async def _calculate_success_rate(
        self,
        db: AsyncSession,
        user_id: str,
        care_logs: List[PlantCareLog]
    ) -> float:
        """Calculate user's success rate based on plant health outcomes."""
        try:
            # Get user's plants and their health status
            stmt = select(UserPlant).where(UserPlant.user_id == user_id)
            result = await db.execute(stmt)
            plants = result.scalars().all()
            if not plants:
                return 0.7  # Default moderate success rate
            # Calculate success based on plant health
            healthy_plants = sum(1 for plant in plants if plant.health_status in ["healthy", "thriving"])
            total_plants = len(plants)
            base_success_rate = healthy_plants / total_plants
            # Adjust based on care frequency (more care logs might indicate more engaged user)
            care_engagement_bonus = min(0.2, len(care_logs) / 100)
            return min(1.0, base_success_rate + care_engagement_bonus)
        except Exception as e:
            logger.error(f"Error calculating success rate: {str(e)}")
            return 0.7
    def _analyze_care_times(self, care_logs: List[PlantCareLog]) -> List[str]:
        """Analyze preferred times of day for plant care."""
        time_counts = {"morning": 0, "afternoon": 0, "evening": 0}
        for log in care_logs:
            hour = log.care_date.hour
            if 6 <= hour < 12:
                time_counts["morning"] += 1
            elif 12 <= hour < 18:
                time_counts["afternoon"] += 1
            else:
                time_counts["evening"] += 1
        # Return times sorted by frequency
        sorted_times = sorted(time_counts.items(), key=lambda x: x[1], reverse=True)
        return [time for time, count in sorted_times if count > 0]
    def _determine_care_style(self, watering_frequency: float, total_logs: int, days_back: int) -> str:
        """Determine user's care style based on frequency and engagement."""
        care_events_per_week = (total_logs / days_back) * 7
        if watering_frequency <= 3 or care_events_per_week > 5:
            return "frequent"
        elif watering_frequency >= 10 or care_events_per_week < 1:
            return "minimal"
        else:
            return "moderate"
    async def _update_care_preferences(
        self,
        db: AsyncSession,
        user_id: str,
        care_pattern: CarePattern
    ) -> None:
        """Update user preferences based on care pattern analysis."""
        try:
            preference_data = {
                "care_style": care_pattern.care_style,
                "watering_frequency": care_pattern.watering_frequency,
                "consistency_score": care_pattern.consistency_score,
                "success_rate": care_pattern.success_rate,
                "preferred_care_times": care_pattern.preferred_care_times
            }
            await self.embedding_service.update_user_preferences(
                db=db,
                user_id=user_id,
                preference_type="care_patterns",
                preference_data=preference_data,
                confidence_score=0.8
            )
        except Exception as e:
            logger.error(f"Error updating care preferences: {str(e)}")
    def _determine_climate_zone(self, location: str) -> str:
        """Determine climate zone based on location."""
        location_lower = location.lower() if location else ""
        if any(region in location_lower for region in ["florida", "california", "texas", "arizona"]):
            return "subtropical"
        elif any(region in location_lower for region in ["alaska", "maine", "minnesota", "montana"]):
            return "cold"
        elif any(region in location_lower for region in ["hawaii", "puerto rico"]):
            return "tropical"
        else:
            return "temperate"
    def _adjust_for_user_pattern(self, base_frequency: int, care_pattern: CarePattern) -> float:
        """Adjust watering frequency based on user's care patterns."""
        adjustment_factor = 1.0
        # Adjust based on care style
        if care_pattern.care_style == "frequent":
            adjustment_factor *= 0.8  # Water more often
        elif care_pattern.care_style == "minimal":
            adjustment_factor *= 1.3  # Water less often
        # Adjust based on success rate
        if care_pattern.success_rate > 0.8:
            adjustment_factor *= 0.9  # Successful users can water slightly more often
        elif care_pattern.success_rate < 0.5:
            adjustment_factor *= 1.2  # Less successful users should water less often
        return base_frequency * adjustment_factor
    def _adjust_for_environment(self, frequency: float, env_data: EnvironmentalData) -> float:
        """Adjust watering frequency based on environmental conditions."""
        adjustment = 1.0
        # Seasonal adjustments
        if env_data.season == "winter":
            adjustment *= 1.5  # Water less in winter
        elif env_data.season == "summer":
            adjustment *= 0.8  # Water more in summer
        # Humidity adjustments
        if env_data.humidity_level == "low":
            adjustment *= 0.9  # Water slightly more in low humidity
        elif env_data.humidity_level == "high":
            adjustment *= 1.1  # Water slightly less in high humidity
        return frequency * adjustment
    def _get_last_care_date(self, care_logs: List[PlantCareLog], care_type: str) -> datetime:
        """Get the last date a specific type of care was performed."""
        for log in care_logs:
            if log.care_type == care_type:
                return log.care_date
        # If no care of this type found, assume it was done a while ago
        return datetime.utcnow() - timedelta(days=30)
    def _get_seasonal_adjustments(
        self,
        species: PlantSpecies,
        env_data: EnvironmentalData
    ) -> Dict[str, str]:
        """Get seasonal care adjustments for the plant species."""
        adjustments = {}
        if env_data.season == "winter":
            adjustments.update({
                "watering": "Reduce watering frequency as plant enters dormancy",
                "fertilizing": "Stop fertilizing during winter months",
                "light": "Move closer to windows for maximum light exposure",
                "humidity": "Increase humidity to combat dry indoor air"
            })
        elif env_data.season == "spring":
            adjustments.update({
                "watering": "Gradually increase watering as growth resumes",
                "fertilizing": "Begin monthly fertilizing schedule",
                "repotting": "Best time for repotting if needed",
                "pruning": "Prune dead or damaged growth"
            })
        elif env_data.season == "summer":
            adjustments.update({
                "watering": "Monitor soil moisture more frequently",
                "fertilizing": "Continue regular fertilizing",
                "light": "Protect from intense direct sunlight",
                "humidity": "Maintain good air circulation"
            })
        else:  # fall
            adjustments.update({
                "watering": "Begin reducing watering frequency",
                "fertilizing": "Stop fertilizing by mid-fall",
                "preparation": "Prepare plant for winter dormancy",
                "inspection": "Check for pests before bringing indoors"
            })
        return adjustments
    def _generate_care_reminders(
        self,
        plant: UserPlant,
        care_pattern: CarePattern,
        env_data: EnvironmentalData
    ) -> List[Dict[str, Any]]:
        """Generate personalized care reminders."""
        reminders = []
        # Watering reminder
        preferred_time = care_pattern.preferred_care_times[0] if care_pattern.preferred_care_times else "morning"
        reminders.append({
            "type": "watering",
            "message": f"Water your {plant.nickname or plant.species.common_names[0]} in the {preferred_time}",
            "frequency": f"every {int(care_pattern.watering_frequency)} days",
            "priority": "high"
        })
        # Seasonal reminders
        if env_data.season == "winter":
            reminders.append({
                "type": "humidity",
                "message": "Check humidity levels - winter air can be very dry",
                "frequency": "weekly",
                "priority": "medium"
            })
        elif env_data.season == "spring":
            reminders.append({
                "type": "fertilizing",
                "message": "Time to start fertilizing for the growing season",
                "frequency": "monthly",
                "priority": "medium"
            })
        return reminders
    async def _get_species_specific_risks(
        self,
        db: AsyncSession,
        species: PlantSpecies,
        env_data: EnvironmentalData
    ) -> List[str]:
        """Get species-specific health risks based on current conditions."""
        risks = []
        # Check if species care level matches current conditions
        if species.care_level == "difficult" and env_data.season == "winter":
            risks.append("Increased sensitivity during winter months")
        # Check humidity requirements
        if species.humidity_preference == "high" and env_data.humidity_level == "low":
            risks.append("Low humidity stress for humidity-loving plant")
        # Check temperature requirements
        if species.temperature_range:
            temp_range = species.temperature_range.split("-")
            if len(temp_range) == 2:
                min_temp, max_temp = int(temp_range[0]), int(temp_range[1])
                env_min, env_max = env_data.temperature_range
                if env_min < min_temp or env_max > max_temp:
                    risks.append("Temperature outside plant's preferred range")
        return risks
    def _calculate_risk_level(self, risk_factors: List[str], success_rate: float) -> str:
        """Calculate overall risk level based on factors and user success rate."""
        base_risk = len(risk_factors)
        # Adjust based on user success rate
        if success_rate > 0.8:
            base_risk *= 0.7  # Experienced users have lower risk
        elif success_rate < 0.5:
            base_risk *= 1.3  # Inexperienced users have higher risk
        if base_risk >= 3:
            return "high"
        elif base_risk >= 1:
            return "medium"
        else:
            return "low"
</file>

<file path="backend/app/services/plant_achievement_service.py">
"""Plant achievement service.
This module provides business logic for plant achievements and milestone tracking.
"""
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, func, desc, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app.models.plant_achievement import PlantAchievement, UserAchievement, PlantMilestone, UserStats
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_identification import PlantIdentification
from app.models.plant_question import PlantQuestion, PlantAnswer
class PlantAchievementService:
    """Service for managing plant achievements."""
    @staticmethod
    async def get_user_achievements(
        db: AsyncSession,
        user_id: UUID,
        limit: int = 50,
        offset: int = 0
    ) -> List[UserAchievement]:
        """Get user's earned achievements."""
        result = await db.execute(
            select(UserAchievement).options(
                selectinload(UserAchievement.achievement)
            ).where(
                UserAchievement.user_id == user_id
            ).order_by(desc(UserAchievement.earned_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def get_available_achievements(
        db: AsyncSession,
        user_id: UUID
    ) -> List[PlantAchievement]:
        """Get achievements available to unlock."""
        # Get achievements user hasn't earned yet
        earned_achievement_ids = await db.execute(
            select(UserAchievement.achievement_id).where(
                UserAchievement.user_id == user_id
            )
        )
        earned_ids = [row[0] for row in earned_achievement_ids.fetchall()]
        result = await db.execute(
            select(PlantAchievement).where(
                and_(
                    PlantAchievement.is_active == True,
                    ~PlantAchievement.id.in_(earned_ids) if earned_ids else True
                )
            ).order_by(PlantAchievement.points)
        )
        return result.scalars().all()
    @staticmethod
    async def check_and_award_achievements(
        db: AsyncSession,
        user_id: UUID
    ) -> List[UserAchievement]:
        """Check and award any newly earned achievements."""
        newly_earned = []
        # Get user stats
        user_stats = await PlantAchievementService.get_or_create_user_stats(db, user_id)
        # Get available achievements
        available_achievements = await PlantAchievementService.get_available_achievements(db, user_id)
        for achievement in available_achievements:
            if await PlantAchievementService._check_achievement_criteria(db, user_id, achievement, user_stats):
                # Award the achievement
                user_achievement = UserAchievement(
                    user_id=user_id,
                    achievement_id=achievement.id,
                    earned_at=datetime.utcnow()
                )
                db.add(user_achievement)
                # Update user stats
                user_stats.total_achievements += 1
                user_stats.total_points += achievement.points
                user_stats.level = PlantAchievementService._calculate_level(user_stats.total_points)
                newly_earned.append(user_achievement)
        if newly_earned:
            await db.commit()
            # Reload with relationships
            for ua in newly_earned:
                await db.refresh(ua, ['achievement'])
        return newly_earned
    @staticmethod
    async def _check_achievement_criteria(
        db: AsyncSession,
        user_id: UUID,
        achievement: PlantAchievement,
        user_stats: UserStats
    ) -> bool:
        """Check if user meets achievement criteria."""
        criteria = achievement.unlock_criteria or {}
        if achievement.achievement_type == "care_streak":
            required_days = criteria.get("days", 7)
            return user_stats.care_streak_days >= required_days
        elif achievement.achievement_type == "plant_collection":
            required_count = criteria.get("count", 5)
            return user_stats.active_plants >= required_count
        elif achievement.achievement_type == "identification":
            required_count = criteria.get("count", 10)
            return user_stats.plants_identified >= required_count
        elif achievement.achievement_type == "community_helper":
            required_answers = criteria.get("helpful_answers", 5)
            return user_stats.helpful_answers >= required_answers
        elif achievement.achievement_type == "plant_age":
            required_days = criteria.get("days", 365)
            # Check if user has any plants older than required days
            result = await db.execute(
                select(func.count(UserPlant.id)).where(
                    and_(
                        UserPlant.user_id == user_id,
                        UserPlant.is_active == True,
                        UserPlant.acquired_date <= datetime.utcnow() - timedelta(days=required_days)
                    )
                )
            )
            count = result.scalar()
            return count > 0
        return False
    @staticmethod
    def _calculate_level(total_points: int) -> int:
        """Calculate user level based on total points."""
        if total_points < 100:
            return 1
        elif total_points < 300:
            return 2
        elif total_points < 600:
            return 3
        elif total_points < 1000:
            return 4
        elif total_points < 1500:
            return 5
        else:
            return min(10, 5 + (total_points - 1500) // 500)
    @staticmethod
    async def get_or_create_user_stats(
        db: AsyncSession,
        user_id: UUID
    ) -> UserStats:
        """Get or create user statistics."""
        result = await db.execute(
            select(UserStats).where(UserStats.user_id == user_id)
        )
        user_stats = result.scalar_one_or_none()
        if not user_stats:
            user_stats = UserStats(user_id=user_id)
            db.add(user_stats)
            await db.commit()
            await db.refresh(user_stats)
        return user_stats
    @staticmethod
    async def update_user_stats(
        db: AsyncSession,
        user_id: UUID,
        stat_updates: Dict[str, Any]
    ) -> UserStats:
        """Update user statistics."""
        user_stats = await PlantAchievementService.get_or_create_user_stats(db, user_id)
        for key, value in stat_updates.items():
            if hasattr(user_stats, key):
                setattr(user_stats, key, value)
        user_stats.last_updated = datetime.utcnow()
        await db.commit()
        await db.refresh(user_stats)
        return user_stats
class PlantMilestoneService:
    """Service for managing plant milestones."""
    @staticmethod
    async def create_milestone(
        db: AsyncSession,
        plant_id: UUID,
        milestone_type: str,
        title: str,
        description: Optional[str] = None,
        photo_url: Optional[str] = None,
        notes: Optional[str] = None
    ) -> PlantMilestone:
        """Create a new plant milestone."""
        milestone = PlantMilestone(
            plant_id=plant_id,
            milestone_type=milestone_type,
            title=title,
            description=description,
            photo_url=photo_url,
            notes=notes
        )
        db.add(milestone)
        await db.commit()
        await db.refresh(milestone)
        return milestone
    @staticmethod
    async def get_plant_milestones(
        db: AsyncSession,
        plant_id: UUID
    ) -> List[PlantMilestone]:
        """Get milestones for a specific plant."""
        result = await db.execute(
            select(PlantMilestone).where(
                PlantMilestone.plant_id == plant_id
            ).order_by(desc(PlantMilestone.achieved_at))
        )
        return result.scalars().all()
    @staticmethod
    async def get_user_milestones(
        db: AsyncSession,
        user_id: UUID,
        limit: int = 50,
        offset: int = 0
    ) -> List[PlantMilestone]:
        """Get all milestones for user's plants."""
        result = await db.execute(
            select(PlantMilestone).options(
                selectinload(PlantMilestone.plant)
            ).join(UserPlant).where(
                UserPlant.user_id == user_id
            ).order_by(desc(PlantMilestone.achieved_at)).limit(limit).offset(offset)
        )
        return result.scalars().all()
    @staticmethod
    async def check_automatic_milestones(
        db: AsyncSession,
        plant_id: UUID
    ) -> List[PlantMilestone]:
        """Check and create automatic milestones for a plant."""
        newly_created = []
        # Get plant info
        result = await db.execute(
            select(UserPlant).where(UserPlant.id == plant_id)
        )
        plant = result.scalar_one_or_none()
        if not plant or not plant.acquired_date:
            return newly_created
        # Get existing milestones
        existing_milestones = await PlantMilestoneService.get_plant_milestones(db, plant_id)
        existing_types = {m.milestone_type for m in existing_milestones}
        # Check age-based milestones
        age_days = (datetime.utcnow().date() - plant.acquired_date).days
        age_milestones = [
            (30, "one_month", "One Month Together", "Your plant has been with you for a month!"),
            (90, "three_months", "Three Months Strong", "Quarter of a year of plant parenthood!"),
            (365, "one_year", "One Year Anniversary", "A full year of growth and care!"),
            (730, "two_years", "Two Years Together", "Two amazing years with your plant companion!"),
        ]
        for days, milestone_type, title, description in age_milestones:
            if age_days >= days and milestone_type not in existing_types:
                milestone = await PlantMilestoneService.create_milestone(
                    db, plant_id, milestone_type, title, description
                )
                newly_created.append(milestone)
        return newly_created
# Initialize default achievements
DEFAULT_ACHIEVEMENTS = [
    {
        "achievement_type": "care_streak",
        "title": "Consistent Caregiver",
        "description": "Care for your plants 7 days in a row",
        "icon": "",
        "badge_color": "gold",
        "points": 50,
        "unlock_criteria": {"days": 7}
    },
    {
        "achievement_type": "care_streak",
        "title": "Plant Parent Pro",
        "description": "Maintain a 30-day care streak",
        "icon": "",
        "badge_color": "gold",
        "points": 200,
        "unlock_criteria": {"days": 30}
    },
    {
        "achievement_type": "plant_collection",
        "title": "Green Thumb",
        "description": "Grow your collection to 5 plants",
        "icon": "",
        "badge_color": "green",
        "points": 100,
        "unlock_criteria": {"count": 5}
    },
    {
        "achievement_type": "plant_collection",
        "title": "Plant Collector",
        "description": "Manage 15 plants in your collection",
        "icon": "",
        "badge_color": "green",
        "points": 300,
        "unlock_criteria": {"count": 15}
    },
    {
        "achievement_type": "identification",
        "title": "Plant Detective",
        "description": "Identify 10 different plant species",
        "icon": "",
        "badge_color": "blue",
        "points": 75,
        "unlock_criteria": {"count": 10}
    },
    {
        "achievement_type": "community_helper",
        "title": "Helpful Gardener",
        "description": "Receive 5 helpful votes on your answers",
        "icon": "",
        "badge_color": "purple",
        "points": 150,
        "unlock_criteria": {"helpful_answers": 5}
    },
    {
        "achievement_type": "plant_age",
        "title": "Long-term Commitment",
        "description": "Keep a plant alive for one full year",
        "icon": "",
        "badge_color": "gold",
        "points": 250,
        "unlock_criteria": {"days": 365}
    }
]
async def initialize_default_achievements(db: AsyncSession):
    """Initialize default achievements in the database."""
    for achievement_data in DEFAULT_ACHIEVEMENTS:
        # Check if achievement already exists
        result = await db.execute(
            select(PlantAchievement).where(
                and_(
                    PlantAchievement.achievement_type == achievement_data["achievement_type"],
                    PlantAchievement.title == achievement_data["title"]
                )
            )
        )
        if not result.scalar_one_or_none():
            achievement = PlantAchievement(**achievement_data)
            db.add(achievement)
    await db.commit()
</file>

<file path="backend/app/services/rag_service.py">
"""Main RAG service for intelligent plant care and content generation."""
import logging
import time
from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from dataclasses import dataclass
from openai import AsyncOpenAI
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.config import settings
from app.models.rag_models import RAGInteraction, PlantKnowledgeBase
from app.models.user import User
from app.models.user_plant import UserPlant
from app.models.plant_species import PlantSpecies
from app.services.embedding_service import EmbeddingService
from app.services.vector_database_service import VectorDatabaseService
logger = logging.getLogger(__name__)
@dataclass
class UserContext:
    """User context for personalized RAG responses."""
    user_id: str
    experience_level: str
    location: Optional[str] = None
    plant_collection: List[Dict[str, Any]] = None
    preferences: Dict[str, Any] = None
    recent_activity: List[Dict[str, Any]] = None
@dataclass
class PlantData:
    """Plant-specific data for RAG queries."""
    species_id: str
    species_name: str
    care_level: str
    user_plant_id: Optional[str] = None
    current_health: Optional[str] = None
    care_history: List[Dict[str, Any]] = None
@dataclass
class PlantCareAdvice:
    """Structured plant care advice response."""
    advice: str
    confidence: float
    sources: List[Dict[str, Any]]
    urgent_actions: List[str] = None
    follow_up_questions: List[str] = None
    care_schedule_updates: Dict[str, Any] = None
class RAGService:
    """Main RAG service for intelligent plant care assistance."""
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.embedding_service = EmbeddingService()
        self.vector_service = VectorDatabaseService(self.embedding_service)
    async def generate_plant_care_advice(
        self,
        db: AsyncSession,
        user_context: UserContext,
        plant_data: PlantData,
        query: str
    ) -> PlantCareAdvice:
        """Generate personalized plant care advice using RAG.
        Args:
            db: Database session
            user_context: User context information
            plant_data: Plant-specific data
            query: User's question or concern
        Returns:
            PlantCareAdvice with personalized recommendations
        """
        start_time = time.time()
        try:
            # Search for relevant plant knowledge
            relevant_docs = await self.vector_service.search_plant_knowledge(
                db=db,
                query=query,
                plant_species_id=plant_data.species_id,
                difficulty_level=self._map_experience_to_difficulty(user_context.experience_level),
                limit=5
            )
            # Build context for LLM
            context = self._build_care_advice_context(user_context, plant_data, relevant_docs)
            # Generate advice using LLM
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": self._get_plant_care_system_prompt()
                    },
                    {
                        "role": "user",
                        "content": f"Context: {context}\n\nQuestion: {query}"
                    }
                ],
                temperature=0.7,
                max_tokens=800
            )
            advice_text = response.choices[0].message.content
            confidence = self._calculate_confidence(relevant_docs)
            # Parse structured response
            advice = PlantCareAdvice(
                advice=advice_text,
                confidence=confidence,
                sources=relevant_docs,
                urgent_actions=self._extract_urgent_actions(advice_text),
                follow_up_questions=self._generate_follow_up_questions(query, advice_text)
            )
            # Log interaction
            await self._log_rag_interaction(
                db=db,
                user_id=user_context.user_id,
                interaction_type="care_advice",
                query=query,
                retrieved_docs=relevant_docs,
                response=advice_text,
                response_time_ms=int((time.time() - start_time) * 1000),
                confidence=confidence
            )
            logger.info(f"Generated plant care advice for user {user_context.user_id}")
            return advice
        except Exception as e:
            logger.error(f"Error generating plant care advice: {str(e)}")
            # Return fallback advice
            return PlantCareAdvice(
                advice="I'm having trouble accessing plant care information right now. Please try again later or consult basic care guides.",
                confidence=0.1,
                sources=[]
            )
    async def generate_personalized_caption(
        self,
        db: AsyncSession,
        user_context: UserContext,
        image_context: Dict[str, Any],
        plant_data: Optional[PlantData] = None
    ) -> str:
        """Generate personalized caption for plant photo.
        Args:
            db: Database session
            user_context: User context information
            image_context: Image analysis context
            plant_data: Plant-specific data if identified
        Returns:
            Generated caption text
        """
        start_time = time.time()
        try:
            # Get relevant plant information if plant is identified
            plant_info = ""
            if plant_data:
                knowledge_results = await self.vector_service.search_plant_knowledge(
                    db=db,
                    query=f"interesting facts about {plant_data.species_name}",
                    plant_species_id=plant_data.species_id,
                    content_types=['species_info'],
                    limit=2
                )
                plant_info = self._extract_plant_facts(knowledge_results)
            # Build caption generation context
            context = self._build_caption_context(user_context, image_context, plant_info)
            # Generate caption
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": self._get_caption_generation_system_prompt()
                    },
                    {
                        "role": "user",
                        "content": context
                    }
                ],
                temperature=0.8,
                max_tokens=200
            )
            caption = response.choices[0].message.content.strip()
            # Log interaction
            await self._log_rag_interaction(
                db=db,
                user_id=user_context.user_id,
                interaction_type="content_generation",
                query=f"Caption for {image_context.get('plant_type', 'plant')} photo",
                response=caption,
                response_time_ms=int((time.time() - start_time) * 1000)
            )
            logger.info(f"Generated personalized caption for user {user_context.user_id}")
            return caption
        except Exception as e:
            logger.error(f"Error generating caption: {str(e)}")
            return "Beautiful plant moment  #PlantParent #GreenThumb"
    async def analyze_plant_health(
        self,
        db: AsyncSession,
        user_context: UserContext,
        plant_data: PlantData,
        symptoms: List[str]
    ) -> Dict[str, Any]:
        """Analyze plant health issues and provide diagnosis.
        Args:
            db: Database session
            user_context: User context information
            plant_data: Plant-specific data
            symptoms: List of observed symptoms
        Returns:
            Health analysis with diagnosis and treatment recommendations
        """
        start_time = time.time()
        try:
            # Search for relevant problem-solving knowledge
            symptoms_query = " ".join(symptoms)
            relevant_docs = await self.vector_service.search_plant_knowledge(
                db=db,
                query=f"{plant_data.species_name} {symptoms_query} problems diagnosis treatment",
                plant_species_id=plant_data.species_id,
                content_types=['problem_solution', 'care_guide'],
                limit=5
            )
            # Build health analysis context
            context = self._build_health_analysis_context(user_context, plant_data, symptoms, relevant_docs)
            # Generate health analysis
            response = await self.client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {
                        "role": "system",
                        "content": self._get_health_analysis_system_prompt()
                    },
                    {
                        "role": "user",
                        "content": context
                    }
                ],
                temperature=0.3,  # Lower temperature for more factual analysis
                max_tokens=600
            )
            analysis_text = response.choices[0].message.content
            # Parse structured response
            analysis = self._parse_health_analysis(analysis_text)
            analysis['confidence'] = self._calculate_confidence(relevant_docs)
            analysis['sources'] = relevant_docs
            # Log interaction
            await self._log_rag_interaction(
                db=db,
                user_id=user_context.user_id,
                interaction_type="health_diagnosis",
                query=f"Health analysis for {plant_data.species_name}: {symptoms_query}",
                retrieved_docs=relevant_docs,
                response=analysis_text,
                response_time_ms=int((time.time() - start_time) * 1000),
                confidence=analysis['confidence']
            )
            logger.info(f"Analyzed plant health for user {user_context.user_id}")
            return analysis
        except Exception as e:
            logger.error(f"Error analyzing plant health: {str(e)}")
            return {
                'diagnosis': 'Unable to analyze symptoms at this time',
                'treatment': 'Please consult a plant expert or local nursery',
                'urgency': 'unknown',
                'confidence': 0.1,
                'sources': []
            }
    async def get_personalized_recommendations(
        self,
        db: AsyncSession,
        user_id: str,
        recommendation_type: str = "general",
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get personalized content recommendations.
        Args:
            db: Database session
            user_id: User ID
            recommendation_type: Type of recommendations
            limit: Maximum number of recommendations
        Returns:
            List of personalized recommendations
        """
        try:
            return await self.vector_service.get_personalized_recommendations(
                db=db,
                user_id=user_id,
                recommendation_type=recommendation_type,
                limit=limit
            )
        except Exception as e:
            logger.error(f"Error getting recommendations: {str(e)}")
            return []
    async def update_user_preferences_from_interaction(
        self,
        db: AsyncSession,
        user_id: str,
        interaction_data: Dict[str, Any]
    ) -> None:
        """Update user preferences based on interactions.
        Args:
            db: Database session
            user_id: User ID
            interaction_data: Interaction data to learn from
        """
        try:
            # Extract preferences from interaction
            preferences = self._extract_preferences_from_interaction(interaction_data)
            # Update preference embeddings
            for pref_type, pref_data in preferences.items():
                await self.embedding_service.update_user_preferences(
                    db=db,
                    user_id=user_id,
                    preference_type=pref_type,
                    preference_data=pref_data,
                    confidence_score=0.8
                )
            logger.info(f"Updated preferences for user {user_id}")
        except Exception as e:
            logger.error(f"Error updating user preferences: {str(e)}")
    def _build_care_advice_context(
        self,
        user_context: UserContext,
        plant_data: PlantData,
        relevant_docs: List[Dict[str, Any]]
    ) -> str:
        """Build context string for care advice generation."""
        context_parts = []
        # User context
        context_parts.append(f"User experience level: {user_context.experience_level}")
        if user_context.location:
            context_parts.append(f"User location: {user_context.location}")
        # Plant context
        context_parts.append(f"Plant species: {plant_data.species_name}")
        context_parts.append(f"Care level: {plant_data.care_level}")
        if plant_data.current_health:
            context_parts.append(f"Current health status: {plant_data.current_health}")
        # Relevant knowledge
        if relevant_docs:
            context_parts.append("Relevant plant care information:")
            for doc in relevant_docs[:3]:  # Limit to top 3 most relevant
                context_parts.append(f"- {doc['title']}: {doc['content'][:200]}...")
        return "\n".join(context_parts)
    def _build_caption_context(
        self,
        user_context: UserContext,
        image_context: Dict[str, Any],
        plant_info: str
    ) -> str:
        """Build context for caption generation."""
        context_parts = []
        context_parts.append(f"Generate a social media caption for a plant photo.")
        context_parts.append(f"User experience level: {user_context.experience_level}")
        if user_context.preferences:
            writing_style = user_context.preferences.get('writing_style', 'casual')
            context_parts.append(f"User's preferred writing style: {writing_style}")
        if image_context.get('plant_type'):
            context_parts.append(f"Plant type: {image_context['plant_type']}")
        if plant_info:
            context_parts.append(f"Interesting plant facts: {plant_info}")
        context_parts.append("Make the caption engaging, informative, and matching the user's style.")
        return "\n".join(context_parts)
    def _build_health_analysis_context(
        self,
        user_context: UserContext,
        plant_data: PlantData,
        symptoms: List[str],
        relevant_docs: List[Dict[str, Any]]
    ) -> str:
        """Build context for health analysis."""
        context_parts = []
        context_parts.append(f"Analyze plant health issues and provide diagnosis.")
        context_parts.append(f"Plant species: {plant_data.species_name}")
        context_parts.append(f"User experience level: {user_context.experience_level}")
        context_parts.append(f"Observed symptoms: {', '.join(symptoms)}")
        if relevant_docs:
            context_parts.append("Relevant diagnostic information:")
            for doc in relevant_docs[:3]:
                context_parts.append(f"- {doc['title']}: {doc['content'][:150]}...")
        context_parts.append("Provide diagnosis, treatment recommendations, and urgency level.")
        return "\n".join(context_parts)
    def _get_plant_care_system_prompt(self) -> str:
        """Get system prompt for plant care advice."""
        return """You are an expert plant care advisor. Provide personalized, practical advice based on the user's experience level and plant-specific information. Be encouraging and supportive while being accurate. If you're uncertain about something, acknowledge it and suggest consulting additional resources."""
    def _get_caption_generation_system_prompt(self) -> str:
        """Get system prompt for caption generation."""
        return """You are a creative social media content creator specializing in plant content. Generate engaging, authentic captions that match the user's style and experience level. Include relevant hashtags and encourage community engagement."""
    def _get_health_analysis_system_prompt(self) -> str:
        """Get system prompt for health analysis."""
        return """You are a plant health diagnostic expert. Analyze symptoms and provide structured diagnosis with treatment recommendations. Be precise about urgency levels and always recommend professional consultation for serious issues."""
    def _calculate_confidence(self, relevant_docs: List[Dict[str, Any]]) -> float:
        """Calculate confidence score based on retrieved documents."""
        if not relevant_docs:
            return 0.3
        avg_similarity = sum(doc['similarity_score'] for doc in relevant_docs) / len(relevant_docs)
        verified_bonus = 0.1 if any(doc.get('verified') == 'verified' for doc in relevant_docs) else 0
        return min(avg_similarity + verified_bonus, 1.0)
    def _map_experience_to_difficulty(self, experience_level: str) -> str:
        """Map user experience to plant difficulty level."""
        mapping = {
            'beginner': 'beginner',
            'intermediate': 'intermediate',
            'expert': 'advanced'
        }
        return mapping.get(experience_level, 'beginner')
    def _extract_urgent_actions(self, advice_text: str) -> List[str]:
        """Extract urgent actions from advice text."""
        urgent_keywords = ['urgent', 'immediately', 'right away', 'asap', 'critical']
        actions = []
        sentences = advice_text.split('.')
        for sentence in sentences:
            if any(keyword in sentence.lower() for keyword in urgent_keywords):
                actions.append(sentence.strip())
        return actions
    def _generate_follow_up_questions(self, original_query: str, advice: str) -> List[str]:
        """Generate relevant follow-up questions."""
        # Simple implementation - could be enhanced with LLM generation
        return [
            "How often should I check for improvement?",
            "Are there any warning signs to watch for?",
            "When should I seek additional help?"
        ]
    def _extract_plant_facts(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """Extract interesting plant facts from knowledge results."""
        facts = []
        for result in knowledge_results:
            content = result.get('content', '')
            # Extract first sentence as a fact
            sentences = content.split('.')
            if sentences:
                facts.append(sentences[0].strip())
        return ". ".join(facts[:2])  # Return top 2 facts
    def _parse_health_analysis(self, analysis_text: str) -> Dict[str, Any]:
        """Parse structured health analysis from text."""
        # Simple parsing - could be enhanced with structured output
        return {
            'diagnosis': analysis_text.split('\n')[0] if analysis_text else 'Unknown',
            'treatment': analysis_text,
            'urgency': 'medium'  # Default urgency
        }
    def _extract_preferences_from_interaction(self, interaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract user preferences from interaction data."""
        preferences = {}
        # Extract plant interests
        if 'plant_species' in interaction_data:
            preferences['plant_interests'] = {
                'species': interaction_data['plant_species'],
                'interaction_type': interaction_data.get('interaction_type', 'query')
            }
        # Extract content preferences
        if 'query' in interaction_data:
            preferences['content_preferences'] = {
                'topics': [interaction_data['query']],
                'engagement_level': 'high'
            }
        return preferences
    async def _log_rag_interaction(
        self,
        db: AsyncSession,
        user_id: str,
        interaction_type: str,
        query: str,
        retrieved_docs: Optional[List[Dict[str, Any]]] = None,
        response: Optional[str] = None,
        response_time_ms: Optional[int] = None,
        confidence: Optional[float] = None
    ) -> None:
        """Log RAG interaction for analytics."""
        try:
            query_embedding = await self.embedding_service.generate_text_embedding(query)
            interaction = RAGInteraction(
                user_id=user_id,
                interaction_type=interaction_type,
                query_text=query,
                query_embedding=query_embedding,
                retrieved_documents=retrieved_docs,
                generated_response=response,
                response_time_ms=response_time_ms,
                confidence_score=confidence
            )
            db.add(interaction)
            await db.commit()
        except Exception as e:
            logger.error(f"Error logging RAG interaction: {str(e)}")
            await db.rollback()
</file>

<file path="backend/app/services/smart_community_service.py">
"""Smart community matching service for connecting plant enthusiasts."""
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func
from sqlalchemy.orm import selectinload
from app.models.user import User
from app.models.user_plant import UserPlant
from app.models.plant_question import PlantQuestion, PlantAnswer
from app.models.plant_trade import PlantTrade
from app.services.vector_database_service import VectorDatabaseService
logger = logging.getLogger(__name__)
@dataclass
class UserMatch:
    """A matched user with similarity details."""
    user_id: str
    username: str
    display_name: Optional[str]
    similarity_score: float
    matching_factors: List[str]
    shared_interests: List[str]
    expertise_areas: List[str]
    location_match: bool
@dataclass
class ExpertRecommendation:
    """Expert user recommendation for specific plant questions."""
    user_id: str
    username: str
    expertise_score: float
    relevant_experience: List[str]
    success_rate: float
    response_time_avg: int
class SmartCommunityService:
    """Service for intelligent community matching and recommendations."""
    def __init__(self, vector_service: VectorDatabaseService):
        self.vector_service = vector_service
    async def find_similar_users(
        self,
        db: AsyncSession,
        user_id: str,
        limit: int = 10
    ) -> List[UserMatch]:
        """Find users with similar plant interests."""
        try:
            # Get target user context
            target_user = await self._get_user_context(db, user_id)
            if not target_user:
                return []
            # Find similar users using vector similarity
            similar_users = await self.vector_service.find_similar_users(
                db=db,
                user_id=user_id,
                preference_types=["plant_interests"],
                limit=limit
            )
            # Convert to UserMatch objects
            matches = []
            for similar_user in similar_users:
                user_context = await self._get_user_context(db, similar_user["id"])
                if user_context:
                    match = self._build_user_match(target_user, user_context, similar_user["similarity_score"])
                    if match:
                        matches.append(match)
            return matches
        except Exception as e:
            logger.error(f"Error finding similar users: {str(e)}")
            return []
    async def recommend_plant_experts(
        self,
        db: AsyncSession,
        plant_species_id: str,
        limit: int = 5
    ) -> List[ExpertRecommendation]:
        """Recommend expert users for plant questions."""
        try:
            # Find users with this plant species
            stmt = select(UserPlant, User).join(User).where(
                UserPlant.species_id == plant_species_id
            )
            result = await db.execute(stmt)
            user_plants = result.fetchall()
            experts = []
            for user_plant, user in user_plants:
                # Calculate expertise score
                expertise_score = 0.5
                if user_plant.health_status in ["healthy", "thriving"]:
                    expertise_score += 0.3
                if user_plant.date_acquired:
                    days_owned = (datetime.utcnow() - user_plant.date_acquired).days
                    if days_owned > 365:
                        expertise_score += 0.2
                expert = ExpertRecommendation(
                    user_id=str(user.id),
                    username=user.username,
                    expertise_score=min(1.0, expertise_score),
                    relevant_experience=["plant_care"],
                    success_rate=0.8 if user_plant.health_status in ["healthy", "thriving"] else 0.6,
                    response_time_avg=24
                )
                experts.append(expert)
            # Sort by expertise score
            experts.sort(key=lambda x: x.expertise_score, reverse=True)
            return experts[:limit]
        except Exception as e:
            logger.error(f"Error recommending experts: {str(e)}")
            return []
    async def find_trading_matches(
        self,
        db: AsyncSession,
        user_id: str,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Find compatible users for plant trading."""
        try:
            # Get user's plants for trading context
            user_plants_stmt = select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(UserPlant.user_id == user_id)
            user_plants_result = await db.execute(user_plants_stmt)
            user_plants = user_plants_result.scalars().all()
            # Find other users with active trades
            trades_stmt = select(PlantTrade, User).join(User).where(
                and_(
                    PlantTrade.trader_id != user_id,
                    PlantTrade.status == "available"
                )
            ).limit(limit)
            trades_result = await db.execute(trades_stmt)
            potential_trades = trades_result.fetchall()
            trading_matches = []
            for trade, trader in potential_trades:
                match = {
                    "user_id": str(trader.id),
                    "username": trader.username,
                    "trade_id": str(trade.id),
                    "plant_name": trade.plant_name,
                    "trade_type": trade.trade_type,
                    "location": trader.location,
                    "compatibility_score": 0.8  # Simplified scoring
                }
                trading_matches.append(match)
            return trading_matches
        except Exception as e:
            logger.error(f"Error finding trading matches: {str(e)}")
            return []
    async def discover_local_community(
        self,
        db: AsyncSession,
        user_id: str,
        limit: int = 15
    ) -> List[UserMatch]:
        """Discover local plant community members."""
        try:
            # Get user location
            user_stmt = select(User).where(User.id == user_id)
            result = await db.execute(user_stmt)
            user = result.scalar_one_or_none()
            if not user or not user.location:
                return []
            # Find users in similar location (simplified)
            location_filter = user.location.lower()
            local_users_stmt = select(User).where(
                and_(
                    User.id != user_id,
                    func.lower(User.location).contains(location_filter)
                )
            ).limit(limit)
            result = await db.execute(local_users_stmt)
            local_users = result.scalars().all()
            # Build matches
            local_matches = []
            for local_user in local_users:
                user_context = await self._get_user_context(db, str(local_user.id))
                target_context = await self._get_user_context(db, user_id)
                if user_context and target_context:
                    similarity_score = self._calculate_interest_similarity(target_context, user_context)
                    if similarity_score > 0.3:
                        match = UserMatch(
                            user_id=str(local_user.id),
                            username=local_user.username,
                            display_name=local_user.display_name,
                            similarity_score=similarity_score,
                            matching_factors=["location"],
                            shared_interests=self._find_shared_interests(target_context, user_context),
                            expertise_areas=[],
                            location_match=True
                        )
                        local_matches.append(match)
            return local_matches
        except Exception as e:
            logger.error(f"Error discovering local community: {str(e)}")
            return []
    async def _get_user_context(self, db: AsyncSession, user_id: str) -> Optional[Dict[str, Any]]:
        """Get user context for matching."""
        try:
            # Get user
            user_stmt = select(User).where(User.id == user_id)
            user_result = await db.execute(user_stmt)
            user = user_result.scalar_one_or_none()
            if not user:
                return None
            # Get user's plants
            plants_stmt = select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(UserPlant.user_id == user_id)
            plants_result = await db.execute(plants_stmt)
            plants = plants_result.scalars().all()
            return {
                "user": user,
                "plants": plants,
                "plant_species": [plant.species.scientific_name for plant in plants],
                "experience_level": user.gardening_experience
            }
        except Exception as e:
            logger.error(f"Error getting user context: {str(e)}")
            return None
    def _build_user_match(
        self,
        target_user: Dict[str, Any],
        candidate_user: Dict[str, Any],
        base_similarity: float
    ) -> Optional[UserMatch]:
        """Build user match object."""
        try:
            matching_factors = []
            shared_interests = []
            # Check plant species overlap
            target_species = set(target_user["plant_species"])
            candidate_species = set(candidate_user["plant_species"])
            common_species = target_species.intersection(candidate_species)
            if common_species:
                matching_factors.append("plant_species")
                shared_interests.extend(list(common_species))
            # Experience level matching
            if target_user["experience_level"] == candidate_user["experience_level"]:
                matching_factors.append("experience_level")
            return UserMatch(
                user_id=str(candidate_user["user"].id),
                username=candidate_user["user"].username,
                display_name=candidate_user["user"].display_name,
                similarity_score=base_similarity,
                matching_factors=matching_factors,
                shared_interests=shared_interests,
                expertise_areas=[],
                location_match=False
            )
        except Exception as e:
            logger.error(f"Error building user match: {str(e)}")
            return None
    def _calculate_interest_similarity(
        self,
        user1_context: Dict[str, Any],
        user2_context: Dict[str, Any]
    ) -> float:
        """Calculate plant interest similarity between users."""
        species1 = set(user1_context.get("plant_species", []))
        species2 = set(user2_context.get("plant_species", []))
        if not species1 or not species2:
            return 0.3
        # Jaccard similarity
        intersection = len(species1.intersection(species2))
        union = len(species1.union(species2))
        if union == 0:
            return 0.3
        return intersection / union
    def _find_shared_interests(
        self,
        user1_context: Dict[str, Any],
        user2_context: Dict[str, Any]
    ) -> List[str]:
        """Find shared plant interests between users."""
        species1 = set(user1_context.get("plant_species", []))
        species2 = set(user2_context.get("plant_species", []))
        return list(species1.intersection(species2))
</file>

<file path="backend/app/services/vector_database_service.py">
"""Vector database service for semantic search and similarity matching."""
import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, text
from sqlalchemy.orm import selectinload
from app.models.rag_models import PlantContentEmbedding, UserPreferenceEmbedding, PlantKnowledgeBase
from app.models.plant_species import PlantSpecies
from app.models.user import User
from app.services.embedding_service import EmbeddingService
logger = logging.getLogger(__name__)
class VectorDatabaseService:
    """Service for vector similarity search and retrieval."""
    def __init__(self, embedding_service: EmbeddingService):
        self.embedding_service = embedding_service
    async def similarity_search(
        self,
        db: AsyncSession,
        query_embedding: List[float],
        content_types: Optional[List[str]] = None,
        filters: Optional[Dict[str, Any]] = None,
        limit: int = 10,
        similarity_threshold: float = 0.7
    ) -> List[Dict[str, Any]]:
        """Perform similarity search across plant content embeddings.
        Args:
            db: Database session
            query_embedding: Query embedding vector
            content_types: Filter by content types
            filters: Additional filters (species, difficulty, season, etc.)
            limit: Maximum number of results
            similarity_threshold: Minimum similarity score
        Returns:
            List of similar content with metadata
        """
        try:
            # Build base query with similarity calculation
            similarity_expr = func.cosine_similarity(
                PlantContentEmbedding.embedding,
                query_embedding
            )
            stmt = select(
                PlantContentEmbedding,
                similarity_expr.label('similarity_score')
            ).where(
                similarity_expr > similarity_threshold
            )
            # Apply content type filters
            if content_types:
                stmt = stmt.where(PlantContentEmbedding.content_type.in_(content_types))
            # Apply metadata filters
            if filters:
                metadata_conditions = []
                for key, value in filters.items():
                    if isinstance(value, list):
                        # JSON array contains any of the values
                        metadata_conditions.append(
                            PlantContentEmbedding.meta_data[key].astext.in_(value)
                        )
                    else:
                        # Exact match
                        metadata_conditions.append(
                            PlantContentEmbedding.meta_data[key].astext == str(value)
                        )
                if metadata_conditions:
                    stmt = stmt.where(and_(*metadata_conditions))
            # Order by similarity and limit
            stmt = stmt.order_by(similarity_expr.desc()).limit(limit)
            result = await db.execute(stmt)
            rows = result.fetchall()
            # Convert to list of dictionaries
            results = []
            for embedding, similarity_score in rows:
                result_dict = {
                    'id': str(embedding.id),
                    'content_type': embedding.content_type,
                    'content_id': str(embedding.content_id),
                    'metadata': embedding.meta_data,
                    'similarity_score': float(similarity_score),
                    'created_at': embedding.created_at.isoformat()
                }
                results.append(result_dict)
            logger.info(f"Found {len(results)} similar content items")
            return results
        except Exception as e:
            logger.error(f"Error performing similarity search: {str(e)}")
            raise
    async def search_plant_knowledge(
        self,
        db: AsyncSession,
        query: str,
        plant_species_id: Optional[str] = None,
        difficulty_level: Optional[str] = None,
        season: Optional[str] = None,
        content_types: Optional[List[str]] = None,
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        """Search plant knowledge base using semantic similarity.
        Args:
            db: Database session
            query: Search query text
            plant_species_id: Filter by plant species
            difficulty_level: Filter by difficulty level
            season: Filter by season
            content_types: Filter by content types
            limit: Maximum number of results
        Returns:
            List of relevant knowledge base entries
        """
        try:
            # Generate query embedding
            query_embedding = await self.embedding_service.generate_text_embedding(query)
            # Build filters
            filters = {}
            if plant_species_id:
                filters['plant_species_id'] = plant_species_id
            if difficulty_level:
                filters['difficulty_level'] = difficulty_level
            if season:
                filters['season'] = season
            # Search embeddings
            embedding_results = await self.similarity_search(
                db=db,
                query_embedding=query_embedding,
                content_types=content_types or ['care_guide', 'species_info', 'technique', 'problem_solution'],
                filters=filters,
                limit=limit
            )
            # Get full knowledge base entries
            knowledge_entries = []
            for embedding_result in embedding_results:
                content_id = embedding_result['content_id']
                stmt = select(PlantKnowledgeBase).options(
                    selectinload(PlantKnowledgeBase.plant_species)
                ).where(PlantKnowledgeBase.id == content_id)
                result = await db.execute(stmt)
                knowledge_entry = result.scalar_one_or_none()
                if knowledge_entry:
                    entry_dict = {
                        'id': str(knowledge_entry.id),
                        'title': knowledge_entry.title,
                        'content': knowledge_entry.content,
                        'content_type': knowledge_entry.content_type,
                        'difficulty_level': knowledge_entry.difficulty_level,
                        'season': knowledge_entry.season,
                        'tags': knowledge_entry.tags,
                        'plant_species': {
                            'id': str(knowledge_entry.plant_species.id),
                            'scientific_name': knowledge_entry.plant_species.scientific_name,
                            'common_names': knowledge_entry.plant_species.common_names
                        } if knowledge_entry.plant_species else None,
                        'similarity_score': embedding_result['similarity_score'],
                        'verified': knowledge_entry.verified,
                        'helpful_count': knowledge_entry.helpful_count
                    }
                    knowledge_entries.append(entry_dict)
            logger.info(f"Retrieved {len(knowledge_entries)} knowledge base entries for query")
            return knowledge_entries
        except Exception as e:
            logger.error(f"Error searching plant knowledge: {str(e)}")
            raise
    async def find_similar_users(
        self,
        db: AsyncSession,
        user_id: str,
        preference_types: Optional[List[str]] = None,
        limit: int = 10,
        similarity_threshold: float = 0.6
    ) -> List[Dict[str, Any]]:
        """Find users with similar plant preferences.
        Args:
            db: Database session
            user_id: Target user ID
            preference_types: Types of preferences to compare
            limit: Maximum number of similar users
            similarity_threshold: Minimum similarity score
        Returns:
            List of similar users with similarity scores
        """
        try:
            # Get target user's preference embeddings
            target_prefs_stmt = select(UserPreferenceEmbedding).where(
                UserPreferenceEmbedding.user_id == user_id
            )
            if preference_types:
                target_prefs_stmt = target_prefs_stmt.where(
                    UserPreferenceEmbedding.preference_type.in_(preference_types)
                )
            target_result = await db.execute(target_prefs_stmt)
            target_preferences = target_result.scalars().all()
            if not target_preferences:
                logger.info(f"No preferences found for user {user_id}")
                return []
            # Find similar users for each preference type
            similar_users = {}
            for target_pref in target_preferences:
                # Calculate similarity with other users' preferences of the same type
                similarity_expr = func.cosine_similarity(
                    UserPreferenceEmbedding.embedding,
                    target_pref.embedding
                )
                stmt = select(
                    UserPreferenceEmbedding.user_id,
                    similarity_expr.label('similarity_score')
                ).where(
                    and_(
                        UserPreferenceEmbedding.user_id != user_id,
                        UserPreferenceEmbedding.preference_type == target_pref.preference_type,
                        similarity_expr > similarity_threshold
                    )
                ).order_by(similarity_expr.desc()).limit(limit * 2)  # Get more to deduplicate
                result = await db.execute(stmt)
                rows = result.fetchall()
                # Aggregate scores by user
                for similar_user_id, score in rows:
                    if similar_user_id not in similar_users:
                        similar_users[similar_user_id] = []
                    similar_users[similar_user_id].append(float(score))
            # Calculate average similarity scores
            user_similarities = []
            for similar_user_id, scores in similar_users.items():
                avg_score = sum(scores) / len(scores)
                user_similarities.append((similar_user_id, avg_score))
            # Sort by average similarity and limit
            user_similarities.sort(key=lambda x: x[1], reverse=True)
            user_similarities = user_similarities[:limit]
            # Get user details
            similar_users_list = []
            for similar_user_id, similarity_score in user_similarities:
                user_stmt = select(User).where(User.id == similar_user_id)
                user_result = await db.execute(user_stmt)
                user = user_result.scalar_one_or_none()
                if user:
                    user_dict = {
                        'id': str(user.id),
                        'username': user.username,
                        'display_name': user.display_name,
                        'gardening_experience': user.gardening_experience,
                        'location': user.location,
                        'similarity_score': similarity_score
                    }
                    similar_users_list.append(user_dict)
            logger.info(f"Found {len(similar_users_list)} similar users for user {user_id}")
            return similar_users_list
        except Exception as e:
            logger.error(f"Error finding similar users: {str(e)}")
            raise
    async def get_personalized_recommendations(
        self,
        db: AsyncSession,
        user_id: str,
        recommendation_type: str = "general",
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get personalized content recommendations based on user preferences.
        Args:
            db: Database session
            user_id: User ID
            recommendation_type: Type of recommendations
            limit: Maximum number of recommendations
        Returns:
            List of personalized recommendations
        """
        try:
            # Get user's preference embeddings
            prefs_stmt = select(UserPreferenceEmbedding).where(
                UserPreferenceEmbedding.user_id == user_id
            )
            prefs_result = await db.execute(prefs_stmt)
            user_preferences = prefs_result.scalars().all()
            if not user_preferences:
                # Return popular content if no preferences
                return await self._get_popular_content(db, limit)
            # Combine user preference embeddings (weighted average)
            combined_embedding = self._combine_embeddings([
                (pref.embedding, pref.confidence_score or 1.0) 
                for pref in user_preferences
            ])
            # Search for similar content
            recommendations = await self.similarity_search(
                db=db,
                query_embedding=combined_embedding,
                content_types=['care_guide', 'species_info', 'technique'],
                limit=limit,
                similarity_threshold=0.5
            )
            logger.info(f"Generated {len(recommendations)} personalized recommendations for user {user_id}")
            return recommendations
        except Exception as e:
            logger.error(f"Error getting personalized recommendations: {str(e)}")
            raise
    async def index_content(
        self,
        db: AsyncSession,
        content_id: str,
        content_type: str,
        text_content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> PlantContentEmbedding:
        """Index new content for vector search.
        Args:
            db: Database session
            content_id: Content ID
            content_type: Type of content
            text_content: Text to index
            metadata: Additional metadata
        Returns:
            Created embedding record
        """
        try:
            return await self.embedding_service.store_content_embedding(
                db=db,
                content_type=content_type,
                content_id=content_id,
                text=text_content,
                metadata=metadata
            )
        except Exception as e:
            logger.error(f"Error indexing content: {str(e)}")
            raise
    def _combine_embeddings(self, embeddings_with_weights: List[Tuple[List[float], float]]) -> List[float]:
        """Combine multiple embeddings using weighted average.
        Args:
            embeddings_with_weights: List of (embedding, weight) tuples
        Returns:
            Combined embedding vector
        """
        if not embeddings_with_weights:
            return [0.0] * self.embedding_service.embedding_dimension
        # Calculate weighted average
        total_weight = sum(weight for _, weight in embeddings_with_weights)
        if total_weight == 0:
            total_weight = 1.0
        combined = [0.0] * len(embeddings_with_weights[0][0])
        for embedding, weight in embeddings_with_weights:
            normalized_weight = weight / total_weight
            for i, value in enumerate(embedding):
                combined[i] += value * normalized_weight
        return combined
    async def _get_popular_content(self, db: AsyncSession, limit: int) -> List[Dict[str, Any]]:
        """Get popular content as fallback recommendations.
        Args:
            db: Database session
            limit: Maximum number of results
        Returns:
            List of popular content items
        """
        try:
            stmt = select(PlantKnowledgeBase).where(
                PlantKnowledgeBase.verified == 'verified'
            ).order_by(
                PlantKnowledgeBase.helpful_count.desc(),
                PlantKnowledgeBase.view_count.desc()
            ).limit(limit)
            result = await db.execute(stmt)
            popular_entries = result.scalars().all()
            popular_content = []
            for entry in popular_entries:
                content_dict = {
                    'id': str(entry.id),
                    'title': entry.title,
                    'content': entry.content,
                    'content_type': entry.content_type,
                    'helpful_count': entry.helpful_count,
                    'view_count': entry.view_count,
                    'similarity_score': 0.5  # Default score for popular content
                }
                popular_content.append(content_dict)
            return popular_content
        except Exception as e:
            logger.error(f"Error getting popular content: {str(e)}")
            return []
</file>

<file path="backend/Dockerfile.postgres">
FROM postgres:15

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    git \
    postgresql-server-dev-15 \
    && rm -rf /var/lib/apt/lists/*

# Clone and install pgvector
RUN git clone --branch v0.5.1 https://github.com/pgvector/pgvector.git \
    && cd pgvector \
    && make \
    && make install

# Add initialization script
COPY database/init.sql /docker-entrypoint-initdb.d/
</file>

<file path="backend/scripts/enable_pgvector.sql">
-- Enable pgvector extension for vector similarity search
-- This script should be run by a database administrator or user with appropriate privileges
-- Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;
-- Verify the extension is installed
SELECT extname, extversion FROM pg_extension WHERE extname = 'vector';
</file>

<file path="backend/scripts/seed_plant_knowledge.py">
"""Seed script for plant knowledge base."""
import asyncio
import json
from datetime import datetime
from uuid import uuid4
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.database import AsyncSessionLocal
from app.models.plant_species import PlantSpecies
from app.models.rag_models import PlantKnowledgeBase
from app.services.embedding_service import EmbeddingService
from app.services.vector_database_service import VectorDatabaseService
# Sample plant knowledge data
PLANT_KNOWLEDGE_DATA = [
    {
        "title": "Monstera Deliciosa Care Guide",
        "content": "Monstera deliciosa, also known as the Swiss Cheese Plant, is a popular houseplant known for its distinctive split leaves. It thrives in bright, indirect light and prefers well-draining soil. Water when the top inch of soil feels dry, typically every 1-2 weeks. This plant loves humidity and benefits from regular misting. During growing season (spring and summer), feed monthly with a balanced liquid fertilizer. Monstera can grow quite large indoors, reaching 6-8 feet tall. Support with a moss pole for best results. Common problems include yellowing leaves (overwatering) and brown leaf tips (low humidity or fluoride in water).",
        "content_type": "care_guide",
        "difficulty_level": "intermediate",
        "season": "year_round",
        "tags": ["houseplant", "tropical", "climbing", "low_light_tolerant"],
        "source": "expert"
    },
    {
        "title": "Snake Plant (Sansevieria) Beginner Care",
        "content": "Snake plants are perfect for beginners due to their low maintenance requirements. They tolerate low light conditions but prefer bright, indirect light. Water sparingly - only when soil is completely dry, usually every 2-3 weeks in growing season and less in winter. Overwatering is the most common cause of death. Use well-draining cactus soil mix. Snake plants are extremely drought tolerant and can survive weeks without water. They prefer temperatures between 70-90F and low humidity. Fertilize sparingly, only 2-3 times during growing season. Propagate by leaf cuttings or division.",
        "content_type": "care_guide",
        "difficulty_level": "beginner",
        "season": "year_round",
        "tags": ["houseplant", "low_maintenance", "drought_tolerant", "air_purifying"],
        "source": "expert"
    },
    {
        "title": "Fiddle Leaf Fig Common Problems",
        "content": "Fiddle leaf figs are notorious for being finicky. Brown spots on leaves usually indicate overwatering or bacterial infection - reduce watering and ensure good drainage. Dropping leaves can be caused by sudden changes in light, temperature, or watering schedule - maintain consistency. Yellow leaves typically mean overwatering, while brown crispy edges suggest underwatering or low humidity. Fiddle leaf figs hate being moved, so find a good spot and leave them there. They need bright, indirect light and consistent watering when top 2 inches of soil are dry. Dust leaves regularly for optimal photosynthesis.",
        "content_type": "problem_solution",
        "difficulty_level": "advanced",
        "season": "year_round",
        "tags": ["houseplant", "finicky", "common_problems", "troubleshooting"],
        "source": "expert"
    },
    {
        "title": "Pothos Propagation Techniques",
        "content": "Pothos is one of the easiest plants to propagate. For water propagation: cut a 4-6 inch stem with at least 2 nodes, remove lower leaves, place in water, and change water every few days. Roots will develop in 1-2 weeks. For soil propagation: take cuttings with nodes, dip in rooting hormone (optional), plant in moist potting mix, and keep soil consistently moist but not soggy. Pothos can also be propagated by division when repotting. The best time to propagate is during growing season (spring/summer). New plants will be identical to the parent plant.",
        "content_type": "technique",
        "difficulty_level": "beginner",
        "season": "spring",
        "tags": ["propagation", "houseplant", "easy", "water_propagation"],
        "source": "expert"
    },
    {
        "title": "Winter Plant Care Adjustments",
        "content": "During winter months, most houseplants enter a dormant period and require adjusted care. Reduce watering frequency as plants use less water in lower light and cooler temperatures. Stop or reduce fertilizing from October through February as plants aren't actively growing. Increase humidity around plants as indoor heating can dry the air. Move plants closer to windows for maximum light exposure, but away from cold drafts and heating vents. Some plants may drop leaves naturally - this is normal. Avoid repotting during winter unless absolutely necessary. Monitor for pests more closely as dry indoor air can stress plants and make them more susceptible.",
        "content_type": "care_guide",
        "difficulty_level": "intermediate",
        "season": "winter",
        "tags": ["seasonal_care", "winter", "dormancy", "houseplant"],
        "source": "expert"
    },
    {
        "title": "Spider Plant Care and Benefits",
        "content": "Spider plants (Chlorophytum comosum) are excellent air-purifying houseplants that are nearly impossible to kill. They thrive in bright, indirect light but tolerate various lighting conditions. Water when soil surface feels dry, typically weekly. Spider plants prefer temperatures between 65-75F and moderate humidity. They produce plantlets (babies) on long stolons that can be propagated easily. These plants are non-toxic to pets and children. NASA studies show spider plants remove formaldehyde and xylene from indoor air. Brown leaf tips usually indicate fluoride in water - use distilled water if this occurs. Fertilize monthly during growing season.",
        "content_type": "species_info",
        "difficulty_level": "beginner",
        "season": "year_round",
        "tags": ["air_purifying", "pet_safe", "easy_care", "propagation"],
        "source": "research"
    }
]
async def get_or_create_species(db: AsyncSession, common_name: str, scientific_name: str) -> PlantSpecies:
    """Get existing species or create a new one."""
    stmt = select(PlantSpecies).where(PlantSpecies.scientific_name == scientific_name)
    result = await db.execute(stmt)
    species = result.scalar_one_or_none()
    if not species:
        species = PlantSpecies(
            scientific_name=scientific_name,
            common_names=[common_name],
            care_level="intermediate"
        )
        db.add(species)
        await db.commit()
        await db.refresh(species)
    return species
async def seed_plant_knowledge():
    """Seed the plant knowledge base with initial data."""
    print("Starting plant knowledge seeding...")
    embedding_service = EmbeddingService()
    vector_service = VectorDatabaseService(embedding_service)
    async with AsyncSessionLocal() as db:
        try:
            # Create some basic plant species if they don't exist
            species_mapping = {
                "Monstera Deliciosa": ("Monstera deliciosa", "Monstera deliciosa"),
                "Snake Plant": ("Sansevieria trifasciata", "Snake Plant"),
                "Fiddle Leaf Fig": ("Ficus lyrata", "Fiddle Leaf Fig"),
                "Pothos": ("Epipremnum aureum", "Golden Pothos"),
                "Spider Plant": ("Chlorophytum comosum", "Spider Plant")
            }
            species_dict = {}
            for common, (scientific, display) in species_mapping.items():
                species = await get_or_create_species(db, display, scientific)
                species_dict[common] = species
            # Create knowledge base entries
            for knowledge_data in PLANT_KNOWLEDGE_DATA:
                # Determine plant species for this knowledge entry
                plant_species = None
                title = knowledge_data["title"]
                for species_name, species in species_dict.items():
                    if species_name.lower() in title.lower():
                        plant_species = species
                        break
                # Create knowledge base entry
                knowledge_entry = PlantKnowledgeBase(
                    title=knowledge_data["title"],
                    content=knowledge_data["content"],
                    content_type=knowledge_data["content_type"],
                    plant_species_id=plant_species.id if plant_species else None,
                    difficulty_level=knowledge_data["difficulty_level"],
                    season=knowledge_data["season"],
                    climate_zones=["temperate", "subtropical"],  # Default zones
                    tags=knowledge_data["tags"],
                    source=knowledge_data["source"],
                    verified="verified"
                )
                db.add(knowledge_entry)
                await db.commit()
                await db.refresh(knowledge_entry)
                # Create embedding for the knowledge entry
                content_for_embedding = f"{knowledge_entry.title}. {knowledge_entry.content}"
                metadata = {
                    "plant_species_id": str(plant_species.id) if plant_species else None,
                    "difficulty_level": knowledge_entry.difficulty_level,
                    "season": knowledge_entry.season,
                    "content_type": knowledge_entry.content_type,
                    "tags": knowledge_entry.tags
                }
                await vector_service.index_content(
                    db=db,
                    content_id=str(knowledge_entry.id),
                    content_type=knowledge_entry.content_type,
                    text_content=content_for_embedding,
                    metadata=metadata
                )
                print(f"Created knowledge entry: {knowledge_entry.title}")
            print(f"Successfully seeded {len(PLANT_KNOWLEDGE_DATA)} knowledge base entries!")
        except Exception as e:
            print(f"Error seeding plant knowledge: {str(e)}")
            await db.rollback()
            raise
if __name__ == "__main__":
    asyncio.run(seed_plant_knowledge())
</file>

<file path="frontend/lib/features/auth/models/auth_models.freezed.dart">
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
part of 'auth_models.dart';
// **************************************************************************
// FreezedGenerator
// **************************************************************************
T _$identity<T>(T value) => value;
final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');
LoginRequest _$LoginRequestFromJson(Map<String, dynamic> json) {
  return _LoginRequest.fromJson(json);
}
/// @nodoc
mixin _$LoginRequest {
  String get email => throw _privateConstructorUsedError;
  String get password => throw _privateConstructorUsedError;
  /// Serializes this LoginRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of LoginRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LoginRequestCopyWith<LoginRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $LoginRequestCopyWith<$Res> {
  factory $LoginRequestCopyWith(
          LoginRequest value, $Res Function(LoginRequest) then) =
      _$LoginRequestCopyWithImpl<$Res, LoginRequest>;
  @useResult
  $Res call({String email, String password});
}
/// @nodoc
class _$LoginRequestCopyWithImpl<$Res, $Val extends LoginRequest>
    implements $LoginRequestCopyWith<$Res> {
  _$LoginRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of LoginRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_value.copyWith(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$LoginRequestImplCopyWith<$Res>
    implements $LoginRequestCopyWith<$Res> {
  factory _$$LoginRequestImplCopyWith(
          _$LoginRequestImpl value, $Res Function(_$LoginRequestImpl) then) =
      __$$LoginRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String email, String password});
}
/// @nodoc
class __$$LoginRequestImplCopyWithImpl<$Res>
    extends _$LoginRequestCopyWithImpl<$Res, _$LoginRequestImpl>
    implements _$$LoginRequestImplCopyWith<$Res> {
  __$$LoginRequestImplCopyWithImpl(
      _$LoginRequestImpl _value, $Res Function(_$LoginRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of LoginRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(_$LoginRequestImpl(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$LoginRequestImpl implements _LoginRequest {
  const _$LoginRequestImpl({required this.email, required this.password});
  factory _$LoginRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$LoginRequestImplFromJson(json);
  @override
  final String email;
  @override
  final String password;
  @override
  String toString() {
    return 'LoginRequest(email: $email, password: $password)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginRequestImpl &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);
  /// Create a copy of LoginRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoginRequestImplCopyWith<_$LoginRequestImpl> get copyWith =>
      __$$LoginRequestImplCopyWithImpl<_$LoginRequestImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$LoginRequestImplToJson(
      this,
    );
  }
}
abstract class _LoginRequest implements LoginRequest {
  const factory _LoginRequest(
      {required final String email,
      required final String password}) = _$LoginRequestImpl;
  factory _LoginRequest.fromJson(Map<String, dynamic> json) =
      _$LoginRequestImpl.fromJson;
  @override
  String get email;
  @override
  String get password;
  /// Create a copy of LoginRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoginRequestImplCopyWith<_$LoginRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
RegisterRequest _$RegisterRequestFromJson(Map<String, dynamic> json) {
  return _RegisterRequest.fromJson(json);
}
/// @nodoc
mixin _$RegisterRequest {
  String get email => throw _privateConstructorUsedError;
  String get username => throw _privateConstructorUsedError;
  String get password => throw _privateConstructorUsedError;
  String get confirmPassword => throw _privateConstructorUsedError;
  String? get displayName => throw _privateConstructorUsedError;
  String? get inviteCode => throw _privateConstructorUsedError;
  /// Serializes this RegisterRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of RegisterRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RegisterRequestCopyWith<RegisterRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $RegisterRequestCopyWith<$Res> {
  factory $RegisterRequestCopyWith(
          RegisterRequest value, $Res Function(RegisterRequest) then) =
      _$RegisterRequestCopyWithImpl<$Res, RegisterRequest>;
  @useResult
  $Res call(
      {String email,
      String username,
      String password,
      String confirmPassword,
      String? displayName,
      String? inviteCode});
}
/// @nodoc
class _$RegisterRequestCopyWithImpl<$Res, $Val extends RegisterRequest>
    implements $RegisterRequestCopyWith<$Res> {
  _$RegisterRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of RegisterRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? username = null,
    Object? password = null,
    Object? confirmPassword = null,
    Object? displayName = freezed,
    Object? inviteCode = freezed,
  }) {
    return _then(_value.copyWith(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      inviteCode: freezed == inviteCode
          ? _value.inviteCode
          : inviteCode // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$RegisterRequestImplCopyWith<$Res>
    implements $RegisterRequestCopyWith<$Res> {
  factory _$$RegisterRequestImplCopyWith(_$RegisterRequestImpl value,
          $Res Function(_$RegisterRequestImpl) then) =
      __$$RegisterRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String email,
      String username,
      String password,
      String confirmPassword,
      String? displayName,
      String? inviteCode});
}
/// @nodoc
class __$$RegisterRequestImplCopyWithImpl<$Res>
    extends _$RegisterRequestCopyWithImpl<$Res, _$RegisterRequestImpl>
    implements _$$RegisterRequestImplCopyWith<$Res> {
  __$$RegisterRequestImplCopyWithImpl(
      _$RegisterRequestImpl _value, $Res Function(_$RegisterRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of RegisterRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
    Object? username = null,
    Object? password = null,
    Object? confirmPassword = null,
    Object? displayName = freezed,
    Object? inviteCode = freezed,
  }) {
    return _then(_$RegisterRequestImpl(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      username: null == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      inviteCode: freezed == inviteCode
          ? _value.inviteCode
          : inviteCode // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$RegisterRequestImpl implements _RegisterRequest {
  const _$RegisterRequestImpl(
      {required this.email,
      required this.username,
      required this.password,
      required this.confirmPassword,
      this.displayName,
      this.inviteCode});
  factory _$RegisterRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$RegisterRequestImplFromJson(json);
  @override
  final String email;
  @override
  final String username;
  @override
  final String password;
  @override
  final String confirmPassword;
  @override
  final String? displayName;
  @override
  final String? inviteCode;
  @override
  String toString() {
    return 'RegisterRequest(email: $email, username: $username, password: $password, confirmPassword: $confirmPassword, displayName: $displayName, inviteCode: $inviteCode)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RegisterRequestImpl &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.confirmPassword, confirmPassword) ||
                other.confirmPassword == confirmPassword) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.inviteCode, inviteCode) ||
                other.inviteCode == inviteCode));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, username, password,
      confirmPassword, displayName, inviteCode);
  /// Create a copy of RegisterRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RegisterRequestImplCopyWith<_$RegisterRequestImpl> get copyWith =>
      __$$RegisterRequestImplCopyWithImpl<_$RegisterRequestImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$RegisterRequestImplToJson(
      this,
    );
  }
}
abstract class _RegisterRequest implements RegisterRequest {
  const factory _RegisterRequest(
      {required final String email,
      required final String username,
      required final String password,
      required final String confirmPassword,
      final String? displayName,
      final String? inviteCode}) = _$RegisterRequestImpl;
  factory _RegisterRequest.fromJson(Map<String, dynamic> json) =
      _$RegisterRequestImpl.fromJson;
  @override
  String get email;
  @override
  String get username;
  @override
  String get password;
  @override
  String get confirmPassword;
  @override
  String? get displayName;
  @override
  String? get inviteCode;
  /// Create a copy of RegisterRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RegisterRequestImplCopyWith<_$RegisterRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
AuthResponse _$AuthResponseFromJson(Map<String, dynamic> json) {
  return _AuthResponse.fromJson(json);
}
/// @nodoc
mixin _$AuthResponse {
  String get accessToken => throw _privateConstructorUsedError;
  String get refreshToken => throw _privateConstructorUsedError;
  User get user => throw _privateConstructorUsedError;
  String? get tokenType => throw _privateConstructorUsedError;
  int? get expiresIn => throw _privateConstructorUsedError;
  /// Serializes this AuthResponse to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthResponseCopyWith<AuthResponse> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $AuthResponseCopyWith<$Res> {
  factory $AuthResponseCopyWith(
          AuthResponse value, $Res Function(AuthResponse) then) =
      _$AuthResponseCopyWithImpl<$Res, AuthResponse>;
  @useResult
  $Res call(
      {String accessToken,
      String refreshToken,
      User user,
      String? tokenType,
      int? expiresIn});
  $UserCopyWith<$Res> get user;
}
/// @nodoc
class _$AuthResponseCopyWithImpl<$Res, $Val extends AuthResponse>
    implements $AuthResponseCopyWith<$Res> {
  _$AuthResponseCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accessToken = null,
    Object? refreshToken = null,
    Object? user = null,
    Object? tokenType = freezed,
    Object? expiresIn = freezed,
  }) {
    return _then(_value.copyWith(
      accessToken: null == accessToken
          ? _value.accessToken
          : accessToken // ignore: cast_nullable_to_non_nullable
              as String,
      refreshToken: null == refreshToken
          ? _value.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresIn: freezed == expiresIn
          ? _value.expiresIn
          : expiresIn // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get user {
    return $UserCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$AuthResponseImplCopyWith<$Res>
    implements $AuthResponseCopyWith<$Res> {
  factory _$$AuthResponseImplCopyWith(
          _$AuthResponseImpl value, $Res Function(_$AuthResponseImpl) then) =
      __$$AuthResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String accessToken,
      String refreshToken,
      User user,
      String? tokenType,
      int? expiresIn});
  @override
  $UserCopyWith<$Res> get user;
}
/// @nodoc
class __$$AuthResponseImplCopyWithImpl<$Res>
    extends _$AuthResponseCopyWithImpl<$Res, _$AuthResponseImpl>
    implements _$$AuthResponseImplCopyWith<$Res> {
  __$$AuthResponseImplCopyWithImpl(
      _$AuthResponseImpl _value, $Res Function(_$AuthResponseImpl) _then)
      : super(_value, _then);
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accessToken = null,
    Object? refreshToken = null,
    Object? user = null,
    Object? tokenType = freezed,
    Object? expiresIn = freezed,
  }) {
    return _then(_$AuthResponseImpl(
      accessToken: null == accessToken
          ? _value.accessToken
          : accessToken // ignore: cast_nullable_to_non_nullable
              as String,
      refreshToken: null == refreshToken
          ? _value.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresIn: freezed == expiresIn
          ? _value.expiresIn
          : expiresIn // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$AuthResponseImpl implements _AuthResponse {
  const _$AuthResponseImpl(
      {required this.accessToken,
      required this.refreshToken,
      required this.user,
      this.tokenType,
      this.expiresIn});
  factory _$AuthResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthResponseImplFromJson(json);
  @override
  final String accessToken;
  @override
  final String refreshToken;
  @override
  final User user;
  @override
  final String? tokenType;
  @override
  final int? expiresIn;
  @override
  String toString() {
    return 'AuthResponse(accessToken: $accessToken, refreshToken: $refreshToken, user: $user, tokenType: $tokenType, expiresIn: $expiresIn)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthResponseImpl &&
            (identical(other.accessToken, accessToken) ||
                other.accessToken == accessToken) &&
            (identical(other.refreshToken, refreshToken) ||
                other.refreshToken == refreshToken) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.tokenType, tokenType) ||
                other.tokenType == tokenType) &&
            (identical(other.expiresIn, expiresIn) ||
                other.expiresIn == expiresIn));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, accessToken, refreshToken, user, tokenType, expiresIn);
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthResponseImplCopyWith<_$AuthResponseImpl> get copyWith =>
      __$$AuthResponseImplCopyWithImpl<_$AuthResponseImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$AuthResponseImplToJson(
      this,
    );
  }
}
abstract class _AuthResponse implements AuthResponse {
  const factory _AuthResponse(
      {required final String accessToken,
      required final String refreshToken,
      required final User user,
      final String? tokenType,
      final int? expiresIn}) = _$AuthResponseImpl;
  factory _AuthResponse.fromJson(Map<String, dynamic> json) =
      _$AuthResponseImpl.fromJson;
  @override
  String get accessToken;
  @override
  String get refreshToken;
  @override
  User get user;
  @override
  String? get tokenType;
  @override
  int? get expiresIn;
  /// Create a copy of AuthResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthResponseImplCopyWith<_$AuthResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
RefreshTokenRequest _$RefreshTokenRequestFromJson(Map<String, dynamic> json) {
  return _RefreshTokenRequest.fromJson(json);
}
/// @nodoc
mixin _$RefreshTokenRequest {
  String get refreshToken => throw _privateConstructorUsedError;
  /// Serializes this RefreshTokenRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of RefreshTokenRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RefreshTokenRequestCopyWith<RefreshTokenRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $RefreshTokenRequestCopyWith<$Res> {
  factory $RefreshTokenRequestCopyWith(
          RefreshTokenRequest value, $Res Function(RefreshTokenRequest) then) =
      _$RefreshTokenRequestCopyWithImpl<$Res, RefreshTokenRequest>;
  @useResult
  $Res call({String refreshToken});
}
/// @nodoc
class _$RefreshTokenRequestCopyWithImpl<$Res, $Val extends RefreshTokenRequest>
    implements $RefreshTokenRequestCopyWith<$Res> {
  _$RefreshTokenRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of RefreshTokenRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? refreshToken = null,
  }) {
    return _then(_value.copyWith(
      refreshToken: null == refreshToken
          ? _value.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$RefreshTokenRequestImplCopyWith<$Res>
    implements $RefreshTokenRequestCopyWith<$Res> {
  factory _$$RefreshTokenRequestImplCopyWith(_$RefreshTokenRequestImpl value,
          $Res Function(_$RefreshTokenRequestImpl) then) =
      __$$RefreshTokenRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String refreshToken});
}
/// @nodoc
class __$$RefreshTokenRequestImplCopyWithImpl<$Res>
    extends _$RefreshTokenRequestCopyWithImpl<$Res, _$RefreshTokenRequestImpl>
    implements _$$RefreshTokenRequestImplCopyWith<$Res> {
  __$$RefreshTokenRequestImplCopyWithImpl(_$RefreshTokenRequestImpl _value,
      $Res Function(_$RefreshTokenRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of RefreshTokenRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? refreshToken = null,
  }) {
    return _then(_$RefreshTokenRequestImpl(
      refreshToken: null == refreshToken
          ? _value.refreshToken
          : refreshToken // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$RefreshTokenRequestImpl implements _RefreshTokenRequest {
  const _$RefreshTokenRequestImpl({required this.refreshToken});
  factory _$RefreshTokenRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$RefreshTokenRequestImplFromJson(json);
  @override
  final String refreshToken;
  @override
  String toString() {
    return 'RefreshTokenRequest(refreshToken: $refreshToken)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RefreshTokenRequestImpl &&
            (identical(other.refreshToken, refreshToken) ||
                other.refreshToken == refreshToken));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, refreshToken);
  /// Create a copy of RefreshTokenRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RefreshTokenRequestImplCopyWith<_$RefreshTokenRequestImpl> get copyWith =>
      __$$RefreshTokenRequestImplCopyWithImpl<_$RefreshTokenRequestImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$RefreshTokenRequestImplToJson(
      this,
    );
  }
}
abstract class _RefreshTokenRequest implements RefreshTokenRequest {
  const factory _RefreshTokenRequest({required final String refreshToken}) =
      _$RefreshTokenRequestImpl;
  factory _RefreshTokenRequest.fromJson(Map<String, dynamic> json) =
      _$RefreshTokenRequestImpl.fromJson;
  @override
  String get refreshToken;
  /// Create a copy of RefreshTokenRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RefreshTokenRequestImplCopyWith<_$RefreshTokenRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
ForgotPasswordRequest _$ForgotPasswordRequestFromJson(
    Map<String, dynamic> json) {
  return _ForgotPasswordRequest.fromJson(json);
}
/// @nodoc
mixin _$ForgotPasswordRequest {
  String get email => throw _privateConstructorUsedError;
  /// Serializes this ForgotPasswordRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of ForgotPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ForgotPasswordRequestCopyWith<ForgotPasswordRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $ForgotPasswordRequestCopyWith<$Res> {
  factory $ForgotPasswordRequestCopyWith(ForgotPasswordRequest value,
          $Res Function(ForgotPasswordRequest) then) =
      _$ForgotPasswordRequestCopyWithImpl<$Res, ForgotPasswordRequest>;
  @useResult
  $Res call({String email});
}
/// @nodoc
class _$ForgotPasswordRequestCopyWithImpl<$Res,
        $Val extends ForgotPasswordRequest>
    implements $ForgotPasswordRequestCopyWith<$Res> {
  _$ForgotPasswordRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of ForgotPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
  }) {
    return _then(_value.copyWith(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$ForgotPasswordRequestImplCopyWith<$Res>
    implements $ForgotPasswordRequestCopyWith<$Res> {
  factory _$$ForgotPasswordRequestImplCopyWith(
          _$ForgotPasswordRequestImpl value,
          $Res Function(_$ForgotPasswordRequestImpl) then) =
      __$$ForgotPasswordRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String email});
}
/// @nodoc
class __$$ForgotPasswordRequestImplCopyWithImpl<$Res>
    extends _$ForgotPasswordRequestCopyWithImpl<$Res,
        _$ForgotPasswordRequestImpl>
    implements _$$ForgotPasswordRequestImplCopyWith<$Res> {
  __$$ForgotPasswordRequestImplCopyWithImpl(_$ForgotPasswordRequestImpl _value,
      $Res Function(_$ForgotPasswordRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of ForgotPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
  }) {
    return _then(_$ForgotPasswordRequestImpl(
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$ForgotPasswordRequestImpl implements _ForgotPasswordRequest {
  const _$ForgotPasswordRequestImpl({required this.email});
  factory _$ForgotPasswordRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ForgotPasswordRequestImplFromJson(json);
  @override
  final String email;
  @override
  String toString() {
    return 'ForgotPasswordRequest(email: $email)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ForgotPasswordRequestImpl &&
            (identical(other.email, email) || other.email == email));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email);
  /// Create a copy of ForgotPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ForgotPasswordRequestImplCopyWith<_$ForgotPasswordRequestImpl>
      get copyWith => __$$ForgotPasswordRequestImplCopyWithImpl<
          _$ForgotPasswordRequestImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$ForgotPasswordRequestImplToJson(
      this,
    );
  }
}
abstract class _ForgotPasswordRequest implements ForgotPasswordRequest {
  const factory _ForgotPasswordRequest({required final String email}) =
      _$ForgotPasswordRequestImpl;
  factory _ForgotPasswordRequest.fromJson(Map<String, dynamic> json) =
      _$ForgotPasswordRequestImpl.fromJson;
  @override
  String get email;
  /// Create a copy of ForgotPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ForgotPasswordRequestImplCopyWith<_$ForgotPasswordRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}
ResetPasswordRequest _$ResetPasswordRequestFromJson(Map<String, dynamic> json) {
  return _ResetPasswordRequest.fromJson(json);
}
/// @nodoc
mixin _$ResetPasswordRequest {
  String get token => throw _privateConstructorUsedError;
  String get newPassword => throw _privateConstructorUsedError;
  String get confirmPassword => throw _privateConstructorUsedError;
  /// Serializes this ResetPasswordRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of ResetPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResetPasswordRequestCopyWith<ResetPasswordRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $ResetPasswordRequestCopyWith<$Res> {
  factory $ResetPasswordRequestCopyWith(ResetPasswordRequest value,
          $Res Function(ResetPasswordRequest) then) =
      _$ResetPasswordRequestCopyWithImpl<$Res, ResetPasswordRequest>;
  @useResult
  $Res call({String token, String newPassword, String confirmPassword});
}
/// @nodoc
class _$ResetPasswordRequestCopyWithImpl<$Res,
        $Val extends ResetPasswordRequest>
    implements $ResetPasswordRequestCopyWith<$Res> {
  _$ResetPasswordRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of ResetPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? newPassword = null,
    Object? confirmPassword = null,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      newPassword: null == newPassword
          ? _value.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$ResetPasswordRequestImplCopyWith<$Res>
    implements $ResetPasswordRequestCopyWith<$Res> {
  factory _$$ResetPasswordRequestImplCopyWith(_$ResetPasswordRequestImpl value,
          $Res Function(_$ResetPasswordRequestImpl) then) =
      __$$ResetPasswordRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String token, String newPassword, String confirmPassword});
}
/// @nodoc
class __$$ResetPasswordRequestImplCopyWithImpl<$Res>
    extends _$ResetPasswordRequestCopyWithImpl<$Res, _$ResetPasswordRequestImpl>
    implements _$$ResetPasswordRequestImplCopyWith<$Res> {
  __$$ResetPasswordRequestImplCopyWithImpl(_$ResetPasswordRequestImpl _value,
      $Res Function(_$ResetPasswordRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of ResetPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? newPassword = null,
    Object? confirmPassword = null,
  }) {
    return _then(_$ResetPasswordRequestImpl(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      newPassword: null == newPassword
          ? _value.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$ResetPasswordRequestImpl implements _ResetPasswordRequest {
  const _$ResetPasswordRequestImpl(
      {required this.token,
      required this.newPassword,
      required this.confirmPassword});
  factory _$ResetPasswordRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResetPasswordRequestImplFromJson(json);
  @override
  final String token;
  @override
  final String newPassword;
  @override
  final String confirmPassword;
  @override
  String toString() {
    return 'ResetPasswordRequest(token: $token, newPassword: $newPassword, confirmPassword: $confirmPassword)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResetPasswordRequestImpl &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.newPassword, newPassword) ||
                other.newPassword == newPassword) &&
            (identical(other.confirmPassword, confirmPassword) ||
                other.confirmPassword == confirmPassword));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, token, newPassword, confirmPassword);
  /// Create a copy of ResetPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResetPasswordRequestImplCopyWith<_$ResetPasswordRequestImpl>
      get copyWith =>
          __$$ResetPasswordRequestImplCopyWithImpl<_$ResetPasswordRequestImpl>(
              this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$ResetPasswordRequestImplToJson(
      this,
    );
  }
}
abstract class _ResetPasswordRequest implements ResetPasswordRequest {
  const factory _ResetPasswordRequest(
      {required final String token,
      required final String newPassword,
      required final String confirmPassword}) = _$ResetPasswordRequestImpl;
  factory _ResetPasswordRequest.fromJson(Map<String, dynamic> json) =
      _$ResetPasswordRequestImpl.fromJson;
  @override
  String get token;
  @override
  String get newPassword;
  @override
  String get confirmPassword;
  /// Create a copy of ResetPasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResetPasswordRequestImplCopyWith<_$ResetPasswordRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}
ChangePasswordRequest _$ChangePasswordRequestFromJson(
    Map<String, dynamic> json) {
  return _ChangePasswordRequest.fromJson(json);
}
/// @nodoc
mixin _$ChangePasswordRequest {
  String get currentPassword => throw _privateConstructorUsedError;
  String get newPassword => throw _privateConstructorUsedError;
  String get confirmPassword => throw _privateConstructorUsedError;
  /// Serializes this ChangePasswordRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of ChangePasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ChangePasswordRequestCopyWith<ChangePasswordRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $ChangePasswordRequestCopyWith<$Res> {
  factory $ChangePasswordRequestCopyWith(ChangePasswordRequest value,
          $Res Function(ChangePasswordRequest) then) =
      _$ChangePasswordRequestCopyWithImpl<$Res, ChangePasswordRequest>;
  @useResult
  $Res call(
      {String currentPassword, String newPassword, String confirmPassword});
}
/// @nodoc
class _$ChangePasswordRequestCopyWithImpl<$Res,
        $Val extends ChangePasswordRequest>
    implements $ChangePasswordRequestCopyWith<$Res> {
  _$ChangePasswordRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of ChangePasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPassword = null,
    Object? newPassword = null,
    Object? confirmPassword = null,
  }) {
    return _then(_value.copyWith(
      currentPassword: null == currentPassword
          ? _value.currentPassword
          : currentPassword // ignore: cast_nullable_to_non_nullable
              as String,
      newPassword: null == newPassword
          ? _value.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$ChangePasswordRequestImplCopyWith<$Res>
    implements $ChangePasswordRequestCopyWith<$Res> {
  factory _$$ChangePasswordRequestImplCopyWith(
          _$ChangePasswordRequestImpl value,
          $Res Function(_$ChangePasswordRequestImpl) then) =
      __$$ChangePasswordRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String currentPassword, String newPassword, String confirmPassword});
}
/// @nodoc
class __$$ChangePasswordRequestImplCopyWithImpl<$Res>
    extends _$ChangePasswordRequestCopyWithImpl<$Res,
        _$ChangePasswordRequestImpl>
    implements _$$ChangePasswordRequestImplCopyWith<$Res> {
  __$$ChangePasswordRequestImplCopyWithImpl(_$ChangePasswordRequestImpl _value,
      $Res Function(_$ChangePasswordRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of ChangePasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPassword = null,
    Object? newPassword = null,
    Object? confirmPassword = null,
  }) {
    return _then(_$ChangePasswordRequestImpl(
      currentPassword: null == currentPassword
          ? _value.currentPassword
          : currentPassword // ignore: cast_nullable_to_non_nullable
              as String,
      newPassword: null == newPassword
          ? _value.newPassword
          : newPassword // ignore: cast_nullable_to_non_nullable
              as String,
      confirmPassword: null == confirmPassword
          ? _value.confirmPassword
          : confirmPassword // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$ChangePasswordRequestImpl implements _ChangePasswordRequest {
  const _$ChangePasswordRequestImpl(
      {required this.currentPassword,
      required this.newPassword,
      required this.confirmPassword});
  factory _$ChangePasswordRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChangePasswordRequestImplFromJson(json);
  @override
  final String currentPassword;
  @override
  final String newPassword;
  @override
  final String confirmPassword;
  @override
  String toString() {
    return 'ChangePasswordRequest(currentPassword: $currentPassword, newPassword: $newPassword, confirmPassword: $confirmPassword)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangePasswordRequestImpl &&
            (identical(other.currentPassword, currentPassword) ||
                other.currentPassword == currentPassword) &&
            (identical(other.newPassword, newPassword) ||
                other.newPassword == newPassword) &&
            (identical(other.confirmPassword, confirmPassword) ||
                other.confirmPassword == confirmPassword));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, currentPassword, newPassword, confirmPassword);
  /// Create a copy of ChangePasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangePasswordRequestImplCopyWith<_$ChangePasswordRequestImpl>
      get copyWith => __$$ChangePasswordRequestImplCopyWithImpl<
          _$ChangePasswordRequestImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$ChangePasswordRequestImplToJson(
      this,
    );
  }
}
abstract class _ChangePasswordRequest implements ChangePasswordRequest {
  const factory _ChangePasswordRequest(
      {required final String currentPassword,
      required final String newPassword,
      required final String confirmPassword}) = _$ChangePasswordRequestImpl;
  factory _ChangePasswordRequest.fromJson(Map<String, dynamic> json) =
      _$ChangePasswordRequestImpl.fromJson;
  @override
  String get currentPassword;
  @override
  String get newPassword;
  @override
  String get confirmPassword;
  /// Create a copy of ChangePasswordRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangePasswordRequestImplCopyWith<_$ChangePasswordRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}
MessageResponse _$MessageResponseFromJson(Map<String, dynamic> json) {
  return _MessageResponse.fromJson(json);
}
/// @nodoc
mixin _$MessageResponse {
  String get message => throw _privateConstructorUsedError;
  bool? get success => throw _privateConstructorUsedError;
  /// Serializes this MessageResponse to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of MessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MessageResponseCopyWith<MessageResponse> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $MessageResponseCopyWith<$Res> {
  factory $MessageResponseCopyWith(
          MessageResponse value, $Res Function(MessageResponse) then) =
      _$MessageResponseCopyWithImpl<$Res, MessageResponse>;
  @useResult
  $Res call({String message, bool? success});
}
/// @nodoc
class _$MessageResponseCopyWithImpl<$Res, $Val extends MessageResponse>
    implements $MessageResponseCopyWith<$Res> {
  _$MessageResponseCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of MessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? success = freezed,
  }) {
    return _then(_value.copyWith(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      success: freezed == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$MessageResponseImplCopyWith<$Res>
    implements $MessageResponseCopyWith<$Res> {
  factory _$$MessageResponseImplCopyWith(_$MessageResponseImpl value,
          $Res Function(_$MessageResponseImpl) then) =
      __$$MessageResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String message, bool? success});
}
/// @nodoc
class __$$MessageResponseImplCopyWithImpl<$Res>
    extends _$MessageResponseCopyWithImpl<$Res, _$MessageResponseImpl>
    implements _$$MessageResponseImplCopyWith<$Res> {
  __$$MessageResponseImplCopyWithImpl(
      _$MessageResponseImpl _value, $Res Function(_$MessageResponseImpl) _then)
      : super(_value, _then);
  /// Create a copy of MessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? success = freezed,
  }) {
    return _then(_$MessageResponseImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      success: freezed == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$MessageResponseImpl implements _MessageResponse {
  const _$MessageResponseImpl({required this.message, this.success});
  factory _$MessageResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageResponseImplFromJson(json);
  @override
  final String message;
  @override
  final bool? success;
  @override
  String toString() {
    return 'MessageResponse(message: $message, success: $success)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageResponseImpl &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.success, success) || other.success == success));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, message, success);
  /// Create a copy of MessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageResponseImplCopyWith<_$MessageResponseImpl> get copyWith =>
      __$$MessageResponseImplCopyWithImpl<_$MessageResponseImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$MessageResponseImplToJson(
      this,
    );
  }
}
abstract class _MessageResponse implements MessageResponse {
  const factory _MessageResponse(
      {required final String message,
      final bool? success}) = _$MessageResponseImpl;
  factory _MessageResponse.fromJson(Map<String, dynamic> json) =
      _$MessageResponseImpl.fromJson;
  @override
  String get message;
  @override
  bool? get success;
  /// Create a copy of MessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MessageResponseImplCopyWith<_$MessageResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
</file>

<file path="frontend/lib/features/camera/widgets/plant_ar_filters.dart">
import 'package:flutter/material.dart';
import 'package:camera/camera.dart';
import 'dart:math' as math;
/// Advanced AR filters for plant-focused camera features
class PlantARFilters extends StatefulWidget {
  final CameraController cameraController;
  final Function(String filterType) onFilterSelected;
  final String? currentFilter;
  const PlantARFilters({
    Key? key,
    required this.cameraController,
    required this.onFilterSelected,
    this.currentFilter,
  }) : super(key: key);
  @override
  State<PlantARFilters> createState() => _PlantARFiltersState();
}
class _PlantARFiltersState extends State<PlantARFilters>
    with TickerProviderStateMixin {
  late AnimationController _growthAnimationController;
  late AnimationController _healthPulseController;
  late AnimationController _seasonalController;
  @override
  void initState() {
    super.initState();
    _growthAnimationController = AnimationController(
      duration: const Duration(seconds: 3),
      vsync: this,
    );
    _healthPulseController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    )..repeat();
    _seasonalController = AnimationController(
      duration: const Duration(seconds: 4),
      vsync: this,
    );
  }
  @override
  void dispose() {
    _growthAnimationController.dispose();
    _healthPulseController.dispose();
    _seasonalController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // AR Filter Overlays
        if (widget.currentFilter != null) _buildFilterOverlay(),
        // Filter Selection UI
        Positioned(
          bottom: 100,
          left: 0,
          right: 0,
          child: _buildFilterSelector(),
        ),
      ],
    );
  }
  Widget _buildFilterOverlay() {
    switch (widget.currentFilter) {
      case 'growth_timelapse':
        return _buildGrowthTimelapseOverlay();
      case 'health_overlay':
        return _buildHealthOverlay();
      case 'seasonal_transformation':
        return _buildSeasonalTransformation();
      case 'plant_identification':
        return _buildPlantIdentificationOverlay();
      case 'care_reminder':
        return _buildCareReminderOverlay();
      default:
        return const SizedBox.shrink();
    }
  }
  Widget _buildGrowthTimelapseOverlay() {
    return AnimatedBuilder(
      animation: _growthAnimationController,
      builder: (context, child) {
        return Stack(
          children: [
            // Growth progression indicators
            Positioned(
              bottom: 200,
              left: 50,
              child: _buildGrowthStage(
                'Seedling',
                _growthAnimationController.value >= 0.0,
                _growthAnimationController.value >= 0.25,
              ),
            ),
            Positioned(
              bottom: 250,
              left: 100,
              child: _buildGrowthStage(
                'Young Plant',
                _growthAnimationController.value >= 0.25,
                _growthAnimationController.value >= 0.5,
              ),
            ),
            Positioned(
              bottom: 300,
              left: 150,
              child: _buildGrowthStage(
                'Mature',
                _growthAnimationController.value >= 0.5,
                _growthAnimationController.value >= 0.75,
              ),
            ),
            Positioned(
              bottom: 350,
              left: 200,
              child: _buildGrowthStage(
                'Flowering',
                _growthAnimationController.value >= 0.75,
                _growthAnimationController.value >= 1.0,
              ),
            ),
            // Timeline scrubber
            Positioned(
              bottom: 150,
              left: 20,
              right: 20,
              child: _buildTimelineScrubber(),
            ),
          ],
        );
      },
    );
  }
  Widget _buildGrowthStage(String label, bool isActive, bool isCompleted) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 500),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: isCompleted
            ? Colors.green.withOpacity(0.8)
            : isActive
                ? Colors.orange.withOpacity(0.8)
                : Colors.grey.withOpacity(0.5),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: Colors.white,
          width: isActive ? 2 : 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            isCompleted
                ? Icons.check_circle
                : isActive
                    ? Icons.radio_button_checked
                    : Icons.radio_button_unchecked,
            color: Colors.white,
            size: 16,
          ),
          const SizedBox(width: 4),
          Text(
            label,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 12,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildTimelineScrubber() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(25),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
            'Plant Growth Timeline',
            style: TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              IconButton(
                onPressed: () {
                  _growthAnimationController.reset();
                },
                icon: const Icon(Icons.replay, color: Colors.white),
              ),
              Expanded(
                child: Slider(
                  value: _growthAnimationController.value,
                  onChanged: (value) {
                    _growthAnimationController.value = value;
                  },
                  activeColor: Colors.green,
                  inactiveColor: Colors.grey,
                ),
              ),
              IconButton(
                onPressed: () {
                  if (_growthAnimationController.isAnimating) {
                    _growthAnimationController.stop();
                  } else {
                    _growthAnimationController.forward();
                  }
                },
                icon: Icon(
                  _growthAnimationController.isAnimating
                      ? Icons.pause
                      : Icons.play_arrow,
                  color: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  Widget _buildHealthOverlay() {
    return AnimatedBuilder(
      animation: _healthPulseController,
      builder: (context, child) {
        return Stack(
          children: [
            // Health indicators positioned around detected plant areas
            _buildHealthIndicator(
              top: 200,
              left: 100,
              healthScore: 0.85,
              label: 'Leaf Health',
              icon: Icons.eco,
            ),
            _buildHealthIndicator(
              top: 350,
              left: 150,
              healthScore: 0.6,
              label: 'Soil Moisture',
              icon: Icons.water_drop,
            ),
            _buildHealthIndicator(
              top: 300,
              right: 100,
              healthScore: 0.9,
              label: 'Light Exposure',
              icon: Icons.wb_sunny,
            ),
            // Health summary panel
            Positioned(
              top: 50,
              left: 20,
              right: 20,
              child: _buildHealthSummaryPanel(),
            ),
          ],
        );
      },
    );
  }
  Widget _buildHealthIndicator({
    double? top,
    double? bottom,
    double? left,
    double? right,
    required double healthScore,
    required String label,
    required IconData icon,
  }) {
    final color = healthScore >= 0.8
        ? Colors.green
        : healthScore >= 0.6
            ? Colors.orange
            : Colors.red;
    return Positioned(
      top: top,
      bottom: bottom,
      left: left,
      right: right,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Pulsing health indicator
            AnimatedBuilder(
              animation: _healthPulseController,
              builder: (context, child) {
                final scale = 1.0 + (_healthPulseController.value * 0.2);
                return Transform.scale(
                  scale: scale,
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: color.withOpacity(0.8),
                      shape: BoxShape.circle,
                      border: Border.all(color: Colors.white, width: 2),
                    ),
                    child: Icon(icon, color: Colors.white, size: 20),
                  ),
                );
              },
            ),
            const SizedBox(height: 4),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.7),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    label,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    '${(healthScore * 100).round()}%',
                    style: TextStyle(
                      color: color,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildHealthSummaryPanel() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.8),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.green, width: 1),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Row(
            children: [
              Icon(Icons.local_hospital, color: Colors.green, size: 20),
              SizedBox(width: 8),
              Text(
                'Plant Health Analysis',
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildHealthMetric('Overall', 0.78, Colors.green),
              _buildHealthMetric('Hydration', 0.6, Colors.orange),
              _buildHealthMetric('Growth', 0.85, Colors.green),
            ],
          ),
          const SizedBox(height: 8),
          const Text(
            'Recommendation: Water in 2-3 days',
            style: TextStyle(
              color: Colors.orange,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildHealthMetric(String label, double value, Color color) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 10,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          '${(value * 100).round()}%',
          style: TextStyle(
            color: color,
            fontSize: 14,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }
  Widget _buildSeasonalTransformation() {
    return AnimatedBuilder(
      animation: _seasonalController,
      builder: (context, child) {
        final seasons = ['Spring', 'Summer', 'Fall', 'Winter'];
        final colors = [
          Colors.lightGreen,
          Colors.green,
          Colors.orange,
          Colors.blueGrey,
        ];
        final currentSeasonIndex = (_seasonalController.value * 4).floor() % 4;
        final currentSeason = seasons[currentSeasonIndex];
        final currentColor = colors[currentSeasonIndex];
        return Stack(
          children: [
            // Seasonal overlay effect
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: RadialGradient(
                    center: Alignment.center,
                    radius: 1.5,
                    colors: [
                      currentColor.withOpacity(0.0),
                      currentColor.withOpacity(0.2),
                    ],
                  ),
                ),
              ),
            ),
            // Seasonal particles
            ...List.generate(20, (index) {
              return _buildSeasonalParticle(index, currentSeasonIndex);
            }),
            // Season info panel
            Positioned(
              top: 50,
              left: 20,
              right: 20,
              child: _buildSeasonInfoPanel(currentSeason, currentColor),
            ),
          ],
        );
      },
    );
  }
  Widget _buildSeasonalParticle(int index, int seasonIndex) {
    final random = math.Random(index);
    final x = random.nextDouble() * 300 + 50;
    final y = random.nextDouble() * 500 + 100;
    IconData icon;
    Color color;
    switch (seasonIndex) {
      case 0: // Spring
        icon = Icons.local_florist;
        color = Colors.pink;
        break;
      case 1: // Summer
        icon = Icons.wb_sunny;
        color = Colors.yellow;
        break;
      case 2: // Fall
        icon = Icons.eco;
        color = Colors.orange;
        break;
      default: // Winter
        icon = Icons.ac_unit;
        color = Colors.lightBlue;
    }
    return Positioned(
      left: x,
      top: y,
      child: AnimatedBuilder(
        animation: _seasonalController,
        builder: (context, child) {
          final offset = _seasonalController.value * 50;
          return Transform.translate(
            offset: Offset(0, offset),
            child: Opacity(
              opacity: 0.7,
              child: Icon(
                icon,
                color: color,
                size: 16,
              ),
            ),
          );
        },
      ),
    );
  }
  Widget _buildSeasonInfoPanel(String season, Color color) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.8),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color, width: 2),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              Icon(Icons.calendar_today, color: color, size: 20),
              const SizedBox(width: 8),
              Text(
                '$season Transformation',
                style: TextStyle(
                  color: color,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            _getSeasonalDescription(season),
            style: const TextStyle(
              color: Colors.white,
              fontSize: 12,
            ),
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              ElevatedButton(
                onPressed: () {
                  _seasonalController.forward();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: color,
                  foregroundColor: Colors.white,
                ),
                child: const Text('Next Season'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: () {
                  _seasonalController.reset();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.grey,
                  foregroundColor: Colors.white,
                ),
                child: const Text('Reset'),
              ),
            ],
          ),
        ],
      ),
    );
  }
  String _getSeasonalDescription(String season) {
    switch (season) {
      case 'Spring':
        return 'New growth, fresh leaves, perfect time for repotting';
      case 'Summer':
        return 'Peak growing season, increase watering frequency';
      case 'Fall':
        return 'Prepare for dormancy, reduce fertilizing';
      case 'Winter':
        return 'Dormant period, minimal watering needed';
      default:
        return '';
    }
  }
  Widget _buildPlantIdentificationOverlay() {
    return Stack(
      children: [
        // Scanning frame
        Center(
          child: Container(
            width: 250,
            height: 250,
            decoration: BoxDecoration(
              border: Border.all(color: Colors.green, width: 3),
              borderRadius: BorderRadius.circular(16),
            ),
            child: const Center(
              child: Text(
                'Position plant in frame',
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ),
        // Identification info
        Positioned(
          bottom: 200,
          left: 20,
          right: 20,
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.8),
              borderRadius: BorderRadius.circular(16),
            ),
            child: const Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  children: [
                    Icon(Icons.search, color: Colors.green),
                    SizedBox(width: 8),
                    Text(
                      'Plant Identification',
                      style: TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: 8),
                Text(
                  'Hold steady for best results',
                  style: TextStyle(color: Colors.grey),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildCareReminderOverlay() {
    return Positioned(
      top: 100,
      left: 20,
      right: 20,
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.blue.withOpacity(0.9),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: Colors.white, width: 2),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Row(
              children: [
                Icon(Icons.schedule, color: Colors.white),
                SizedBox(width: 8),
                Text(
                  'Care Reminder',
                  style: TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            const Text(
              'Your Monstera needs watering!',
              style: TextStyle(
                color: Colors.white,
                fontSize: 14,
              ),
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: () {},
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.blue,
                  ),
                  child: const Text('Done'),
                ),
                ElevatedButton(
                  onPressed: () {},
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.transparent,
                    foregroundColor: Colors.white,
                    side: const BorderSide(color: Colors.white),
                  ),
                  child: const Text('Snooze'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildFilterSelector() {
    final filters = [
      {'id': 'growth_timelapse', 'name': 'Growth', 'icon': Icons.timeline},
      {'id': 'health_overlay', 'name': 'Health', 'icon': Icons.favorite},
      {'id': 'seasonal_transformation', 'name': 'Seasons', 'icon': Icons.calendar_today},
      {'id': 'plant_identification', 'name': 'ID Plant', 'icon': Icons.search},
      {'id': 'care_reminder', 'name': 'Care', 'icon': Icons.schedule},
    ];
    return SizedBox(
      height: 80,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        padding: const EdgeInsets.symmetric(horizontal: 20),
        itemCount: filters.length,
        itemBuilder: (context, index) {
          final filter = filters[index];
          final isSelected = widget.currentFilter == filter['id'];
          return Padding(
            padding: const EdgeInsets.only(right: 12),
            child: GestureDetector(
              onTap: () {
                if (isSelected) {
                  widget.onFilterSelected('none');
                } else {
                  widget.onFilterSelected(filter['id'] as String);
                  _startFilterAnimation(filter['id'] as String);
                }
              },
              child: Container(
                width: 60,
                decoration: BoxDecoration(
                  color: isSelected
                      ? Colors.green.withOpacity(0.8)
                      : Colors.black.withOpacity(0.6),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: isSelected ? Colors.white : Colors.grey,
                    width: isSelected ? 2 : 1,
                  ),
                ),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      filter['icon'] as IconData,
                      color: Colors.white,
                      size: 24,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      filter['name'] as String,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
  void _startFilterAnimation(String filterType) {
    switch (filterType) {
      case 'growth_timelapse':
        _growthAnimationController.reset();
        _growthAnimationController.forward();
        break;
      case 'seasonal_transformation':
        _seasonalController.reset();
        _seasonalController.repeat();
        break;
    }
  }
}
</file>

<file path="_docs/phases/development-roadmap.md">
# Development Roadmap: Plant-Focused Social Platform

**Project Duration**: 10-12 days total  
**Development Approach**: Iterative, AI-first, modular architecture

---

## Project Overview

This roadmap outlines the complete development journey for building a revolutionary plant-focused social platform that combines Snapchat-like features with advanced AI capabilities. The project emphasizes modularity, scalability, and AI-first design principles while delivering a functional product at each phase.

---

## Phase Summary

| Phase | Duration | Focus | Key Deliverables | Status |
|-------|----------|-------|------------------|--------|
| **Phase 0: Setup** | 1-2 days | Foundation & Infrastructure | Project setup, basic auth, minimal camera |  Ready |
| **Phase 1: Core MVP** | 2-3 days | Essential Social Features | Messaging, stories, friends, media storage |  Pending |
| **Phase 2: Plant Features** | 2-3 days | Plant-Specific AI Integration | Plant ID, care recommendations, community |  Pending |
| **Phase 3: RAG Enhancement** | 2-3 days | Advanced AI & Personalization | RAG system, smart recommendations, context-aware AI |  Pending |
| **Phase 4: Polish & Advanced** | 3-4 days | Production Ready & Advanced Features | Performance, AR, marketplace, expert network |  Pending |

---

## Detailed Phase Breakdown

###  Phase 0: Setup & Foundation
**Goal**: Establish a working foundation with basic functionality

**Core Deliverables**:
-  Project infrastructure (Flutter + FastAPI + PostgreSQL + Redis)
-  Basic user authentication and registration
-  Core navigation structure
-  Minimal camera integration
-  Basic API connectivity

**Success Criteria**:
- App launches and navigates between screens
- Users can register and log in
- Camera can capture photos
- Backend API responds to requests
- Database connections are established

**Key Files Created**:
- Backend: `app/main.py`, `app/auth/`, `app/core/`
- Frontend: `lib/main.dart`, `lib/features/auth/`, `lib/shared/`
- Infrastructure: `docker-compose.yml`, database migrations

---

###  Phase 1: Core MVP
**Goal**: Build essential Snapchat-like social features

**Core Deliverables**:
-  Real-time messaging system with WebSockets
-  Stories feature with 24-hour expiration
-  Friend management and discovery
-  File storage and media management
-  Enhanced camera and content creation

**Success Criteria**:
- Users can send and receive messages in real-time
- Stories can be posted and viewed by friends
- Friend requests and connections work properly
- Media uploads and downloads function correctly
- Camera captures and processes content effectively

**Key Features**:
- WebSocket-based real-time communication
- Redis pub/sub for message distribution
- AWS S3 integration for media storage
- Story timeline with automatic expiration
- Friend recommendation system

---

###  Phase 2: Plant Features
**Goal**: Transform into a specialized plant community platform

**Core Deliverables**:
-  Plant identification using OpenAI Vision API
-  Plant care recommendations and scheduling
-  Plant-themed AR filters and effects
-  Plant community features (collections, trading, Q&A)
-  Enhanced discovery feed with plant content

**Success Criteria**:
- Plant identification achieves 85%+ accuracy
- Care recommendations are personalized and actionable
- AR filters work smoothly on target devices
- Community features encourage user engagement
- Discovery feed surfaces relevant plant content

**Key Features**:
- OpenAI Vision API integration for plant recognition
- Plant species database with care information
- AR SDK integration for plant-themed filters
- Plant collection and care tracking system
- Community Q&A and trading marketplace

---

###  Phase 3: RAG Enhancement
**Goal**: Implement sophisticated AI-powered personalization

**Core Deliverables**:
-  RAG infrastructure with vector database (pgvector)
-  Personalized plant care AI recommendations
-  Intelligent content generation (captions, tips)
-  Smart community matching and discovery
-  Contextual discovery feed with RAG curation

**Success Criteria**:
- RAG-generated content receives 80%+ positive feedback
- Personalized recommendations improve plant care outcomes
- Content discovery increases user engagement by 40%
- Smart matching creates meaningful community connections
- AI responses are contextually relevant and helpful

**Key Features**:
- pgvector integration for semantic search
- OpenAI API for content generation and analysis
- User behavior analysis and preference learning
- Multi-factor content ranking and personalization
- Real-time context-aware recommendations

---

###  Phase 4: Polish & Advanced Features
**Goal**: Production-ready app with advanced capabilities

**Core Deliverables**:
-  Performance optimization and scalability
-  Advanced AR features (health visualization, measurement)
-  Social commerce and plant trading platform
-  Professional expert network and consultations
-  Advanced analytics and insights dashboard

**Success Criteria**:
- App achieves 4.5+ star rating potential
- 95% uptime with sub-second response times
- 70%+ user retention after 30 days
- Active marketplace with successful trades
- Expert network with verified professionals

**Key Features**:
- Comprehensive caching and optimization
- Advanced AR with plant health overlays
- Secure trading system with escrow
- Professional verification and consultation booking
- Detailed analytics and achievement system

---

## Technical Architecture Evolution

### Phase 0-1: Foundation
```
        
   Flutter App      FastAPI          PostgreSQL    
   (Mobile)             (Backend)            (Database)    
        
                                
                                
                       
                            Redis       
                          (Cache/Pub)   
                       
```

### Phase 2-3: AI Integration
```
        
   Flutter App      FastAPI          PostgreSQL    
   + AR SDK             + AI Services        + pgvector    
        
                                
                                
                       
                          OpenAI API    
                          + Vision      
                       
                                
                                
                       
                          AWS S3 +      
                          CloudFront    
                       
```

### Phase 4: Production Scale
```
        
   Flutter App      Load Balancer    PostgreSQL    
   + Advanced AR                             + Replication 
        
                                
                                
                       
                          FastAPI       
                          Microservices 
                       
                                
                                
                       
                          Redis Cluster 
                          + Monitoring  
                       
```

---

## Development Guidelines

### Code Quality Standards
- **File Size Limit**: Maximum 500 lines per file
- **Function Documentation**: All public functions must have docstrings
- **Naming Conventions**: Descriptive names following language conventions
- **Modularity**: Features should be self-contained and reusable
- **Testing**: Minimum 80% test coverage for critical paths

### AI-First Principles
- **RAG Integration**: All content should leverage retrieval-augmented generation
- **Personalization**: Features should adapt to user behavior and preferences
- **Context Awareness**: AI should consider user's current situation and needs
- **Continuous Learning**: System should improve based on user feedback
- **Transparency**: AI decisions should be explainable to users

### Performance Targets
- **App Launch**: Under 3 seconds on average devices
- **API Response**: 95% of requests under 100ms
- **Image Processing**: Plant identification under 5 seconds
- **Real-time Features**: Sub-second message delivery
- **Memory Usage**: Stable during extended usage

---

## Risk Mitigation

### Technical Risks
- **AI API Costs**: Implement caching and request optimization
- **Performance Issues**: Regular performance testing and optimization
- **Scalability Concerns**: Design for horizontal scaling from Phase 1
- **Data Privacy**: GDPR compliance and secure data handling
- **Third-party Dependencies**: Have fallback options for critical services

### Development Risks
- **Scope Creep**: Strict adherence to phase deliverables
- **Technical Debt**: Regular refactoring and code reviews
- **Integration Issues**: Continuous integration and testing
- **Timeline Delays**: Buffer time built into each phase
- **Quality Compromises**: Automated testing and quality gates

---

## Success Metrics by Phase

### Phase 0: Foundation
-  All core services running
-  Basic user flows functional
-  Development environment stable

### Phase 1: Core MVP
-  Real-time messaging latency < 500ms
-  Story upload success rate > 95%
-  Friend discovery engagement > 60%

### Phase 2: Plant Features
-  Plant identification accuracy > 85%
-  Care recommendation adoption > 70%
-  Community feature usage > 50%

### Phase 3: RAG Enhancement
-  AI-generated content approval > 80%
-  User engagement increase > 40%
-  Personalization effectiveness > 75%

### Phase 4: Production Ready
-  App store rating potential > 4.5 stars
-  User retention (30-day) > 70%
-  System uptime > 95%

---

## Next Steps

1. **Review Phase Documents**: Examine each phase document for detailed implementation guidance
2. **Set Up Development Environment**: Follow Phase 0 setup instructions
3. **Create Project Structure**: Implement the directory structure from `project-rules.md`
4. **Begin Phase 0 Development**: Start with infrastructure and basic authentication
5. **Establish CI/CD Pipeline**: Set up automated testing and deployment
6. **Monitor Progress**: Track deliverables and success metrics for each phase

---

## Resources

- **Project Rules**: `_docs/project-rules.md` - Development standards and conventions
- **Tech Stack**: `_docs/tech-stack.md` - Technology choices and best practices
- **UI Guidelines**: `_docs/ui-rules.md` - Design principles and patterns
- **Theme Guide**: `_docs/theme-rules.md` - Visual style and branding
- **User Flow**: `_docs/user-flow.md` - User journey and feature requirements

---

## Conclusion

This roadmap provides a clear path from initial setup to a production-ready, AI-powered plant social platform. Each phase builds upon the previous one, ensuring a functional product at every stage while progressively adding sophisticated features.

The iterative approach allows for:
- **Early User Feedback**: Test core concepts before investing in advanced features
- **Risk Mitigation**: Identify and resolve issues early in the development process
- **Flexible Scope**: Adjust features based on user needs and technical constraints
- **Quality Assurance**: Maintain high code quality throughout development
- **Team Learning**: Build expertise progressively with each phase

By following this roadmap, the development team will create a revolutionary plant care platform that combines social networking, AI intelligence, and augmented reality into a cohesive, user-friendly experience.
</file>

<file path="_docs/phases/phase-0-setup.md">
# Phase 0: Project Setup & Foundation

**Duration**: 1-2 days  
**Goal**: Establish a barebones but functional project foundation with basic structure and minimal features

---

## Phase Overview

This phase creates the fundamental project structure and implements the most basic functionality to ensure the development environment is properly configured and the core architecture is in place. The result will be a minimal but running application that demonstrates the basic tech stack integration.

---

## Core Deliverables

### 1. Project Infrastructure Setup

**Objective**: Establish development environment and project structure

**Tasks**:
- [x] Initialize Flutter project with proper folder structure
- [ ] Set up FastAPI backend with basic configuration
- [ ] Configure PostgreSQL database with initial schema
- [ ] Set up Redis for caching and real-time features
- [ ] Create Docker development environment

**Acceptance Criteria**:
- Flutter app builds and runs on both iOS and Android
- FastAPI server starts and responds to health check
- Database connection established and migrations work
- Redis connection functional
- Docker containers run successfully

### 2. Basic Authentication System

**Objective**: Implement minimal user registration and login

**Tasks**:
- [ ] Create user model and database schema
- [ ] Implement JWT-based authentication endpoints
- [x] Build basic login/register screens in Flutter
- [x] Set up secure token storage
- [x] Add basic form validation

**Acceptance Criteria**:
- Users can register with email/password
- Users can login and receive JWT tokens
- Tokens are securely stored on device
- Basic input validation prevents invalid submissions
- Protected routes require authentication

### 3. Core Navigation Structure

**Objective**: Establish main app navigation and basic screens

**Tasks**:
- [x] Implement bottom tab navigation
- [x] Create placeholder screens for main features
- [x] Set up routing and navigation logic
- [x] Add basic app theme and styling
- [x] Implement logout functionality

**Acceptance Criteria**:
- Bottom navigation works between main tabs
- All placeholder screens are accessible
- App maintains navigation state
- Basic theme is applied consistently
- Users can logout and return to login screen

### 4. Basic Camera Integration

**Objective**: Implement minimal camera functionality

**Tasks**:
- [x] Add camera permissions handling
- [x] Integrate camera plugin
- [x] Create basic camera screen
- [x] Implement photo capture
- [x] Add basic image preview

**Acceptance Criteria**:
- Camera permissions are requested and handled
- Camera preview displays correctly
- Users can capture photos
- Captured photos can be previewed
- Basic error handling for camera failures

### 5. Minimal API Integration

**Objective**: Establish frontend-backend communication

**Tasks**:
- [x] Set up HTTP client configuration
- [x] Create API service layer
- [x] Implement basic error handling
- [ ] Add network connectivity checks
- [ ] Test API endpoints from Flutter

**Acceptance Criteria**:
- Flutter app can communicate with FastAPI backend
- API errors are handled gracefully
- Network status is monitored
- Basic retry logic for failed requests
- API responses are properly parsed

---

## Technical Requirements

### Backend Setup
- FastAPI application with basic CORS configuration
- PostgreSQL database with user table
- Redis instance for session management
- Basic logging and error handling
- Health check endpoint

### Frontend Setup
- Flutter project with clean architecture structure
- Riverpod for state management
- HTTP client for API communication
- Secure storage for tokens
- Basic error handling and loading states

### Development Environment
- Docker Compose for local development
- Environment variables configuration
- Basic CI/CD pipeline setup
- Code formatting and linting rules
- Git hooks for code quality

---

## Success Metrics

- [x] Application builds without errors
- [ ] All core services start successfully
- [x] User can complete registration flow
- [x] User can login and access main app
- [x] Camera functionality works on device
- [ ] API communication is functional
- [x] Basic navigation works smoothly

---

## Relevant Files

**Configuration Files**:
- `pubspec.yaml` - Flutter dependencies and configuration
- `requirements.txt` - Python backend dependencies
- `docker-compose.yml` - Development environment setup
- `.env.example` - Environment variables template

**Core Backend Files**:
- `app/main.py` - FastAPI application entry point
- `app/core/config.py` - Application configuration
- `app/models/user.py` - User database model
- `app/api/endpoints/auth.py` - Authentication endpoints

**Core Frontend Files**:
- `lib/main.dart` - Flutter application entry point
- `lib/core/router/app_router.dart` - Application routing configuration
- `lib/core/constants/` - Application constants
- `lib/features/auth/presentation/screens/login_screen.dart` - Login screen implementation
- `lib/features/auth/presentation/screens/register_screen.dart` - Registration screen implementation
- `lib/features/auth/presentation/screens/splash_screen.dart` - Splash screen implementation
- `lib/features/auth/providers/auth_provider.dart` - Authentication state management
- `lib/features/home/presentation/screens/main_screen.dart` - Main app screen with bottom navigation
- `lib/features/camera/presentation/screens/camera_screen.dart` - Basic camera functionality

**Database Files**:
- `database/migrations/` - Database migration files
- `database/init.sql` - Initial database setup

---

## Next Phase Preview

Phase 1 will build upon this foundation by implementing:
- Complete messaging system
- Enhanced camera features with filters
- User profile management
- Basic social features
- File upload and storage integration

The setup phase ensures all core systems are working together before adding complex features in subsequent phases.
</file>

<file path="_docs/phases/phase-3-rag-enhancement.md">
# Phase 3: Advanced RAG Integration & AI Enhancement

**Duration**: 2-3 days  
**Goal**: Implement sophisticated RAG capabilities that provide personalized, context-aware plant care and social experiences

---

## Phase Overview

This phase transforms the plant-focused social app into an AI-first platform that leverages Retrieval-Augmented Generation to provide unprecedented personalization and intelligence. The RAG system will analyze user behavior, plant collection data, environmental factors, and community interactions to deliver highly relevant content, recommendations, and assistance.

---

## Core Deliverables

### 1. RAG Infrastructure & Vector Database

**Objective**: Establish the foundation for intelligent content retrieval and generation

**Tasks**:
- [ ] Set up pgvector extension for PostgreSQL
- [ ] Create embedding generation pipeline for plant content
- [ ] Build vector search and similarity matching system
- [ ] Implement content indexing for plant care knowledge
- [ ] Create user behavior and preference embedding system

**Acceptance Criteria**:
- Vector database stores embeddings for plant species, care guides, and user content
- Similarity search returns relevant plant information with high accuracy
- User preference embeddings capture plant care patterns and interests
- Content embeddings enable semantic search across plant knowledge base
- System handles real-time embedding updates efficiently

### 2. Personalized Plant Care AI  COMPLETED

**Objective**: Provide intelligent, context-aware plant care recommendations

**Tasks**:
- [x] Implement user plant history analysis
- [x] Create environmental factor integration (weather, season, location)
- [x] Build personalized care schedule optimization
- [x] Develop plant health problem diagnosis system
- [x] Add predictive care recommendations

**Acceptance Criteria**:
-  Care recommendations adapt to user's success/failure patterns
-  Environmental data influences watering and care schedules
-  System predicts potential plant problems before they occur
-  Recommendations improve based on user feedback and outcomes
-  Care advice considers user's experience level and plant collection

**Implementation Summary**:
- **PersonalizedPlantCareService**: Comprehensive service analyzing user care patterns, environmental factors, and generating personalized schedules and health predictions
- **API Endpoints**: New endpoints for personalized care schedules, health predictions, care pattern analysis, and seasonal recommendations
- **Smart Community Integration**: SmartCommunityService for expert recommendations and user matching
- **Quality Rating**: 4/5 (Excellent) - Strong architecture with room for ML model enhancements

**Gemini Review Highlights**:
- Excellent architecture and modularity with proper separation of concerns
- Complete implementation of all acceptance criteria
- High code quality with proper type hints and documentation
- Effective integration with RAG infrastructure
- Suggested improvements focus on ML model refinement and feedback loop optimization

### 3. Intelligent Content Generation  COMPLETED

**Objective**: Generate personalized captions, posts, and plant care content

**Tasks**:
- [x] Implement RAG-powered caption generation for plant photos
- [x] Create personalized plant care tip generation
- [x] Build intelligent story content suggestions
- [x] Develop context-aware plant identification descriptions
- [x] Add seasonal content generation based on user location

**Acceptance Criteria**:
-  Generated captions reflect user's writing style and plant knowledge level
-  Care tips are specific to user's plants and current conditions
-  Story suggestions encourage engagement and community interaction
-  Plant descriptions include relevant care information for user's context
-  Seasonal content appears at optimal times for user's location

**Implementation Summary**:
- **ContentGenerationService**: Comprehensive service for AI-powered content generation including captions, tips, story suggestions, and plant descriptions
- **API Endpoints**: Complete REST API for content generation with support for different content types, feedback collection, and analytics
- **Personalization**: Deep integration with user preferences, plant collection, and seasonal context
- **Quality Features**: Confidence scoring, engagement prediction, hashtag generation, and writing style analysis

**Key Features Implemented**:
- Plant photo caption generation with tone and style customization
- Personalized plant care tips based on user's plants and conditions
- Story content suggestions for different types of plant-related posts
- Context-aware plant descriptions for identification and care guides
- Seasonal content recommendations based on user location and time
- Content analytics and feedback system for continuous improvement
- Writing style analysis for better personalization

**Gemini Review Results**:
- **Overall Rating**: 4/5 (Excellent)
- **Strengths**: Excellent modularity, strong personalization, robust RAG pipeline, good code quality
- **Critical Security Fix**: Resolved user authentication vulnerability in API endpoints
- **Architecture**: Well-structured with clean separation of concerns
- **Suggestions**: Implement real trending topics analysis, enhance seasonal awareness, replace heuristic scoring with ML models

### 4. Smart Community Matching

**Objective**: Connect users with relevant plant community members and content

**Tasks**:
- [ ] Implement plant interest similarity matching
- [ ] Create expertise-based user recommendations
- [ ] Build location-aware gardening community discovery
- [ ] Develop plant trading compatibility analysis
- [ ] Add intelligent Q&A routing to expert users

**Acceptance Criteria**:
- Friend suggestions match plant interests and experience levels
- Expert users are identified and highlighted for specific plant types
- Local community recommendations consider climate and growing conditions
- Trading matches consider plant compatibility and user preferences
- Questions are routed to users with relevant expertise

### 5. Contextual Discovery Feed  COMPLETED

**Objective**: Curate highly personalized content discovery using RAG

**Tasks**:
- [x] Implement user behavior analysis for content preferences
- [x] Create multi-factor content ranking system
- [x] Build real-time content personalization
- [x] Develop trending topic detection for plant community
- [x] Add contextual content filtering based on user's current needs

**Acceptance Criteria**:
-  Feed content matches user's current plant care needs and interests
-  Trending plant topics are surfaced at relevant times
-  Content ranking considers user engagement patterns and preferences
-  Real-time personalization adapts to user's immediate context
-  Discovery introduces new relevant content while maintaining user interests

**Implementation Summary**:
- **ContextualDiscoveryService**: Advanced service for personalized content curation using RAG and user behavior analysis
- **Discovery Feed API**: Comprehensive endpoints for personalized feeds, trending topics, and contextual recommendations
- **Multi-factor Ranking**: Sophisticated algorithm considering relevance, engagement, freshness, and personalization factors
- **Behavior Analysis**: Deep insights into user preferences, engagement patterns, and content consumption habits

**Key Features Implemented**:
- Personalized discovery feed with stories, questions, trades, and knowledge articles
- User behavior analysis for content preferences and engagement patterns
- Trending topic detection based on community interactions
- Contextual recommendations for specific situations (plant problems, seasonal care)
- Feed statistics and analytics for optimization
- Feedback system for continuous algorithm improvement
- Discovery insights for understanding user preferences and patterns

---

## Technical Implementation

### RAG System Architecture

```python
class RAGService:
    def __init__(self, vector_db: VectorDatabase, llm_client: OpenAI):
        self.vector_db = vector_db
        self.llm_client = llm_client
        self.embedding_model = "text-embedding-3-small"
    
    async def generate_plant_care_advice(
        self, 
        user_context: UserContext, 
        plant_data: PlantData,
        query: str
    ) -> PlantCareAdvice:
        # Generate query embedding
        query_embedding = await self._generate_embedding(query)
        
        # Retrieve relevant plant care knowledge
        relevant_docs = await self.vector_db.similarity_search(
            embedding=query_embedding,
            filters={
                "plant_species": plant_data.species_id,
                "care_level": user_context.experience_level,
                "climate_zone": user_context.location.climate_zone
            },
            limit=5
        )
        
        # Generate personalized advice using RAG
        context = self._build_context(user_context, plant_data, relevant_docs)
        
        response = await self.llm_client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[
                {
                    "role": "system",
                    "content": self._get_plant_care_system_prompt()
                },
                {
                    "role": "user",
                    "content": f"Context: {context}\n\nQuestion: {query}"
                }
            ],
            temperature=0.7,
            max_tokens=500
        )
        
        return PlantCareAdvice(
            advice=response.choices[0].message.content,
            confidence=self._calculate_confidence(relevant_docs),
            sources=relevant_docs
        )
```

### Vector Database Schema

```sql
-- Vector embeddings for plant content
CREATE TABLE plant_content_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_type VARCHAR(50), -- species_info, care_guide, user_post, qa_answer
    content_id UUID, -- References to specific content
    embedding vector(1536), -- OpenAI embedding dimension
    metadata JSONB, -- Additional context (species, difficulty, season, etc.)
    created_at TIMESTAMP DEFAULT NOW()
);

-- User preference embeddings
CREATE TABLE user_preference_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    preference_type VARCHAR(50), -- plant_interests, care_style, content_preferences
    embedding vector(1536),
    confidence_score DECIMAL(3,2),
    last_updated TIMESTAMP DEFAULT NOW()
);

-- RAG interaction logs
CREATE TABLE rag_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    interaction_type VARCHAR(50), -- care_advice, content_generation, recommendation
    query_text TEXT,
    query_embedding vector(1536),
    retrieved_documents JSONB,
    generated_response TEXT,
    user_feedback INTEGER, -- 1-5 rating
    created_at TIMESTAMP DEFAULT NOW()
);

-- Create vector similarity indexes
CREATE INDEX ON plant_content_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX ON user_preference_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX ON rag_interactions USING ivfflat (query_embedding vector_cosine_ops) WITH (lists = 100);
```

### Personalization Engine

```python
class PersonalizationEngine:
    def __init__(self, rag_service: RAGService, user_service: UserService):
        self.rag_service = rag_service
        self.user_service = user_service
    
    async def generate_personalized_content(
        self, 
        user_id: str, 
        content_type: str,
        context: dict
    ) -> PersonalizedContent:
        # Get user profile and preferences
        user_profile = await self.user_service.get_user_profile(user_id)
        user_preferences = await self._get_user_preferences(user_id)
        
        # Build personalization context
        personalization_context = {
            "user_experience_level": user_profile.plant_experience,
            "plant_collection": user_profile.plant_collection,
            "location": user_profile.location,
            "preferences": user_preferences,
            "recent_activity": await self._get_recent_activity(user_id),
            "seasonal_context": self._get_seasonal_context(user_profile.location)
        }
        
        # Generate content using RAG
        if content_type == "plant_caption":
            return await self._generate_plant_caption(context, personalization_context)
        elif content_type == "care_reminder":
            return await self._generate_care_reminder(context, personalization_context)
        elif content_type == "discovery_content":
            return await self._generate_discovery_content(context, personalization_context)
        
    async def _generate_plant_caption(
        self, 
        image_context: dict, 
        user_context: dict
    ) -> str:
        # Analyze plant in image
        plant_analysis = await self.rag_service.analyze_plant_image(
            image_context["image_url"]
        )
        
        # Retrieve relevant plant information
        plant_info = await self.rag_service.get_plant_information(
            species=plant_analysis.species,
            user_context=user_context
        )
        
        # Generate personalized caption
        prompt = f"""
        Generate a social media caption for this {plant_analysis.species} photo.
        
        User context:
        - Experience level: {user_context['user_experience_level']}
        - Writing style: {user_context['preferences']['writing_style']}
        - Plant collection: {len(user_context['plant_collection'])} plants
        
        Plant information:
        {plant_info}
        
        Make the caption engaging, informative, and matching the user's style.
        """
        
        return await self.rag_service.generate_text(prompt)
```

### Frontend RAG Integration

```dart
// RAG-powered content generation provider
final ragContentProvider = StateNotifierProvider.family<RAGContentNotifier, RAGContentState, String>(
  (ref, contentType) => RAGContentNotifier(
    ref.read(ragServiceProvider),
    contentType,
  ),
);

class RAGContentNotifier extends StateNotifier<RAGContentState> {
  RAGContentNotifier(this._ragService, this.contentType) : super(RAGContentState.initial());
  
  final RAGService _ragService;
  final String contentType;
  
  Future<void> generateContent(Map<String, dynamic> context) async {
    state = state.copyWith(isLoading: true);
    
    try {
      final content = await _ragService.generatePersonalizedContent(
        contentType: contentType,
        context: context,
      );
      
      state = state.copyWith(
        content: content,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }
}

// Smart plant care widget
class SmartPlantCareWidget extends ConsumerWidget {
  const SmartPlantCareWidget({Key? key, required this.plant}) : super(key: key);
  
  final UserPlant plant;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final careAdvice = ref.watch(plantCareAdviceProvider(plant.id));
    
    return careAdvice.when(
      data: (advice) => Column(
        children: [
          PlantCareCard(
            title: 'Personalized Care Tips',
            content: advice.recommendations,
            confidence: advice.confidence,
          ),
          if (advice.urgentActions.isNotEmpty)
            UrgentCareAlert(actions: advice.urgentActions),
          PlantHealthPrediction(prediction: advice.healthPrediction),
        ],
      ),
      loading: () => const PlantCareLoader(),
      error: (error, stack) => PlantCareError(error: error),
    );
  }
}
```

---

## RAG Knowledge Base

### Content Categories for Embedding

1. **Plant Species Information**
   - Scientific and common names
   - Care requirements and preferences
   - Common problems and solutions
   - Seasonal care variations
   - Propagation methods

2. **Care Techniques and Best Practices**
   - Watering techniques for different plant types
   - Fertilization schedules and methods
   - Pruning and maintenance procedures
   - Pest and disease management
   - Repotting guidelines

3. **Environmental Factors**
   - Light requirements and positioning
   - Humidity and temperature preferences
   - Seasonal care adjustments
   - Indoor vs outdoor considerations
   - Climate zone specific advice

4. **User-Generated Content**
   - Successful care stories and tips
   - Problem resolution experiences
   - Plant progress photos and timelines
   - Community Q&A responses
   - Plant trading experiences

5. **Expert Knowledge**
   - Professional horticulturist advice
   - Research-backed care methods
   - Advanced propagation techniques
   - Plant breeding information
   - Commercial growing practices

---

## API Endpoints

### RAG Services
```
POST /api/v1/rag/generate-care-advice
POST /api/v1/rag/generate-caption
POST /api/v1/rag/analyze-plant-health
GET /api/v1/rag/personalized-recommendations
POST /api/v1/rag/feedback
```

### Content Discovery
```
GET /api/v1/discovery/personalized-feed
GET /api/v1/discovery/trending-topics
GET /api/v1/discovery/similar-users
GET /api/v1/discovery/recommended-content
```

### Smart Features
```
POST /api/v1/smart/predict-plant-needs
GET /api/v1/smart/optimal-care-schedule
POST /api/v1/smart/diagnose-problem
GET /api/v1/smart/seasonal-recommendations
```

---

## Success Metrics

- [ ] RAG-generated content receives 80%+ positive user feedback
- [ ] Personalized care advice improves plant health outcomes
- [ ] Content discovery increases user engagement by 40%
- [ ] Smart recommendations reduce plant care problems by 30%
- [ ] User retention improves due to personalized experience
- [ ] Community matching increases meaningful connections
- [ ] Generated captions match user writing style preferences
- [ ] Seasonal recommendations align with local growing conditions

---

## Relevant Files

**RAG Core Services**:
- `app/services/rag_service.py` - Main RAG orchestration service
- `app/services/vector_database_service.py` - Vector search and similarity
- `app/services/personalization_engine.py` - User personalization logic
- `app/services/content_generation_service.py` - AI content generation
- `app/services/embedding_service.py` - Text and image embedding generation

**AI and ML Integration**:
- `app/ml/plant_health_predictor.py` - Plant health prediction models
- `app/ml/user_preference_analyzer.py` - User behavior analysis
- `app/ml/content_recommender.py` - Content recommendation engine
- `app/ml/seasonal_optimizer.py` - Seasonal care optimization

**Database and Models**:
- `app/models/rag_models.py` - RAG-specific database models
- `app/models/embedding_models.py` - Vector embedding models
- `database/migrations/004_rag_system.sql` - RAG database schema
- `database/seeds/plant_knowledge_base.sql` - Initial knowledge base

**Frontend RAG Features**:
- `lib/features/rag/` - RAG-powered UI components
- `lib/features/smart_care/` - Intelligent plant care interfaces
- `lib/features/personalized_discovery/` - Personalized content discovery
- `lib/shared/services/rag_service.dart` - Frontend RAG API client
- `lib/shared/widgets/smart_suggestions.dart` - AI suggestion components

**Configuration and Infrastructure**:
- `app/core/rag_config.py` - RAG system configuration
- `app/core/embedding_config.py` - Embedding model configuration
- `scripts/knowledge_base_indexer.py` - Content indexing scripts
- `scripts/embedding_updater.py` - Embedding maintenance scripts

---

## Next Phase Preview

Phase 4 will focus on polish, optimization, and advanced features:
- Performance optimization for real-time RAG responses
- Advanced AR features with plant health visualization
- Social commerce integration for plant trading
- Professional horticulturist verification system
- Advanced analytics and insights dashboard
- Multi-language support for global plant community

The RAG enhancement in Phase 3 creates the intelligent foundation that makes this app truly revolutionary in the plant care and social media space.
</file>

<file path="_docs/phases/phase-4-polish-advanced.md">
# Phase 4: Polish & Advanced Features

**Duration**: 3-4 days  
**Goal**: Transform the MVP into a production-ready, polished application with advanced features and optimizations

---

## Phase Overview

This final phase focuses on polish, performance optimization, advanced features, and production readiness. The app will be transformed from a functional MVP into a professional, scalable platform ready for real users. This phase emphasizes user experience refinement, performance optimization, advanced social features, and comprehensive testing.

---

## Core Deliverables

### 1. Performance Optimization & Scalability

**Objective**: Ensure the app performs excellently under real-world conditions

**Tasks**:
- [ ] Implement comprehensive caching strategies (Redis, CDN)
- [ ] Optimize database queries and add proper indexing
- [ ] Add image compression and optimization pipeline
- [ ] Implement lazy loading and pagination for all lists
- [ ] Add performance monitoring and analytics

**Acceptance Criteria**:
- App loads in under 3 seconds on average mobile connections
- Image uploads are compressed and optimized automatically
- Database queries execute in under 100ms for 95% of requests
- Memory usage remains stable during extended app usage
- Real-time features maintain sub-second response times

### 2. Advanced AR & Camera Features

**Objective**: Create immersive, plant-focused AR experiences

**Tasks**:
- [ ] Implement plant health visualization overlays
- [ ] Create seasonal plant growth prediction AR
- [ ] Add plant measurement and size tracking tools
- [ ] Build plant care reminder AR notifications
- [ ] Develop plant identification confidence indicators

**Acceptance Criteria**:
- AR overlays accurately track plant positions and movements
- Health visualization provides actionable insights
- Growth predictions are based on species-specific data
- Measurement tools are accurate within 5% margin
- AR features work smoothly on mid-range devices

### 3. Social Commerce & Trading Platform

**Objective**: Enable secure plant trading and marketplace features

**Tasks**:
- [ ] Build plant marketplace with search and filters
- [ ] Implement secure trading system with escrow
- [ ] Add plant valuation and pricing suggestions
- [ ] Create shipping and logistics integration
- [ ] Develop seller reputation and review system

**Acceptance Criteria**:
- Users can list plants with detailed information and photos
- Trading system protects both buyers and sellers
- Pricing suggestions are based on market data and plant rarity
- Shipping integration provides accurate costs and tracking
- Review system maintains marketplace quality and trust

### 4. Professional Features & Expert Network

**Objective**: Connect users with plant care professionals and expert knowledge

**Tasks**:
- [ ] Create professional horticulturist verification system
- [ ] Build expert consultation booking and payment system
- [ ] Implement professional plant care service marketplace
- [ ] Add plant care certification and achievement system
- [ ] Develop expert-curated content and courses

**Acceptance Criteria**:
- Verified experts have clear badges and credentials
- Consultation system handles scheduling and payments securely
- Service marketplace connects users with local professionals
- Achievement system gamifies learning and plant care success
- Expert content is clearly distinguished from user-generated content

### 5. Advanced Analytics & Insights

**Objective**: Provide users with detailed insights about their plant care journey

**Tasks**:
- [ ] Build comprehensive plant care analytics dashboard
- [ ] Implement plant health tracking and trend analysis
- [ ] Create personalized plant care success metrics
- [ ] Add community engagement and social impact insights
- [ ] Develop predictive analytics for plant care optimization

**Acceptance Criteria**:
- Dashboard shows clear plant health trends over time
- Users can track care consistency and plant growth progress
- Success metrics motivate continued engagement
- Community insights show user's impact and connections
- Predictive features help prevent plant care problems

---

## Technical Implementation

### Performance Optimization Architecture

```python
# Advanced caching service
class CacheService:
    def __init__(self, redis_client: Redis, cdn_client: CDNClient):
        self.redis = redis_client
        self.cdn = cdn_client
        self.cache_strategies = {
            'user_profile': {'ttl': 3600, 'strategy': 'write_through'},
            'plant_data': {'ttl': 86400, 'strategy': 'write_behind'},
            'feed_content': {'ttl': 1800, 'strategy': 'cache_aside'},
            'rag_responses': {'ttl': 7200, 'strategy': 'write_through'}
        }
    
    async def get_or_set(
        self, 
        key: str, 
        fetch_func: Callable,
        cache_type: str = 'default'
    ) -> Any:
        # Check cache first
        cached_value = await self.redis.get(key)
        if cached_value:
            return json.loads(cached_value)
        
        # Fetch from source
        value = await fetch_func()
        
        # Cache with appropriate strategy
        strategy = self.cache_strategies.get(cache_type, {'ttl': 3600})
        await self.redis.setex(
            key, 
            strategy['ttl'], 
            json.dumps(value, default=str)
        )
        
        return value

# Database query optimization
class OptimizedPlantRepository:
    def __init__(self, db: Database):
        self.db = db
    
    async def get_user_plants_with_care_data(
        self, 
        user_id: str,
        limit: int = 20,
        offset: int = 0
    ) -> List[UserPlantWithCare]:
        # Optimized query with proper joins and indexing
        query = """
        SELECT 
            up.*,
            ps.name as species_name,
            ps.care_difficulty,
            ps.watering_frequency,
            COUNT(cl.id) as care_log_count,
            MAX(cl.created_at) as last_care_date,
            AVG(ph.health_score) as avg_health_score
        FROM user_plants up
        JOIN plant_species ps ON up.species_id = ps.id
        LEFT JOIN care_logs cl ON up.id = cl.plant_id 
            AND cl.created_at > NOW() - INTERVAL '30 days'
        LEFT JOIN plant_health ph ON up.id = ph.plant_id 
            AND ph.created_at > NOW() - INTERVAL '7 days'
        WHERE up.user_id = $1 AND up.is_active = true
        GROUP BY up.id, ps.id
        ORDER BY up.created_at DESC
        LIMIT $2 OFFSET $3
        """
        
        return await self.db.fetch_all(
            query, 
            user_id, 
            limit, 
            offset
        )
```

### Advanced AR Implementation

```dart
// Plant health AR overlay widget
class PlantHealthAROverlay extends StatefulWidget {
  const PlantHealthAROverlay({
    Key? key,
    required this.plantId,
    required this.arController,
  }) : super(key: key);
  
  final String plantId;
  final ARController arController;
  
  @override
  State<PlantHealthAROverlay> createState() => _PlantHealthAROverlayState();
}

class _PlantHealthAROverlayState extends State<PlantHealthAROverlay> {
  PlantHealthData? _healthData;
  List<ARNode> _healthIndicators = [];
  
  @override
  void initState() {
    super.initState();
    _loadPlantHealthData();
    _setupARTracking();
  }
  
  Future<void> _loadPlantHealthData() async {
    final healthData = await ref.read(plantHealthServiceProvider)
        .getPlantHealthAnalysis(widget.plantId);
    
    setState(() {
      _healthData = healthData;
    });
    
    _createHealthIndicators();
  }
  
  void _createHealthIndicators() {
    if (_healthData == null) return;
    
    _healthIndicators = [
      // Leaf health indicators
      ARNode(
        type: ARNodeType.healthIndicator,
        position: _healthData!.leafHealthPositions,
        data: {
          'health_score': _healthData!.leafHealthScore,
          'issues': _healthData!.leafIssues,
          'color': _getHealthColor(_healthData!.leafHealthScore),
        },
      ),
      
      // Soil moisture indicator
      ARNode(
        type: ARNodeType.soilIndicator,
        position: _healthData!.soilPosition,
        data: {
          'moisture_level': _healthData!.soilMoisture,
          'next_watering': _healthData!.nextWateringDate,
          'recommendation': _healthData!.wateringRecommendation,
        },
      ),
      
      // Growth prediction overlay
      ARNode(
        type: ARNodeType.growthPrediction,
        position: _healthData!.plantCenter,
        data: {
          'predicted_size': _healthData!.predictedGrowth,
          'timeline': _healthData!.growthTimeline,
          'care_requirements': _healthData!.futureCareneeds,
        },
      ),
    ];
    
    // Add indicators to AR scene
    for (final indicator in _healthIndicators) {
      widget.arController.addNode(indicator);
    }
  }
  
  Color _getHealthColor(double healthScore) {
    if (healthScore >= 0.8) return Colors.green;
    if (healthScore >= 0.6) return Colors.yellow;
    return Colors.red;
  }
  
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // AR Camera View
        ARView(
          controller: widget.arController,
          onPlaneDetected: _onPlaneDetected,
          onNodeTapped: _onHealthIndicatorTapped,
        ),
        
        // Health data overlay
        if (_healthData != null)
          Positioned(
            top: 50,
            left: 20,
            right: 20,
            child: PlantHealthSummaryCard(
              healthData: _healthData!,
              onActionTap: _handleHealthAction,
            ),
          ),
        
        // AR controls
        Positioned(
          bottom: 100,
          left: 0,
          right: 0,
          child: ARControlsPanel(
            onToggleIndicators: _toggleHealthIndicators,
            onCapturePhoto: _captureARPhoto,
            onShareView: _shareARView,
          ),
        ),
      ],
    );
  }
}

// Plant measurement AR tool
class PlantMeasurementTool extends StatefulWidget {
  const PlantMeasurementTool({
    Key? key,
    required this.onMeasurementComplete,
  }) : super(key: key);
  
  final Function(PlantMeasurement) onMeasurementComplete;
  
  @override
  State<PlantMeasurementTool> createState() => _PlantMeasurementToolState();
}

class _PlantMeasurementToolState extends State<PlantMeasurementTool> {
  final List<Vector3> _measurementPoints = [];
  PlantMeasurement? _currentMeasurement;
  
  @override
  Widget build(BuildContext context) {
    return ARView(
      onPlaneDetected: (plane) {
        // Enable measurement mode when plane is detected
        setState(() {
          _measurementEnabled = true;
        });
      },
      onTap: (position) {
        if (_measurementPoints.length < 2) {
          _addMeasurementPoint(position);
        }
        
        if (_measurementPoints.length == 2) {
          _calculateMeasurement();
        }
      },
      children: [
        // Measurement points visualization
        for (int i = 0; i < _measurementPoints.length; i++)
          ARNode(
            position: _measurementPoints[i],
            child: MeasurementPointWidget(index: i),
          ),
        
        // Measurement line
        if (_measurementPoints.length == 2)
          ARLine(
            start: _measurementPoints[0],
            end: _measurementPoints[1],
            color: Theme.of(context).primaryColor,
            width: 2.0,
          ),
        
        // Measurement result display
        if (_currentMeasurement != null)
          ARNode(
            position: _getMidpoint(_measurementPoints[0], _measurementPoints[1]),
            child: MeasurementResultWidget(
              measurement: _currentMeasurement!,
            ),
          ),
      ],
    );
  }
  
  void _addMeasurementPoint(Vector3 position) {
    setState(() {
      _measurementPoints.add(position);
    });
  }
  
  void _calculateMeasurement() {
    final distance = _calculateDistance(
      _measurementPoints[0], 
      _measurementPoints[1]
    );
    
    final measurement = PlantMeasurement(
      height: distance,
      timestamp: DateTime.now(),
      confidence: _calculateConfidence(),
      method: MeasurementMethod.ar,
    );
    
    setState(() {
      _currentMeasurement = measurement;
    });
    
    widget.onMeasurementComplete(measurement);
  }
}
```

### Social Commerce Implementation

```python
# Plant marketplace service
class PlantMarketplaceService:
    def __init__(
        self, 
        db: Database, 
        payment_service: PaymentService,
        shipping_service: ShippingService
    ):
        self.db = db
        self.payment_service = payment_service
        self.shipping_service = shipping_service
    
    async def create_plant_listing(
        self, 
        seller_id: str, 
        listing_data: PlantListingCreate
    ) -> PlantListing:
        # Validate plant information
        plant_validation = await self._validate_plant_listing(listing_data)
        if not plant_validation.is_valid:
            raise ValidationError(plant_validation.errors)
        
        # Generate pricing suggestions
        pricing_suggestion = await self._generate_pricing_suggestion(
            listing_data.species_id,
            listing_data.size,
            listing_data.condition,
            listing_data.location
        )
        
        # Create listing
        listing = await self.db.execute(
            """
            INSERT INTO plant_listings (
                seller_id, species_id, title, description, price,
                suggested_price, condition, size, location,
                photos, care_instructions, shipping_options
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
            ) RETURNING *
            """,
            seller_id,
            listing_data.species_id,
            listing_data.title,
            listing_data.description,
            listing_data.price,
            pricing_suggestion.suggested_price,
            listing_data.condition,
            listing_data.size,
            listing_data.location,
            listing_data.photos,
            listing_data.care_instructions,
            listing_data.shipping_options
        )
        
        # Index for search
        await self._index_listing_for_search(listing)
        
        return PlantListing.from_db(listing)
    
    async def initiate_trade(
        self, 
        buyer_id: str, 
        listing_id: str,
        trade_details: TradeDetails
    ) -> Trade:
        # Create escrow account
        escrow = await self.payment_service.create_escrow(
            amount=trade_details.total_amount,
            buyer_id=buyer_id,
            seller_id=trade_details.seller_id
        )
        
        # Calculate shipping
        shipping_quote = await self.shipping_service.get_shipping_quote(
            from_location=trade_details.seller_location,
            to_location=trade_details.buyer_location,
            package_details=trade_details.package_details
        )
        
        # Create trade record
        trade = await self.db.execute(
            """
            INSERT INTO plant_trades (
                buyer_id, seller_id, listing_id, escrow_id,
                trade_amount, shipping_cost, total_amount,
                shipping_quote_id, status, created_at
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, 'pending', NOW()
            ) RETURNING *
            """,
            buyer_id,
            trade_details.seller_id,
            listing_id,
            escrow.id,
            trade_details.trade_amount,
            shipping_quote.cost,
            trade_details.total_amount,
            shipping_quote.id
        )
        
        # Send notifications
        await self._send_trade_notifications(trade)
        
        return Trade.from_db(trade)
    
    async def _generate_pricing_suggestion(
        self,
        species_id: str,
        size: str,
        condition: str,
        location: str
    ) -> PricingSuggestion:
        # Analyze recent sales data
        recent_sales = await self.db.fetch_all(
            """
            SELECT price, size, condition, created_at
            FROM plant_trades pt
            JOIN plant_listings pl ON pt.listing_id = pl.id
            WHERE pl.species_id = $1 
                AND pt.status = 'completed'
                AND pt.created_at > NOW() - INTERVAL '90 days'
            ORDER BY pt.created_at DESC
            LIMIT 50
            """,
            species_id
        )
        
        # Calculate market price
        if recent_sales:
            prices = [sale['price'] for sale in recent_sales]
            market_price = statistics.median(prices)
            
            # Adjust for size and condition
            size_multiplier = self._get_size_multiplier(size)
            condition_multiplier = self._get_condition_multiplier(condition)
            
            suggested_price = market_price * size_multiplier * condition_multiplier
        else:
            # Fallback to species base price
            species_data = await self._get_species_market_data(species_id)
            suggested_price = species_data.base_price
        
        return PricingSuggestion(
            suggested_price=suggested_price,
            market_data=recent_sales,
            confidence=self._calculate_price_confidence(recent_sales),
            factors={
                'size': size_multiplier,
                'condition': condition_multiplier,
                'location': self._get_location_factor(location)
            }
        )
```

---

## Advanced Features

### Expert Network Integration

```python
# Professional verification system
class ProfessionalVerificationService:
    def __init__(self, db: Database, verification_api: VerificationAPI):
        self.db = db
        self.verification_api = verification_api
    
    async def submit_professional_application(
        self, 
        user_id: str, 
        application: ProfessionalApplication
    ) -> VerificationRequest:
        # Validate credentials
        credential_validation = await self.verification_api.validate_credentials(
            credentials=application.credentials,
            profession_type=application.profession_type
        )
        
        # Create verification request
        request = await self.db.execute(
            """
            INSERT INTO professional_verification_requests (
                user_id, profession_type, credentials, 
                experience_years, specializations, portfolio,
                validation_results, status
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, 'pending'
            ) RETURNING *
            """,
            user_id,
            application.profession_type,
            application.credentials,
            application.experience_years,
            application.specializations,
            application.portfolio,
            credential_validation
        )
        
        # Queue for manual review if needed
        if credential_validation.requires_manual_review:
            await self._queue_for_manual_review(request)
        
        return VerificationRequest.from_db(request)
    
    async def approve_professional(
        self, 
        request_id: str, 
        reviewer_id: str
    ) -> ProfessionalProfile:
        # Update verification status
        await self.db.execute(
            """
            UPDATE professional_verification_requests 
            SET status = 'approved', 
                reviewed_by = $1, 
                reviewed_at = NOW()
            WHERE id = $2
            """,
            reviewer_id,
            request_id
        )
        
        # Create professional profile
        request = await self._get_verification_request(request_id)
        
        professional_profile = await self.db.execute(
            """
            INSERT INTO professional_profiles (
                user_id, profession_type, specializations,
                experience_years, verification_level, 
                consultation_rate, availability
            ) VALUES (
                $1, $2, $3, $4, 'verified', $5, $6
            ) RETURNING *
            """,
            request.user_id,
            request.profession_type,
            request.specializations,
            request.experience_years,
            request.consultation_rate,
            request.availability
        )
        
        # Grant professional permissions
        await self._grant_professional_permissions(request.user_id)
        
        return ProfessionalProfile.from_db(professional_profile)
```

### Analytics Dashboard

```dart
// Plant care analytics dashboard
class PlantCareAnalyticsDashboard extends ConsumerWidget {
  const PlantCareAnalyticsDashboard({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final analytics = ref.watch(plantCareAnalyticsProvider);
    
    return analytics.when(
      data: (data) => SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Overview cards
            Row(
              children: [
                Expanded(
                  child: AnalyticsCard(
                    title: 'Plants Thriving',
                    value: '${data.healthyPlantsCount}',
                    subtitle: 'of ${data.totalPlantsCount} plants',
                    trend: data.healthTrend,
                    color: Colors.green,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: AnalyticsCard(
                    title: 'Care Consistency',
                    value: '${data.careConsistencyScore}%',
                    subtitle: 'last 30 days',
                    trend: data.consistencyTrend,
                    color: Colors.blue,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: 24),
            
            // Plant health trends chart
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Plant Health Trends',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    SizedBox(
                      height: 200,
                      child: PlantHealthChart(
                        data: data.healthTrendData,
                        timeRange: data.selectedTimeRange,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            // Care activity heatmap
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Care Activity',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    CareActivityHeatmap(
                      data: data.careActivityData,
                      onDateTap: (date) => _showDayDetails(context, date),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            // Individual plant performance
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Plant Performance',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    ...data.plantPerformanceData.map(
                      (plant) => PlantPerformanceCard(
                        plant: plant,
                        onTap: () => _showPlantDetails(context, plant),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            // Achievements and milestones
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Achievements',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 16),
                    AchievementGrid(
                      achievements: data.achievements,
                      onAchievementTap: _showAchievementDetails,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
      loading: () => const AnalyticsDashboardSkeleton(),
      error: (error, stack) => AnalyticsErrorWidget(error: error),
    );
  }
}
```

---

## Production Readiness Checklist

### Security & Privacy
- [ ] Implement comprehensive input validation and sanitization
- [ ] Add rate limiting and DDoS protection
- [ ] Ensure GDPR compliance for user data
- [ ] Implement secure file upload with virus scanning
- [ ] Add comprehensive audit logging
- [ ] Conduct security penetration testing

### Performance & Scalability
- [ ] Implement horizontal scaling for backend services
- [ ] Add comprehensive monitoring and alerting
- [ ] Optimize database for high-load scenarios
- [ ] Implement CDN for global content delivery
- [ ] Add automated performance testing
- [ ] Optimize mobile app bundle size

### Quality Assurance
- [ ] Achieve 90%+ test coverage for critical paths
- [ ] Implement automated UI testing
- [ ] Add comprehensive error tracking and reporting
- [ ] Conduct accessibility testing and improvements
- [ ] Perform cross-platform compatibility testing
- [ ] Add comprehensive API documentation

### Deployment & Operations
- [ ] Set up production CI/CD pipeline
- [ ] Implement blue-green deployment strategy
- [ ] Add comprehensive backup and disaster recovery
- [ ] Set up production monitoring and logging
- [ ] Create operational runbooks and documentation
- [ ] Implement feature flags for controlled rollouts

---

## Success Metrics

- [ ] App store rating of 4.5+ stars
- [ ] 95% uptime with sub-second response times
- [ ] User retention rate of 70%+ after 30 days
- [ ] Plant care success rate improvement of 40%+
- [ ] Active marketplace with 100+ successful trades
- [ ] Expert network with 50+ verified professionals
- [ ] Community engagement with 1000+ daily active users
- [ ] Zero critical security vulnerabilities

---

## Relevant Files

**Performance & Optimization**:
- `app/core/cache_service.py` - Advanced caching strategies
- `app/core/performance_monitor.py` - Performance monitoring
- `app/services/optimization_service.py` - Query and resource optimization
- `scripts/performance_tests.py` - Automated performance testing

**Advanced AR Features**:
- `lib/features/ar_advanced/` - Advanced AR implementations
- `lib/features/plant_measurement/` - AR measurement tools
- `lib/features/health_visualization/` - Plant health AR overlays
- `lib/shared/ar/advanced_ar_controller.dart` - Enhanced AR controls

**Social Commerce**:
- `app/services/marketplace_service.py` - Plant marketplace logic
- `app/services/trading_service.py` - Secure trading system
- `app/services/payment_service.py` - Payment and escrow handling
- `lib/features/marketplace/` - Marketplace UI components

**Professional Network**:
- `app/services/professional_service.py` - Expert verification and management
- `app/services/consultation_service.py` - Expert consultation system
- `lib/features/expert_network/` - Professional features UI
- `lib/features/consultations/` - Consultation booking interface

**Analytics & Insights**:
- `app/services/analytics_service.py` - Advanced analytics engine
- `app/ml/predictive_analytics.py` - Predictive plant care models
- `lib/features/analytics/` - Analytics dashboard components
- `lib/shared/charts/` - Custom chart widgets

**Production Infrastructure**:
- `docker/production/` - Production Docker configurations
- `kubernetes/` - Kubernetes deployment manifests
- `scripts/deployment/` - Deployment automation scripts
- `monitoring/` - Monitoring and alerting configurations
- `docs/operations/` - Operational documentation

---

## Project Completion

With Phase 4 complete, the plant-focused social platform will be a production-ready application that:

- Provides an exceptional user experience with smooth performance
- Offers advanced AR features for immersive plant care
- Enables a thriving marketplace for plant trading
- Connects users with verified plant care professionals
- Delivers personalized insights through advanced analytics
- Maintains high security and privacy standards
- Scales efficiently to support growing user base

The app will be ready for app store submission and real-world deployment, with all necessary infrastructure, monitoring, and operational procedures in place.
</file>

<file path="_docs/project-overview-example.md">
# Project Overview

This 7-day project challenges you to build a fully functional Snapchat clone, then enhance it with cutting-edge RAG (Retrieval-Augmented Generation) capabilities that surpass existing social platforms. You'll leverage modern AI development tools and implement sophisticated content generation and personalization systems throughout the entire user experience.
---

## Phase 1: Core Clone

Build a complete ephemeral messaging platform with essential features:

- **Real-time photo/video sharing with disappearing messages**
- **Simple AR filters and camera effects**
- **User authentication and friend management**
- **Stories and group messaging functionality**
- **Core social features matching Snapchat's core experien**
---

## Phase 2: RAG Enhancement (Days 4-7)

Transform your clone by integrating advanced RAG capabilities tailored to your chosen user niche:

**Personalized content generation based on user interests and history**
**Intelligent caption and story suggestions using RAG**
**Context-aware friend and content recommendations**
**AI-generated content ideas and prompts**


---

## Ultimate Goal: 

Create a better version of Snapchat built with RAG-first principles, demonstrating how retrieval-augmented generation can revolutionize content creation and personalization beyond what traditional platforms offer.
</file>

<file path="_docs/project-rules.md">
# Project Rules & Development Guidelines

Comprehensive development standards and conventions for our AI-first plant-focused Snapchat clone with RAG capabilities. This document consolidates all project rules, directory structures, naming conventions, and best practices to ensure modular, scalable, and maintainable code.

---

## Project Philosophy

### AI-First Development Principles

**Modular Architecture**
- Maximum file size: 500 lines
- Single responsibility principle for all modules
- Clear separation of concerns
- Dependency injection for testability

**Scalable Design**
- Feature-first organization over file-type grouping
- Horizontal scaling considerations from day one
- Stateless service design where possible
- Event-driven architecture for real-time features

**Maintainable Codebase**
- Self-documenting code with descriptive names
- Comprehensive inline documentation
- Consistent patterns across all modules
- Easy navigation for AI tools and developers

---

## Directory Structure

### Frontend (Flutter) Structure

```
lib/
 core/                           # Core application infrastructure
    constants/                  # App-wide constants and configuration
       api_constants.dart      # API endpoints and keys
       app_constants.dart      # General app constants
       theme_constants.dart    # Theme-related constants
    errors/                     # Error handling and exceptions
       exceptions.dart         # Custom exception classes
       failures.dart          # Failure handling
       error_handler.dart      # Global error handling
    network/                    # Network layer and API clients
       api_client.dart         # HTTP client configuration
       network_info.dart       # Network connectivity
       interceptors.dart       # Request/response interceptors
    utils/                      # Utility functions and helpers
        validators.dart         # Input validation utilities
        formatters.dart         # Data formatting utilities
        extensions.dart         # Dart extensions
 features/                       # Feature-based modules
    auth/                       # Authentication feature
       data/                   # Data layer
          datasources/        # Remote and local data sources
          models/             # Data models
          repositories/       # Repository implementations
       domain/                 # Business logic layer
          entities/           # Business entities
          repositories/       # Repository interfaces
          usecases/           # Business use cases
       presentation/           # UI layer
           pages/              # Screen widgets
           widgets/            # Feature-specific widgets
           providers/          # State management
    camera/                     # Camera and AR features
       data/
       domain/
       presentation/
    chat/                       # Messaging functionality
       data/
       domain/
       presentation/
    discover/                   # Content discovery with RAG
       data/
       domain/
       presentation/
    profile/                    # User profile management
       data/
       domain/
       presentation/
    plant_care/                 # Plant care and RAG features
        data/
        domain/
        presentation/
 shared/                         # Shared components across features
    widgets/                    # Reusable UI components
       buttons/                # Button components
       cards/                  # Card components
       forms/                  # Form components
       common/                 # Common widgets
    models/                     # Shared data models
    services/                   # Shared services
       storage_service.dart    # Local storage
       notification_service.dart # Push notifications
       analytics_service.dart  # Analytics tracking
    providers/                  # Global state providers
 main.dart                       # Application entry point
```

### Backend (FastAPI) Structure

```
app/
 api/                            # API layer
    deps.py                     # Dependency injection
    endpoints/                  # API endpoint modules
       auth.py                 # Authentication endpoints
       users.py                # User management endpoints
       plants.py               # Plant-related endpoints
       chat.py                 # Chat and messaging endpoints
       content.py              # Content sharing endpoints
       rag.py                  # RAG and AI endpoints
    middleware/                 # Custom middleware
        auth_middleware.py      # Authentication middleware
        cors_middleware.py      # CORS configuration
        rate_limit_middleware.py # Rate limiting
 core/                           # Core application configuration
    config.py                   # Application configuration
    security.py                 # Security utilities
    database.py                 # Database configuration
    events.py                   # Application lifecycle events
 models/                         # SQLAlchemy models
    user.py                     # User model
    plant.py                    # Plant model
    message.py                  # Message model
    content.py                  # Content model
    base.py                     # Base model class
 schemas/                        # Pydantic schemas
    user.py                     # User schemas
    plant.py                    # Plant schemas
    message.py                  # Message schemas
    content.py                  # Content schemas
    common.py                   # Common schemas
 services/                       # Business logic services
    auth_service.py             # Authentication service
    user_service.py             # User management service
    plant_service.py            # Plant care service
    chat_service.py             # Chat service
    content_service.py          # Content management service
    rag_service.py              # RAG and AI service
    notification_service.py     # Push notification service
    storage_service.py          # File storage service
 utils/                          # Utility functions
    validators.py               # Input validation
    formatters.py               # Data formatting
    helpers.py                  # General helpers
    constants.py                # Application constants
 tests/                          # Test modules
    unit/                       # Unit tests
    integration/                # Integration tests
    e2e/                        # End-to-end tests
 main.py                         # Application entry point
```

### Database Structure

```
database/
 migrations/                     # Alembic migrations
    versions/                   # Migration versions
    env.py                      # Migration environment
 seeds/                          # Database seed data
    users.sql                   # Sample user data
    plants.sql                  # Plant species data
    care_guides.sql             # Plant care information
 scripts/                        # Database utility scripts
     backup.py                   # Backup scripts
     restore.py                  # Restore scripts
     maintenance.py              # Maintenance tasks
```

### Documentation Structure

```
_docs/
 phases/                         # Development phase documentation
    phase-1-core-clone.md      # Phase 1 tasks and deliverables
    phase-2-rag-enhancement.md # Phase 2 tasks and deliverables
    phase-3-optimization.md    # Phase 3 tasks and deliverables
 api/                            # API documentation
    endpoints.md                # Endpoint documentation
    authentication.md          # Auth documentation
    schemas.md                  # Schema documentation
 deployment/                     # Deployment guides
    local-setup.md              # Local development setup
    staging-deployment.md       # Staging deployment
    production-deployment.md    # Production deployment
 architecture/                   # Architecture documentation
     system-design.md            # Overall system design
     database-design.md          # Database schema design
     security-design.md          # Security architecture
```

---

## Naming Conventions

### File Naming

**Flutter/Dart Files**
- Use `snake_case` for all file names
- Descriptive names indicating purpose
- Suffix conventions:
  - `_screen.dart` for screen widgets
  - `_widget.dart` for reusable widgets
  - `_model.dart` for data models
  - `_service.dart` for service classes
  - `_provider.dart` for state providers
  - `_repository.dart` for repository classes
  - `_usecase.dart` for use case classes

**Examples:**
```
user_profile_screen.dart
plant_identification_widget.dart
user_model.dart
auth_service.dart
plant_care_provider.dart
user_repository.dart
get_plant_details_usecase.dart
```

**Python Files**
- Use `snake_case` for all file names
- Descriptive names indicating purpose
- Suffix conventions:
  - `_service.py` for service classes
  - `_model.py` for SQLAlchemy models
  - `_schema.py` for Pydantic schemas
  - `_repository.py` for repository classes
  - `_utils.py` for utility functions

**Examples:**
```
user_service.py
plant_model.py
auth_schema.py
plant_repository.py
validation_utils.py
```

### Code Naming

**Variables and Functions**
- Use `camelCase` in Dart/Flutter
- Use `snake_case` in Python
- Descriptive names with auxiliary verbs
- Boolean variables start with `is`, `has`, `can`, `should`

**Examples:**
```dart
// Dart/Flutter
bool isLoading = false;
bool hasError = false;
bool canEditProfile = true;
String userName = '';
List<Plant> userPlants = [];

void getUserPlants() {}
Future<void> updatePlantCare() async {}
```

```python
# Python
is_authenticated = False
has_permission = True
can_access_feature = False
user_name = ""
plant_collection = []

def get_user_plants():
    pass

async def update_plant_care():
    pass
```

**Classes and Types**
- Use `PascalCase` for all class names
- Descriptive names indicating purpose
- Suffix conventions:
  - `Screen` for screen widgets
  - `Widget` for reusable widgets
  - `Model` for data models
  - `Service` for service classes
  - `Provider` for state providers
  - `Repository` for repository classes
  - `UseCase` for use case classes

**Examples:**
```dart
// Dart/Flutter
class UserProfileScreen extends StatelessWidget {}
class PlantIdentificationWidget extends StatefulWidget {}
class UserModel {}
class AuthService {}
class PlantCareProvider extends StateNotifier {}
class UserRepository {}
class GetPlantDetailsUseCase {}
```

```python
# Python
class UserService:
    pass

class PlantModel(Base):
    pass

class AuthSchema(BaseModel):
    pass

class PlantRepository:
    pass
```

**Constants**
- Use `SCREAMING_SNAKE_CASE` for constants
- Group related constants in dedicated files
- Prefix with context when needed

**Examples:**
```dart
// Dart/Flutter
const String API_BASE_URL = 'https://api.plantsnap.com';
const int MAX_UPLOAD_SIZE = 10485760; // 10MB
const Duration CACHE_DURATION = Duration(hours: 1);
const Color FOREST_GREEN = Color(0xFF2D5A27);
```

```python
# Python
API_BASE_URL = "https://api.plantsnap.com"
MAX_UPLOAD_SIZE = 10485760  # 10MB
CACHE_DURATION = 3600  # 1 hour in seconds
FOREST_GREEN = "#2D5A27"
```

### Database Naming

**Tables**
- Use `snake_case` with plural nouns
- Descriptive names indicating content
- Avoid abbreviations

**Examples:**
```sql
users
plant_collections
care_schedules
message_threads
content_items
rag_embeddings
```

**Columns**
- Use `snake_case` for all column names
- Descriptive names indicating purpose
- Standard suffixes:
  - `_id` for primary/foreign keys
  - `_at` for timestamps
  - `_count` for counters
  - `_url` for URLs
  - `_json` for JSON columns

**Examples:**
```sql
user_id
email_address
created_at
updated_at
plant_count
profile_image_url
metadata_json
```

**Indexes and Constraints**
- Use descriptive names with prefixes
- Prefixes:
  - `idx_` for indexes
  - `fk_` for foreign keys
  - `uk_` for unique constraints
  - `ck_` for check constraints

**Examples:**
```sql
idx_users_email
idx_plants_species_name
fk_plants_user_id
uk_users_username
ck_users_age_positive
```

---

## Code Documentation Standards

### File Headers

Every file must start with a comprehensive header comment explaining its purpose, contents, and usage.

**Dart/Flutter Example:**
```dart
/// Plant Care Service
/// 
/// Handles all plant care related operations including:
/// - Plant identification and species lookup
/// - Care schedule management and reminders
/// - RAG-enhanced care recommendations
/// - Integration with external plant databases
/// 
/// Dependencies:
/// - OpenAI API for plant identification
/// - Local database for care schedules
/// - Push notification service for reminders
/// 
/// Usage:
/// ```dart
/// final plantCareService = PlantCareService();
/// final plant = await plantCareService.identifyPlant(imageFile);
/// await plantCareService.createCareSchedule(plant.id, schedule);
/// ```
/// 
/// Author: Development Team
/// Created: 2024-01-01
/// Last Modified: 2024-01-15

import 'package:flutter/material.dart';
// ... rest of file
```

**Python Example:**
```python
"""
Plant Care Service Module

Handles all plant care related operations including:
- Plant identification and species lookup
- Care schedule management and reminders  
- RAG-enhanced care recommendations
- Integration with external plant databases

Dependencies:
    - OpenAI API for plant identification
    - PostgreSQL database for data persistence
    - Redis for caching and real-time features
    - Celery for background task processing

Usage:
    from services.plant_care_service import PlantCareService
    
    service = PlantCareService()
    plant = await service.identify_plant(image_data)
    schedule = await service.create_care_schedule(plant.id, care_data)

Author: Development Team
Created: 2024-01-01
Last Modified: 2024-01-15
"""

from typing import List, Optional
# ... rest of file
```

### Function Documentation

**Dart/Flutter (DartDoc):**
```dart
/// Identifies a plant species from an uploaded image using AI.
/// 
/// Uses OpenAI's vision API to analyze the plant image and returns
/// detailed species information including care requirements.
/// 
/// Parameters:
/// - [imageFile]: The plant image file to analyze
/// - [confidence]: Minimum confidence threshold (0.0-1.0)
/// - [includeCareTips]: Whether to include care recommendations
/// 
/// Returns:
/// A [PlantIdentification] object containing species info and care data.
/// 
/// Throws:
/// - [PlantIdentificationException] if analysis fails
/// - [NetworkException] if API request fails
/// - [ValidationException] if image format is invalid
/// 
/// Example:
/// ```dart
/// final identification = await identifyPlant(
///   imageFile: selectedImage,
///   confidence: 0.8,
///   includeCareTips: true,
/// );
/// print('Species: ${identification.speciesName}');
/// ```
Future<PlantIdentification> identifyPlant({
  required File imageFile,
  double confidence = 0.7,
  bool includeCareTips = true,
}) async {
  // Implementation
}
```

**Python (Google Style):**
```python
async def identify_plant(
    image_data: bytes,
    confidence: float = 0.7,
    include_care_tips: bool = True
) -> PlantIdentification:
    """Identifies a plant species from uploaded image data using AI.
    
    Uses OpenAI's vision API to analyze the plant image and returns
    detailed species information including care requirements.
    
    Args:
        image_data: Binary image data to analyze
        confidence: Minimum confidence threshold (0.0-1.0)
        include_care_tips: Whether to include care recommendations
        
    Returns:
        PlantIdentification object containing species info and care data
        
    Raises:
        PlantIdentificationError: If analysis fails
        NetworkError: If API request fails  
        ValidationError: If image format is invalid
        
    Example:
        >>> identification = await identify_plant(
        ...     image_data=image_bytes,
        ...     confidence=0.8,
        ...     include_care_tips=True
        ... )
        >>> print(f"Species: {identification.species_name}")
    """
    # Implementation
```

### Class Documentation

**Dart/Flutter:**
```dart
/// Plant Care Provider for state management.
/// 
/// Manages the application state for plant care features including:
/// - User's plant collection
/// - Care schedules and reminders
/// - RAG-generated recommendations
/// - Real-time care notifications
/// 
/// This provider uses Riverpod for dependency injection and state management.
/// It automatically syncs with the backend API and local storage.
/// 
/// State Properties:
/// - [plants]: List of user's plants
/// - [careSchedules]: Active care schedules
/// - [recommendations]: AI-generated care tips
/// - [isLoading]: Loading state indicator
/// - [error]: Error state information
/// 
/// Example:
/// ```dart
/// final plantCareProvider = ref.watch(plantCareProviderProvider);
/// final plants = plantCareProvider.plants;
/// await plantCareProvider.addPlant(newPlant);
/// ```
class PlantCareProvider extends StateNotifier<PlantCareState> {
  // Implementation
}
```

**Python:**
```python
class PlantCareService:
    """Service for managing plant care operations.
    
    Handles all plant care related functionality including:
    - Plant identification and species lookup
    - Care schedule management and reminders
    - RAG-enhanced care recommendations  
    - Integration with external plant databases
    
    This service integrates with multiple external APIs and maintains
    local caching for performance optimization.
    
    Attributes:
        db_session: Database session for data persistence
        openai_client: OpenAI API client for AI operations
        redis_client: Redis client for caching
        notification_service: Service for push notifications
        
    Example:
        >>> service = PlantCareService(db_session=session)
        >>> plant = await service.identify_plant(image_data)
        >>> schedule = await service.create_care_schedule(plant.id, care_data)
    """
    
    def __init__(
        self,
        db_session: AsyncSession,
        openai_client: OpenAI,
        redis_client: Redis,
        notification_service: NotificationService
    ):
        # Implementation
```

---

## Code Quality Standards

### General Principles

**Functional and Declarative Programming**
- Prefer pure functions over stateful classes
- Use immutable data structures where possible
- Avoid side effects in business logic
- Favor composition over inheritance

**Error Handling**
- Throw specific exceptions instead of generic ones
- Never use fallback values that hide errors
- Implement comprehensive error logging
- Provide meaningful error messages to users

**Performance Considerations**
- Lazy loading for large datasets
- Efficient algorithms and data structures
- Proper memory management
- Caching strategies for expensive operations

### Flutter-Specific Standards

**Widget Design**
```dart
/// Good: Functional widget with clear purpose
Widget buildPlantCard(Plant plant, VoidCallback onTap) {
  return Card(
    child: ListTile(
      leading: CachedNetworkImage(imageUrl: plant.imageUrl),
      title: Text(plant.name),
      subtitle: Text(plant.species),
      onTap: onTap,
    ),
  );
}

/// Avoid: Overly complex stateful widgets
class ComplexPlantWidget extends StatefulWidget {
  // Too many responsibilities in one widget
}
```

**State Management**
```dart
/// Good: Clear state management with Riverpod
final plantListProvider = StateNotifierProvider<PlantListNotifier, List<Plant>>(
  (ref) => PlantListNotifier(ref.read(plantRepositoryProvider)),
);

class PlantListNotifier extends StateNotifier<List<Plant>> {
  PlantListNotifier(this._repository) : super([]);
  
  final PlantRepository _repository;
  
  Future<void> loadPlants() async {
    try {
      final plants = await _repository.getAllPlants();
      state = plants;
    } catch (e) {
      // Handle error appropriately
      throw PlantLoadException('Failed to load plants: $e');
    }
  }
}
```

**Performance Optimization**
```dart
/// Good: Optimized list building
Widget buildPlantList(List<Plant> plants) {
  return ListView.builder(
    itemCount: plants.length,
    itemBuilder: (context, index) {
      final plant = plants[index];
      return PlantListItem(key: ValueKey(plant.id), plant: plant);
    },
  );
}

/// Good: Const constructors for static widgets
class PlantIcon extends StatelessWidget {
  const PlantIcon({Key? key, required this.type}) : super(key: key);
  
  final PlantType type;
  
  @override
  Widget build(BuildContext context) {
    return Icon(type.icon);
  }
}
```

### Python-Specific Standards

**Service Layer Design**
```python
# Good: Clear service with single responsibility
class PlantIdentificationService:
    """Service for identifying plants using AI."""
    
    def __init__(self, openai_client: OpenAI, cache: Redis):
        self._openai_client = openai_client
        self._cache = cache
    
    async def identify_plant(self, image_data: bytes) -> PlantIdentification:
        """Identify plant species from image data."""
        # Check cache first
        cache_key = self._generate_cache_key(image_data)
        cached_result = await self._cache.get(cache_key)
        
        if cached_result:
            return PlantIdentification.from_json(cached_result)
        
        # Call AI service
        result = await self._call_openai_vision(image_data)
        
        # Cache result
        await self._cache.setex(
            cache_key, 
            CACHE_DURATION, 
            result.to_json()
        )
        
        return result
```

**Error Handling**
```python
# Good: Specific exceptions with context
class PlantServiceError(Exception):
    """Base exception for plant service errors."""
    pass

class PlantNotFoundError(PlantServiceError):
    """Raised when a plant cannot be found."""
    
    def __init__(self, plant_id: str):
        super().__init__(f"Plant with ID {plant_id} not found")
        self.plant_id = plant_id

class PlantIdentificationError(PlantServiceError):
    """Raised when plant identification fails."""
    
    def __init__(self, reason: str, confidence: float = 0.0):
        super().__init__(f"Plant identification failed: {reason}")
        self.reason = reason
        self.confidence = confidence

# Usage in service
async def get_plant_by_id(self, plant_id: str) -> Plant:
    plant = await self._repository.get_by_id(plant_id)
    if not plant:
        raise PlantNotFoundError(plant_id)
    return plant
```

**Async/Await Patterns**
```python
# Good: Proper async patterns
async def process_plant_care_batch(self, plant_ids: List[str]) -> List[CareResult]:
    """Process care updates for multiple plants concurrently."""
    tasks = [
        self._process_single_plant_care(plant_id) 
        for plant_id in plant_ids
    ]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Handle any exceptions
    processed_results = []
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            logger.error(f"Failed to process plant {plant_ids[i]}: {result}")
            processed_results.append(CareResult.error(plant_ids[i], str(result)))
        else:
            processed_results.append(result)
    
    return processed_results
```

---

## Testing Standards

### Test Organization

**Flutter Tests**
```
test/
 unit/                           # Unit tests
    models/                     # Model tests
    services/                   # Service tests
    providers/                  # Provider tests
    utils/                      # Utility tests
 widget/                         # Widget tests
    screens/                    # Screen widget tests
    components/                 # Component tests
    common/                     # Common widget tests
 integration/                    # Integration tests
    auth_flow_test.dart         # Authentication flow
    plant_care_flow_test.dart   # Plant care flow
    chat_flow_test.dart         # Chat functionality
 test_helpers/                   # Test utilities
     mock_data.dart              # Mock data generators
     test_utils.dart             # Test helper functions
     widget_test_utils.dart      # Widget testing utilities
```

**Python Tests**
```
tests/
 unit/                           # Unit tests
    services/                   # Service tests
    models/                     # Model tests
    schemas/                    # Schema tests
    utils/                      # Utility tests
 integration/                    # Integration tests
    api/                        # API endpoint tests
    database/                   # Database tests
    external/                   # External service tests
 e2e/                            # End-to-end tests
    auth_flow_test.py           # Authentication flow
    plant_care_flow_test.py     # Plant care flow
    chat_flow_test.py           # Chat functionality
 fixtures/                       # Test fixtures
     sample_data.py              # Sample data
     mock_responses.py           # Mock API responses
     test_database.py            # Test database setup
```

### Test Naming and Documentation

**Test Function Naming**
- Use descriptive names that explain what is being tested
- Follow pattern: `test_[method]_[scenario]_[expected_result]`
- Include edge cases and error conditions

**Examples:**
```dart
// Flutter/Dart
void main() {
  group('PlantIdentificationService', () {
    test('identifyPlant_withValidImage_returnsPlantIdentification', () async {
      // Test implementation
    });
    
    test('identifyPlant_withInvalidImage_throwsValidationException', () async {
      // Test implementation
    });
    
    test('identifyPlant_withNetworkError_throwsNetworkException', () async {
      // Test implementation
    });
  });
}
```

```python
# Python
class TestPlantIdentificationService:
    """Tests for PlantIdentificationService."""
    
    async def test_identify_plant_with_valid_image_returns_identification(self):
        """Test that valid image returns plant identification."""
        # Test implementation
        pass
    
    async def test_identify_plant_with_invalid_image_raises_validation_error(self):
        """Test that invalid image raises ValidationError."""
        # Test implementation
        pass
    
    async def test_identify_plant_with_network_error_raises_network_error(self):
        """Test that network issues raise NetworkError."""
        # Test implementation
        pass
```

---

## Security Standards

### Authentication and Authorization

**JWT Token Management**
```python
# Secure token configuration
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY")  # Must be in environment
JWT_ALGORITHM = "HS256"
JWT_ACCESS_TOKEN_EXPIRE_MINUTES = 30
JWT_REFRESH_TOKEN_EXPIRE_DAYS = 7

# Token validation
async def validate_token(token: str) -> UserClaims:
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise InvalidTokenError("Token missing user ID")
        return UserClaims(user_id=user_id, **payload)
    except JWTError as e:
        raise InvalidTokenError(f"Token validation failed: {e}")
```

**Input Validation**
```python
# Pydantic schemas for validation
class PlantCreateSchema(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    species: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    image_url: Optional[HttpUrl] = None
    
    @validator('name')
    def validate_name(cls, v):
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()
    
    @validator('description')
    def validate_description(cls, v):
        if v and len(v.strip()) == 0:
            return None
        return v
```

**Data Protection**
```python
# Sensitive data handling
class UserModel(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)  # Never store plain passwords
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    def set_password(self, password: str) -> None:
        """Hash and set user password."""
        self.password_hash = get_password_hash(password)
    
    def verify_password(self, password: str) -> bool:
        """Verify user password against hash."""
        return verify_password(password, self.password_hash)
```

### API Security

**Rate Limiting**
```python
# Rate limiting middleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Apply rate limits to endpoints
@app.post("/api/v1/plants/identify")
@limiter.limit("10/minute")  # Limit AI calls
async def identify_plant(
    request: Request,
    image: UploadFile,
    current_user: User = Depends(get_current_user)
):
    # Implementation
```

**CORS Configuration**
```python
# Secure CORS setup
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # Development
        "https://plantsnap.com",  # Production
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
    expose_headers=["X-Total-Count"],
)
```

---

## Performance Standards

### Database Optimization

**Query Optimization**
```sql
-- Good: Efficient queries with proper indexes
CREATE INDEX CONCURRENTLY idx_plants_user_id_species 
ON plants(user_id, species_name) 
WHERE deleted_at IS NULL;

-- Good: Optimized pagination
SELECT * FROM plants 
WHERE user_id = $1 
  AND created_at < $2 
ORDER BY created_at DESC 
LIMIT 20;

-- Avoid: N+1 queries
-- Bad: Loading plants then care schedules separately
-- Good: Use JOINs or eager loading
SELECT p.*, cs.* 
FROM plants p 
LEFT JOIN care_schedules cs ON p.id = cs.plant_id 
WHERE p.user_id = $1;
```

**Connection Management**
```python
# Database connection pooling
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=30,
    pool_pre_ping=True,
    pool_recycle=3600,
)

AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

# Proper session management
async def get_db_session() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
```

### Caching Strategies

**Redis Caching**
```python
# Efficient caching patterns
class PlantCacheService:
    """Service for caching plant-related data."""
    
    def __init__(self, redis_client: Redis):
        self._redis = redis_client
    
    async def get_plant_details(self, plant_id: str) -> Optional[PlantDetails]:
        """Get plant details from cache."""
        cache_key = f"plant:details:{plant_id}"
        cached_data = await self._redis.get(cache_key)
        
        if cached_data:
            return PlantDetails.from_json(cached_data)
        return None
    
    async def set_plant_details(
        self, 
        plant_id: str, 
        details: PlantDetails,
        ttl: int = 3600
    ) -> None:
        """Cache plant details with TTL."""
        cache_key = f"plant:details:{plant_id}"
        await self._redis.setex(
            cache_key, 
            ttl, 
            details.to_json()
        )
    
    async def invalidate_plant_cache(self, plant_id: str) -> None:
        """Invalidate all cached data for a plant."""
        pattern = f"plant:*:{plant_id}"
        keys = await self._redis.keys(pattern)
        if keys:
            await self._redis.delete(*keys)
```

### Frontend Performance

**Flutter Optimization**
```dart
// Efficient list rendering
class OptimizedPlantList extends StatelessWidget {
  const OptimizedPlantList({Key? key, required this.plants}) : super(key: key);
  
  final List<Plant> plants;
  
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      // Use item extent for better performance
      itemExtent: 120.0,
      itemCount: plants.length,
      // Cache extent for smooth scrolling
      cacheExtent: 1000.0,
      itemBuilder: (context, index) {
        final plant = plants[index];
        return PlantListItem(
          key: ValueKey(plant.id), // Stable keys for efficient updates
          plant: plant,
        );
      },
    );
  }
}

// Optimized image loading
class OptimizedPlantImage extends StatelessWidget {
  const OptimizedPlantImage({
    Key? key,
    required this.imageUrl,
    this.width,
    this.height,
  }) : super(key: key);
  
  final String imageUrl;
  final double? width;
  final double? height;
  
  @override
  Widget build(BuildContext context) {
    return CachedNetworkImage(
      imageUrl: imageUrl,
      width: width,
      height: height,
      fit: BoxFit.cover,
      // Progressive loading
      progressIndicatorBuilder: (context, url, progress) {
        return Container(
          width: width,
          height: height,
          color: Colors.grey[200],
          child: Center(
            child: CircularProgressIndicator(
              value: progress.progress,
            ),
          ),
        );
      },
      // Error handling
      errorWidget: (context, url, error) {
        return Container(
          width: width,
          height: height,
          color: Colors.grey[300],
          child: const Icon(Icons.error),
        );
      },
      // Memory cache configuration
      memCacheWidth: width?.toInt(),
      memCacheHeight: height?.toInt(),
    );
  }
}
```

---

## Deployment and Environment Standards

### Environment Configuration

**Environment Variables**
```bash
# .env.example - Template for environment variables

# Database Configuration
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/plantsnap
REDIS_URL=redis://localhost:6379/0

# API Keys (Never commit actual keys)
OPENAI_API_KEY=your_openai_api_key_here
AWS_ACCESS_KEY_ID=your_aws_access_key_here
AWS_SECRET_ACCESS_KEY=your_aws_secret_key_here
AWS_S3_BUCKET=your_s3_bucket_name

# Security
JWT_SECRET_KEY=your_jwt_secret_key_here
ENCRYPTION_KEY=your_encryption_key_here

# Application Settings
APP_ENV=development
DEBUG=true
LOG_LEVEL=INFO
API_VERSION=v1

# External Services
PUSH_NOTIFICATION_KEY=your_fcm_key_here
ANALYTICS_KEY=your_analytics_key_here
```

**Docker Configuration**
```dockerfile
# Dockerfile for FastAPI backend
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash app
USER app

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# Start application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml for local development
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:password@db:5432/plantsnap
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    volumes:
      - ./app:/app
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=plantsnap
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### CI/CD Pipeline

**GitHub Actions Example**
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_plantsnap
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run linting
      run: |
        flake8 app/
        black --check app/
        isort --check-only app/
    
    - name: Run type checking
      run: mypy app/
    
    - name: Run tests
      env:
        DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/test_plantsnap
        REDIS_URL: redis://localhost:6379/0
      run: |
        pytest tests/ --cov=app --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  flutter-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Install dependencies
      run: flutter pub get
    
    - name: Run analyzer
      run: flutter analyze
    
    - name: Run tests
      run: flutter test --coverage
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
```

This comprehensive project rules document ensures consistent development practices, maintainable code structure, and scalable architecture for our AI-first plant-focused social platform.
</file>

<file path="_docs/tech-stack.md">
# Technology Stack Guide

Comprehensive guide covering best practices, limitations, and conventions for our plant-focused Snapchat clone with RAG capabilities.

---

## Selected Technology Stack

- **Frontend**: Flutter
- **Backend**: Python + FastAPI
- **Database**: PostgreSQL + Redis
- **Vector Database**: pgvector (PostgreSQL extension)
- **AI/ML**: OpenAI API + Custom Models
- **File Storage**: AWS S3 + CloudFront
- **Authentication**: FastAPI-Users
- **Real-time**: WebSockets + Redis Pub/Sub

---

## Flutter Frontend

### Best Practices

#### Project Structure
```
lib/
 core/
    constants/
    errors/
    network/
    utils/
 features/
    auth/
    camera/
    chat/
    discover/
    profile/
 shared/
    widgets/
    models/
    services/
 main.dart
```

#### State Management
- **Use**: Riverpod for dependency injection and state management
- **Pattern**: Provider + StateNotifier for complex state
- **Avoid**: setState for anything beyond simple UI state

#### Code Organization
- **Feature-first**: Organize by features, not by file types
- **Barrel exports**: Use index.dart files for clean imports
- **Separation**: Keep business logic separate from UI

#### Performance
- **Lazy loading**: Use ListView.builder for large lists
- **Image optimization**: Implement cached_network_image
- **Memory management**: Dispose controllers and streams
- **Build optimization**: Use const constructors where possible

### Limitations & Considerations

#### Camera & AR Features
- **Platform differences**: iOS and Android camera APIs vary
- **Performance**: AR filters can be resource-intensive
- **Permissions**: Handle camera/storage permissions gracefully
- **Testing**: Camera features difficult to test on simulators

#### Real-time Features
- **WebSocket management**: Handle connection drops and reconnection
- **Background state**: iOS/Android background limitations
- **Battery optimization**: Minimize background processing

#### Platform-Specific Issues
- **iOS**: App Store review guidelines for social features
- **Android**: Various screen sizes and performance levels
- **Permissions**: Different permission models between platforms

### Common Pitfalls

1. **Memory Leaks**: Not disposing StreamControllers and AnimationControllers
2. **Over-rebuilding**: Not using const widgets or proper state management
3. **Platform assumptions**: Assuming iOS/Android behavior is identical
4. **Network handling**: Not implementing proper error handling and retry logic
5. **State persistence**: Not handling app lifecycle state changes

### Conventions

#### Naming
- **Files**: snake_case (user_profile_screen.dart)
- **Classes**: PascalCase (UserProfileScreen)
- **Variables**: camelCase (isLoading, hasError)
- **Constants**: SCREAMING_SNAKE_CASE (API_BASE_URL)

#### File Organization
- **Screens**: End with "Screen" (HomeScreen)
- **Widgets**: Descriptive names (PlantIdentificationCard)
- **Models**: End with "Model" (UserModel)
- **Services**: End with "Service" (ApiService)

---

## FastAPI Backend

### Best Practices

#### Project Structure
```
app/
 api/
    deps.py
    endpoints/
    middleware/
 core/
    config.py
    security.py
    database.py
 models/
 schemas/
 services/
 utils/
 main.py
```

#### API Design
- **RESTful**: Follow REST principles for CRUD operations
- **Versioning**: Use /api/v1/ prefix for API versioning
- **Documentation**: Leverage FastAPI's automatic OpenAPI docs
- **Validation**: Use Pydantic models for request/response validation

#### Database Integration
- **SQLAlchemy**: Use async SQLAlchemy for database operations
- **Migrations**: Implement Alembic for database migrations
- **Connection pooling**: Configure proper connection pool settings
- **Transactions**: Use database transactions for data consistency

#### Security
- **Authentication**: JWT tokens with refresh token rotation
- **Authorization**: Role-based access control (RBAC)
- **Input validation**: Sanitize all user inputs
- **Rate limiting**: Implement API rate limiting
- **CORS**: Configure CORS properly for frontend integration

### Limitations & Considerations

#### Performance
- **Async limitations**: Not all libraries support async operations
- **GIL**: Python's Global Interpreter Lock limits CPU-bound tasks
- **Memory usage**: Python can be memory-intensive for large datasets
- **Cold starts**: Consider startup time for serverless deployments

#### Scalability
- **Single-threaded**: FastAPI runs on single thread per worker
- **Database connections**: Limited by PostgreSQL connection limits
- **File uploads**: Large file uploads can block the event loop
- **WebSocket scaling**: WebSocket connections are stateful

#### AI/ML Integration
- **Model loading**: Large models can cause memory issues
- **Inference time**: AI operations can be slow and block requests
- **API limits**: External AI services have rate limits
- **Cost management**: AI API calls can be expensive

### Common Pitfalls

1. **Blocking operations**: Using synchronous operations in async functions
2. **Database sessions**: Not properly managing database sessions
3. **Error handling**: Not implementing comprehensive error handling
4. **Memory leaks**: Not properly closing database connections
5. **Security**: Exposing sensitive data in API responses
6. **Validation**: Not validating file uploads and user inputs

### Conventions

#### Naming
- **Files**: snake_case (user_service.py)
- **Functions**: snake_case (get_user_by_id)
- **Classes**: PascalCase (UserService)
- **Constants**: SCREAMING_SNAKE_CASE (DATABASE_URL)

#### API Endpoints
- **Resources**: Plural nouns (/users, /plants)
- **Actions**: HTTP verbs (GET, POST, PUT, DELETE)
- **Nested resources**: /users/{user_id}/plants
- **Filtering**: Query parameters (?category=houseplants)

#### Response Format
```python
{
    "success": true,
    "data": {...},
    "message": "Operation completed successfully",
    "timestamp": "2024-01-01T00:00:00Z"
}
```

---

## PostgreSQL Database

### Best Practices

#### Schema Design
- **Normalization**: Normalize data to reduce redundancy
- **Indexes**: Create indexes on frequently queried columns
- **Constraints**: Use foreign keys and check constraints
- **Data types**: Choose appropriate data types for efficiency

#### Performance Optimization
- **Query optimization**: Use EXPLAIN ANALYZE for query planning
- **Connection pooling**: Use pgbouncer for connection management
- **Partitioning**: Partition large tables by date or category
- **Vacuum**: Regular VACUUM and ANALYZE operations

#### JSON and Vector Data
- **JSONB**: Use JSONB for plant metadata and flexible schemas
- **pgvector**: Leverage pgvector extension for RAG embeddings
- **Indexing**: Create GIN indexes on JSONB columns
- **Vector indexes**: Use HNSW indexes for vector similarity search

### Limitations & Considerations

#### Scalability
- **Vertical scaling**: PostgreSQL scales better vertically than horizontally
- **Read replicas**: Use read replicas for read-heavy workloads
- **Connection limits**: Default connection limit is relatively low
- **Lock contention**: High write concurrency can cause lock issues

#### Vector Operations
- **Memory usage**: Vector operations are memory-intensive
- **Index building**: Vector index creation can be slow
- **Similarity search**: Large vector datasets impact query performance
- **Dimensionality**: Higher dimensions increase storage and compute costs

#### Backup and Recovery
- **WAL archiving**: Configure Write-Ahead Logging for point-in-time recovery
- **Backup size**: Large databases require significant backup storage
- **Recovery time**: Recovery time increases with database size

### Common Pitfalls

1. **Missing indexes**: Not creating indexes on foreign keys and query columns
2. **N+1 queries**: Not using JOINs or eager loading
3. **Connection leaks**: Not properly closing database connections
4. **Lock timeouts**: Long-running transactions causing deadlocks
5. **Data types**: Using inappropriate data types (VARCHAR vs TEXT)
6. **Security**: Not using parameterized queries (SQL injection)

### Conventions

#### Naming
- **Tables**: snake_case, plural (users, plant_collections)
- **Columns**: snake_case (created_at, user_id)
- **Indexes**: descriptive names (idx_users_email, idx_plants_species)
- **Constraints**: descriptive names (fk_plants_user_id)

#### Schema Organization
```sql
-- Users and authentication
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Plant-specific data with JSONB
CREATE TABLE plants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    species_name VARCHAR(255),
    metadata JSONB,
    embedding vector(1536), -- OpenAI embedding dimension
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## Redis Cache & Real-time

### Best Practices

#### Data Structure Usage
- **Strings**: Simple key-value caching
- **Hashes**: User sessions and object caching
- **Lists**: Message queues and activity feeds
- **Sets**: Friend lists and unique collections
- **Sorted Sets**: Leaderboards and time-based data

#### Caching Strategy
- **Cache-aside**: Application manages cache population
- **TTL**: Set appropriate expiration times
- **Eviction**: Configure memory eviction policies
- **Serialization**: Use efficient serialization (JSON, MessagePack)

#### Real-time Messaging
- **Pub/Sub**: Use for real-time notifications
- **Channels**: Organize channels by feature (chat, notifications)
- **Message format**: Standardize message structure
- **Connection management**: Handle client disconnections

### Limitations & Considerations

#### Memory Management
- **Memory-only**: Data lost on restart (use persistence if needed)
- **Memory limits**: Configure maxmemory and eviction policies
- **Key expiration**: Expired keys consume memory until cleanup
- **Memory fragmentation**: Can occur with frequent updates

#### Persistence
- **RDB snapshots**: Point-in-time backups
- **AOF**: Append-only file for durability
- **Performance impact**: Persistence affects performance
- **Disk space**: Persistence requires additional storage

#### Scaling
- **Single-threaded**: Redis is single-threaded for commands
- **Clustering**: Redis Cluster for horizontal scaling
- **Replication**: Master-slave replication for read scaling
- **Network latency**: Performance depends on network speed

### Common Pitfalls

1. **Memory leaks**: Not setting TTL on cached data
2. **Hot keys**: Concentrating traffic on single keys
3. **Large values**: Storing large objects that block operations
4. **Connection pooling**: Not using connection pools efficiently
5. **Serialization**: Using inefficient serialization formats
6. **Monitoring**: Not monitoring memory usage and performance

---

## AI/ML Integration

### Best Practices

#### OpenAI API Usage
- **Rate limiting**: Implement exponential backoff
- **Cost optimization**: Cache responses when possible
- **Error handling**: Handle API failures gracefully
- **Prompt engineering**: Optimize prompts for plant domain

#### RAG Implementation
- **Chunking**: Split plant care documents into optimal chunks
- **Embeddings**: Use consistent embedding models
- **Retrieval**: Implement hybrid search (vector + keyword)
- **Context management**: Limit context size for API calls

#### Model Management
- **Versioning**: Track model versions and performance
- **A/B testing**: Test different models and prompts
- **Monitoring**: Monitor accuracy and user satisfaction
- **Fallbacks**: Implement fallback responses for failures

### Limitations & Considerations

#### Cost Management
- **API costs**: OpenAI API calls can be expensive
- **Token limits**: Context window limitations
- **Rate limits**: API rate limiting affects user experience
- **Usage tracking**: Monitor and budget API usage

#### Performance
- **Latency**: AI API calls add latency to responses
- **Caching**: Balance freshness with performance
- **Batch processing**: Use batch operations when possible
- **Async processing**: Use background tasks for non-critical AI operations

#### Accuracy
- **Hallucinations**: AI models can generate incorrect information
- **Domain knowledge**: General models may lack plant-specific knowledge
- **Validation**: Implement validation for AI-generated content
- **Human oversight**: Provide mechanisms for user feedback

### Common Pitfalls

1. **Over-reliance**: Using AI for everything instead of targeted use cases
2. **Poor prompts**: Not optimizing prompts for specific tasks
3. **No fallbacks**: Not handling AI service failures
4. **Cost explosion**: Not monitoring and controlling API costs
5. **Data leakage**: Sending sensitive user data to external APIs
6. **Poor UX**: Not providing loading states for AI operations

---

## Development Workflow

### Environment Setup

#### Local Development
- **Docker**: Use Docker Compose for consistent environments
- **Environment variables**: Use .env files for configuration
- **Database**: Local PostgreSQL with sample data
- **Redis**: Local Redis instance for caching and real-time

#### Testing
- **Unit tests**: Test individual functions and classes
- **Integration tests**: Test API endpoints and database operations
- **E2E tests**: Test complete user workflows
- **Performance tests**: Test under load conditions

#### CI/CD
- **Automated testing**: Run tests on every commit
- **Code quality**: Use linting and formatting tools
- **Security scanning**: Scan for vulnerabilities
- **Deployment**: Automated deployment to staging and production

### Code Quality

#### Linting and Formatting
- **Flutter**: Use dart analyze and dart format
- **Python**: Use black, isort, and flake8
- **Pre-commit hooks**: Enforce code quality before commits
- **IDE integration**: Configure IDE for consistent formatting

#### Documentation
- **API docs**: Maintain up-to-date API documentation
- **Code comments**: Document complex business logic
- **README**: Keep README files current and helpful
- **Architecture docs**: Document system architecture and decisions

---

## Security Considerations

### Authentication & Authorization
- **JWT tokens**: Use short-lived access tokens with refresh tokens
- **Password security**: Hash passwords with bcrypt
- **Session management**: Implement secure session handling
- **Multi-factor authentication**: Consider MFA for sensitive operations

### Data Protection
- **Encryption**: Encrypt sensitive data at rest and in transit
- **PII handling**: Minimize collection and storage of personal data
- **Data retention**: Implement data retention and deletion policies
- **Compliance**: Consider GDPR, CCPA, and other regulations

### API Security
- **Input validation**: Validate and sanitize all inputs
- **Rate limiting**: Prevent abuse with rate limiting
- **CORS**: Configure CORS appropriately
- **Security headers**: Implement security headers

### Infrastructure Security
- **Network security**: Use VPCs and security groups
- **Access control**: Implement least privilege access
- **Monitoring**: Monitor for security threats
- **Updates**: Keep dependencies and systems updated

---

## Monitoring & Observability

### Application Monitoring
- **Error tracking**: Use Sentry for error monitoring
- **Performance monitoring**: Track API response times
- **User analytics**: Monitor user behavior and engagement
- **Business metrics**: Track key business indicators

### Infrastructure Monitoring
- **Database performance**: Monitor query performance and connections
- **Cache hit rates**: Monitor Redis performance
- **Resource usage**: Monitor CPU, memory, and disk usage
- **Network performance**: Monitor network latency and throughput

### Alerting
- **Error rates**: Alert on high error rates
- **Performance degradation**: Alert on slow response times
- **Resource exhaustion**: Alert on high resource usage
- **Business metrics**: Alert on unusual business metric changes

---

## Deployment & Scaling

### Deployment Strategy
- **Blue-green deployment**: Zero-downtime deployments
- **Feature flags**: Control feature rollouts
- **Database migrations**: Safe database schema changes
- **Rollback procedures**: Quick rollback capabilities

### Scaling Considerations
- **Horizontal scaling**: Scale application servers horizontally
- **Database scaling**: Use read replicas and connection pooling
- **Cache scaling**: Scale Redis with clustering
- **CDN**: Use CDN for static assets and media files

### Performance Optimization
- **Database optimization**: Optimize queries and indexes
- **Caching strategy**: Implement multi-level caching
- **API optimization**: Optimize API response times
- **Frontend optimization**: Optimize Flutter app performance

This guide serves as a comprehensive reference for development best practices, helping ensure code quality, performance, and maintainability throughout the project lifecycle.
</file>

<file path="_docs/theme-rules.md">
# Theme Rules & Visual Style Guide

Comprehensive visual styling guidelines for our plant-focused Snapchat clone, defining colors, typography, spacing, and visual elements to ensure consistent theming across all platforms and features.

---

## Design System Overview

### Theme Philosophy: "Glass Garden Minimalism"

**Core Concept**: Botanical minimalism enhanced with strategic glassmorphic elements
**Visual Identity**: Clean, nature-inspired aesthetics with modern technological sophistication
**Brand Personality**: Nurturing, knowledgeable, approachable, and growth-oriented

---

## Color Palette

### Primary Colors

**Forest Green** - `#2D5A27`
- **Usage**: Primary brand color, navigation highlights, expert badges
- **Accessibility**: WCAG AA compliant with white text
- **Semantic**: Trust, expertise, deep plant knowledge
- **Applications**: Headers, primary buttons, active states

**Sage Green** - `#87A96B`
- **Usage**: Secondary actions, learning indicators, growth progress
- **Accessibility**: WCAG AA compliant with dark text
- **Semantic**: Growth, learning, community connection
- **Applications**: Secondary buttons, progress bars, badges

**Cream White** - `#F7F5F3`
- **Usage**: Primary background, content areas, card backgrounds
- **Accessibility**: High contrast base for all text colors
- **Semantic**: Clean slate, new growth, fresh start
- **Applications**: Main backgrounds, card surfaces, input fields

**Earth Brown** - `#8B4513`
- **Usage**: Grounding elements, soil references, stability indicators
- **Accessibility**: WCAG AA compliant with light backgrounds
- **Semantic**: Foundation, stability, natural grounding
- **Applications**: Icons, borders, subtle accents

### Accent Colors

**Sunset Orange** - `#FF6B35`
- **Usage**: Urgent notifications, care alerts, warning states
- **Accessibility**: High contrast for attention-grabbing elements
- **Semantic**: Urgency, attention, immediate action needed
- **Applications**: Error states, urgent care reminders, alerts

**Sky Blue** - `#87CEEB`
- **Usage**: Water-related care tips, calm interactions, info states
- **Accessibility**: WCAG AA compliant with dark text
- **Semantic**: Calm, water, peaceful growth
- **Applications**: Info messages, water care indicators, calm states

**Warm Yellow** - `#F4D03F`
- **Usage**: Achievements, successful growth, positive feedback
- **Accessibility**: Requires dark text for proper contrast
- **Semantic**: Success, achievement, sunny growth
- **Applications**: Success states, achievements, positive notifications

### Glassmorphic Color Variations

**Light Glass** - `rgba(247, 245, 243, 0.15)`
- **Usage**: Subtle overlays, gentle backgrounds
- **Applications**: Camera interface overlays, subtle cards

**Medium Glass** - `rgba(247, 245, 243, 0.25)`
- **Usage**: Prominent cards, modal backgrounds
- **Applications**: RAG content cards, modal dialogs

**Accent Glass** - `rgba(135, 169, 107, 0.12)`
- **Usage**: Botanical-tinted glass effects
- **Applications**: Plant identification overlays, nature-themed cards

**Alert Glass** - `rgba(255, 107, 53, 0.15)`
- **Usage**: Urgent care notifications with glass effect
- **Applications**: Emergency plant care alerts, warning overlays

### Semantic Color System

**Success States**
- Primary: `#87A96B` (Sage Green)
- Background: `rgba(135, 169, 107, 0.1)`
- Border: `rgba(135, 169, 107, 0.3)`

**Warning States**
- Primary: `#F4D03F` (Warm Yellow)
- Background: `rgba(244, 208, 63, 0.1)`
- Border: `rgba(244, 208, 63, 0.3)`

**Error States**
- Primary: `#FF6B35` (Sunset Orange)
- Background: `rgba(255, 107, 53, 0.1)`
- Border: `rgba(255, 107, 53, 0.3)`

**Info States**
- Primary: `#87CEEB` (Sky Blue)
- Background: `rgba(135, 206, 235, 0.1)`
- Border: `rgba(135, 206, 235, 0.3)`

### Seasonal Color Adaptations

**Spring Theme** (March - May)
- Accent: Light green tints `#A8D5A8`
- Glass: Warmer, lighter glass effects
- Mood: Fresh, new growth, optimistic

**Summer Theme** (June - August)
- Accent: Brighter, more saturated greens `#6B8E23`
- Glass: Clearer, more vibrant effects
- Mood: Abundant, thriving, energetic

**Fall Theme** (September - November)
- Accent: Warm orange and brown tints `#CD853F`
- Glass: Warmer, amber-tinted effects
- Mood: Harvest, preparation, cozy

**Winter Theme** (December - February)
- Accent: Cooler blue-green tints `#5F8A8B`
- Glass: Cooler, more muted effects
- Mood: Rest, planning, contemplative

---

## Typography

### Font Families

**Primary Font: Inter**
- **Usage**: Body text, UI elements, buttons, navigation
- **Weights**: 300 (Light), 400 (Regular), 500 (Medium), 600 (SemiBold), 700 (Bold)
- **Characteristics**: Clean, readable, modern, excellent mobile performance
- **Accessibility**: High legibility at all sizes, dyslexia-friendly

**Accent Font: Playfair Display**
- **Usage**: Headers, plant names, special emphasis
- **Weights**: 400 (Regular), 600 (SemiBold), 700 (Bold)
- **Characteristics**: Elegant serif, botanical feel, distinctive personality
- **Applications**: Page titles, plant species names, featured content

### Typography Scale

**Display Large** - 32px / 40px line height
- Font: Playfair Display Bold
- Usage: Main page headers, welcome screens
- Color: Forest Green `#2D5A27`

**Display Medium** - 28px / 36px line height
- Font: Playfair Display SemiBold
- Usage: Section headers, plant species names
- Color: Forest Green `#2D5A27`

**Heading Large** - 24px / 32px line height
- Font: Inter SemiBold
- Usage: Card headers, modal titles
- Color: Forest Green `#2D5A27`

**Heading Medium** - 20px / 28px line height
- Font: Inter Medium
- Usage: Subsection headers, feature titles
- Color: Earth Brown `#8B4513`

**Heading Small** - 18px / 24px line height
- Font: Inter Medium
- Usage: List headers, category labels
- Color: Earth Brown `#8B4513`

**Body Large** - 16px / 24px line height
- Font: Inter Regular
- Usage: Primary body text, descriptions
- Color: `#2C2C2C` (Dark gray for readability)

**Body Medium** - 14px / 20px line height
- Font: Inter Regular
- Usage: Secondary text, captions
- Color: `#5A5A5A` (Medium gray)

**Body Small** - 12px / 16px line height
- Font: Inter Regular
- Usage: Labels, metadata, timestamps
- Color: `#8A8A8A` (Light gray)

**Caption** - 11px / 14px line height
- Font: Inter Medium
- Usage: Fine print, legal text, tiny labels
- Color: `#A0A0A0` (Very light gray)

### Typography Usage Guidelines

**Plant Care Instructions**
- Headers: Heading Medium (Inter Medium)
- Steps: Body Large with numbered lists
- Tips: Body Medium with italic emphasis
- Warnings: Body Large with Sunset Orange color

**User Interface Elements**
- Button text: Body Medium (Inter Medium)
- Navigation labels: Body Small (Inter Medium)
- Input labels: Body Small (Inter Medium)
- Error messages: Body Medium with error color

**Content Hierarchy**
- Plant names: Display Medium (Playfair Display)
- Care categories: Heading Small (Inter Medium)
- Descriptions: Body Large (Inter Regular)
- Metadata: Body Small (Inter Regular)

---

## Spacing and Layout

### Spacing Scale (8px base unit)

**Micro Spacing**
- `4px` - Icon padding, fine adjustments
- `8px` - Base unit, small gaps
- `12px` - Compact spacing, tight layouts

**Standard Spacing**
- `16px` - Default spacing, comfortable gaps
- `24px` - Section spacing, card padding
- `32px` - Large spacing, major sections

**Macro Spacing**
- `48px` - Page margins, major separations
- `64px` - Screen sections, hero spacing
- `96px` - Dramatic spacing, special layouts

### Layout Grid System

**Mobile Grid** (375px base)
- Margins: 16px
- Gutters: 16px
- Columns: 4 columns
- Column width: ~71px

**Tablet Grid** (768px base)
- Margins: 24px
- Gutters: 24px
- Columns: 8 columns
- Column width: ~81px

**Component Spacing Rules**

**Cards and Containers**
- Internal padding: 16px (mobile), 24px (tablet+)
- Between cards: 16px vertical spacing
- Card corner radius: 12px (standard), 20px (prominent)

**Text Spacing**
- Paragraph spacing: 16px
- List item spacing: 8px
- Section spacing: 32px
- Header to content: 16px

**Interactive Elements**
- Button padding: 12px horizontal, 8px vertical
- Input padding: 16px horizontal, 12px vertical
- Touch target minimum: 44px  44px
- Between buttons: 16px horizontal, 12px vertical

---

## Visual Effects and Styling

### Glassmorphic Effects

**Standard Glass Effect**
```css
.botanical-glass {
  background: rgba(247, 245, 243, 0.2);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(135, 169, 107, 0.18);
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(45, 90, 39, 0.08);
}
```

**Prominent Glass Effect**
```css
.prominent-glass {
  background: rgba(247, 245, 243, 0.3);
  backdrop-filter: blur(15px);
  border: 1px solid rgba(135, 169, 107, 0.25);
  border-radius: 20px;
  box-shadow: 0 12px 40px rgba(45, 90, 39, 0.12);
}
```

**Subtle Glass Effect**
```css
.subtle-glass {
  background: rgba(247, 245, 243, 0.1);
  backdrop-filter: blur(6px);
  border: 1px solid rgba(135, 169, 107, 0.1);
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(45, 90, 39, 0.04);
}
```

### Shadow System

**Elevation Levels**

**Level 1** - Subtle elevation
- Shadow: `0 2px 8px rgba(45, 90, 39, 0.06)`
- Usage: Cards, buttons in default state

**Level 2** - Standard elevation
- Shadow: `0 4px 16px rgba(45, 90, 39, 0.08)`
- Usage: Floating elements, modals

**Level 3** - Prominent elevation
- Shadow: `0 8px 32px rgba(45, 90, 39, 0.12)`
- Usage: Important overlays, primary actions

**Level 4** - Maximum elevation
- Shadow: `0 16px 48px rgba(45, 90, 39, 0.16)`
- Usage: Tooltips, dropdowns, critical alerts

### Border Radius System

**Micro Radius** - `4px`
- Usage: Small elements, badges, chips

**Standard Radius** - `8px`
- Usage: Buttons, inputs, small cards

**Medium Radius** - `12px`
- Usage: Cards, containers, panels

**Large Radius** - `16px`
- Usage: Prominent cards, modal dialogs

**Extra Large Radius** - `20px`
- Usage: Hero elements, special containers

**Organic Radius** - `24px+`
- Usage: Botanical-inspired elements, special features

---

## Iconography

### Icon Style Guidelines

**Design Principles**
- Outlined style with 2px stroke weight
- Botanical inspiration where appropriate
- 24px  24px standard size
- Consistent visual weight across icon set
- Rounded line caps for organic feel

**Icon Categories**

**Navigation Icons**
- Camera: Botanical camera with leaf accent
- Chat: Speech bubble with plant motif
- Discover: Magnifying glass with leaf
- Stories: Circle with growth rings
- Profile: User silhouette with plant crown

**Action Icons**
- Add: Plus sign with organic curves
- Share: Arrow with leaf trail
- Save: Bookmark with botanical accent
- Like: Heart with leaf detail
- Comment: Speech bubble with natural curves

**Plant Care Icons**
- Water: Droplet with natural curves
- Light: Sun with organic rays
- Temperature: Thermometer with plant accent
- Fertilizer: Bottle with leaf label
- Pruning: Scissors with botanical handles

**Status Icons**
- Success: Checkmark with leaf flourish
- Warning: Triangle with plant accent
- Error: X with organic curves
- Info: Circle with leaf detail
- Loading: Spinner with growth animation

### Icon Color Usage

**Default State**
- Color: `#8A8A8A` (Light gray)
- Usage: Inactive navigation, secondary actions

**Active State**
- Color: `#2D5A27` (Forest Green)
- Usage: Active navigation, primary actions

**Accent State**
- Color: `#87A96B` (Sage Green)
- Usage: Highlighted features, special states

**Alert State**
- Color: `#FF6B35` (Sunset Orange)
- Usage: Warnings, urgent notifications

---

## Component Styling

### Buttons

**Primary Button**
```css
.btn-primary {
  background: #2D5A27;
  color: #FFFFFF;
  border: none;
  border-radius: 8px;
  padding: 12px 24px;
  font: 500 14px Inter;
  box-shadow: 0 2px 8px rgba(45, 90, 39, 0.2);
}

.btn-primary:hover {
  background: #1F3E1B;
  box-shadow: 0 4px 16px rgba(45, 90, 39, 0.3);
}
```

**Secondary Button**
```css
.btn-secondary {
  background: transparent;
  color: #2D5A27;
  border: 1px solid #87A96B;
  border-radius: 8px;
  padding: 12px 24px;
  font: 500 14px Inter;
}

.btn-secondary:hover {
  background: rgba(135, 169, 107, 0.1);
  border-color: #2D5A27;
}
```

**Glass Button**
```css
.btn-glass {
  background: rgba(247, 245, 243, 0.2);
  backdrop-filter: blur(10px);
  color: #2D5A27;
  border: 1px solid rgba(135, 169, 107, 0.3);
  border-radius: 12px;
  padding: 12px 24px;
  font: 500 14px Inter;
}
```

### Input Fields

**Standard Input**
```css
.input-standard {
  background: #FFFFFF;
  border: 1px solid #E0E0E0;
  border-radius: 8px;
  padding: 16px;
  font: 400 16px Inter;
  color: #2C2C2C;
}

.input-standard:focus {
  border-color: #87A96B;
  box-shadow: 0 0 0 3px rgba(135, 169, 107, 0.1);
}
```

**Glass Input**
```css
.input-glass {
  background: rgba(247, 245, 243, 0.15);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(135, 169, 107, 0.2);
  border-radius: 12px;
  padding: 16px;
  font: 400 16px Inter;
  color: #2C2C2C;
}
```

### Cards

**Standard Card**
```css
.card-standard {
  background: #FFFFFF;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(45, 90, 39, 0.06);
  border: 1px solid #F0F0F0;
}
```

**Glass Card**
```css
.card-glass {
  background: rgba(247, 245, 243, 0.2);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 24px;
  border: 1px solid rgba(135, 169, 107, 0.18);
  box-shadow: 0 8px 32px rgba(45, 90, 39, 0.08);
}
```

---

## Animation and Transitions

### Timing Functions

**Standard Ease** - `cubic-bezier(0.4, 0.0, 0.2, 1)`
- Usage: General UI transitions, button states
- Duration: 200ms

**Organic Ease** - `cubic-bezier(0.25, 0.46, 0.45, 0.94)`
- Usage: Plant-inspired animations, growth effects
- Duration: 300ms

**Bounce Ease** - `cubic-bezier(0.68, -0.55, 0.265, 1.55)`
- Usage: Success states, positive feedback
- Duration: 400ms

**Slow Ease** - `cubic-bezier(0.25, 0.1, 0.25, 1)`
- Usage: Large content transitions, page changes
- Duration: 500ms

### Animation Patterns

**Fade Transitions**
- Opacity: 0  1
- Duration: 200ms
- Easing: Standard ease

**Slide Transitions**
- Transform: translateY(20px)  translateY(0)
- Duration: 300ms
- Easing: Organic ease

**Scale Transitions**
- Transform: scale(0.95)  scale(1)
- Duration: 200ms
- Easing: Standard ease

**Growth Animations**
- Transform: scale(0)  scale(1)
- Duration: 400ms
- Easing: Bounce ease

---

## Dark Mode Adaptations

### Dark Mode Color Palette

**Primary Background** - `#1A1A1A`
**Secondary Background** - `#2D2D2D`
**Card Background** - `#3A3A3A`
**Text Primary** - `#FFFFFF`
**Text Secondary** - `#B0B0B0`
**Text Tertiary** - `#808080`

**Botanical Colors (Adjusted)**
- Forest Green: `#4A8B3A` (Lighter for contrast)
- Sage Green: `#A5C99B` (Maintained visibility)
- Earth Brown: `#B8956A` (Warmed for dark backgrounds)

**Glass Effects (Dark Mode)**
```css
.dark-glass {
  background: rgba(58, 58, 58, 0.3);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(165, 201, 155, 0.2);
}
```

---

## Implementation Guidelines

### CSS Custom Properties

```css
:root {
  /* Primary Colors */
  --color-forest-green: #2D5A27;
  --color-sage-green: #87A96B;
  --color-cream-white: #F7F5F3;
  --color-earth-brown: #8B4513;
  
  /* Accent Colors */
  --color-sunset-orange: #FF6B35;
  --color-sky-blue: #87CEEB;
  --color-warm-yellow: #F4D03F;
  
  /* Glass Effects */
  --glass-light: rgba(247, 245, 243, 0.15);
  --glass-medium: rgba(247, 245, 243, 0.25);
  --glass-accent: rgba(135, 169, 107, 0.12);
  
  /* Typography */
  --font-primary: 'Inter', sans-serif;
  --font-accent: 'Playfair Display', serif;
  
  /* Spacing */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  
  /* Shadows */
  --shadow-sm: 0 2px 8px rgba(45, 90, 39, 0.06);
  --shadow-md: 0 4px 16px rgba(45, 90, 39, 0.08);
  --shadow-lg: 0 8px 32px rgba(45, 90, 39, 0.12);
}
```

### Flutter Theme Implementation

```dart
class BotanicalTheme {
  static const Color forestGreen = Color(0xFF2D5A27);
  static const Color sageGreen = Color(0xFF87A96B);
  static const Color creamWhite = Color(0xFFF7F5F3);
  static const Color earthBrown = Color(0xFF8B4513);
  
  static ThemeData get lightTheme => ThemeData(
    primarySwatch: MaterialColor(0xFF2D5A27, {
      50: Color(0xFFE8F5E8),
      100: Color(0xFFC5E4C5),
      // ... other shades
    }),
    fontFamily: 'Inter',
    // ... other theme properties
  );
}
```

This comprehensive theme guide ensures visual consistency and brand coherence across all aspects of our plant-focused social platform, supporting both the botanical aesthetic and modern technological features.
</file>

<file path="_docs/ui-rules.md">
# UI Design Rules & Principles

Comprehensive design principles and guidelines for our plant-focused Snapchat clone with RAG capabilities, ensuring consistent user experience across all features.

---

## Core Design Philosophy

### Botanical Minimalism with Strategic Glassmorphism

**Primary Foundation**: Clean, nature-inspired design that prioritizes plant content
**Enhancement Layer**: Selective glassmorphic elements for modern appeal and AI feature integration
**Target Audience**: Plant enthusiasts aged 20-30 seeking both functionality and aesthetic appeal

---

## Fundamental Design Principles

### 1. Content-First Architecture

**Plant Photography Priority**
- Plant photos and videos are always the primary visual focus
- UI elements should enhance, never compete with plant content
- Maintain high contrast and readability for plant identification
- Preserve image quality and natural colors

**Progressive Information Disclosure**
- Present basic information immediately (plant name, basic care)
- Reveal detailed RAG-generated content through intuitive interactions
- Layer complexity: Overview  Details  Expert advice
- Avoid information overload in primary views

**Contextual Relevance**
- Show information relevant to user's current context (season, location, experience level)
- Prioritize actionable content over decorative elements
- Adapt content density based on screen size and user preferences

### 2. Biophilic Design Integration

**Natural Visual Hierarchy**
- Use organic shapes and flowing lines over harsh geometric forms
- Implement growth-inspired animations (fade-in like blooming, slide like growing)
- Create visual rhythms that mirror natural patterns
- Maintain balance between structure and organic feel

**Seasonal Adaptability**
- Subtle UI changes reflecting current growing season
- Color temperature adjustments based on time of year
- Seasonal iconography and micro-interactions
- Local growing condition awareness in design elements

**Texture and Depth**
- Subtle botanical textures as background elements (never overwhelming)
- Natural lighting effects and soft shadows
- Organic button shapes and interaction areas
- Tactile feedback that feels natural and responsive

### 3. Community-Centric Design

**Trust and Expertise Indicators**
- Clear visual hierarchy for expert vs. beginner content
- Credibility badges and experience level indicators
- Community-driven content highlighting
- Transparent source attribution for plant information

**Knowledge Sharing Facilitation**
- Easy-access sharing mechanisms for plant care tips
- Visual distinction between questions and answers
- Progress indicators for learning journeys
- Mentorship pathway visualization

**Local Community Integration**
- Geographic context indicators for local growing conditions
- Regional plant community highlights
- Local nursery and garden center integration
- Weather and seasonal condition awareness

### 4. AI-Enhanced User Experience

**Intelligent Content Integration**
- RAG-generated suggestions appear as natural, helpful recommendations
- AI confidence levels clearly indicated through visual cues
- Seamless integration between user content and AI enhancements
- Non-intrusive presentation of intelligent features

**Learning and Adaptation**
- Visual progress indicators for gardening skill development
- Personalized content curation with clear reasoning
- Adaptive interface based on user expertise level
- Contextual help that evolves with user knowledge

---

## Layout and Structure Guidelines

### Screen Organization

**Primary Navigation**
- Bottom tab navigation with botanical iconography
- Camera tab as central, primary action
- Clear visual hierarchy: Camera > Discover > Chat > Stories > Profile
- Consistent tab behavior across all screens

**Content Layout Patterns**
- **Card-based design** for plant collections and discovery content
- **Full-screen immersion** for camera and story viewing
- **List-based organization** for chat and notification areas
- **Grid layouts** for plant collections and search results

**Information Architecture**
- Maximum 3 levels of navigation depth
- Clear breadcrumb trails for complex plant care guides
- Consistent back navigation patterns
- Search functionality accessible from all major screens

### Responsive Design Principles

**Mobile-First Approach**
- Design for one-handed operation
- Thumb-friendly touch targets (minimum 44px)
- Consideration for outdoor use scenarios (bright sunlight, gloves)
- Efficient use of screen real estate

**Cross-Platform Consistency**
- Maintain design language across iOS and Android
- Respect platform conventions while preserving brand identity
- Consistent behavior for gestures and interactions
- Adaptive layouts for different screen sizes

---

## Interaction Design Rules

### Gesture Patterns

**Camera Interface**
- Tap to capture photo
- Hold for video recording
- Swipe for filter selection
- Pinch to zoom (maintain plant focus)
- Double-tap for quick plant identification

**Content Navigation**
- Swipe left/right for story navigation
- Pull-to-refresh for feed updates
- Long-press for contextual actions
- Swipe up for detailed plant information

**Chat and Messaging**
- Swipe to reply or react
- Hold to save plant care tips
- Tap to view disappearing content
- Swipe to dismiss notifications

### Animation Guidelines

**Natural Motion Principles**
- Easing curves that mimic natural growth patterns
- Timing that feels organic (not too fast, not too slow)
- Transitions that maintain spatial relationships
- Loading animations inspired by plant growth

**Feedback Animations**
- Subtle bounce for successful actions
- Gentle fade for content transitions
- Growing/blooming effects for positive feedback
- Wilting effects for errors (used sparingly)

**Performance Considerations**
- 60fps target for all animations
- Reduced motion options for accessibility
- Efficient animation implementations
- Battery-conscious animation choices

---

## Accessibility and Usability

### Visual Accessibility

**Color and Contrast**
- Minimum 4.5:1 contrast ratio for all text
- Color-independent information design
- High contrast mode support
- Colorblind-friendly plant health indicators

**Text and Typography**
- Scalable text supporting system font sizes
- Clear hierarchy with size and weight variations
- Readable fonts for plant care instructions
- Multi-language support considerations

**Visual Indicators**
- Clear focus states for all interactive elements
- Loading states for AI processing
- Error states with clear recovery paths
- Success confirmations for important actions

### Motor Accessibility

**Touch Targets**
- Minimum 44px touch targets
- Adequate spacing between interactive elements
- Alternative input methods support
- Voice control integration for hands-free operation

**Gesture Alternatives**
- Button alternatives for all gesture-based actions
- Customizable interaction methods
- Simplified navigation options
- Assistive technology compatibility

### Cognitive Accessibility

**Information Clarity**
- Simple, clear language for plant care instructions
- Consistent terminology throughout the app
- Visual cues supporting text information
- Progressive complexity in learning materials

**Error Prevention and Recovery**
- Clear confirmation for destructive actions
- Undo functionality for reversible actions
- Helpful error messages with solution guidance
- Graceful degradation when features are unavailable

---

## Content Guidelines

### Plant Photography Standards

**Image Quality Requirements**
- High resolution for plant identification accuracy
- Natural lighting preferred over artificial
- Clear focus on plant subject
- Minimal background distractions

**Composition Guidelines**
- Plant as primary subject (rule of thirds)
- Include scale references when helpful
- Show plant health indicators clearly
- Capture growth stages consistently

### Text Content Principles

**Plant Care Instructions**
- Clear, actionable language
- Seasonal and regional adaptations
- Beginner-friendly explanations with expert details available
- Consistent formatting for care schedules

**Community Content**
- Encouraging, supportive tone
- Inclusive language for all experience levels
- Clear attribution for expert advice
- Fact-checking for plant care information

---

## Performance and Technical Considerations

### Loading and Performance

**Image Optimization**
- Progressive loading for plant photos
- Appropriate compression without quality loss
- Lazy loading for feed content
- Efficient caching strategies

**AI Feature Performance**
- Clear loading indicators for RAG processing
- Graceful fallbacks when AI services are unavailable
- Efficient plant identification algorithms
- Background processing for non-critical AI features

### Offline Capabilities

**Essential Features**
- Basic plant identification from cached data
- Saved plant care guides accessible offline
- Camera functionality with delayed upload
- Critical plant care reminders

**Sync and Updates**
- Clear indicators for offline/online status
- Efficient sync when connection is restored
- Conflict resolution for offline changes
- Background updates for plant care information

---

## Platform-Specific Considerations

### iOS Guidelines

**Design Language**
- Respect iOS Human Interface Guidelines
- Use iOS-native navigation patterns
- Implement iOS-specific gestures appropriately
- Follow iOS accessibility standards

**App Store Compliance**
- Content guidelines for social features
- Privacy policy compliance
- In-app purchase guidelines (if applicable)
- Review guideline adherence

### Android Guidelines

**Material Design Integration**
- Adapt Material Design principles to botanical theme
- Use Android-native navigation patterns
- Implement Android-specific features (widgets, shortcuts)
- Follow Android accessibility guidelines

**Play Store Compliance**
- Content policy compliance
- Privacy and data handling requirements
- Feature graphic and store listing guidelines
- Target API level requirements

---

## Quality Assurance

### Design Review Checklist

**Visual Consistency**
- [ ] Consistent use of botanical color palette
- [ ] Proper typography hierarchy maintained
- [ ] Appropriate use of glassmorphic elements
- [ ] Plant content remains primary focus

**Functionality**
- [ ] All interactive elements clearly identifiable
- [ ] Navigation paths are intuitive
- [ ] Error states are handled gracefully
- [ ] Loading states provide appropriate feedback

**Accessibility**
- [ ] Contrast ratios meet WCAG guidelines
- [ ] Touch targets meet minimum size requirements
- [ ] Alternative text provided for images
- [ ] Keyboard navigation supported

**Performance**
- [ ] Animations run smoothly at 60fps
- [ ] Images load efficiently
- [ ] App responds quickly to user interactions
- [ ] Memory usage remains reasonable

These UI rules ensure our plant-focused social platform maintains consistency, usability, and aesthetic appeal while supporting the unique needs of our gardening community.
</file>

<file path="_docs/user-flow.md">
# User Flow Documentation

This document defines the complete user journey through our plant-focused Snapchat clone with RAG enhancements, targeting general users aged 20-30 with a focus on plant enthusiasts and gardeners of all levels.

---

## User Personas

**Primary Target**: Plant enthusiasts and gardeners (20-30 years old)
- Beginner gardeners seeking advice and inspiration
- Experienced plant parents sharing knowledge
- Urban gardeners with limited space
- Plant collectors showcasing rare finds
- Garden designers and landscapers

---

## Core User Journey

### 1. Onboarding & Authentication

**Entry Point**: App launch (first time)

1. **Welcome Screen**
   - Brief app introduction highlighting plant community focus
   - "Get Started" CTA

2. **Email Registration**
   - Email input and password creation
   - Plant interest selection (houseplants, outdoor gardening, succulents, etc.)
   - Experience level selection (beginner, intermediate, expert)

3. **Profile Setup**
   - Username creation
   - Profile photo upload
   - Bio with gardening interests
   - Location (for local plant community connections)

4. **Permission Requests**
   - Camera access for plant photos
   - Contacts access for friend discovery
   - Location for local gardening communities

### 2. Main Navigation Structure

**Bottom Tab Navigation**:
- **Camera** (Center, primary action)
- **Chat** (Messages)
- **Discover** (Content discovery with RAG)
- **Stories** (Friend stories)
- **Profile** (User profile)

### 3. Content Creation Flow

**Camera Tab (Primary Entry)**:

1. **Camera Interface**
   - Photo/video toggle
   - Plant-specific AR filters (growth time-lapse, plant identification overlay)
   - Swipe gestures to access filters

2. **Content Capture**
   - Tap to capture photo
   - Hold for video recording
   - Plant identification suggestions via RAG

3. **Content Enhancement**
   - **RAG-Generated Captions**: AI suggests plant-specific captions based on identified species
   - **Care Tips Integration**: Automatic care reminders and tips overlay
   - **Filter Application**: Plant health filters, growth progression effects

4. **Sharing Options**
   - Send to specific friends (disappearing message)
   - Add to My Story
   - Post to plant community groups
   - Save to plant journal (persistent)

### 4. Discovery & RAG Integration

**Discover Tab Flow**:

1. **Personalized Feed**
   - RAG-curated content based on user's plant interests
   - Seasonal gardening tips
   - Local plant community highlights

2. **Search Functions**
   - Plant species search with AI identification
   - Care guide lookup
   - Local nursery and garden center finder
   - Expert gardener discovery

3. **RAG-Enhanced Recommendations**
   - **Content Suggestions**: "Plants similar to your collection"
   - **Friend Recommendations**: Connect with local gardeners
   - **Learning Paths**: Beginner to expert gardening guides
   - **Seasonal Content**: "Plants to start this month"

### 5. Social Features Flow

**Friend Management**:

1. **Friend Discovery**
   - Username search for known gardeners
   - Phone contacts integration
   - Local gardener suggestions via location
   - Plant interest-based recommendations

2. **Connection Process**
   - Send friend request
   - Accept/decline incoming requests
   - Follow public plant accounts

**Messaging Experience**:

1. **Chat Tab Navigation**
   - Recent conversations list
   - Group chats for plant communities
   - Direct messages with disappearing content

2. **Message Types**
   - Photo/video with plant care questions
   - Voice messages for plant identification help
   - Location sharing for garden visits
   - Plant care reminders and tips

3. **Disappearing Content**
   - Standard messages disappear after viewing
   - Plant care tips can be saved to personal journal
   - No notification when content disappears

### 6. Stories & Community Features

**Stories Tab Flow**:

1. **Story Viewing**
   - Friend stories in chronological order
   - Plant community highlights
   - Local garden events and workshops

2. **Story Creation**
   - Add to personal story
   - Contribute to community plant challenges
   - Share garden progress updates

3. **Interactive Elements**
   - Plant identification polls
   - Care tip sharing
   - Before/after plant transformations

### 7. RAG-Enhanced Features Throughout Journey

**Contextual AI Integration**:

1. **Smart Captions**
   - Auto-generated plant care captions
   - Species identification with care tips
   - Seasonal growing advice

2. **Personalized Content**
   - Feed curated based on plant collection
   - Care reminders for user's specific plants
   - Local growing condition adjustments

3. **Learning Recommendations**
   - Progressive skill-building content
   - Expert advice matching user's experience level
   - Problem-solving guides for plant issues

4. **Community Connections**
   - Local gardener introductions
   - Plant swap opportunity alerts
   - Garden event recommendations

---

## Key User Flows

### Flow A: New Plant Parent Seeking Help
1. Open camera  Capture struggling plant photo
2. RAG identifies plant and suggests care tips
3. Share to plant expert friends for advice
4. Receive disappearing video responses with solutions
5. Save helpful tips to plant journal

### Flow B: Experienced Gardener Sharing Knowledge
1. Navigate to Discover  See beginner questions
2. Create helpful response video with care demonstration
3. Use plant-specific AR filters for educational overlay
4. Share to community story for broader reach
5. Connect with new gardeners seeking mentorship

### Flow C: Seasonal Garden Planning
1. Open Discover  View RAG-curated seasonal content
2. Explore "Plants to start this month" recommendations
3. Save interesting plants to wishlist
4. Share planning ideas with gardening friends
5. Create story documenting garden planning process

---

## Success Metrics

- **Engagement**: Daily active users sharing plant content
- **Community Growth**: New connections between plant enthusiasts
- **Knowledge Sharing**: Care tips and advice exchanges
- **RAG Effectiveness**: Accuracy of plant identification and recommendations
- **User Retention**: Return visits for seasonal gardening guidance

---

## Technical Considerations

- **RAG Data Sources**: Plant databases, care guides, local growing conditions
- **AR Filter Requirements**: Plant identification, growth visualization
- **Content Moderation**: Plant-focused community guidelines
- **Offline Capabilities**: Basic plant identification and care tips
- **Performance**: Fast plant identification and recommendation loading

This user flow serves as the foundation for our plant-focused social platform, ensuring every feature connects meaningfully to enhance the gardening community experience.
</file>

<file path=".dart_tool/package_config_subset">
_fe_analyzer_shared
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/_fe_analyzer_shared-76.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/_fe_analyzer_shared-76.0.0/lib/
analyzer
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer-6.11.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer-6.11.0/lib/
analyzer_plugin
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer_plugin-0.11.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer_plugin-0.11.3/lib/
archive
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/archive-4.0.7/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/archive-4.0.7/lib/
args
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/args-2.7.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/args-2.7.0/lib/
async
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/async-2.13.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/async-2.13.0/lib/
boolean_selector
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/boolean_selector-2.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/boolean_selector-2.1.2/lib/
build
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build-2.5.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build-2.5.4/lib/
build_config
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_config-1.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_config-1.1.2/lib/
build_daemon
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_daemon-4.0.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_daemon-4.0.4/lib/
build_resolvers
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_resolvers-2.5.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_resolvers-2.5.4/lib/
build_runner
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner-2.5.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner-2.5.4/lib/
build_runner_core
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner_core-9.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner_core-9.1.2/lib/
built_collection
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_collection-5.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_collection-5.1.1/lib/
built_value
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_value-8.10.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_value-8.10.1/lib/
cached_network_image
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image-3.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image-3.4.1/lib/
cached_network_image_platform_interface
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_platform_interface-4.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_platform_interface-4.1.1/lib/
cached_network_image_web
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_web-1.3.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_web-1.3.1/lib/
camera
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera-0.10.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera-0.10.6/lib/
camera_android
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_android-0.10.10+3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_android-0.10.10+3/lib/
camera_avfoundation
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_avfoundation-0.9.20+1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_avfoundation-0.9.20+1/lib/
camera_platform_interface
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_platform_interface-2.10.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_platform_interface-2.10.0/lib/
camera_web
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_web-0.3.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_web-0.3.5/lib/
characters
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/characters-1.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/characters-1.4.0/lib/
checked_yaml
3.8
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/checked_yaml-2.0.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/checked_yaml-2.0.4/lib/
clock
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/clock-1.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/clock-1.1.2/lib/
code_builder
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/code_builder-4.10.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/code_builder-4.10.1/lib/
collection
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/collection-1.19.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/collection-1.19.1/lib/
contacts_service
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/contacts_service-0.6.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/contacts_service-0.6.3/lib/
convert
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/convert-3.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/convert-3.1.2/lib/
cross_file
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cross_file-0.3.4+2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cross_file-0.3.4+2/lib/
crypto
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/crypto-3.0.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/crypto-3.0.6/lib/
csslib
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/csslib-1.0.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/csslib-1.0.2/lib/
cupertino_icons
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cupertino_icons-1.0.8/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cupertino_icons-1.0.8/lib/
custom_lint_core
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_core-0.7.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_core-0.7.0/lib/
custom_lint_visitor
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_visitor-1.0.0+6.11.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_visitor-1.0.0+6.11.0/lib/
dart_style
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dart_style-2.3.8/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dart_style-2.3.8/lib/
dbus
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dbus-0.7.11/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dbus-0.7.11/lib/
dio
2.18
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio-5.8.0+1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio-5.8.0+1/lib/
dio_web_adapter
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio_web_adapter-2.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio_web_adapter-2.1.1/lib/
fake_async
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fake_async-1.3.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fake_async-1.3.3/lib/
ffi
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/ffi-2.1.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/ffi-2.1.4/lib/
file
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file-7.0.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file-7.0.1/lib/
file_selector_linux
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_linux-0.9.3+2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_linux-0.9.3+2/lib/
file_selector_macos
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_macos-0.9.4+3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_macos-0.9.4+3/lib/
file_selector_platform_interface
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_platform_interface-2.6.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_platform_interface-2.6.2/lib/
file_selector_windows
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_windows-0.9.3+4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_windows-0.9.3+4/lib/
fixnum
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fixnum-1.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fixnum-1.1.1/lib/
flutter_cache_manager
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_cache_manager-3.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_cache_manager-3.4.1/lib/
flutter_lints
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_lints-3.0.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_lints-3.0.2/lib/
flutter_local_notifications
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications-16.3.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications-16.3.3/lib/
flutter_local_notifications_linux
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_linux-4.0.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_linux-4.0.1/lib/
flutter_local_notifications_platform_interface
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_platform_interface-7.2.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_platform_interface-7.2.0/lib/
flutter_plugin_android_lifecycle
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_plugin_android_lifecycle-2.0.28/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_plugin_android_lifecycle-2.0.28/lib/
flutter_riverpod
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_riverpod-2.6.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_riverpod-2.6.1/lib/
flutter_secure_storage
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage-9.2.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage-9.2.4/lib/
flutter_secure_storage_linux
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_linux-1.2.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_linux-1.2.3/lib/
flutter_secure_storage_macos
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_macos-3.1.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_macos-3.1.3/lib/
flutter_secure_storage_platform_interface
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_platform_interface-1.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_platform_interface-1.1.2/lib/
flutter_secure_storage_web
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_web-1.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_web-1.2.1/lib/
flutter_secure_storage_windows
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_windows-3.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_windows-3.1.2/lib/
flutter_svg
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_svg-2.2.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_svg-2.2.0/lib/
freezed_annotation
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/freezed_annotation-2.4.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/freezed_annotation-2.4.4/lib/
frontend_server_client
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/frontend_server_client-4.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/frontend_server_client-4.0.0/lib/
geolocator
2.15
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator-10.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator-10.1.1/lib/
geolocator_android
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_android-4.6.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_android-4.6.2/lib/
geolocator_apple
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_apple-2.3.13/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_apple-2.3.13/lib/
geolocator_platform_interface
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_platform_interface-4.2.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_platform_interface-4.2.6/lib/
geolocator_web
2.15
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_web-2.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_web-2.2.1/lib/
geolocator_windows
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_windows-0.2.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_windows-0.2.5/lib/
glob
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/glob-2.1.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/glob-2.1.3/lib/
go_router
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/go_router-12.1.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/go_router-12.1.3/lib/
google_fonts
2.14
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/google_fonts-6.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/google_fonts-6.2.1/lib/
graphs
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/graphs-2.3.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/graphs-2.3.2/lib/
html
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/html-0.15.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/html-0.15.6/lib/
http
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http-1.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http-1.4.0/lib/
http_multi_server
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_multi_server-3.2.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_multi_server-3.2.2/lib/
http_parser
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_parser-4.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_parser-4.1.2/lib/
image
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image-4.5.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image-4.5.4/lib/
image_picker
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker-1.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker-1.1.2/lib/
image_picker_android
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_android-0.8.12+23/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_android-0.8.12+23/lib/
image_picker_for_web
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_for_web-3.0.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_for_web-3.0.6/lib/
image_picker_ios
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_ios-0.8.12+2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_ios-0.8.12+2/lib/
image_picker_linux
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_linux-0.2.1+2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_linux-0.2.1+2/lib/
image_picker_macos
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_macos-0.2.1+2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_macos-0.2.1+2/lib/
image_picker_platform_interface
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_platform_interface-2.10.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_platform_interface-2.10.1/lib/
image_picker_windows
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_windows-0.2.1+1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_windows-0.2.1+1/lib/
intl
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/intl-0.18.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/intl-0.18.1/lib/
io
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/io-1.0.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/io-1.0.5/lib/
js
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/js-0.6.7/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/js-0.6.7/lib/
json_annotation
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_annotation-4.9.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_annotation-4.9.0/lib/
json_serializable
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_serializable-6.9.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_serializable-6.9.0/lib/
leak_tracker
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker-10.0.9/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker-10.0.9/lib/
leak_tracker_flutter_testing
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_flutter_testing-3.0.9/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_flutter_testing-3.0.9/lib/
leak_tracker_testing
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_testing-3.0.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_testing-3.0.1/lib/
lints
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/lints-3.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/lints-3.0.0/lib/
logging
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/logging-1.3.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/logging-1.3.0/lib/
macros
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/macros-0.1.3-main.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/macros-0.1.3-main.0/lib/
matcher
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/matcher-0.12.17/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/matcher-0.12.17/lib/
material_color_utilities
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/material_color_utilities-0.11.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/material_color_utilities-0.11.1/lib/
meta
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/meta-1.16.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/meta-1.16.0/lib/
mime
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mime-2.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mime-2.0.0/lib/
mockito
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mockito-5.4.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mockito-5.4.5/lib/
octo_image
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/octo_image-2.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/octo_image-2.1.0/lib/
package_config
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/package_config-2.2.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/package_config-2.2.0/lib/
path
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path-1.9.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path-1.9.1/lib/
path_parsing
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_parsing-1.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_parsing-1.1.0/lib/
path_provider
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider-2.1.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider-2.1.5/lib/
path_provider_android
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_android-2.2.17/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_android-2.2.17/lib/
path_provider_foundation
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_foundation-2.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_foundation-2.4.1/lib/
path_provider_linux
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_linux-2.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_linux-2.2.1/lib/
path_provider_platform_interface
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_platform_interface-2.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_platform_interface-2.1.2/lib/
path_provider_windows
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_windows-2.3.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_windows-2.3.0/lib/
permission_handler
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler-11.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler-11.4.0/lib/
permission_handler_android
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_android-12.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_android-12.1.0/lib/
permission_handler_apple
2.18
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_apple-9.4.7/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_apple-9.4.7/lib/
permission_handler_html
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_html-0.1.3+5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_html-0.1.3+5/lib/
permission_handler_platform_interface
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_platform_interface-4.3.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_platform_interface-4.3.0/lib/
permission_handler_windows
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_windows-0.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_windows-0.2.1/lib/
petitparser
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/petitparser-6.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/petitparser-6.1.0/lib/
photo_view
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/photo_view-0.14.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/photo_view-0.14.0/lib/
platform
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/platform-3.1.6/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/platform-3.1.6/lib/
plugin_platform_interface
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/plugin_platform_interface-2.1.8/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/plugin_platform_interface-2.1.8/lib/
pool
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pool-1.5.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pool-1.5.1/lib/
posix
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/posix-6.0.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/posix-6.0.2/lib/
process
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/process-5.0.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/process-5.0.3/lib/
protobuf
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/protobuf-3.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/protobuf-3.1.0/lib/
pub_semver
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pub_semver-2.2.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pub_semver-2.2.0/lib/
pubspec_parse
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pubspec_parse-1.5.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pubspec_parse-1.5.0/lib/
quiver
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/quiver-3.2.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/quiver-3.2.2/lib/
retrofit
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit-4.4.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit-4.4.2/lib/
retrofit_generator
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit_generator-8.2.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit_generator-8.2.1/lib/
riverpod
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod-2.6.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod-2.6.1/lib/
riverpod_analyzer_utils
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_analyzer_utils-0.5.8/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_analyzer_utils-0.5.8/lib/
riverpod_annotation
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_annotation-2.6.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_annotation-2.6.1/lib/
riverpod_generator
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_generator-2.6.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_generator-2.6.3/lib/
rxdart
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/rxdart-0.28.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/rxdart-0.28.0/lib/
shared_preferences
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences-2.5.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences-2.5.3/lib/
shared_preferences_android
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_android-2.4.10/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_android-2.4.10/lib/
shared_preferences_foundation
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_foundation-2.5.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_foundation-2.5.4/lib/
shared_preferences_linux
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_linux-2.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_linux-2.4.1/lib/
shared_preferences_platform_interface
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_platform_interface-2.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_platform_interface-2.4.1/lib/
shared_preferences_web
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_web-2.4.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_web-2.4.3/lib/
shared_preferences_windows
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_windows-2.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_windows-2.4.1/lib/
shelf
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf-1.4.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf-1.4.2/lib/
shelf_web_socket
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf_web_socket-3.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf_web_socket-3.0.0/lib/
source_gen
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_gen-1.5.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_gen-1.5.0/lib/
source_helper
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_helper-1.3.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_helper-1.3.5/lib/
source_span
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_span-1.10.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_span-1.10.1/lib/
sprintf
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sprintf-7.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sprintf-7.0.0/lib/
sqflite
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite-2.4.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite-2.4.2/lib/
sqflite_android
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_android-2.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_android-2.4.1/lib/
sqflite_common
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_common-2.5.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_common-2.5.5/lib/
sqflite_darwin
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_darwin-2.4.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_darwin-2.4.2/lib/
sqflite_platform_interface
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_platform_interface-2.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_platform_interface-2.4.0/lib/
stack_trace
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stack_trace-1.12.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stack_trace-1.12.1/lib/
state_notifier
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/state_notifier-1.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/state_notifier-1.0.0/lib/
stream_channel
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_channel-2.1.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_channel-2.1.4/lib/
stream_transform
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_transform-2.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_transform-2.1.1/lib/
string_scanner
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/string_scanner-1.4.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/string_scanner-1.4.1/lib/
sync_http
2.12
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sync_http-0.3.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sync_http-0.3.1/lib/
synchronized
3.8
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/synchronized-3.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/synchronized-3.4.0/lib/
term_glyph
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/term_glyph-1.2.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/term_glyph-1.2.2/lib/
test_api
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/test_api-0.7.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/test_api-0.7.4/lib/
timezone
2.19
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timezone-0.9.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timezone-0.9.4/lib/
timing
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timing-1.0.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timing-1.0.2/lib/
tuple
2.17
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/tuple-2.0.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/tuple-2.0.2/lib/
typed_data
3.5
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/typed_data-1.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/typed_data-1.4.0/lib/
uuid
3.0
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/uuid-4.5.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/uuid-4.5.1/lib/
vector_graphics
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics-1.1.19/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics-1.1.19/lib/
vector_graphics_codec
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_codec-1.1.13/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_codec-1.1.13/lib/
vector_graphics_compiler
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_compiler-1.1.17/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_compiler-1.1.17/lib/
vector_math
2.14
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_math-2.1.4/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_math-2.1.4/lib/
video_player
3.6
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player-2.10.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player-2.10.0/lib/
video_player_android
3.7
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_android-2.8.7/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_android-2.8.7/lib/
video_player_avfoundation
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_avfoundation-2.7.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_avfoundation-2.7.1/lib/
video_player_platform_interface
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_platform_interface-6.3.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_platform_interface-6.3.0/lib/
video_player_web
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_web-2.3.5/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_web-2.3.5/lib/
vm_service
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vm_service-15.0.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vm_service-15.0.0/lib/
watcher
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/watcher-1.1.2/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/watcher-1.1.2/lib/
web
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web-1.1.1/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web-1.1.1/lib/
web_socket_channel
2.15
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web_socket_channel-2.4.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web_socket_channel-2.4.0/lib/
webdriver
3.1
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/webdriver-3.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/webdriver-3.1.0/lib/
win32
3.8
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/win32-5.14.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/win32-5.14.0/lib/
xdg_directories
3.3
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xdg_directories-1.1.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xdg_directories-1.1.0/lib/
xml
3.2
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xml-6.5.0/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xml-6.5.0/lib/
yaml
3.4
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/yaml-3.1.3/
file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/yaml-3.1.3/lib/
plant_social
3.0
file:///C:/Users/User/Gauntlet/snap/
file:///C:/Users/User/Gauntlet/snap/lib/
_macros
3.5
file:///C:/tools/flutter/bin/cache/dart-sdk/pkg/_macros/
file:///C:/tools/flutter/bin/cache/dart-sdk/pkg/_macros/lib/
sky_engine
3.7
file:///C:/tools/flutter/bin/cache/pkg/sky_engine/
file:///C:/tools/flutter/bin/cache/pkg/sky_engine/lib/
flutter
3.7
file:///C:/tools/flutter/packages/flutter/
file:///C:/tools/flutter/packages/flutter/lib/
flutter_driver
3.7
file:///C:/tools/flutter/packages/flutter_driver/
file:///C:/tools/flutter/packages/flutter_driver/lib/
flutter_test
3.7
file:///C:/tools/flutter/packages/flutter_test/
file:///C:/tools/flutter/packages/flutter_test/lib/
flutter_web_plugins
3.7
file:///C:/tools/flutter/packages/flutter_web_plugins/
file:///C:/tools/flutter/packages/flutter_web_plugins/lib/
fuchsia_remote_debug_protocol
3.7
file:///C:/tools/flutter/packages/fuchsia_remote_debug_protocol/
file:///C:/tools/flutter/packages/fuchsia_remote_debug_protocol/lib/
integration_test
3.7
file:///C:/tools/flutter/packages/integration_test/
file:///C:/tools/flutter/packages/integration_test/lib/
2
</file>

<file path=".dart_tool/package_config.json">
{
  "configVersion": 2,
  "packages": [
    {
      "name": "_fe_analyzer_shared",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/_fe_analyzer_shared-76.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "_macros",
      "rootUri": "file:///C:/tools/flutter/bin/cache/dart-sdk/pkg/_macros",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "analyzer",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer-6.11.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "analyzer_plugin",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/analyzer_plugin-0.11.3",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "archive",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/archive-4.0.7",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "args",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/args-2.7.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "async",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/async-2.13.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "boolean_selector",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/boolean_selector-2.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "build",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build-2.5.4",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "build_config",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_config-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "build_daemon",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_daemon-4.0.4",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "build_resolvers",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_resolvers-2.5.4",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "build_runner",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner-2.5.4",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "build_runner_core",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/build_runner_core-9.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "built_collection",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_collection-5.1.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "built_value",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/built_value-8.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "cached_network_image",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image-3.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "cached_network_image_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_platform_interface-4.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "cached_network_image_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cached_network_image_web-1.3.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "camera",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera-0.10.6",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "camera_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_android-0.10.10+3",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "camera_avfoundation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_avfoundation-0.9.20+1",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "camera_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_platform_interface-2.10.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "camera_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/camera_web-0.3.5",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "characters",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/characters-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "checked_yaml",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/checked_yaml-2.0.4",
      "packageUri": "lib/",
      "languageVersion": "3.8"
    },
    {
      "name": "clock",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/clock-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "code_builder",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/code_builder-4.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "collection",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/collection-1.19.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "contacts_service",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/contacts_service-0.6.3",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "convert",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/convert-3.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "cross_file",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cross_file-0.3.4+2",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "crypto",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/crypto-3.0.6",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "csslib",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/csslib-1.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "cupertino_icons",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/cupertino_icons-1.0.8",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "custom_lint_core",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_core-0.7.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "custom_lint_visitor",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/custom_lint_visitor-1.0.0+6.11.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "dart_style",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dart_style-2.3.8",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "dbus",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dbus-0.7.11",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "dio",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio-5.8.0+1",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "dio_web_adapter",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/dio_web_adapter-2.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "fake_async",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fake_async-1.3.3",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "ffi",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/ffi-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "file",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file-7.0.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "file_selector_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_linux-0.9.3+2",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "file_selector_macos",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_macos-0.9.4+3",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "file_selector_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_platform_interface-2.6.2",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "file_selector_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/file_selector_windows-0.9.3+4",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "fixnum",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/fixnum-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "flutter",
      "rootUri": "file:///C:/tools/flutter/packages/flutter",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "flutter_cache_manager",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_cache_manager-3.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "flutter_driver",
      "rootUri": "file:///C:/tools/flutter/packages/flutter_driver",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "flutter_lints",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_lints-3.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "flutter_local_notifications",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications-16.3.3",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "flutter_local_notifications_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_linux-4.0.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "flutter_local_notifications_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_local_notifications_platform_interface-7.2.0",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "flutter_plugin_android_lifecycle",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_plugin_android_lifecycle-2.0.28",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "flutter_riverpod",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_riverpod-2.6.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "flutter_secure_storage",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage-9.2.4",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_secure_storage_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_linux-1.2.3",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_secure_storage_macos",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_macos-3.1.3",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_secure_storage_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_platform_interface-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_secure_storage_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_web-1.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_secure_storage_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_secure_storage_windows-3.1.2",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter_svg",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/flutter_svg-2.2.0",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "flutter_test",
      "rootUri": "file:///C:/tools/flutter/packages/flutter_test",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "flutter_web_plugins",
      "rootUri": "file:///C:/tools/flutter/packages/flutter_web_plugins",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "freezed_annotation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/freezed_annotation-2.4.4",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "frontend_server_client",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/frontend_server_client-4.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "fuchsia_remote_debug_protocol",
      "rootUri": "file:///C:/tools/flutter/packages/fuchsia_remote_debug_protocol",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "geolocator",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator-10.1.1",
      "packageUri": "lib/",
      "languageVersion": "2.15"
    },
    {
      "name": "geolocator_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_android-4.6.2",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "geolocator_apple",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_apple-2.3.13",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "geolocator_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_platform_interface-4.2.6",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "geolocator_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_web-2.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.15"
    },
    {
      "name": "geolocator_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/geolocator_windows-0.2.5",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "glob",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/glob-2.1.3",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "go_router",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/go_router-12.1.3",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "google_fonts",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/google_fonts-6.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "graphs",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/graphs-2.3.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "html",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/html-0.15.6",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "http",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "http_multi_server",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_multi_server-3.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "http_parser",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/http_parser-4.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image-4.5.4",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "image_picker",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "image_picker_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_android-0.8.12+23",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "image_picker_for_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_for_web-3.0.6",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image_picker_ios",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_ios-0.8.12+2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image_picker_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_linux-0.2.1+2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image_picker_macos",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_macos-0.2.1+2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image_picker_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_platform_interface-2.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "image_picker_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/image_picker_windows-0.2.1+1",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "integration_test",
      "rootUri": "file:///C:/tools/flutter/packages/integration_test",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "intl",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/intl-0.18.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "io",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/io-1.0.5",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "js",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/js-0.6.7",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "json_annotation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_annotation-4.9.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "json_serializable",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/json_serializable-6.9.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "leak_tracker",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker-10.0.9",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_flutter_testing",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_flutter_testing-3.0.9",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_testing",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/leak_tracker_testing-3.0.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "lints",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/lints-3.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "logging",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/logging-1.3.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "macros",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/macros-0.1.3-main.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "matcher",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/matcher-0.12.17",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "material_color_utilities",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/material_color_utilities-0.11.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "meta",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/meta-1.16.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "mime",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mime-2.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "mockito",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/mockito-5.4.5",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "octo_image",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/octo_image-2.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "package_config",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/package_config-2.2.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "path",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path-1.9.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "path_parsing",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_parsing-1.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "path_provider",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider-2.1.5",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "path_provider_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_android-2.2.17",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "path_provider_foundation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_foundation-2.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "path_provider_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_linux-2.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "path_provider_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_platform_interface-2.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "path_provider_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/path_provider_windows-2.3.0",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "permission_handler",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler-11.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "permission_handler_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_android-12.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "permission_handler_apple",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_apple-9.4.7",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "permission_handler_html",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_html-0.1.3+5",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "permission_handler_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_platform_interface-4.3.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "permission_handler_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/permission_handler_windows-0.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "petitparser",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/petitparser-6.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "photo_view",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/photo_view-0.14.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "platform",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/platform-3.1.6",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "plugin_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/plugin_platform_interface-2.1.8",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "pool",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pool-1.5.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "posix",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/posix-6.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "process",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/process-5.0.3",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "protobuf",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/protobuf-3.1.0",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "pub_semver",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pub_semver-2.2.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "pubspec_parse",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/pubspec_parse-1.5.0",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "quiver",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/quiver-3.2.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "retrofit",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit-4.4.2",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "retrofit_generator",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/retrofit_generator-8.2.1",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "riverpod",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod-2.6.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "riverpod_analyzer_utils",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_analyzer_utils-0.5.8",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "riverpod_annotation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_annotation-2.6.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "riverpod_generator",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/riverpod_generator-2.6.3",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "rxdart",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/rxdart-0.28.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "shared_preferences",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences-2.5.3",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "shared_preferences_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_android-2.4.10",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "shared_preferences_foundation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_foundation-2.5.4",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "shared_preferences_linux",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_linux-2.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "shared_preferences_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_platform_interface-2.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "shared_preferences_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_web-2.4.3",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "shared_preferences_windows",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shared_preferences_windows-2.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "shelf",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf-1.4.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "shelf_web_socket",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/shelf_web_socket-3.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "sky_engine",
      "rootUri": "file:///C:/tools/flutter/bin/cache/pkg/sky_engine",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "source_gen",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_gen-1.5.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "source_helper",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_helper-1.3.5",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "source_span",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/source_span-1.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "sprintf",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sprintf-7.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "sqflite",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite-2.4.2",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "sqflite_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_android-2.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "sqflite_common",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_common-2.5.5",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "sqflite_darwin",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_darwin-2.4.2",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "sqflite_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sqflite_platform_interface-2.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "stack_trace",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stack_trace-1.12.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "state_notifier",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/state_notifier-1.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "stream_channel",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_channel-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "stream_transform",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/stream_transform-2.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "string_scanner",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/string_scanner-1.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "sync_http",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/sync_http-0.3.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "synchronized",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/synchronized-3.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.8"
    },
    {
      "name": "term_glyph",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/term_glyph-1.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "test_api",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/test_api-0.7.4",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "timezone",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timezone-0.9.4",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "timing",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/timing-1.0.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "tuple",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/tuple-2.0.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "typed_data",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/typed_data-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "uuid",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/uuid-4.5.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "vector_graphics",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics-1.1.19",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "vector_graphics_codec",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_codec-1.1.13",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "vector_graphics_compiler",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_graphics_compiler-1.1.17",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "vector_math",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vector_math-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "video_player",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player-2.10.0",
      "packageUri": "lib/",
      "languageVersion": "3.6"
    },
    {
      "name": "video_player_android",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_android-2.8.7",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "video_player_avfoundation",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_avfoundation-2.7.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "video_player_platform_interface",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_platform_interface-6.3.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "video_player_web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/video_player_web-2.3.5",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "vm_service",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/vm_service-15.0.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "watcher",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/watcher-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "web",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "web_socket_channel",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/web_socket_channel-2.4.0",
      "packageUri": "lib/",
      "languageVersion": "2.15"
    },
    {
      "name": "webdriver",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/webdriver-3.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "win32",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/win32-5.14.0",
      "packageUri": "lib/",
      "languageVersion": "3.8"
    },
    {
      "name": "xdg_directories",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xdg_directories-1.1.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "xml",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/xml-6.5.0",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "yaml",
      "rootUri": "file:///C:/Users/User/AppData/Local/Pub/Cache/hosted/pub.dev/yaml-3.1.3",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "plant_social",
      "rootUri": "../",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    }
  ],
  "generator": "pub",
  "generatorVersion": "3.8.1",
  "flutterRoot": "file:///C:/tools/flutter",
  "flutterVersion": "3.32.5",
  "pubCache": "file:///C:/Users/User/AppData/Local/Pub/Cache"
}
</file>

<file path=".dart_tool/package_graph.json">
{
  "roots": [
    "plant_social"
  ],
  "packages": [
    {
      "name": "plant_social",
      "version": "1.0.0+1",
      "dependencies": [
        "cached_network_image",
        "camera",
        "contacts_service",
        "cupertino_icons",
        "dio",
        "flutter",
        "flutter_local_notifications",
        "flutter_riverpod",
        "flutter_secure_storage",
        "flutter_svg",
        "geolocator",
        "go_router",
        "google_fonts",
        "image",
        "image_picker",
        "intl",
        "json_annotation",
        "path_provider",
        "permission_handler",
        "photo_view",
        "retrofit",
        "riverpod_annotation",
        "shared_preferences",
        "uuid",
        "video_player",
        "web_socket_channel"
      ],
      "devDependencies": [
        "build_runner",
        "flutter_lints",
        "flutter_test",
        "integration_test",
        "json_serializable",
        "mockito",
        "retrofit_generator",
        "riverpod_generator"
      ]
    },
    {
      "name": "integration_test",
      "version": "0.0.0",
      "dependencies": [
        "async",
        "boolean_selector",
        "characters",
        "clock",
        "collection",
        "fake_async",
        "file",
        "flutter",
        "flutter_driver",
        "flutter_test",
        "leak_tracker",
        "leak_tracker_flutter_testing",
        "leak_tracker_testing",
        "matcher",
        "material_color_utilities",
        "meta",
        "path",
        "source_span",
        "stack_trace",
        "stream_channel",
        "string_scanner",
        "sync_http",
        "term_glyph",
        "test_api",
        "vector_math",
        "vm_service",
        "webdriver"
      ]
    },
    {
      "name": "flutter_test",
      "version": "0.0.0",
      "dependencies": [
        "async",
        "boolean_selector",
        "characters",
        "clock",
        "collection",
        "fake_async",
        "flutter",
        "leak_tracker",
        "leak_tracker_flutter_testing",
        "leak_tracker_testing",
        "matcher",
        "material_color_utilities",
        "meta",
        "path",
        "source_span",
        "stack_trace",
        "stream_channel",
        "string_scanner",
        "term_glyph",
        "test_api",
        "vector_math",
        "vm_service"
      ]
    },
    {
      "name": "contacts_service",
      "version": "0.6.3",
      "dependencies": [
        "collection",
        "flutter",
        "quiver"
      ]
    },
    {
      "name": "intl",
      "version": "0.18.1",
      "dependencies": [
        "clock",
        "meta",
        "path"
      ]
    },
    {
      "name": "photo_view",
      "version": "0.14.0",
      "dependencies": [
        "flutter"
      ]
    },
    {
      "name": "go_router",
      "version": "12.1.3",
      "dependencies": [
        "collection",
        "flutter",
        "flutter_web_plugins",
        "logging",
        "meta"
      ]
    },
    {
      "name": "flutter",
      "version": "0.0.0",
      "dependencies": [
        "characters",
        "collection",
        "material_color_utilities",
        "meta",
        "sky_engine",
        "vector_math"
      ]
    },
    {
      "name": "source_span",
      "version": "1.10.1",
      "dependencies": [
        "collection",
        "path",
        "term_glyph"
      ]
    },
    {
      "name": "path",
      "version": "1.9.1",
      "dependencies": []
    },
    {
      "name": "async",
      "version": "2.13.0",
      "dependencies": [
        "collection",
        "meta"
      ]
    },
    {
      "name": "collection",
      "version": "1.19.1",
      "dependencies": []
    },
    {
      "name": "term_glyph",
      "version": "1.2.2",
      "dependencies": []
    },
    {
      "name": "string_scanner",
      "version": "1.4.1",
      "dependencies": [
        "source_span"
      ]
    },
    {
      "name": "meta",
      "version": "1.16.0",
      "dependencies": []
    },
    {
      "name": "matcher",
      "version": "0.12.17",
      "dependencies": [
        "async",
        "meta",
        "stack_trace",
        "term_glyph",
        "test_api"
      ]
    },
    {
      "name": "built_collection",
      "version": "5.1.1",
      "dependencies": []
    },
    {
      "name": "stack_trace",
      "version": "1.12.1",
      "dependencies": [
        "path"
      ]
    },
    {
      "name": "test_api",
      "version": "0.7.4",
      "dependencies": [
        "async",
        "boolean_selector",
        "collection",
        "meta",
        "source_span",
        "stack_trace",
        "stream_channel",
        "string_scanner",
        "term_glyph"
      ]
    },
    {
      "name": "stream_channel",
      "version": "2.1.4",
      "dependencies": [
        "async"
      ]
    },
    {
      "name": "boolean_selector",
      "version": "2.1.2",
      "dependencies": [
        "source_span",
        "string_scanner"
      ]
    },
    {
      "name": "webdriver",
      "version": "3.1.0",
      "dependencies": [
        "matcher",
        "path",
        "stack_trace",
        "sync_http"
      ]
    },
    {
      "name": "vm_service",
      "version": "15.0.0",
      "dependencies": []
    },
    {
      "name": "vector_math",
      "version": "2.1.4",
      "dependencies": []
    },
    {
      "name": "sync_http",
      "version": "0.3.1",
      "dependencies": []
    },
    {
      "name": "material_color_utilities",
      "version": "0.11.1",
      "dependencies": [
        "collection"
      ]
    },
    {
      "name": "leak_tracker_testing",
      "version": "3.0.1",
      "dependencies": [
        "leak_tracker",
        "matcher",
        "meta"
      ]
    },
    {
      "name": "leak_tracker_flutter_testing",
      "version": "3.0.9",
      "dependencies": [
        "flutter",
        "leak_tracker",
        "leak_tracker_testing",
        "matcher",
        "meta"
      ]
    },
    {
      "name": "leak_tracker",
      "version": "10.0.9",
      "dependencies": [
        "clock",
        "collection",
        "meta",
        "path",
        "vm_service"
      ]
    },
    {
      "name": "flutter_driver",
      "version": "0.0.0",
      "dependencies": [
        "async",
        "boolean_selector",
        "characters",
        "clock",
        "collection",
        "file",
        "flutter",
        "flutter_test",
        "fuchsia_remote_debug_protocol",
        "leak_tracker",
        "leak_tracker_flutter_testing",
        "leak_tracker_testing",
        "matcher",
        "material_color_utilities",
        "meta",
        "path",
        "platform",
        "process",
        "source_span",
        "stack_trace",
        "stream_channel",
        "string_scanner",
        "sync_http",
        "term_glyph",
        "test_api",
        "vector_math",
        "vm_service",
        "webdriver"
      ]
    },
    {
      "name": "file",
      "version": "7.0.1",
      "dependencies": [
        "meta",
        "path"
      ]
    },
    {
      "name": "fake_async",
      "version": "1.3.3",
      "dependencies": [
        "clock",
        "collection"
      ]
    },
    {
      "name": "clock",
      "version": "1.1.2",
      "dependencies": []
    },
    {
      "name": "characters",
      "version": "1.4.0",
      "dependencies": []
    },
    {
      "name": "process",
      "version": "5.0.3",
      "dependencies": [
        "file",
        "path",
        "platform"
      ]
    },
    {
      "name": "platform",
      "version": "3.1.6",
      "dependencies": []
    },
    {
      "name": "fuchsia_remote_debug_protocol",
      "version": "0.0.0",
      "dependencies": [
        "file",
        "meta",
        "path",
        "platform",
        "process",
        "vm_service"
      ]
    },
    {
      "name": "flutter_web_plugins",
      "version": "0.0.0",
      "dependencies": [
        "characters",
        "collection",
        "flutter",
        "material_color_utilities",
        "meta",
        "vector_math"
      ]
    },
    {
      "name": "sky_engine",
      "version": "0.0.0",
      "dependencies": []
    },
    {
      "name": "mockito",
      "version": "5.4.5",
      "dependencies": [
        "analyzer",
        "build",
        "code_builder",
        "collection",
        "dart_style",
        "matcher",
        "meta",
        "path",
        "source_gen",
        "test_api"
      ]
    },
    {
      "name": "geolocator",
      "version": "10.1.1",
      "dependencies": [
        "flutter",
        "geolocator_android",
        "geolocator_apple",
        "geolocator_platform_interface",
        "geolocator_web",
        "geolocator_windows"
      ]
    },
    {
      "name": "json_annotation",
      "version": "4.9.0",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "source_gen",
      "version": "1.5.0",
      "dependencies": [
        "analyzer",
        "async",
        "build",
        "dart_style",
        "glob",
        "path",
        "source_span",
        "yaml"
      ]
    },
    {
      "name": "dart_style",
      "version": "2.3.8",
      "dependencies": [
        "analyzer",
        "args",
        "collection",
        "package_config",
        "path",
        "pub_semver",
        "source_span"
      ]
    },
    {
      "name": "geolocator_web",
      "version": "2.2.1",
      "dependencies": [
        "flutter",
        "flutter_web_plugins",
        "geolocator_platform_interface"
      ]
    },
    {
      "name": "flutter_lints",
      "version": "3.0.2",
      "dependencies": [
        "lints"
      ]
    },
    {
      "name": "lints",
      "version": "3.0.0",
      "dependencies": []
    },
    {
      "name": "json_serializable",
      "version": "6.9.0",
      "dependencies": [
        "analyzer",
        "async",
        "build",
        "build_config",
        "collection",
        "json_annotation",
        "meta",
        "path",
        "pub_semver",
        "pubspec_parse",
        "source_gen",
        "source_helper"
      ]
    },
    {
      "name": "source_helper",
      "version": "1.3.5",
      "dependencies": [
        "analyzer",
        "collection",
        "source_gen"
      ]
    },
    {
      "name": "google_fonts",
      "version": "6.2.1",
      "dependencies": [
        "crypto",
        "flutter",
        "http",
        "path_provider"
      ]
    },
    {
      "name": "analyzer",
      "version": "6.11.0",
      "dependencies": [
        "_fe_analyzer_shared",
        "collection",
        "convert",
        "crypto",
        "glob",
        "macros",
        "meta",
        "package_config",
        "path",
        "pub_semver",
        "source_span",
        "watcher",
        "yaml"
      ]
    },
    {
      "name": "macros",
      "version": "0.1.3-main.0",
      "dependencies": [
        "_macros"
      ]
    },
    {
      "name": "_fe_analyzer_shared",
      "version": "76.0.0",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "_macros",
      "version": "0.3.3",
      "dependencies": []
    },
    {
      "name": "pub_semver",
      "version": "2.2.0",
      "dependencies": [
        "collection"
      ]
    },
    {
      "name": "package_config",
      "version": "2.2.0",
      "dependencies": [
        "path"
      ]
    },
    {
      "name": "build_config",
      "version": "1.1.2",
      "dependencies": [
        "checked_yaml",
        "json_annotation",
        "path",
        "pubspec_parse",
        "yaml"
      ]
    },
    {
      "name": "watcher",
      "version": "1.1.2",
      "dependencies": [
        "async",
        "path"
      ]
    },
    {
      "name": "cached_network_image",
      "version": "3.4.1",
      "dependencies": [
        "cached_network_image_platform_interface",
        "cached_network_image_web",
        "flutter",
        "flutter_cache_manager",
        "octo_image"
      ]
    },
    {
      "name": "web_socket_channel",
      "version": "2.4.0",
      "dependencies": [
        "async",
        "crypto",
        "stream_channel"
      ]
    },
    {
      "name": "octo_image",
      "version": "2.1.0",
      "dependencies": [
        "flutter"
      ]
    },
    {
      "name": "flutter_cache_manager",
      "version": "3.4.1",
      "dependencies": [
        "clock",
        "collection",
        "file",
        "flutter",
        "http",
        "path",
        "path_provider",
        "rxdart",
        "sqflite",
        "uuid"
      ]
    },
    {
      "name": "cached_network_image_web",
      "version": "1.3.1",
      "dependencies": [
        "cached_network_image_platform_interface",
        "flutter",
        "flutter_cache_manager",
        "web"
      ]
    },
    {
      "name": "cached_network_image_platform_interface",
      "version": "4.1.1",
      "dependencies": [
        "flutter",
        "flutter_cache_manager"
      ]
    },
    {
      "name": "sprintf",
      "version": "7.0.0",
      "dependencies": []
    },
    {
      "name": "path_provider",
      "version": "2.1.5",
      "dependencies": [
        "flutter",
        "path_provider_android",
        "path_provider_foundation",
        "path_provider_linux",
        "path_provider_platform_interface",
        "path_provider_windows"
      ]
    },
    {
      "name": "fixnum",
      "version": "1.1.1",
      "dependencies": []
    },
    {
      "name": "path_provider_linux",
      "version": "2.2.1",
      "dependencies": [
        "ffi",
        "flutter",
        "path",
        "path_provider_platform_interface",
        "xdg_directories"
      ]
    },
    {
      "name": "uuid",
      "version": "4.5.1",
      "dependencies": [
        "crypto",
        "fixnum",
        "meta",
        "sprintf"
      ]
    },
    {
      "name": "http",
      "version": "1.4.0",
      "dependencies": [
        "async",
        "http_parser",
        "meta",
        "web"
      ]
    },
    {
      "name": "web",
      "version": "1.1.1",
      "dependencies": []
    },
    {
      "name": "path_provider_windows",
      "version": "2.3.0",
      "dependencies": [
        "ffi",
        "flutter",
        "path",
        "path_provider_platform_interface"
      ]
    },
    {
      "name": "path_provider_platform_interface",
      "version": "2.1.2",
      "dependencies": [
        "flutter",
        "platform",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "plugin_platform_interface",
      "version": "2.1.8",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "path_provider_foundation",
      "version": "2.4.1",
      "dependencies": [
        "flutter",
        "path_provider_platform_interface"
      ]
    },
    {
      "name": "typed_data",
      "version": "1.4.0",
      "dependencies": [
        "collection"
      ]
    },
    {
      "name": "geolocator_windows",
      "version": "0.2.5",
      "dependencies": [
        "flutter",
        "geolocator_platform_interface"
      ]
    },
    {
      "name": "flutter_local_notifications",
      "version": "16.3.3",
      "dependencies": [
        "clock",
        "flutter",
        "flutter_local_notifications_linux",
        "flutter_local_notifications_platform_interface",
        "timezone"
      ]
    },
    {
      "name": "flutter_local_notifications_linux",
      "version": "4.0.1",
      "dependencies": [
        "dbus",
        "ffi",
        "flutter",
        "flutter_local_notifications_platform_interface",
        "path",
        "xdg_directories"
      ]
    },
    {
      "name": "flutter_local_notifications_platform_interface",
      "version": "7.2.0",
      "dependencies": [
        "flutter",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "dbus",
      "version": "0.7.11",
      "dependencies": [
        "args",
        "ffi",
        "meta",
        "xml"
      ]
    },
    {
      "name": "yaml",
      "version": "3.1.3",
      "dependencies": [
        "collection",
        "source_span",
        "string_scanner"
      ]
    },
    {
      "name": "checked_yaml",
      "version": "2.0.4",
      "dependencies": [
        "json_annotation",
        "source_span",
        "yaml"
      ]
    },
    {
      "name": "rxdart",
      "version": "0.28.0",
      "dependencies": []
    },
    {
      "name": "timezone",
      "version": "0.9.4",
      "dependencies": [
        "path"
      ]
    },
    {
      "name": "permission_handler",
      "version": "11.4.0",
      "dependencies": [
        "flutter",
        "meta",
        "permission_handler_android",
        "permission_handler_apple",
        "permission_handler_html",
        "permission_handler_platform_interface",
        "permission_handler_windows"
      ]
    },
    {
      "name": "permission_handler_windows",
      "version": "0.2.1",
      "dependencies": [
        "flutter",
        "permission_handler_platform_interface"
      ]
    },
    {
      "name": "permission_handler_platform_interface",
      "version": "4.3.0",
      "dependencies": [
        "flutter",
        "meta",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "permission_handler_android",
      "version": "12.1.0",
      "dependencies": [
        "flutter",
        "permission_handler_platform_interface"
      ]
    },
    {
      "name": "permission_handler_apple",
      "version": "9.4.7",
      "dependencies": [
        "flutter",
        "permission_handler_platform_interface"
      ]
    },
    {
      "name": "camera",
      "version": "0.10.6",
      "dependencies": [
        "camera_android",
        "camera_avfoundation",
        "camera_platform_interface",
        "camera_web",
        "flutter",
        "flutter_plugin_android_lifecycle"
      ]
    },
    {
      "name": "camera_web",
      "version": "0.3.5",
      "dependencies": [
        "camera_platform_interface",
        "flutter",
        "flutter_web_plugins",
        "stream_transform",
        "web"
      ]
    },
    {
      "name": "stream_transform",
      "version": "2.1.1",
      "dependencies": []
    },
    {
      "name": "cupertino_icons",
      "version": "1.0.8",
      "dependencies": []
    },
    {
      "name": "riverpod_annotation",
      "version": "2.6.1",
      "dependencies": [
        "meta",
        "riverpod"
      ]
    },
    {
      "name": "riverpod",
      "version": "2.6.1",
      "dependencies": [
        "collection",
        "meta",
        "stack_trace",
        "state_notifier"
      ]
    },
    {
      "name": "state_notifier",
      "version": "1.0.0",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "flutter_riverpod",
      "version": "2.6.1",
      "dependencies": [
        "collection",
        "flutter",
        "meta",
        "riverpod",
        "state_notifier"
      ]
    },
    {
      "name": "convert",
      "version": "3.1.2",
      "dependencies": [
        "typed_data"
      ]
    },
    {
      "name": "quiver",
      "version": "3.2.2",
      "dependencies": [
        "matcher"
      ]
    },
    {
      "name": "http_parser",
      "version": "4.1.2",
      "dependencies": [
        "collection",
        "source_span",
        "string_scanner",
        "typed_data"
      ]
    },
    {
      "name": "sqflite",
      "version": "2.4.2",
      "dependencies": [
        "flutter",
        "path",
        "sqflite_android",
        "sqflite_common",
        "sqflite_darwin",
        "sqflite_platform_interface"
      ]
    },
    {
      "name": "sqflite_platform_interface",
      "version": "2.4.0",
      "dependencies": [
        "flutter",
        "meta",
        "platform",
        "plugin_platform_interface",
        "sqflite_common"
      ]
    },
    {
      "name": "sqflite_common",
      "version": "2.5.5",
      "dependencies": [
        "meta",
        "path",
        "synchronized"
      ]
    },
    {
      "name": "sqflite_darwin",
      "version": "2.4.2",
      "dependencies": [
        "flutter",
        "meta",
        "path",
        "sqflite_common",
        "sqflite_platform_interface"
      ]
    },
    {
      "name": "sqflite_android",
      "version": "2.4.1",
      "dependencies": [
        "flutter",
        "path",
        "sqflite_common",
        "sqflite_platform_interface"
      ]
    },
    {
      "name": "retrofit",
      "version": "4.4.2",
      "dependencies": [
        "dio",
        "meta"
      ]
    },
    {
      "name": "glob",
      "version": "2.1.3",
      "dependencies": [
        "async",
        "collection",
        "file",
        "path",
        "string_scanner"
      ]
    },
    {
      "name": "logging",
      "version": "1.3.0",
      "dependencies": []
    },
    {
      "name": "crypto",
      "version": "3.0.6",
      "dependencies": [
        "typed_data"
      ]
    },
    {
      "name": "build",
      "version": "2.5.4",
      "dependencies": [
        "analyzer",
        "async",
        "build_runner_core",
        "built_collection",
        "built_value",
        "convert",
        "crypto",
        "glob",
        "graphs",
        "logging",
        "meta",
        "package_config",
        "path",
        "pool"
      ]
    },
    {
      "name": "build_runner",
      "version": "2.5.4",
      "dependencies": [
        "analyzer",
        "args",
        "async",
        "build",
        "build_config",
        "build_daemon",
        "build_resolvers",
        "build_runner_core",
        "code_builder",
        "collection",
        "crypto",
        "dart_style",
        "frontend_server_client",
        "glob",
        "graphs",
        "http",
        "http_multi_server",
        "io",
        "js",
        "logging",
        "meta",
        "mime",
        "package_config",
        "path",
        "pool",
        "pub_semver",
        "pubspec_parse",
        "shelf",
        "shelf_web_socket",
        "stack_trace",
        "stream_transform",
        "timing",
        "watcher",
        "web",
        "web_socket_channel",
        "yaml"
      ]
    },
    {
      "name": "built_value",
      "version": "8.10.1",
      "dependencies": [
        "built_collection",
        "collection",
        "fixnum",
        "meta"
      ]
    },
    {
      "name": "build_runner_core",
      "version": "9.1.2",
      "dependencies": [
        "analyzer",
        "async",
        "build",
        "build_config",
        "build_resolvers",
        "build_runner",
        "built_collection",
        "built_value",
        "collection",
        "convert",
        "crypto",
        "glob",
        "graphs",
        "json_annotation",
        "logging",
        "meta",
        "package_config",
        "path",
        "pool",
        "timing",
        "watcher",
        "yaml"
      ]
    },
    {
      "name": "build_resolvers",
      "version": "2.5.4",
      "dependencies": [
        "analyzer",
        "async",
        "build",
        "build_runner_core",
        "collection",
        "convert",
        "crypto",
        "graphs",
        "logging",
        "package_config",
        "path",
        "pool",
        "pub_semver",
        "stream_transform"
      ]
    },
    {
      "name": "pool",
      "version": "1.5.1",
      "dependencies": [
        "async",
        "stack_trace"
      ]
    },
    {
      "name": "timing",
      "version": "1.0.2",
      "dependencies": [
        "json_annotation"
      ]
    },
    {
      "name": "graphs",
      "version": "2.3.2",
      "dependencies": [
        "collection"
      ]
    },
    {
      "name": "frontend_server_client",
      "version": "4.0.0",
      "dependencies": [
        "async",
        "path"
      ]
    },
    {
      "name": "io",
      "version": "1.0.5",
      "dependencies": [
        "meta",
        "path",
        "string_scanner"
      ]
    },
    {
      "name": "http_multi_server",
      "version": "3.2.2",
      "dependencies": [
        "async"
      ]
    },
    {
      "name": "build_daemon",
      "version": "4.0.4",
      "dependencies": [
        "built_collection",
        "built_value",
        "crypto",
        "http_multi_server",
        "logging",
        "path",
        "pool",
        "shelf",
        "shelf_web_socket",
        "stream_transform",
        "watcher",
        "web_socket_channel"
      ]
    },
    {
      "name": "code_builder",
      "version": "4.10.1",
      "dependencies": [
        "built_collection",
        "built_value",
        "collection",
        "matcher",
        "meta"
      ]
    },
    {
      "name": "ffi",
      "version": "2.1.4",
      "dependencies": []
    },
    {
      "name": "permission_handler_html",
      "version": "0.1.3+5",
      "dependencies": [
        "flutter",
        "flutter_web_plugins",
        "permission_handler_platform_interface",
        "web"
      ]
    },
    {
      "name": "retrofit_generator",
      "version": "8.2.1",
      "dependencies": [
        "analyzer",
        "build",
        "built_collection",
        "code_builder",
        "dart_style",
        "dio",
        "protobuf",
        "retrofit",
        "source_gen",
        "tuple"
      ]
    },
    {
      "name": "protobuf",
      "version": "3.1.0",
      "dependencies": [
        "collection",
        "fixnum",
        "meta"
      ]
    },
    {
      "name": "tuple",
      "version": "2.0.2",
      "dependencies": []
    },
    {
      "name": "image_picker",
      "version": "1.1.2",
      "dependencies": [
        "flutter",
        "image_picker_android",
        "image_picker_for_web",
        "image_picker_ios",
        "image_picker_linux",
        "image_picker_macos",
        "image_picker_platform_interface",
        "image_picker_windows"
      ]
    },
    {
      "name": "image_picker_windows",
      "version": "0.2.1+1",
      "dependencies": [
        "file_selector_platform_interface",
        "file_selector_windows",
        "flutter",
        "image_picker_platform_interface"
      ]
    },
    {
      "name": "image_picker_platform_interface",
      "version": "2.10.1",
      "dependencies": [
        "cross_file",
        "flutter",
        "http",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "image_picker_macos",
      "version": "0.2.1+2",
      "dependencies": [
        "file_selector_macos",
        "file_selector_platform_interface",
        "flutter",
        "image_picker_platform_interface"
      ]
    },
    {
      "name": "image_picker_linux",
      "version": "0.2.1+2",
      "dependencies": [
        "file_selector_linux",
        "file_selector_platform_interface",
        "flutter",
        "image_picker_platform_interface"
      ]
    },
    {
      "name": "file_selector_linux",
      "version": "0.9.3+2",
      "dependencies": [
        "cross_file",
        "file_selector_platform_interface",
        "flutter"
      ]
    },
    {
      "name": "file_selector_platform_interface",
      "version": "2.6.2",
      "dependencies": [
        "cross_file",
        "flutter",
        "http",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "flutter_secure_storage",
      "version": "9.2.4",
      "dependencies": [
        "flutter",
        "flutter_secure_storage_linux",
        "flutter_secure_storage_macos",
        "flutter_secure_storage_platform_interface",
        "flutter_secure_storage_web",
        "flutter_secure_storage_windows",
        "meta"
      ]
    },
    {
      "name": "flutter_secure_storage_windows",
      "version": "3.1.2",
      "dependencies": [
        "ffi",
        "flutter",
        "flutter_secure_storage_platform_interface",
        "path",
        "path_provider",
        "win32"
      ]
    },
    {
      "name": "flutter_secure_storage_web",
      "version": "1.2.1",
      "dependencies": [
        "flutter",
        "flutter_secure_storage_platform_interface",
        "flutter_web_plugins",
        "js"
      ]
    },
    {
      "name": "flutter_secure_storage_platform_interface",
      "version": "1.1.2",
      "dependencies": [
        "flutter",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "flutter_secure_storage_macos",
      "version": "3.1.3",
      "dependencies": [
        "flutter",
        "flutter_secure_storage_platform_interface"
      ]
    },
    {
      "name": "flutter_secure_storage_linux",
      "version": "1.2.3",
      "dependencies": [
        "flutter",
        "flutter_secure_storage_platform_interface"
      ]
    },
    {
      "name": "js",
      "version": "0.6.7",
      "dependencies": [
        "meta"
      ]
    },
    {
      "name": "shelf_web_socket",
      "version": "3.0.0",
      "dependencies": [
        "shelf",
        "stream_channel",
        "web_socket_channel"
      ]
    },
    {
      "name": "mime",
      "version": "2.0.0",
      "dependencies": []
    },
    {
      "name": "image_picker_for_web",
      "version": "3.0.6",
      "dependencies": [
        "flutter",
        "flutter_web_plugins",
        "image_picker_platform_interface",
        "mime",
        "web"
      ]
    },
    {
      "name": "pubspec_parse",
      "version": "1.5.0",
      "dependencies": [
        "checked_yaml",
        "collection",
        "json_annotation",
        "pub_semver",
        "yaml"
      ]
    },
    {
      "name": "geolocator_platform_interface",
      "version": "4.2.6",
      "dependencies": [
        "flutter",
        "meta",
        "plugin_platform_interface",
        "vector_math"
      ]
    },
    {
      "name": "xdg_directories",
      "version": "1.1.0",
      "dependencies": [
        "meta",
        "path"
      ]
    },
    {
      "name": "camera_platform_interface",
      "version": "2.10.0",
      "dependencies": [
        "cross_file",
        "flutter",
        "plugin_platform_interface",
        "stream_transform"
      ]
    },
    {
      "name": "dio",
      "version": "5.8.0+1",
      "dependencies": [
        "async",
        "collection",
        "dio_web_adapter",
        "http_parser",
        "meta",
        "path"
      ]
    },
    {
      "name": "dio_web_adapter",
      "version": "2.1.1",
      "dependencies": [
        "dio",
        "http_parser",
        "meta",
        "web"
      ]
    },
    {
      "name": "xml",
      "version": "6.5.0",
      "dependencies": [
        "collection",
        "meta",
        "petitparser"
      ]
    },
    {
      "name": "petitparser",
      "version": "6.1.0",
      "dependencies": [
        "collection",
        "meta"
      ]
    },
    {
      "name": "file_selector_macos",
      "version": "0.9.4+3",
      "dependencies": [
        "cross_file",
        "file_selector_platform_interface",
        "flutter"
      ]
    },
    {
      "name": "flutter_svg",
      "version": "2.2.0",
      "dependencies": [
        "flutter",
        "http",
        "vector_graphics",
        "vector_graphics_codec",
        "vector_graphics_compiler"
      ]
    },
    {
      "name": "vector_graphics_codec",
      "version": "1.1.13",
      "dependencies": []
    },
    {
      "name": "vector_graphics_compiler",
      "version": "1.1.17",
      "dependencies": [
        "args",
        "meta",
        "path",
        "path_parsing",
        "vector_graphics_codec",
        "xml"
      ]
    },
    {
      "name": "path_parsing",
      "version": "1.1.0",
      "dependencies": [
        "meta",
        "vector_math"
      ]
    },
    {
      "name": "vector_graphics",
      "version": "1.1.19",
      "dependencies": [
        "flutter",
        "http",
        "vector_graphics_codec"
      ]
    },
    {
      "name": "args",
      "version": "2.7.0",
      "dependencies": []
    },
    {
      "name": "path_provider_android",
      "version": "2.2.17",
      "dependencies": [
        "flutter",
        "path_provider_platform_interface"
      ]
    },
    {
      "name": "shelf",
      "version": "1.4.2",
      "dependencies": [
        "async",
        "collection",
        "http_parser",
        "path",
        "stack_trace",
        "stream_channel"
      ]
    },
    {
      "name": "riverpod_generator",
      "version": "2.6.3",
      "dependencies": [
        "analyzer",
        "build",
        "build_config",
        "collection",
        "crypto",
        "meta",
        "path",
        "riverpod_analyzer_utils",
        "riverpod_annotation",
        "source_gen"
      ]
    },
    {
      "name": "riverpod_analyzer_utils",
      "version": "0.5.8",
      "dependencies": [
        "analyzer",
        "collection",
        "crypto",
        "custom_lint_core",
        "freezed_annotation",
        "meta",
        "path",
        "source_span"
      ]
    },
    {
      "name": "custom_lint_core",
      "version": "0.7.0",
      "dependencies": [
        "analyzer",
        "analyzer_plugin",
        "collection",
        "custom_lint_visitor",
        "glob",
        "matcher",
        "meta",
        "package_config",
        "path",
        "pubspec_parse",
        "source_span",
        "uuid",
        "yaml"
      ]
    },
    {
      "name": "freezed_annotation",
      "version": "2.4.4",
      "dependencies": [
        "collection",
        "json_annotation",
        "meta"
      ]
    },
    {
      "name": "analyzer_plugin",
      "version": "0.11.3",
      "dependencies": [
        "analyzer",
        "collection",
        "dart_style",
        "pub_semver",
        "yaml"
      ]
    },
    {
      "name": "custom_lint_visitor",
      "version": "1.0.0+6.11.0",
      "dependencies": [
        "analyzer"
      ]
    },
    {
      "name": "image",
      "version": "4.5.4",
      "dependencies": [
        "archive",
        "meta",
        "xml"
      ]
    },
    {
      "name": "archive",
      "version": "4.0.7",
      "dependencies": [
        "crypto",
        "path",
        "posix"
      ]
    },
    {
      "name": "posix",
      "version": "6.0.2",
      "dependencies": [
        "ffi",
        "meta",
        "path"
      ]
    },
    {
      "name": "video_player",
      "version": "2.10.0",
      "dependencies": [
        "flutter",
        "html",
        "video_player_android",
        "video_player_avfoundation",
        "video_player_platform_interface",
        "video_player_web"
      ]
    },
    {
      "name": "video_player_platform_interface",
      "version": "6.3.0",
      "dependencies": [
        "flutter",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "video_player_avfoundation",
      "version": "2.7.1",
      "dependencies": [
        "flutter",
        "video_player_platform_interface"
      ]
    },
    {
      "name": "video_player_android",
      "version": "2.8.7",
      "dependencies": [
        "flutter",
        "video_player_platform_interface"
      ]
    },
    {
      "name": "html",
      "version": "0.15.6",
      "dependencies": [
        "csslib",
        "source_span"
      ]
    },
    {
      "name": "csslib",
      "version": "1.0.2",
      "dependencies": [
        "source_span"
      ]
    },
    {
      "name": "video_player_web",
      "version": "2.3.5",
      "dependencies": [
        "flutter",
        "flutter_web_plugins",
        "video_player_platform_interface",
        "web"
      ]
    },
    {
      "name": "shared_preferences",
      "version": "2.5.3",
      "dependencies": [
        "flutter",
        "shared_preferences_android",
        "shared_preferences_foundation",
        "shared_preferences_linux",
        "shared_preferences_platform_interface",
        "shared_preferences_web",
        "shared_preferences_windows"
      ]
    },
    {
      "name": "shared_preferences_windows",
      "version": "2.4.1",
      "dependencies": [
        "file",
        "flutter",
        "path",
        "path_provider_platform_interface",
        "path_provider_windows",
        "shared_preferences_platform_interface"
      ]
    },
    {
      "name": "shared_preferences_platform_interface",
      "version": "2.4.1",
      "dependencies": [
        "flutter",
        "plugin_platform_interface"
      ]
    },
    {
      "name": "shared_preferences_linux",
      "version": "2.4.1",
      "dependencies": [
        "file",
        "flutter",
        "path",
        "path_provider_linux",
        "path_provider_platform_interface",
        "shared_preferences_platform_interface"
      ]
    },
    {
      "name": "shared_preferences_web",
      "version": "2.4.3",
      "dependencies": [
        "flutter",
        "flutter_web_plugins",
        "shared_preferences_platform_interface",
        "web"
      ]
    },
    {
      "name": "shared_preferences_foundation",
      "version": "2.5.4",
      "dependencies": [
        "flutter",
        "shared_preferences_platform_interface"
      ]
    },
    {
      "name": "shared_preferences_android",
      "version": "2.4.10",
      "dependencies": [
        "flutter",
        "shared_preferences_platform_interface"
      ]
    },
    {
      "name": "geolocator_apple",
      "version": "2.3.13",
      "dependencies": [
        "flutter",
        "geolocator_platform_interface"
      ]
    },
    {
      "name": "synchronized",
      "version": "3.4.0",
      "dependencies": []
    },
    {
      "name": "geolocator_android",
      "version": "4.6.2",
      "dependencies": [
        "flutter",
        "geolocator_platform_interface",
        "meta",
        "uuid"
      ]
    },
    {
      "name": "image_picker_ios",
      "version": "0.8.12+2",
      "dependencies": [
        "flutter",
        "image_picker_platform_interface"
      ]
    },
    {
      "name": "file_selector_windows",
      "version": "0.9.3+4",
      "dependencies": [
        "cross_file",
        "file_selector_platform_interface",
        "flutter"
      ]
    },
    {
      "name": "cross_file",
      "version": "0.3.4+2",
      "dependencies": [
        "meta",
        "web"
      ]
    },
    {
      "name": "camera_android",
      "version": "0.10.10+3",
      "dependencies": [
        "camera_platform_interface",
        "flutter",
        "flutter_plugin_android_lifecycle",
        "stream_transform"
      ]
    },
    {
      "name": "flutter_plugin_android_lifecycle",
      "version": "2.0.28",
      "dependencies": [
        "flutter"
      ]
    },
    {
      "name": "win32",
      "version": "5.14.0",
      "dependencies": [
        "ffi"
      ]
    },
    {
      "name": "camera_avfoundation",
      "version": "0.9.20+1",
      "dependencies": [
        "camera_platform_interface",
        "flutter",
        "stream_transform"
      ]
    },
    {
      "name": "image_picker_android",
      "version": "0.8.12+23",
      "dependencies": [
        "flutter",
        "flutter_plugin_android_lifecycle",
        "image_picker_platform_interface"
      ]
    }
  ],
  "configVersion": 1
}
</file>

<file path=".dart_tool/version">
3.32.5
</file>

<file path=".flutter-plugins-dependencies">
{"info":"This is a generated file; do not edit or check into version control.","plugins":{"ios":[{"name":"camera_avfoundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\camera_avfoundation-0.9.20+1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"contacts_service","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\contacts_service-0.6.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_local_notifications","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_local_notifications-16.3.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage-9.2.4\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"geolocator_apple","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\geolocator_apple-2.3.13\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"image_picker_ios","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_ios-0.8.12+2\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"integration_test","path":"C:\\\\tools\\\\flutter\\\\packages\\\\integration_test\\\\","native_build":true,"dependencies":[],"dev_dependency":true},{"name":"path_provider_foundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\path_provider_foundation-2.4.1\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"permission_handler_apple","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\permission_handler_apple-9.4.7\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"shared_preferences_foundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_foundation-2.5.4\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"sqflite_darwin","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\sqflite_darwin-2.4.2\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"video_player_avfoundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\video_player_avfoundation-2.7.1\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false}],"android":[{"name":"camera_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\camera_android-0.10.10+3\\\\","native_build":true,"dependencies":["flutter_plugin_android_lifecycle"],"dev_dependency":false},{"name":"contacts_service","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\contacts_service-0.6.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_local_notifications","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_local_notifications-16.3.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_plugin_android_lifecycle","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_plugin_android_lifecycle-2.0.28\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage-9.2.4\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"geolocator_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\geolocator_android-4.6.2\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"image_picker_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_android-0.8.12+23\\\\","native_build":true,"dependencies":["flutter_plugin_android_lifecycle"],"dev_dependency":false},{"name":"integration_test","path":"C:\\\\tools\\\\flutter\\\\packages\\\\integration_test\\\\","native_build":true,"dependencies":[],"dev_dependency":true},{"name":"path_provider_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\path_provider_android-2.2.17\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"permission_handler_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\permission_handler_android-12.1.0\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"shared_preferences_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_android-2.4.10\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"sqflite_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\sqflite_android-2.4.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"video_player_android","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\video_player_android-2.8.7\\\\","native_build":true,"dependencies":[],"dev_dependency":false}],"macos":[{"name":"file_selector_macos","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\file_selector_macos-0.9.4+3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_local_notifications","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_local_notifications-16.3.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage_macos","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage_macos-3.1.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"geolocator_apple","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\geolocator_apple-2.3.13\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"image_picker_macos","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_macos-0.2.1+2\\\\","native_build":false,"dependencies":["file_selector_macos"],"dev_dependency":false},{"name":"path_provider_foundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\path_provider_foundation-2.4.1\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"shared_preferences_foundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_foundation-2.5.4\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"sqflite_darwin","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\sqflite_darwin-2.4.2\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false},{"name":"video_player_avfoundation","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\video_player_avfoundation-2.7.1\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false}],"linux":[{"name":"file_selector_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\file_selector_linux-0.9.3+2\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_local_notifications_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_local_notifications_linux-4.0.1\\\\","native_build":false,"dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage_linux-1.2.3\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"image_picker_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_linux-0.2.1+2\\\\","native_build":false,"dependencies":["file_selector_linux"],"dev_dependency":false},{"name":"path_provider_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\path_provider_linux-2.2.1\\\\","native_build":false,"dependencies":[],"dev_dependency":false},{"name":"shared_preferences_linux","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_linux-2.4.1\\\\","native_build":false,"dependencies":["path_provider_linux"],"dev_dependency":false}],"windows":[{"name":"file_selector_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\file_selector_windows-0.9.3+4\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage_windows-3.1.2\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"geolocator_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\geolocator_windows-0.2.5\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"image_picker_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_windows-0.2.1+1\\\\","native_build":false,"dependencies":["file_selector_windows"],"dev_dependency":false},{"name":"path_provider_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\path_provider_windows-2.3.0\\\\","native_build":false,"dependencies":[],"dev_dependency":false},{"name":"permission_handler_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\permission_handler_windows-0.2.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"shared_preferences_windows","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_windows-2.4.1\\\\","native_build":false,"dependencies":["path_provider_windows"],"dev_dependency":false}],"web":[{"name":"camera_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\camera_web-0.3.5\\\\","dependencies":[],"dev_dependency":false},{"name":"flutter_secure_storage_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\flutter_secure_storage_web-1.2.1\\\\","dependencies":[],"dev_dependency":false},{"name":"geolocator_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\geolocator_web-2.2.1\\\\","dependencies":[],"dev_dependency":false},{"name":"image_picker_for_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\image_picker_for_web-3.0.6\\\\","dependencies":[],"dev_dependency":false},{"name":"permission_handler_html","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\permission_handler_html-0.1.3+5\\\\","dependencies":[],"dev_dependency":false},{"name":"shared_preferences_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\shared_preferences_web-2.4.3\\\\","dependencies":[],"dev_dependency":false},{"name":"video_player_web","path":"C:\\\\Users\\\\User\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\video_player_web-2.3.5\\\\","dependencies":[],"dev_dependency":false}]},"dependencyGraph":[{"name":"camera","dependencies":["camera_android","camera_avfoundation","camera_web","flutter_plugin_android_lifecycle"]},{"name":"camera_android","dependencies":["flutter_plugin_android_lifecycle"]},{"name":"camera_avfoundation","dependencies":[]},{"name":"camera_web","dependencies":[]},{"name":"contacts_service","dependencies":[]},{"name":"file_selector_linux","dependencies":[]},{"name":"file_selector_macos","dependencies":[]},{"name":"file_selector_windows","dependencies":[]},{"name":"flutter_local_notifications","dependencies":["flutter_local_notifications_linux"]},{"name":"flutter_local_notifications_linux","dependencies":[]},{"name":"flutter_plugin_android_lifecycle","dependencies":[]},{"name":"flutter_secure_storage","dependencies":["flutter_secure_storage_linux","flutter_secure_storage_macos","flutter_secure_storage_web","flutter_secure_storage_windows"]},{"name":"flutter_secure_storage_linux","dependencies":[]},{"name":"flutter_secure_storage_macos","dependencies":[]},{"name":"flutter_secure_storage_web","dependencies":[]},{"name":"flutter_secure_storage_windows","dependencies":["path_provider"]},{"name":"geolocator","dependencies":["geolocator_android","geolocator_apple","geolocator_web","geolocator_windows"]},{"name":"geolocator_android","dependencies":[]},{"name":"geolocator_apple","dependencies":[]},{"name":"geolocator_web","dependencies":[]},{"name":"geolocator_windows","dependencies":[]},{"name":"image_picker","dependencies":["image_picker_android","image_picker_for_web","image_picker_ios","image_picker_linux","image_picker_macos","image_picker_windows"]},{"name":"image_picker_android","dependencies":["flutter_plugin_android_lifecycle"]},{"name":"image_picker_for_web","dependencies":[]},{"name":"image_picker_ios","dependencies":[]},{"name":"image_picker_linux","dependencies":["file_selector_linux"]},{"name":"image_picker_macos","dependencies":["file_selector_macos"]},{"name":"image_picker_windows","dependencies":["file_selector_windows"]},{"name":"integration_test","dependencies":[]},{"name":"path_provider","dependencies":["path_provider_android","path_provider_foundation","path_provider_linux","path_provider_windows"]},{"name":"path_provider_android","dependencies":[]},{"name":"path_provider_foundation","dependencies":[]},{"name":"path_provider_linux","dependencies":[]},{"name":"path_provider_windows","dependencies":[]},{"name":"permission_handler","dependencies":["permission_handler_android","permission_handler_apple","permission_handler_html","permission_handler_windows"]},{"name":"permission_handler_android","dependencies":[]},{"name":"permission_handler_apple","dependencies":[]},{"name":"permission_handler_html","dependencies":[]},{"name":"permission_handler_windows","dependencies":[]},{"name":"shared_preferences","dependencies":["shared_preferences_android","shared_preferences_foundation","shared_preferences_linux","shared_preferences_web","shared_preferences_windows"]},{"name":"shared_preferences_android","dependencies":[]},{"name":"shared_preferences_foundation","dependencies":[]},{"name":"shared_preferences_linux","dependencies":["path_provider_linux"]},{"name":"shared_preferences_web","dependencies":[]},{"name":"shared_preferences_windows","dependencies":["path_provider_windows"]},{"name":"sqflite","dependencies":["sqflite_android","sqflite_darwin"]},{"name":"sqflite_android","dependencies":[]},{"name":"sqflite_darwin","dependencies":[]},{"name":"video_player","dependencies":["video_player_android","video_player_avfoundation","video_player_web"]},{"name":"video_player_android","dependencies":[]},{"name":"video_player_avfoundation","dependencies":[]},{"name":"video_player_web","dependencies":[]}],"date_created":"2025-06-27 18:05:32.303901","version":"3.32.5","swift_package_manager_enabled":{"ios":false,"macos":false}}
</file>

<file path="backend/alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# file_template = %%Y%%m%%d_%%H%%M_%%%(rev)s_%%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version number format.  This value should be a string
# that is a valid Python format string.
# version_num_format = %04d

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses
# os.pathsep. If this key is omitted entirely, it falls back to the legacy
# behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql+asyncpg://postgres:password@localhost:5432/plant_social_db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="backend/alembic/env.py">
"""Alembic environment configuration."""
import asyncio
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context
# Import all models to ensure they are registered with SQLAlchemy
from app.core.database import Base
from app.models.user import User
from app.models.message import Message
from app.models.story import Story, StoryView
from app.models.friendship import Friendship, FriendshipStatus
from app.models.plant_species import PlantSpecies
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_photo import PlantPhoto
from app.models.plant_identification import PlantIdentification
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_question import PlantQuestion, PlantAnswer
# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config
# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        # Enable vector extension
        context.execute('CREATE EXTENSION IF NOT EXISTS vector;')
        # Run migrations
        context.run_migrations()
def do_run_migrations(connection: Connection) -> None:
    """Run migrations with the given connection."""
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
    )
    with context.begin_transaction():
        # Enable vector extension
        context.execute('CREATE EXTENSION IF NOT EXISTS vector;')
        # Run migrations
        context.run_migrations()
async def run_async_migrations() -> None:
    """Run migrations in async mode."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()
def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    asyncio.run(run_async_migrations())
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="backend/alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade database schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade database schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="backend/app/api/__init__.py">
"""API package initialization."""
</file>

<file path="backend/app/api/api_v1/__init__.py">
"""API v1 package initialization."""
</file>

<file path="backend/app/api/api_v1/api.py">
"""Main API router for version 1.
This module combines all API endpoints into a single router
for the FastAPI application.
"""
from fastapi import APIRouter
from app.api.api_v1.endpoints import (
    auth, messages, stories, friends, users, websocket,
    plant_species, user_plants, plant_care_logs, plant_identification,
    plant_trades, plant_questions, achievements, nurseries, smart_community,
    content_generation, discovery_feed
)
api_router = APIRouter()
# Include all endpoint routers
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(messages.router, prefix="/messages", tags=["messages"])
api_router.include_router(stories.router, prefix="/stories", tags=["stories"])
api_router.include_router(friends.router, prefix="/friends", tags=["friends"])
api_router.include_router(websocket.router, prefix="/ws", tags=["websocket"])
# Plant feature endpoints
api_router.include_router(plant_species.router, prefix="/plant-species", tags=["plant-species"])
api_router.include_router(user_plants.router, prefix="/my-plants", tags=["user-plants"])
api_router.include_router(plant_care_logs.router, prefix="/care-logs", tags=["plant-care"])
api_router.include_router(plant_identification.router, prefix="/plant-id", tags=["plant-identification"])
api_router.include_router(plant_trades.router, prefix="/marketplace", tags=["plant-marketplace"])
api_router.include_router(plant_questions.router, prefix="/plant-qa", tags=["plant-community"])
api_router.include_router(achievements.router, prefix="/achievements", tags=["achievements"])
api_router.include_router(nurseries.router, prefix="/nurseries", tags=["local-nurseries"])
# RAG and AI-powered endpoints
api_router.include_router(smart_community.router, prefix="/smart-community", tags=["smart-community"])
api_router.include_router(content_generation.router, prefix="/content-generation", tags=["content-generation"])
api_router.include_router(discovery_feed.router, prefix="/discovery", tags=["discovery-feed"])
</file>

<file path="backend/app/api/api_v1/endpoints/__init__.py">
"""API v1 endpoints package initialization."""
</file>

<file path="backend/app/api/api_v1/endpoints/auth.py">
"""Authentication endpoints.
This module provides user registration, login, logout,
and authentication management using FastAPI-Users.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.auth import UserCreate, UserRead, UserUpdate, Token
from app.services.auth_service import get_auth_service
from app.services.user_service import get_user_service
from app.models.user import User
router = APIRouter()
async def get_current_user(
    token: str = Depends(OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")),
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
) -> User:
    """Get current authenticated user from JWT token."""
    user = await auth_service.get_current_user(token, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user
@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
async def register(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
    user_service = Depends(get_user_service)
):
    """Register a new user.
    Args:
        user_data: User registration data
        db: Database session
    Returns:
        UserRead: Created user data
    Raises:
        HTTPException: If email or username already exists
    """
    # Check if email already exists
    existing_user = await user_service.get_user_by_email(user_data.email, db)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    # Check if username already exists
    existing_username = await user_service.get_user_by_username(user_data.username, db)
    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    # Create new user
    user = await user_service.create_user(user_data, db)
    return UserRead.from_orm(user)
@router.post("/login", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
):
    """Authenticate user and return access token.
    Args:
        form_data: Login form data (username/email and password)
        db: Database session
    Returns:
        Token: Access and refresh tokens
    Raises:
        HTTPException: If authentication fails
    """
    # Authenticate user (supports both email and username)
    user = await auth_service.authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email/username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    # Create tokens
    access_token = auth_service.create_access_token(data={"sub": str(user.id)})
    refresh_token = auth_service.create_refresh_token(data={"sub": str(user.id)})
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    )
@router.post("/refresh", response_model=Token)
async def refresh_token(
    refresh_token: str,
    db: AsyncSession = Depends(get_db),
    auth_service = Depends(get_auth_service)
):
    """Refresh access token using refresh token.
    Args:
        refresh_token: Valid refresh token
        db: Database session
    Returns:
        Token: New access and refresh tokens
    Raises:
        HTTPException: If refresh token is invalid
    """
    # Verify refresh token
    payload = await auth_service.verify_refresh_token(refresh_token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    user_id = payload.get("sub")
    # Create new tokens
    access_token = auth_service.create_access_token(data={"sub": user_id})
    new_refresh_token = auth_service.create_refresh_token(data={"sub": user_id})
    return Token(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer"
    )
@router.get("/me", response_model=UserRead)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current authenticated user information.
    Args:
        current_user: Current authenticated user
    Returns:
        UserRead: Current user data
    """
    return UserRead.from_orm(current_user)
@router.put("/me", response_model=UserRead)
async def update_current_user(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current authenticated user information.
    Args:
        user_update: User update data
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: Updated user data
    """
    # Update user fields
    update_data = user_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        if hasattr(current_user, field):
            setattr(current_user, field, value)
    # Save changes
    db.add(current_user)
    await db.commit()
    await db.refresh(current_user)
    return UserRead.from_orm(current_user)
@router.post("/logout")
async def logout(
    current_user: User = Depends(get_current_user)
):
    """Logout current user.
    Note: In a stateless JWT system, logout is handled client-side
    by removing the token. This endpoint is for consistency.
    Args:
        current_user: Current authenticated user
    Returns:
        dict: Success message
    """
    return {"message": "Successfully logged out"}
@router.post("/verify-email")
async def verify_email(
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """Verify user email address.
    Args:
        token: Email verification token
        db: Database session
    Returns:
        dict: Success message
    Note: Implementation depends on email service setup
    """
    # TODO: Implement email verification logic
    return {"message": "Email verification not implemented yet"}
@router.post("/forgot-password")
async def forgot_password(
    email: str,
    db: AsyncSession = Depends(get_db)
):
    """Send password reset email.
    Args:
        email: User's email address
        db: Database session
    Returns:
        dict: Success message
    Note: Implementation depends on email service setup
    """
    # TODO: Implement password reset logic
    return {"message": "Password reset not implemented yet"}
</file>

<file path="backend/app/api/api_v1/endpoints/friends.py">
"""Friend management endpoints.
This module provides endpoints for managing friendships,
friend requests, and social connections.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.friendship import FriendshipRead, FriendRequestCreate
from app.schemas.user import UserSearch
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.friendship_service import (
    send_friend_request,
    accept_friend_request,
    decline_friend_request,
    remove_friend,
    block_user,
    unblock_user,
    get_friends_list,
    get_pending_requests,
    get_sent_requests,
    get_blocked_users,
    toggle_close_friend,
    get_close_friends,
    check_friendship_status
)
from app.services.user_service import get_user_by_id
from app.models.user import User
router = APIRouter()
@router.post("/request", status_code=status.HTTP_201_CREATED)
async def send_friend_request_endpoint(
    request_data: FriendRequestCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a friend request to another user.
    Args:
        request_data: Friend request data containing user_id
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found, already friends, or request already sent
    """
    # Check if target user exists
    target_user = await get_user_by_id(db, request_data.user_id)
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # Can't send request to self
    if str(current_user.id) == request_data.user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot send friend request to yourself"
        )
    # Check current friendship status
    status_result = await check_friendship_status(db, current_user.id, request_data.user_id)
    if status_result == "accepted":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Already friends with this user"
        )
    elif status_result == "pending":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Friend request already sent"
        )
    elif status_result == "blocked":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot send friend request to this user"
        )
    # Send friend request
    await send_friend_request(db, current_user.id, request_data.user_id)
    return {"message": f"Friend request sent to {target_user.username}"}
@router.post("/accept/{friendship_id}")
async def accept_friend_request_endpoint(
    friendship_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Accept a friend request.
    Args:
        friendship_id: ID of the friendship/request to accept
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If request not found or not authorized
    """
    success = await accept_friend_request(db, friendship_id, current_user.id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friend request not found or not authorized"
        )
    return {"message": "Friend request accepted"}
@router.post("/decline/{friendship_id}")
async def decline_friend_request_endpoint(
    friendship_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Decline a friend request.
    Args:
        friendship_id: ID of the friendship/request to decline
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If request not found or not authorized
    """
    success = await decline_friend_request(db, friendship_id, current_user.id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friend request not found or not authorized"
        )
    return {"message": "Friend request declined"}
@router.delete("/remove/{user_id}")
async def remove_friend_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Remove a friend (unfriend).
    Args:
        user_id: ID of the user to unfriend
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If not friends or user not found
    """
    success = await remove_friend(db, current_user.id, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Friendship not found"
        )
    return {"message": "Friend removed successfully"}
@router.get("/list", response_model=List[UserSearch])
async def get_friends_list_endpoint(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of current user's friends.
    Args:
        limit: Maximum number of friends to return
        offset: Number of friends to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of friends
    """
    friends = await get_friends_list(db, current_user.id, limit, offset)
    return [UserSearch.from_orm(friend) for friend in friends]
@router.get("/requests/pending", response_model=List[FriendshipRead])
async def get_pending_requests_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get pending friend requests received by current user.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[FriendshipRead]: List of pending friend requests
    """
    requests = await get_pending_requests(db, current_user.id)
    return [FriendshipRead.from_orm(request) for request in requests]
@router.get("/requests/sent", response_model=List[FriendshipRead])
async def get_sent_requests_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get friend requests sent by current user.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[FriendshipRead]: List of sent friend requests
    """
    requests = await get_sent_requests(db, current_user.id)
    return [FriendshipRead.from_orm(request) for request in requests]
@router.post("/block/{user_id}")
async def block_user_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Block a user.
    Args:
        user_id: ID of the user to block
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or trying to block self
    """
    if str(current_user.id) == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot block yourself"
        )
    # Check if target user exists
    target_user = await get_user_by_id(db, user_id)
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    await block_user(db, current_user.id, user_id)
    return {"message": f"User {target_user.username} has been blocked"}
@router.delete("/block/{user_id}")
async def unblock_user_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unblock a user.
    Args:
        user_id: ID of the user to unblock
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or not blocked
    """
    success = await unblock_user(db, current_user.id, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found or not blocked"
        )
    return {"message": "User has been unblocked"}
@router.get("/blocked", response_model=List[UserSearch])
async def get_blocked_users_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of blocked users.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of blocked users
    """
    blocked_users = await get_blocked_users(db, current_user.id)
    return [UserSearch.from_orm(user) for user in blocked_users]
@router.post("/close-friend/{user_id}")
async def toggle_close_friend_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Toggle close friend status for a user.
    Args:
        user_id: ID of the friend to toggle close friend status
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message with new status
    Raises:
        HTTPException: If not friends with the user
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, user_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Can only set close friend status for existing friends"
        )
    is_close_friend = await toggle_close_friend(db, current_user.id, user_id)
    status_text = "added to" if is_close_friend else "removed from"
    return {"message": f"User {status_text} close friends list"}
@router.get("/close-friends", response_model=List[UserSearch])
async def get_close_friends_endpoint(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of close friends.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of close friends
    """
    close_friends = await get_close_friends(db, current_user.id)
    return [UserSearch.from_orm(friend) for friend in close_friends]
@router.get("/status/{user_id}")
async def get_friendship_status(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get friendship status with another user.
    Args:
        user_id: ID of the user to check friendship status with
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Friendship status information
    """
    if str(current_user.id) == user_id:
        return {"status": "self"}
    status_result = await check_friendship_status(db, current_user.id, user_id)
    return {"status": status_result}
@router.get("/mutual/{user_id}")
async def get_mutual_friends(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get mutual friends with another user.
    Args:
        user_id: ID of the user to find mutual friends with
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Mutual friends information
    Note: This is a placeholder implementation.
    In production, you'd implement efficient mutual friends logic.
    """
    # TODO: Implement mutual friends functionality
    return {
        "mutual_friends_count": 0,
        "mutual_friends": []
    }
</file>

<file path="backend/app/api/api_v1/endpoints/messages.py">
"""Message endpoints.
This module provides endpoints for sending, receiving, and managing
messages in the real-time messaging system.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.message import MessageCreate, MessageRead, MessageUpdate
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.message_service import (
    create_message,
    get_conversation_messages,
    get_user_conversations,
    mark_message_as_read,
    delete_message,
    get_message_by_id
)
from app.services.friendship_service import check_friendship_status
from app.services.file_service import upload_media_file
from app.models.user import User
from app.schemas.message import MessageType
router = APIRouter()
@router.post("/", response_model=MessageRead, status_code=status.HTTP_201_CREATED)
async def send_message(
    message_data: MessageCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a new message.
    Args:
        message_data: Message creation data
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Created message
    Raises:
        HTTPException: If recipient not found or not friends
    """
    # Check if users are friends (required for messaging)
    friendship_status = await check_friendship_status(db, current_user.id, message_data.recipient_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only send messages to friends"
        )
    # Create message
    message = await create_message(db, current_user.id, message_data)
    return MessageRead.from_orm(message)
@router.post("/media", response_model=MessageRead, status_code=status.HTTP_201_CREATED)
async def send_media_message(
    recipient_id: str,
    file: UploadFile = File(...),
    caption: Optional[str] = None,
    disappears_at: Optional[int] = None,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a media message (image, video, audio).
    Args:
        recipient_id: ID of the message recipient
        file: Media file to upload
        caption: Optional caption for the media
        disappears_at: Optional timestamp when message should disappear
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Created message with media
    Raises:
        HTTPException: If file upload fails or users not friends
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, recipient_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only send messages to friends"
        )
    # Upload media file
    try:
        media_url, file_size, duration = await upload_media_file(file)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to upload media: {str(e)}"
        )
    # Determine message type based on file type
    content_type = file.content_type or ""
    if content_type.startswith("image/"):
        message_type = MessageType.IMAGE
    elif content_type.startswith("video/"):
        message_type = MessageType.VIDEO
    elif content_type.startswith("audio/"):
        message_type = MessageType.AUDIO
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unsupported media type"
        )
    # Create message data
    message_data = MessageCreate(
        recipient_id=recipient_id,
        content_type=message_type,
        media_url=media_url,
        caption=caption,
        file_size=file_size,
        duration=duration,
        disappears_at=disappears_at
    )
    # Create message
    message = await create_message(db, current_user.id, message_data)
    return MessageRead.from_orm(message)
@router.get("/conversations", response_model=List[dict])
async def get_conversations(
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's conversations with latest message preview.
    Args:
        limit: Maximum number of conversations to return
        offset: Number of conversations to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[dict]: List of conversations with latest messages
    """
    conversations = await get_user_conversations(db, current_user.id, limit, offset)
    return conversations
@router.get("/conversation/{user_id}", response_model=List[MessageRead])
async def get_conversation(
    user_id: str,
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get messages in a conversation with another user.
    Args:
        user_id: ID of the other user in the conversation
        limit: Maximum number of messages to return
        offset: Number of messages to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[MessageRead]: List of messages in the conversation
    Raises:
        HTTPException: If users are not friends
    """
    # Check if users are friends
    friendship_status = await check_friendship_status(db, current_user.id, user_id)
    if friendship_status != "accepted":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only view conversations with friends"
        )
    messages = await get_conversation_messages(db, current_user.id, user_id, limit, offset)
    return [MessageRead.from_orm(message) for message in messages]
@router.put("/{message_id}/read")
async def mark_as_read(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Mark a message as read.
    Args:
        message_id: ID of the message to mark as read
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is the recipient
    if str(message.recipient_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only mark own messages as read"
        )
    await mark_message_as_read(db, message_id)
    return {"message": "Message marked as read"}
@router.delete("/{message_id}")
async def delete_message_endpoint(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a message.
    Args:
        message_id: ID of the message to delete
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is the sender
    if str(message.sender_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Can only delete own messages"
        )
    await delete_message(db, message_id)
    return {"message": "Message deleted successfully"}
@router.get("/{message_id}", response_model=MessageRead)
async def get_message(
    message_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific message by ID.
    Args:
        message_id: ID of the message to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        MessageRead: Message data
    Raises:
        HTTPException: If message not found or unauthorized
    """
    message = await get_message_by_id(db, message_id)
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    # Check if current user is sender or recipient
    if str(current_user.id) not in [str(message.sender_id), str(message.recipient_id)]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view this message"
        )
    return MessageRead.from_orm(message)
@router.get("/search/{query}")
async def search_messages(
    query: str,
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Search messages by content.
    Args:
        query: Search query string
        limit: Maximum number of results to return
        offset: Number of results to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[MessageRead]: List of matching messages
    Note: This is a basic implementation. In production,
    you might want to use full-text search capabilities.
    """
    # TODO: Implement message search functionality
    return []
</file>

<file path="backend/app/api/api_v1/endpoints/plant_care_logs.py">
"""Plant care logs API endpoints.
This module provides REST API endpoints for managing plant care logs.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime, date
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_care_log import (
    PlantCareLogCreate,
    PlantCareLogUpdate,
    PlantCareLogResponse,
    PlantCareLogListResponse,
    CareTypeStatsResponse
)
from app.services.plant_care_log_service import (
    create_care_log,
    get_care_log_by_id,
    get_plant_care_logs,
    get_user_care_logs,
    update_care_log,
    delete_care_log,
    get_care_statistics
)
from app.services.personalized_plant_care_service import PersonalizedPlantCareService
from app.services.vector_database_service import VectorDatabaseService
from app.services.embedding_service import EmbeddingService
router = APIRouter()
# Initialize services
plant_care_service = PlantCareLogService()
embedding_service = EmbeddingService()
vector_service = VectorDatabaseService(embedding_service)
personalized_care_service = PersonalizedPlantCareService(vector_service, embedding_service)
@router.post(
    "/",
    response_model=PlantCareLogResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create care log",
    description="Create a new plant care log entry."
)
async def create_plant_care_log(
    care_log_data: PlantCareLogCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Create a new plant care log."""
    try:
        care_log = await create_care_log(db, current_user.id, care_log_data)
        return PlantCareLogResponse.from_orm(care_log)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create care log"
        )
@router.get(
    "/",
    response_model=PlantCareLogListResponse,
    summary="Get user's care logs",
    description="Get all care logs for the current user."
)
async def get_my_care_logs(
    plant_id: Optional[UUID] = Query(None, description="Filter by plant ID"),
    care_type: Optional[str] = Query(None, description="Filter by care type"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogListResponse:
    """Get user's care logs with optional filters."""
    try:
        care_logs, total = await get_user_care_logs(
            db, current_user.id, plant_id, care_type, start_date, end_date, skip, limit
        )
        return PlantCareLogListResponse(
            care_logs=[PlantCareLogResponse.from_orm(log) for log in care_logs],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care logs"
        )
@router.get(
    "/plant/{plant_id}",
    response_model=PlantCareLogListResponse,
    summary="Get plant care logs",
    description="Get all care logs for a specific plant."
)
async def get_plant_logs(
    plant_id: UUID,
    care_type: Optional[str] = Query(None, description="Filter by care type"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogListResponse:
    """Get care logs for a specific plant."""
    try:
        care_logs, total = await get_plant_care_logs(
            db, plant_id, current_user.id, care_type, start_date, end_date, skip, limit
        )
        return PlantCareLogListResponse(
            care_logs=[PlantCareLogResponse.from_orm(log) for log in care_logs],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plant care logs"
        )
@router.get(
    "/stats",
    response_model=List[CareTypeStatsResponse],
    summary="Get care statistics",
    description="Get care statistics for the current user."
)
async def get_my_care_stats(
    plant_id: Optional[UUID] = Query(None, description="Filter by plant ID"),
    start_date: Optional[date] = Query(None, description="Filter from this date"),
    end_date: Optional[date] = Query(None, description="Filter until this date"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[CareTypeStatsResponse]:
    """Get care statistics for the current user."""
    try:
        stats = await get_care_statistics(
            db, current_user.id, plant_id, start_date, end_date
        )
        return [CareTypeStatsResponse(**stat) for stat in stats]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care statistics"
        )
@router.get(
    "/{care_log_id}",
    response_model=PlantCareLogResponse,
    summary="Get care log details",
    description="Get details of a specific care log."
)
async def get_care_log(
    care_log_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Get care log by ID."""
    care_log = await get_care_log_by_id(db, care_log_id, current_user.id)
    if not care_log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Care log not found"
        )
    return PlantCareLogResponse.from_orm(care_log)
@router.put(
    "/{care_log_id}",
    response_model=PlantCareLogResponse,
    summary="Update care log",
    description="Update a care log entry."
)
async def update_plant_care_log(
    care_log_id: UUID,
    care_log_data: PlantCareLogUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantCareLogResponse:
    """Update care log."""
    try:
        care_log = await update_care_log(db, care_log_id, current_user.id, care_log_data)
        if not care_log:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Care log not found"
            )
        return PlantCareLogResponse.from_orm(care_log)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update care log"
        )
@router.delete(
    "/{care_log_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete care log",
    description="Delete a care log entry."
)
async def delete_plant_care_log(
    care_log_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete care log."""
    try:
        success = await delete_care_log(db, care_log_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Care log not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete care log"
        )
# Bulk operations
@router.post(
    "/bulk",
    response_model=List[PlantCareLogResponse],
    status_code=status.HTTP_201_CREATED,
    summary="Create multiple care logs",
    description="Create multiple care log entries at once."
)
async def create_bulk_care_logs(
    care_logs_data: List[PlantCareLogCreate],
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[PlantCareLogResponse]:
    """Create multiple care logs."""
    if len(care_logs_data) > 50:  # Limit bulk operations
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot create more than 50 care logs at once"
        )
    try:
        created_logs = []
        for care_log_data in care_logs_data:
            care_log = await create_care_log(db, current_user.id, care_log_data)
            created_logs.append(care_log)
        return [PlantCareLogResponse.from_orm(log) for log in created_logs]
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create care logs"
        )
# Personalized Plant Care Endpoints
@router.get("/personalized/{user_id}/{plant_id}/care-schedule")
async def get_personalized_care_schedule(
    user_id: str,
    plant_id: str,
    db: AsyncSession = Depends(get_db)
):
    """Get personalized care schedule for a specific plant."""
    try:
        schedule = await personalized_care_service.get_personalized_care_schedule(
            db=db,
            user_id=user_id,
            plant_id=plant_id
        )
        return schedule
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating care schedule: {str(e)}"
        )
@router.get("/personalized/{user_id}/{plant_id}/health-prediction")
async def get_plant_health_prediction(
    user_id: str,
    plant_id: str,
    db: AsyncSession = Depends(get_db)
):
    """Get plant health prediction based on care patterns."""
    try:
        prediction = await personalized_care_service.predict_plant_health(
            db=db,
            user_id=user_id,
            plant_id=plant_id
        )
        return prediction
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error predicting plant health: {str(e)}"
        )
@router.get("/personalized/{user_id}/care-patterns")
async def analyze_user_care_patterns(
    user_id: str,
    db: AsyncSession = Depends(get_db)
):
    """Analyze user's plant care patterns."""
    try:
        patterns = await personalized_care_service.analyze_care_patterns(
            db=db,
            user_id=user_id
        )
        return patterns
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error analyzing care patterns: {str(e)}"
        )
@router.post("/personalized/{user_id}/{plant_id}/care-advice")
async def get_personalized_care_advice(
    user_id: str,
    plant_id: str,
    question: str,
    db: AsyncSession = Depends(get_db)
):
    """Get personalized plant care advice."""
    try:
        advice = await personalized_care_service.get_personalized_care_advice(
            db=db,
            user_id=user_id,
            plant_id=plant_id,
            question=question
        )
        return advice
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating care advice: {str(e)}"
        )
@router.get("/personalized/{user_id}/seasonal-recommendations")
async def get_seasonal_recommendations(
    user_id: str,
    db: AsyncSession = Depends(get_db)
):
    """Get seasonal care recommendations for all user's plants."""
    try:
        recommendations = await personalized_care_service.get_seasonal_recommendations(
            db=db,
            user_id=user_id
        )
        return recommendations
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating seasonal recommendations: {str(e)}"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/plant_identification.py">
"""Plant identification API endpoints.
This module provides REST API endpoints for AI-powered plant identification.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, Query, UploadFile, File, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_identification import (
    PlantIdentificationCreate,
    PlantIdentificationUpdate,
    PlantIdentificationResponse,
    PlantIdentificationListResponse,
    PlantIdentificationResultResponse
)
from app.services.plant_identification_service import (
    create_identification,
    get_identification_by_id,
    get_user_identifications,
    update_identification,
    delete_identification,
    verify_identification,
    get_pending_verifications,
    get_identification_statistics
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantIdentificationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create plant identification",
    description="Submit a plant image for AI identification."
)
async def create_plant_identification(
    identification_data: PlantIdentificationCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Create a new plant identification request."""
    try:
        identification = await create_identification(db, current_user.id, identification_data)
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create identification"
        )
@router.post(
    "/upload",
    response_model=PlantIdentificationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload and identify plant",
    description="Upload a plant image and get AI identification results."
)
async def upload_and_identify(
    file: UploadFile = File(..., description="Plant image file"),
    location: Optional[str] = Query(None, description="Location where photo was taken"),
    notes: Optional[str] = Query(None, description="Additional notes about the plant"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Upload image and create identification request."""
    # Validate file type
    if not file.content_type or not file.content_type.startswith('image/'):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be an image"
        )
    # Validate file size (e.g., max 10MB)
    max_size = 10 * 1024 * 1024  # 10MB
    if file.size and file.size > max_size:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File size too large. Maximum size is 10MB"
        )
    try:
        # In a real implementation, you would:
        # 1. Save the uploaded file to storage (S3, local filesystem, etc.)
        # 2. Call an AI service for plant identification
        # 3. Process the results
        # For now, we'll create a placeholder identification
        # TODO: Implement actual file upload and AI identification
        image_url = f"https://example.com/uploads/{file.filename}"  # Placeholder
        identification_data = PlantIdentificationCreate(
            image_url=image_url,
            location=location,
            notes=notes,
            confidence_score=0.85,  # Placeholder
            identified_species_id=None,  # Would be set by AI service
            ai_suggestions=[
                {
                    "species_name": "Unknown Species",
                    "confidence": 0.85,
                    "scientific_name": "Species unknown"
                }
            ]
        )
        identification = await create_identification(db, current_user.id, identification_data)
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to process identification"
        )
@router.get(
    "/",
    response_model=PlantIdentificationListResponse,
    summary="Get user's identifications",
    description="Get all plant identifications for the current user."
)
async def get_my_identifications(
    status_filter: Optional[str] = Query(None, description="Filter by status (pending, completed, failed)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationListResponse:
    """Get user's plant identifications."""
    try:
        identifications, total = await get_user_identifications(
            db, current_user.id, status_filter, skip, limit
        )
        return PlantIdentificationListResponse(
            identifications=[PlantIdentificationResponse.from_orm(ident) for ident in identifications],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get identifications"
        )
@router.get(
    "/pending",
    response_model=PlantIdentificationListResponse,
    summary="Get pending verifications",
    description="Get plant identifications pending expert verification (admin only)."
)
async def get_pending_identification_verifications(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationListResponse:
    """Get pending identifications for verification (admin only)."""
    # TODO: Add admin role check
    # if not current_user.is_admin:
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Admin access required"
    #     )
    try:
        identifications, total = await get_pending_verifications(db, skip, limit)
        return PlantIdentificationListResponse(
            identifications=[PlantIdentificationResponse.from_orm(ident) for ident in identifications],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get pending verifications"
        )
@router.get(
    "/stats",
    summary="Get identification statistics",
    description="Get statistics about plant identifications."
)
async def get_identification_statistics(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Get identification statistics for the current user."""
    try:
        stats = await get_identification_statistics(db, current_user.id)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get identification statistics"
        )
@router.get(
    "/{identification_id}",
    response_model=PlantIdentificationResponse,
    summary="Get identification details",
    description="Get details of a specific plant identification."
)
async def get_identification(
    identification_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Get identification by ID."""
    identification = await get_identification_by_id(db, identification_id, current_user.id)
    if not identification:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Identification not found"
        )
    return PlantIdentificationResponse.from_orm(identification)
@router.put(
    "/{identification_id}",
    response_model=PlantIdentificationResponse,
    summary="Update identification",
    description="Update plant identification information."
)
async def update_plant_identification(
    identification_id: UUID,
    identification_data: PlantIdentificationUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Update plant identification."""
    try:
        identification = await update_identification(
            db, identification_id, current_user.id, identification_data
        )
        if not identification:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update identification"
        )
@router.post(
    "/{identification_id}/verify",
    response_model=PlantIdentificationResponse,
    summary="Verify identification",
    description="Verify or correct a plant identification (expert/admin only)."
)
async def verify_plant_identification(
    identification_id: UUID,
    verified_species_id: Optional[UUID] = Query(None, description="Correct species ID if different from AI suggestion"),
    verification_notes: Optional[str] = Query(None, description="Verification notes"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantIdentificationResponse:
    """Verify plant identification (expert/admin only)."""
    # TODO: Add expert/admin role check
    # if not (current_user.is_expert or current_user.is_admin):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Expert or admin access required"
    #     )
    try:
        identification = await verify_identification(
            db, identification_id, current_user.id, verified_species_id, verification_notes
        )
        if not identification:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
        return PlantIdentificationResponse.from_orm(identification)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to verify identification"
        )
@router.delete(
    "/{identification_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete identification",
    description="Delete a plant identification."
)
async def delete_plant_identification(
    identification_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete plant identification."""
    try:
        success = await delete_identification(db, identification_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Identification not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete identification"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/plant_questions.py">
"""Plant questions and answers API endpoints.
This module provides REST API endpoints for the plant Q&A community.
"""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_question import (
    PlantQuestionCreate,
    PlantQuestionUpdate,
    PlantAnswerCreate,
    PlantAnswerUpdate,
    PlantQuestionResponse,
    PlantAnswerResponse,
    PlantQuestionListResponse,
    PlantQuestionSearchRequest,
    PlantAnswerVoteRequest
)
from app.services.plant_question_service import (
    get_plant_question_service,
    get_plant_answer_service
)
router = APIRouter()
# Question endpoints
@router.post(
    "/",
    response_model=PlantQuestionResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Ask a question",
    description="Ask a new plant-related question."
)
async def create_question(
    question_data: PlantQuestionCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionResponse:
    """Create a new plant question."""
    try:
        question_service = get_plant_question_service()
        question = await question_service.create_question(db, current_user.id, question_data)
        return PlantQuestionResponse.from_orm(question)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create question"
        )
@router.get(
    "/",
    response_model=PlantQuestionListResponse,
    summary="Search questions",
    description="Search and browse plant questions."
)
async def search_questions(
    query: Optional[str] = Query(None, description="Search query"),
    category: Optional[str] = Query(None, description="Filter by category"),
    species_id: Optional[UUID] = Query(None, description="Filter by plant species"),
    is_solved: Optional[bool] = Query(None, description="Filter by solved status"),
    sort_by: Optional[str] = Query("created_at", description="Sort by field (created_at, votes, answers)"),
    sort_order: Optional[str] = Query("desc", description="Sort order (asc, desc)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantQuestionListResponse:
    """Search plant questions."""
    try:
        search_request = PlantQuestionSearchRequest(
            query=query,
            category=category,
            species_id=species_id,
            is_solved=is_solved,
            sort_by=sort_by,
            sort_order=sort_order
        )
        question_service = get_plant_question_service()
        questions, total = await question_service.search_questions(db, search_request, skip, limit)
        return PlantQuestionListResponse(
            questions=[PlantQuestionResponse.from_orm(q) for q in questions],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search questions"
        )
@router.get(
    "/my-questions",
    response_model=PlantQuestionListResponse,
    summary="Get user's questions",
    description="Get all questions asked by the current user."
)
async def get_my_questions(
    is_solved: Optional[bool] = Query(None, description="Filter by solved status"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionListResponse:
    """Get user's questions."""
    try:
        question_service = get_plant_question_service()
        questions, total = await question_service.get_user_questions(
            db, current_user.id, is_solved, skip, limit
        )
        return PlantQuestionListResponse(
            questions=[PlantQuestionResponse.from_orm(q) for q in questions],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user questions"
        )
@router.get(
    "/{question_id}",
    response_model=PlantQuestionResponse,
    summary="Get question details",
    description="Get details of a specific question with its answers."
)
async def get_question(
    question_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantQuestionResponse:
    """Get question by ID."""
    question_service = get_plant_question_service()
    question = await question_service.get_question_by_id(db, question_id)
    if not question:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Question not found"
        )
    return PlantQuestionResponse.from_orm(question)
@router.put(
    "/{question_id}",
    response_model=PlantQuestionResponse,
    summary="Update question",
    description="Update a question (author only)."
)
async def update_question(
    question_id: UUID,
    question_data: PlantQuestionUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantQuestionResponse:
    """Update question."""
    try:
        question_service = get_plant_question_service()
        question = await question_service.update_question(
            db, question_id, current_user.id, question_data
        )
        if not question:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
        return PlantQuestionResponse.from_orm(question)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update question"
        )
@router.post(
    "/{question_id}/solve",
    summary="Mark question as solved",
    description="Mark a question as solved (author only)."
)
async def mark_question_solved(
    question_id: UUID,
    best_answer_id: Optional[UUID] = Query(None, description="ID of the best answer"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Mark question as solved."""
    try:
        question_service = get_plant_question_service()
        success = await question_service.mark_as_solved(
            db, question_id, current_user.id, best_answer_id
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
        return {
            "message": "Question marked as solved",
            "question_id": question_id,
            "best_answer_id": best_answer_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to mark question as solved"
        )
@router.delete(
    "/{question_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete question",
    description="Delete a question (author only)."
)
async def delete_question(
    question_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete question."""
    try:
        question_service = get_plant_question_service()
        success = await question_service.delete_question(db, question_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Question not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete question"
        )
# Answer endpoints
@router.post(
    "/{question_id}/answers",
    response_model=PlantAnswerResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Answer a question",
    description="Provide an answer to a plant question."
)
async def create_answer(
    question_id: UUID,
    answer_data: PlantAnswerCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantAnswerResponse:
    """Create an answer to a question."""
    try:
        answer_service = get_plant_answer_service()
        answer = await answer_service.create_answer(db, question_id, current_user.id, answer_data)
        return PlantAnswerResponse.from_orm(answer)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create answer"
        )
@router.get(
    "/{question_id}/answers",
    response_model=List[PlantAnswerResponse],
    summary="Get question answers",
    description="Get all answers for a specific question."
)
async def get_question_answers(
    question_id: UUID,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(50, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> List[PlantAnswerResponse]:
    """Get answers for a question."""
    try:
        answer_service = get_plant_answer_service()
        answers = await answer_service.get_question_answers(db, question_id, skip, limit)
        return [PlantAnswerResponse.from_orm(answer) for answer in answers]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get answers"
        )
@router.put(
    "/answers/{answer_id}",
    response_model=PlantAnswerResponse,
    summary="Update answer",
    description="Update an answer (author only)."
)
async def update_answer(
    answer_id: UUID,
    answer_data: PlantAnswerUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantAnswerResponse:
    """Update answer."""
    try:
        answer_service = get_plant_answer_service()
        answer = await answer_service.update_answer(db, answer_id, current_user.id, answer_data)
        if not answer:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found or access denied"
            )
        return PlantAnswerResponse.from_orm(answer)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update answer"
        )
@router.post(
    "/answers/{answer_id}/vote",
    summary="Vote on answer",
    description="Vote on an answer (upvote or downvote)."
)
async def vote_on_answer(
    answer_id: UUID,
    vote_data: PlantAnswerVoteRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Vote on an answer."""
    try:
        answer_service = get_plant_answer_service()
        success = await answer_service.vote_answer(
            db, answer_id, current_user.id, vote_data.is_upvote
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found"
            )
        return {
            "message": f"{'Upvoted' if vote_data.is_upvote else 'Downvoted'} successfully",
            "answer_id": answer_id,
            "is_upvote": vote_data.is_upvote
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to vote on answer"
        )
@router.delete(
    "/answers/{answer_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete answer",
    description="Delete an answer (author only)."
)
async def delete_answer(
    answer_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete answer."""
    try:
        answer_service = get_plant_answer_service()
        success = await answer_service.delete_answer(db, answer_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Answer not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete answer"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/plant_species.py">
"""Plant species API endpoints.
This module provides REST API endpoints for managing plant species data.
"""
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_species import (
    PlantSpeciesCreate,
    PlantSpeciesUpdate,
    PlantSpeciesResponse,
    PlantSpeciesListResponse
)
from app.services.plant_species_service import (
    create_species,
    get_species_by_id,
    get_species_by_scientific_name,
    search_species,
    update_species,
    delete_species,
    get_popular_species
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantSpeciesResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create plant species",
    description="Create a new plant species. Requires authentication."
)
async def create_plant_species(
    species_data: PlantSpeciesCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantSpeciesResponse:
    """Create a new plant species."""
    try:
        species = await create_species(db, species_data)
        return PlantSpeciesResponse.from_orm(species)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create plant species"
        )
@router.get(
    "/search",
    response_model=PlantSpeciesListResponse,
    summary="Search plant species",
    description="Search plant species by name, care requirements, or other criteria."
)
async def search_plant_species(
    query: Optional[str] = Query(None, description="Search query for species name"),
    care_level: Optional[str] = Query(None, description="Filter by care level"),
    light_requirements: Optional[str] = Query(None, description="Filter by light requirements"),
    water_frequency_days: Optional[int] = Query(None, description="Filter by watering frequency"),
    is_toxic: Optional[bool] = Query(None, description="Filter by toxicity"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesListResponse:
    """Search plant species with filters."""
    try:
        filters = {}
        if care_level:
            filters["care_level"] = care_level
        if light_requirements:
            filters["light_requirements"] = light_requirements
        if water_frequency_days:
            filters["water_frequency_days"] = water_frequency_days
        if is_toxic is not None:
            filters["is_toxic"] = is_toxic
        species_list, total = await search_species(db, query, filters, skip, limit)
        return PlantSpeciesListResponse(
            species=[PlantSpeciesResponse.from_orm(species) for species in species_list],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search plant species"
        )
@router.get(
    "/popular",
    response_model=PlantSpeciesListResponse,
    summary="Get popular plant species",
    description="Get the most popular plant species based on user plants."
)
async def get_popular_plant_species(
    limit: int = Query(10, ge=1, le=50, description="Maximum number of species to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesListResponse:
    """Get popular plant species."""
    try:
        species_list = await get_popular_species(db, limit)
        return PlantSpeciesListResponse(
            species=[PlantSpeciesResponse.from_orm(species) for species in species_list],
            total=len(species_list),
            skip=0,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get popular plant species"
        )
@router.get(
    "/scientific-name/{scientific_name}",
    response_model=PlantSpeciesResponse,
    summary="Get species by scientific name",
    description="Get plant species by scientific name."
)
async def get_species_by_scientific_name_endpoint(
    scientific_name: str,
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesResponse:
    """Get plant species by scientific name."""
    species = await get_species_by_scientific_name(db, scientific_name)
    if not species:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant species not found"
        )
    return PlantSpeciesResponse.from_orm(species)
@router.get(
    "/{species_id}",
    response_model=PlantSpeciesResponse,
    summary="Get plant species by ID",
    description="Get plant species details by ID."
)
async def get_plant_species(
    species_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantSpeciesResponse:
    """Get plant species by ID."""
    species = await get_species_by_id(db, species_id)
    if not species:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant species not found"
        )
    return PlantSpeciesResponse.from_orm(species)
@router.put(
    "/{species_id}",
    response_model=PlantSpeciesResponse,
    summary="Update plant species",
    description="Update plant species information. Requires authentication."
)
async def update_plant_species(
    species_id: UUID,
    species_data: PlantSpeciesUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantSpeciesResponse:
    """Update plant species."""
    try:
        species = await update_species(db, species_id, species_data)
        if not species:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant species not found"
            )
        return PlantSpeciesResponse.from_orm(species)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update plant species"
        )
@router.delete(
    "/{species_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete plant species",
    description="Delete plant species. Requires authentication."
)
async def delete_plant_species(
    species_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete plant species."""
    try:
        success = await delete_species(db, species_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant species not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete plant species"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/plant_trades.py">
"""Plant trades API endpoints.
This module provides REST API endpoints for the plant trading marketplace.
"""
from typing import List, Optional
from uuid import UUID
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.plant_trade import (
    PlantTradeCreate,
    PlantTradeUpdate,
    PlantTradeResponse,
    PlantTradeListResponse,
    PlantTradeSearchRequest,
    PlantTradeInterestRequest
)
from app.services.plant_trade_service import (
    create_trade,
    get_trade_by_id,
    search_trades,
    get_user_trades,
    update_trade,
    express_interest,
    accept_trade,
    cancel_trade,
    delete_trade,
    get_trade_stats,
    get_popular_trade_species
)
router = APIRouter()
@router.post(
    "/",
    response_model=PlantTradeResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create trade listing",
    description="Create a new plant trade listing."
)
async def create_trade_listing(
    trade_data: PlantTradeCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeResponse:
    """Create a new plant trade listing."""
    try:
        trade = await create_trade(db, current_user.id, trade_data)
        return PlantTradeResponse.from_orm(trade)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create trade listing"
        )
@router.get(
    "/",
    response_model=PlantTradeListResponse,
    summary="Search trade listings",
    description="Search and browse plant trade listings."
)
async def search_trade_listings(
    trade_type: Optional[str] = Query(None, description="Filter by trade type (sell, trade, giveaway)"),
    species_id: Optional[UUID] = Query(None, description="Filter by plant species"),
    location: Optional[str] = Query(None, description="Filter by location"),
    min_price: Optional[Decimal] = Query(None, description="Minimum price filter"),
    max_price: Optional[Decimal] = Query(None, description="Maximum price filter"),
    is_available: Optional[bool] = Query(True, description="Filter by availability"),
    sort_by: Optional[str] = Query("created_at", description="Sort by field (created_at, price, title)"),
    sort_order: Optional[str] = Query("desc", description="Sort order (asc, desc)"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> PlantTradeListResponse:
    """Search plant trade listings."""
    try:
        search_request = PlantTradeSearchRequest(
            trade_type=trade_type,
            species_id=species_id,
            location=location,
            min_price=min_price,
            max_price=max_price,
            is_available=is_available,
            sort_by=sort_by,
            sort_order=sort_order
        )
        trades, total = await search_trades(db, search_request, skip, limit)
        return PlantTradeListResponse(
            trades=[PlantTradeResponse.from_orm(trade) for trade in trades],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to search trade listings"
        )
@router.get(
    "/my-trades",
    response_model=PlantTradeListResponse,
    summary="Get user's trade listings",
    description="Get all trade listings created by the current user."
)
async def get_my_trades(
    is_available: Optional[bool] = Query(None, description="Filter by availability"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeListResponse:
    """Get user's trade listings."""
    try:
        trades, total = await get_user_trades(db, current_user.id, is_available, skip, limit)
        return PlantTradeListResponse(
            trades=[PlantTradeResponse.from_orm(trade) for trade in trades],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user trades"
        )
@router.get(
    "/stats",
    summary="Get trade statistics",
    description="Get marketplace statistics."
)
async def get_marketplace_stats(
    db: AsyncSession = Depends(get_db)
) -> dict:
    """Get marketplace statistics."""
    try:
        stats = await get_trade_stats(db)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get trade statistics"
        )
@router.get(
    "/popular-species",
    summary="Get popular trade species",
    description="Get most popular plant species in trades."
)
async def get_popular_species(
    limit: int = Query(10, ge=1, le=50, description="Maximum number of species to return"),
    db: AsyncSession = Depends(get_db)
) -> List[dict]:
    """Get popular species in trades."""
    try:
        popular_species = await get_popular_trade_species(db, limit)
        return popular_species
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get popular species"
        )
@router.get(
    "/{trade_id}",
    response_model=PlantTradeResponse,
    summary="Get trade details",
    description="Get details of a specific trade listing."
)
async def get_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> PlantTradeResponse:
    """Get trade listing by ID."""
    trade = await get_trade_by_id(db, trade_id)
    if not trade:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Trade listing not found"
        )
    return PlantTradeResponse.from_orm(trade)
@router.put(
    "/{trade_id}",
    response_model=PlantTradeResponse,
    summary="Update trade listing",
    description="Update a trade listing (owner only)."
)
async def update_trade_listing(
    trade_id: UUID,
    trade_data: PlantTradeUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> PlantTradeResponse:
    """Update trade listing."""
    try:
        trade = await update_trade(db, trade_id, current_user.id, trade_data)
        if not trade:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return PlantTradeResponse.from_orm(trade)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update trade listing"
        )
@router.post(
    "/{trade_id}/interest",
    summary="Express interest",
    description="Express interest in a trade listing."
)
async def express_trade_interest(
    trade_id: UUID,
    interest_data: PlantTradeInterestRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Express interest in a trade listing."""
    try:
        success = await express_interest(
            db, trade_id, current_user.id, interest_data.message, interest_data.offered_plant_id
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or not available"
            )
        return {
            "message": "Interest expressed successfully",
            "trade_id": trade_id,
            "user_id": current_user.id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to express interest"
        )
@router.post(
    "/{trade_id}/accept",
    summary="Accept trade",
    description="Accept a trade offer (owner only)."
)
async def accept_trade_offer(
    trade_id: UUID,
    interested_user_id: UUID = Query(..., description="ID of the user whose offer to accept"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Accept a trade offer."""
    try:
        success = await accept_trade(db, trade_id, current_user.id, interested_user_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return {
            "message": "Trade accepted successfully",
            "trade_id": trade_id,
            "accepted_user_id": interested_user_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to accept trade"
        )
@router.post(
    "/{trade_id}/cancel",
    summary="Cancel trade",
    description="Cancel a trade listing (owner only)."
)
async def cancel_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Cancel trade listing."""
    try:
        success = await cancel_trade(db, trade_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
        return {
            "message": "Trade cancelled successfully",
            "trade_id": trade_id
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to cancel trade"
        )
@router.delete(
    "/{trade_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete trade listing",
    description="Delete a trade listing (owner only)."
)
async def delete_trade_listing(
    trade_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete trade listing."""
    try:
        success = await delete_trade(db, trade_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Trade listing not found or access denied"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete trade listing"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/stories.py">
"""Story endpoints.
This module provides endpoints for creating, viewing, and managing
ephemeral stories that disappear after 24 hours.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.story import StoryCreate, StoryRead, StoryViewCreate
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.story_service import (
    create_story,
    get_user_stories,
    get_friends_stories,
    get_story_by_id,
    view_story,
    delete_story,
    get_story_views
)
from app.services.file_service import upload_media_file
from app.models.user import User
from app.schemas.story import StoryType
router = APIRouter()
@router.post("/", response_model=StoryRead, status_code=status.HTTP_201_CREATED)
async def create_story_endpoint(
    file: UploadFile = File(...),
    caption: Optional[str] = None,
    privacy_level: str = "friends",
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new story.
    Args:
        file: Media file for the story (image or video)
        caption: Optional caption for the story
        privacy_level: Privacy level (public, friends, close_friends)
        current_user: Current authenticated user
        db: Database session
    Returns:
        StoryRead: Created story
    Raises:
        HTTPException: If file upload fails or invalid privacy level
    """
    # Validate privacy level
    valid_privacy_levels = ["public", "friends", "close_friends"]
    if privacy_level not in valid_privacy_levels:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid privacy level. Must be one of: {valid_privacy_levels}"
        )
    # Upload media file
    try:
        media_url, file_size, duration = await upload_media_file(file)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to upload media: {str(e)}"
        )
    # Determine story type based on file type
    content_type = file.content_type or ""
    if content_type.startswith("image/"):
        story_type = StoryType.IMAGE
    elif content_type.startswith("video/"):
        story_type = StoryType.VIDEO
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unsupported media type. Only images and videos are allowed."
        )
    # Create story data
    story_data = StoryCreate(
        content_type=story_type,
        media_url=media_url,
        caption=caption,
        file_size=file_size,
        duration=duration,
        privacy_level=privacy_level
    )
    # Create story
    story = await create_story(db, current_user.id, story_data)
    return StoryRead.from_orm(story)
@router.get("/feed", response_model=List[StoryRead])
async def get_stories_feed(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get stories feed from friends.
    Args:
        limit: Maximum number of stories to return
        offset: Number of stories to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of stories from friends
    """
    stories = await get_friends_stories(db, current_user.id, limit, offset)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/user/{user_id}", response_model=List[StoryRead])
async def get_user_stories_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get stories from a specific user.
    Args:
        user_id: ID of the user whose stories to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of user's stories
    Note: Only returns stories that the current user is allowed to see
    based on privacy settings and friendship status.
    """
    stories = await get_user_stories(db, user_id, viewer_id=current_user.id)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/my-stories", response_model=List[StoryRead])
async def get_my_stories(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get current user's own stories.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of current user's stories
    """
    stories = await get_user_stories(db, current_user.id, viewer_id=current_user.id, include_all=True)
    return [StoryRead.from_orm(story) for story in stories]
@router.get("/{story_id}", response_model=StoryRead)
async def get_story(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific story by ID.
    Args:
        story_id: ID of the story to retrieve
        current_user: Current authenticated user
        db: Database session
    Returns:
        StoryRead: Story data
    Raises:
        HTTPException: If story not found or not authorized to view
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found or not authorized to view"
        )
    return StoryRead.from_orm(story)
@router.post("/{story_id}/view")
async def view_story_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Mark a story as viewed.
    Args:
        story_id: ID of the story to mark as viewed
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized to view
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found or not authorized to view"
        )
    # Don't record views for own stories
    if str(story.user_id) == str(current_user.id):
        return {"message": "Story viewed (own story)"}
    await view_story(db, story_id, current_user.id)
    return {"message": "Story viewed successfully"}
@router.get("/{story_id}/views")
async def get_story_views_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get views for a story.
    Args:
        story_id: ID of the story to get views for
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Story views data
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can see views
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view story analytics"
        )
    views = await get_story_views(db, story_id)
    return {
        "story_id": story_id,
        "total_views": len(views),
        "views": views
    }
@router.delete("/{story_id}")
async def delete_story_endpoint(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a story.
    Args:
        story_id: ID of the story to delete
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can delete
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to delete this story"
        )
    await delete_story(db, story_id)
    return {"message": "Story deleted successfully"}
@router.get("/archive/my-stories", response_model=List[StoryRead])
async def get_archived_stories(
    limit: int = Query(20, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get current user's archived stories.
    Args:
        limit: Maximum number of stories to return
        offset: Number of stories to skip
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[StoryRead]: List of archived stories
    Note: This would return stories that have expired but been
    saved to the user's archive.
    """
    # TODO: Implement archived stories functionality
    return []
@router.post("/{story_id}/archive")
async def archive_story(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Archive a story before it expires.
    Args:
        story_id: ID of the story to archive
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If story not found or not authorized
    """
    story = await get_story_by_id(db, story_id, viewer_id=current_user.id)
    if not story:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Story not found"
        )
    # Only story owner can archive
    if str(story.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to archive this story"
        )
    # TODO: Implement story archiving logic
    return {"message": "Story archived successfully"}
</file>

<file path="backend/app/api/api_v1/endpoints/user_plants.py">
"""User plants API endpoints.
This module provides REST API endpoints for managing user's individual plants.
"""
from typing import List, Optional
from uuid import UUID
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.api.api_v1.endpoints.auth import get_current_user
from app.models.user import User
from app.schemas.user_plant import (
    UserPlantCreate,
    UserPlantUpdate,
    UserPlantResponse,
    UserPlantListResponse,
    PlantCareReminderResponse
)
from app.services.user_plant_service import (
    create_plant,
    get_plant_by_id,
    get_user_plants,
    update_plant,
    delete_plant,
    get_care_reminders,
    update_care_activity,
    get_plant_stats
)
router = APIRouter()
@router.post(
    "/",
    response_model=UserPlantResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Add new plant",
    description="Add a new plant to user's collection."
)
async def create_user_plant(
    plant_data: UserPlantCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Create a new user plant."""
    try:
        plant = await create_plant(db, current_user.id, plant_data)
        return UserPlantResponse.from_orm(plant)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create plant"
        )
@router.get(
    "/",
    response_model=UserPlantListResponse,
    summary="Get user's plants",
    description="Get all plants owned by the current user."
)
async def get_my_plants(
    is_active: Optional[bool] = Query(True, description="Filter by active status"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantListResponse:
    """Get user's plants."""
    try:
        plants, total = await get_user_plants(db, current_user.id, is_active, skip, limit)
        return UserPlantListResponse(
            plants=[UserPlantResponse.from_orm(plant) for plant in plants],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plants"
        )
@router.get(
    "/stats",
    summary="Get plant statistics",
    description="Get statistics about user's plant collection."
)
async def get_my_plant_stats(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Get plant statistics for the current user."""
    try:
        stats = await get_plant_stats(db, current_user.id)
        return stats
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get plant statistics"
        )
@router.get(
    "/care-reminders",
    response_model=List[PlantCareReminderResponse],
    summary="Get care reminders",
    description="Get care reminders for user's plants."
)
async def get_my_care_reminders(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> List[PlantCareReminderResponse]:
    """Get care reminders for user's plants."""
    try:
        reminders = await get_care_reminders(db, current_user.id)
        return [PlantCareReminderResponse(**reminder) for reminder in reminders]
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get care reminders"
        )
@router.get(
    "/{plant_id}",
    response_model=UserPlantResponse,
    summary="Get plant details",
    description="Get details of a specific plant owned by the user."
)
async def get_user_plant(
    plant_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Get user plant by ID."""
    plant = await get_plant_by_id(db, plant_id, current_user.id)
    if not plant:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Plant not found"
        )
    return UserPlantResponse.from_orm(plant)
@router.put(
    "/{plant_id}",
    response_model=UserPlantResponse,
    summary="Update plant",
    description="Update plant information."
)
async def update_user_plant(
    plant_id: UUID,
    plant_data: UserPlantUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> UserPlantResponse:
    """Update user plant."""
    try:
        plant = await update_plant(db, plant_id, current_user.id, plant_data)
        if not plant:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
        return UserPlantResponse.from_orm(plant)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update plant"
        )
@router.post(
    "/{plant_id}/care",
    summary="Record care activity",
    description="Record a care activity for the plant (watering, fertilizing, etc.)."
)
async def record_care_activity(
    plant_id: UUID,
    care_type: str = Query(..., description="Type of care activity"),
    care_date: Optional[datetime] = Query(None, description="Date of care activity (defaults to now)"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Record care activity for a plant."""
    try:
        success = await update_care_activity(
            db, plant_id, current_user.id, care_type, care_date
        )
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
        return {
            "message": f"Care activity '{care_type}' recorded successfully",
            "plant_id": plant_id,
            "care_type": care_type,
            "care_date": care_date or datetime.utcnow()
        }
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record care activity"
        )
@router.delete(
    "/{plant_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Remove plant",
    description="Remove plant from user's collection (soft delete)."
)
async def delete_user_plant(
    plant_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> None:
    """Delete user plant."""
    try:
        success = await delete_plant(db, plant_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plant not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete plant"
        )
# Public endpoint for viewing other users' plants (optional)
@router.get(
    "/user/{user_id}",
    response_model=UserPlantListResponse,
    summary="Get user's public plants",
    description="Get public plants owned by a specific user."
)
async def get_user_public_plants(
    user_id: UUID,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(20, ge=1, le=100, description="Maximum number of records to return"),
    db: AsyncSession = Depends(get_db)
) -> UserPlantListResponse:
    """Get public plants owned by a specific user."""
    try:
        # Only get active plants for public viewing
        plants, total = await get_user_plants(db, user_id, True, skip, limit)
        return UserPlantListResponse(
            plants=[UserPlantResponse.from_orm(plant) for plant in plants],
            total=total,
            skip=skip,
            limit=limit
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user plants"
        )
</file>

<file path="backend/app/api/api_v1/endpoints/users.py">
"""User management endpoints.
This module provides endpoints for user profile management,
user discovery, and user-related operations.
"""
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.user import UserRead, UserUpdate, UserSearch
from app.api.api_v1.endpoints.auth import get_current_user
from app.services.user_service import (
    get_user_by_id,
    get_user_by_username,
    search_users,
    update_user_profile,
    get_user_stats
)
from app.models.user import User
router = APIRouter()
@router.get("/search", response_model=List[UserSearch])
async def search_users_endpoint(
    q: str = Query(..., min_length=2, description="Search query (username, display name)"),
    limit: int = Query(20, ge=1, le=50, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Number of results to skip"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Search for users by username or display name.
    Args:
        q: Search query string
        limit: Maximum number of results to return
        offset: Number of results to skip for pagination
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of matching users
    """
    users = await search_users(db, query=q, limit=limit, offset=offset, exclude_user_id=current_user.id)
    return [UserSearch.from_orm(user) for user in users]
@router.get("/username/{username}", response_model=UserRead)
async def get_user_by_username_endpoint(
    username: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user profile by username.
    Args:
        username: Username to look up
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: User profile data
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_username(db, username)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserRead.from_orm(user)
@router.get("/{user_id}", response_model=UserRead)
async def get_user_by_id_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user profile by ID.
    Args:
        user_id: User ID to look up
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: User profile data
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserRead.from_orm(user)
@router.put("/{user_id}", response_model=UserRead)
async def update_user_profile_endpoint(
    user_id: str,
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update user profile.
    Args:
        user_id: User ID to update
        user_update: User update data
        current_user: Current authenticated user
        db: Database session
    Returns:
        UserRead: Updated user profile
    Raises:
        HTTPException: If user not found or unauthorized
    """
    # Check if user exists
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # Check if current user can update this profile
    if str(current_user.id) != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to update this profile"
        )
    # Update profile
    updated_user = await update_user_profile(db, user, user_update)
    return UserRead.from_orm(updated_user)
@router.get("/{user_id}/stats")
async def get_user_stats_endpoint(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user statistics (friends count, stories count, etc.).
    Args:
        user_id: User ID to get stats for
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: User statistics
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    stats = await get_user_stats(db, user_id)
    return stats
@router.get("/discover/suggestions", response_model=List[UserSearch])
async def get_user_suggestions(
    limit: int = Query(10, ge=1, le=20, description="Maximum number of suggestions"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user suggestions for friend recommendations.
    Args:
        limit: Maximum number of suggestions to return
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of suggested users
    Note: This is a basic implementation. In production, this would
    use more sophisticated algorithms based on mutual friends,
    interests, location, etc.
    """
    # For now, return random users excluding current user and existing friends
    # TODO: Implement sophisticated recommendation algorithm
    users = await search_users(
        db, 
        query="", 
        limit=limit, 
        offset=0, 
        exclude_user_id=current_user.id,
        random_order=True
    )
    return [UserSearch.from_orm(user) for user in users]
@router.post("/{user_id}/block")
async def block_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Block a user.
    Args:
        user_id: User ID to block
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found or trying to block self
    """
    if str(current_user.id) == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot block yourself"
        )
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # TODO: Implement blocking logic in friendship service
    return {"message": f"User {user.username} has been blocked"}
@router.delete("/{user_id}/block")
async def unblock_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unblock a user.
    Args:
        user_id: User ID to unblock
        current_user: Current authenticated user
        db: Database session
    Returns:
        dict: Success message
    Raises:
        HTTPException: If user not found
    """
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    # TODO: Implement unblocking logic in friendship service
    return {"message": f"User {user.username} has been unblocked"}
@router.get("/blocked/list", response_model=List[UserSearch])
async def get_blocked_users(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get list of blocked users.
    Args:
        current_user: Current authenticated user
        db: Database session
    Returns:
        List[UserSearch]: List of blocked users
    """
    # TODO: Implement get blocked users logic
    return []
</file>

<file path="backend/app/api/api_v1/endpoints/websocket.py">
"""WebSocket endpoints.
This module provides WebSocket endpoints for real-time communication,
including messaging, typing indicators, and live updates.
"""
import json
from typing import Dict, Any
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.websocket import websocket_manager as manager
from app.services.auth_service import get_current_user_from_token
from app.services.message_service import create_message
from app.services.friendship_service import check_friendship_status
from app.schemas.message import MessageCreate
from app.schemas.message import MessageType
router = APIRouter()
@router.websocket("/connect/{token}")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """WebSocket connection endpoint for real-time communication.
    Args:
        websocket: WebSocket connection
        token: Authentication token
        db: Database session
    Note: This endpoint handles real-time messaging, typing indicators,
    and other live updates between users.
    """
    # Authenticate user
    try:
        user = await get_current_user_from_token(token, db)
        if not user:
            await websocket.close(code=4001, reason="Invalid token")
            return
    except Exception:
        await websocket.close(code=4001, reason="Authentication failed")
        return
    # Accept connection and add to manager
    await websocket.accept()
    await manager.connect(websocket, str(user.id))
    try:
        # Send connection confirmation
        await manager.send_personal_message(
            {
                "type": "connection_established",
                "user_id": str(user.id),
                "message": "Connected successfully"
            },
            str(user.id)
        )
        # Listen for messages
        while True:
            # Receive message from client
            data = await websocket.receive_text()
            try:
                message_data = json.loads(data)
                await handle_websocket_message(message_data, user.id, db)
            except json.JSONDecodeError:
                await manager.send_personal_message(
                    {
                        "type": "error",
                        "message": "Invalid JSON format"
                    },
                    str(user.id)
                )
            except Exception as e:
                await manager.send_personal_message(
                    {
                        "type": "error",
                        "message": f"Error processing message: {str(e)}"
                    },
                    str(user.id)
                )
    except WebSocketDisconnect:
        # Handle disconnection
        await manager.disconnect(str(user.id))
        print(f"User {user.username} disconnected")
    except Exception as e:
        # Handle other errors
        print(f"WebSocket error for user {user.username}: {str(e)}")
        await manager.disconnect(str(user.id))
async def handle_websocket_message(
    message_data: Dict[str, Any],
    user_id: str,
    db: AsyncSession
):
    """Handle incoming WebSocket messages.
    Args:
        message_data: Parsed message data from client
        user_id: ID of the user sending the message
        db: Database session
    """
    message_type = message_data.get("type")
    if message_type == "send_message":
        await handle_send_message(message_data, user_id, db)
    elif message_type == "typing_start":
        await handle_typing_indicator(message_data, user_id, True)
    elif message_type == "typing_stop":
        await handle_typing_indicator(message_data, user_id, False)
    elif message_type == "message_read":
        await handle_message_read(message_data, user_id, db)
    elif message_type == "ping":
        await handle_ping(user_id)
    else:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": f"Unknown message type: {message_type}"
            },
            user_id
        )
async def handle_send_message(
    message_data: Dict[str, Any],
    sender_id: str,
    db: AsyncSession
):
    """Handle sending a message through WebSocket.
    Args:
        message_data: Message data from client
        sender_id: ID of the user sending the message
        db: Database session
    """
    try:
        recipient_id = message_data.get("recipient_id")
        content = message_data.get("content")
        if not recipient_id or not content:
            await manager.send_personal_message(
                {
                    "type": "error",
                    "message": "Missing recipient_id or content"
                },
                sender_id
            )
            return
        # Check if users are friends
        friendship_status = await check_friendship_status(db, sender_id, recipient_id)
        if friendship_status != "accepted":
            await manager.send_personal_message(
                {
                    "type": "error",
                    "message": "Can only send messages to friends"
                },
                sender_id
            )
            return
        # Create message in database
        message_create = MessageCreate(
            recipient_id=recipient_id,
            content_type=MessageType.TEXT,
            content=content,
            disappears_at=message_data.get("disappears_at")
        )
        message = await create_message(db, sender_id, message_create)
        # Send message to recipient if online
        await manager.send_personal_message(
            {
                "type": "new_message",
                "message": message.to_dict()
            },
            recipient_id
        )
        # Send confirmation to sender
        await manager.send_personal_message(
            {
                "type": "message_sent",
                "message": message.to_dict()
            },
            sender_id
        )
    except Exception as e:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": f"Failed to send message: {str(e)}"
            },
            sender_id
        )
async def handle_typing_indicator(
    message_data: Dict[str, Any],
    user_id: str,
    is_typing: bool
):
    """Handle typing indicators.
    Args:
        message_data: Message data from client
        user_id: ID of the user typing
        is_typing: Whether user is typing or stopped typing
    """
    recipient_id = message_data.get("recipient_id")
    if not recipient_id:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": "Missing recipient_id for typing indicator"
            },
            user_id
        )
        return
    # Send typing indicator to recipient
    await manager.send_personal_message(
        {
            "type": "typing_indicator",
            "user_id": user_id,
            "is_typing": is_typing
        },
        recipient_id
    )
async def handle_message_read(
    message_data: Dict[str, Any],
    user_id: str,
    db: AsyncSession
):
    """Handle message read receipts.
    Args:
        message_data: Message data from client
        user_id: ID of the user who read the message
        db: Database session
    """
    message_id = message_data.get("message_id")
    if not message_id:
        await manager.send_personal_message(
            {
                "type": "error",
                "message": "Missing message_id for read receipt"
            },
            user_id
        )
        return
    # TODO: Update message read status in database
    # For now, just send read receipt to sender
    sender_id = message_data.get("sender_id")
    if sender_id:
        await manager.send_personal_message(
            {
                "type": "message_read",
                "message_id": message_id,
                "read_by": user_id
            },
            sender_id
        )
async def handle_ping(user_id: str):
    """Handle ping messages for connection health check.
    Args:
        user_id: ID of the user sending ping
    """
    await manager.send_personal_message(
        {
            "type": "pong",
            "timestamp": manager.get_current_timestamp()
        },
        user_id
    )
@router.get("/active-users")
async def get_active_users():
    """Get list of currently active users.
    Returns:
        dict: List of active user IDs
    Note: This endpoint is for debugging/monitoring purposes.
    In production, you might want to restrict access.
    """
    active_users = list(manager.active_connections.keys())
    return {
        "active_users": active_users,
        "total_connections": len(active_users)
    }
@router.post("/broadcast")
async def broadcast_message(
    message: str,
    user_ids: list = None
):
    """Broadcast a message to specific users or all connected users.
    Args:
        message: Message to broadcast
        user_ids: Optional list of user IDs to send to (if None, sends to all)
    Returns:
        dict: Success message
    Note: This endpoint is for admin/system messages.
    In production, you'd want proper authentication and authorization.
    """
    broadcast_data = {
        "type": "system_message",
        "message": message,
        "timestamp": manager.get_current_timestamp()
    }
    if user_ids:
        # Send to specific users
        for user_id in user_ids:
            await manager.send_personal_message(broadcast_data, user_id)
    else:
        # Send to all connected users
        await manager.broadcast(broadcast_data)
    return {"message": "Broadcast sent successfully"}
</file>

<file path="backend/app/core/config.py">
"""Application configuration settings.
This module defines all configuration settings for the FastAPI application,
including database connections, authentication, and external service settings.
"""
import secrets
from typing import Any, Dict, List, Optional, Union
from pydantic import AnyHttpUrl, EmailStr, HttpUrl, PostgresDsn, field_validator
from pydantic_settings import BaseSettings
class Settings(BaseSettings):
    """Application settings loaded from environment variables."""
    # Basic app settings
    PROJECT_NAME: str = "Plant Social API"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    SECRET_KEY: str = secrets.token_urlsafe(32)
    # Security settings
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8  # 8 days
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 30 days
    ALGORITHM: str = "HS256"
    # CORS settings
    BACKEND_CORS_ORIGINS: str = "http://localhost:3000,http://localhost:8000,http://localhost:8080,http://127.0.0.1:3000"
    ALLOWED_HOSTS: str = "localhost,127.0.0.1"
    def get_cors_origins(self) -> List[str]:
        """Parse CORS origins from string."""
        if isinstance(self.BACKEND_CORS_ORIGINS, str):
            return [origin.strip() for origin in self.BACKEND_CORS_ORIGINS.split(",") if origin.strip()]
        return []
    def get_allowed_hosts(self) -> List[str]:
        """Parse allowed hosts from string."""
        if isinstance(self.ALLOWED_HOSTS, str):
            return [host.strip() for host in self.ALLOWED_HOSTS.split(",") if host.strip()]
        return []
    # Database settings
    POSTGRES_SERVER: str = "localhost"
    POSTGRES_USER: str = "postgres"
    POSTGRES_PASSWORD: str = "password"
    POSTGRES_DB: str = "plant_social_db"
    POSTGRES_PORT: str = "5432"
    SQLALCHEMY_DATABASE_URI: Optional[PostgresDsn] = None
    @field_validator("SQLALCHEMY_DATABASE_URI", mode="before")
    @classmethod
    def assemble_db_connection(cls, v: Optional[str], info) -> Any:
        """Assemble database connection string."""
        if isinstance(v, str):
            return v
        values = info.data if hasattr(info, 'data') else {}
        # Construct URL manually to avoid PostgresDsn issues
        user = values.get("POSTGRES_USER", "postgres")
        password = values.get("POSTGRES_PASSWORD", "password")
        host = values.get("POSTGRES_SERVER", "localhost")
        port = values.get("POSTGRES_PORT", "5432")
        db = values.get("POSTGRES_DB", "plant_social_db")
        return f"postgresql+asyncpg://{user}:{password}@{host}:{port}/{db}"
    # Redis settings
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    REDIS_PASSWORD: Optional[str] = None
    # AWS S3 settings
    AWS_ACCESS_KEY_ID: Optional[str] = None
    AWS_SECRET_ACCESS_KEY: Optional[str] = None
    AWS_REGION: str = "us-east-1"
    AWS_ENDPOINT_URL: Optional[str] = None
    S3_BUCKET_NAME: Optional[str] = None
    CLOUDFRONT_DOMAIN: Optional[str] = None
    # OpenAI settings (for future phases)
    OPENAI_API_KEY: Optional[str] = None
    # Email settings (for future use)
    SMTP_TLS: bool = True
    SMTP_PORT: Optional[int] = None
    SMTP_HOST: Optional[str] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None
    EMAILS_FROM_EMAIL: Optional[EmailStr] = None
    EMAILS_FROM_NAME: Optional[str] = None
    # Testing
    TESTING: bool = False
    model_config = {
        "case_sensitive": True,
        "env_file": ".env"
    }
settings = Settings()
</file>

<file path="backend/app/core/database.py">
"""Database configuration and session management.
This module sets up the SQLAlchemy async engine, session factory,
and base model class for the application.
"""
from sqlalchemy import MetaData, text
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import NullPool
from app.core.config import settings
# Create base model class with naming convention
convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}
metadata = MetaData(naming_convention=convention)
Base = declarative_base(metadata=metadata)
# Note: Model imports are handled in app/models/__init__.py to avoid circular imports
# Create async engine
engine = create_async_engine(
    str(settings.SQLALCHEMY_DATABASE_URI),
    poolclass=NullPool,
    echo=True,  # Enable SQL query logging for debugging
)
# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)
async def get_db() -> AsyncSession:
    """Dependency to get database session.
    Yields:
        AsyncSession: Database session instance
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
async def init_db() -> None:
    """Initialize database tables.
    This function creates all tables defined in the models.
    Should be called during application startup.
    """
    async with engine.begin() as conn:
        # Enable vector extension
        await conn.execute(text('CREATE EXTENSION IF NOT EXISTS vector;'))
        # Create all tables
        await conn.run_sync(Base.metadata.create_all)
async def close_db() -> None:
    """Close database connections.
    Should be called during application shutdown.
    """
    await engine.dispose()
</file>

<file path="backend/app/core/websocket.py">
"""WebSocket connection manager for real-time messaging.
This module handles WebSocket connections, message broadcasting,
and real-time communication between users.
"""
import json
import logging
from typing import Dict, List, Optional
from uuid import UUID
from fastapi import WebSocket, WebSocketDisconnect
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import AsyncSessionLocal
from app.models.user import User
from app.services.auth_service import get_current_user_from_token
logger = logging.getLogger(__name__)
class ConnectionManager:
    """Manages WebSocket connections for real-time messaging."""
    def __init__(self):
        # Store active connections: {user_id: websocket}
        self.active_connections: Dict[str, WebSocket] = {}
        # Store user sessions: {websocket: user_id}
        self.user_sessions: Dict[WebSocket, str] = {}
    async def connect(self, websocket: WebSocket, user_id: str) -> bool:
        """Accept a WebSocket connection and register the user.
        Args:
            websocket: The WebSocket connection
            user_id: The authenticated user's ID
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            await websocket.accept()
            # Disconnect existing connection for this user if any
            if user_id in self.active_connections:
                old_websocket = self.active_connections[user_id]
                await self.disconnect(old_websocket)
            # Register new connection
            self.active_connections[user_id] = websocket
            self.user_sessions[websocket] = user_id
            logger.info(f"User {user_id} connected via WebSocket")
            # Send connection confirmation
            await self.send_personal_message(
                {
                    "type": "connection_established",
                    "message": "Connected successfully",
                    "user_id": user_id
                },
                websocket
            )
            return True
        except Exception as e:
            logger.error(f"Error connecting user {user_id}: {e}")
            return False
    async def disconnect(self, websocket: WebSocket) -> None:
        """Disconnect a WebSocket and clean up.
        Args:
            websocket: The WebSocket connection to disconnect
        """
        try:
            user_id = self.user_sessions.get(websocket)
            if user_id:
                # Remove from active connections
                self.active_connections.pop(user_id, None)
                self.user_sessions.pop(websocket, None)
                logger.info(f"User {user_id} disconnected from WebSocket")
            # Close the connection
            await websocket.close()
        except Exception as e:
            logger.error(f"Error disconnecting WebSocket: {e}")
    async def send_personal_message(self, message: dict, websocket: WebSocket) -> bool:
        """Send a message to a specific WebSocket connection.
        Args:
            message: The message data to send
            websocket: The target WebSocket connection
        Returns:
            bool: True if message sent successfully, False otherwise
        """
        try:
            await websocket.send_text(json.dumps(message))
            return True
        except Exception as e:
            logger.error(f"Error sending message: {e}")
            # Connection might be broken, clean it up
            await self.disconnect(websocket)
            return False
    async def send_message_to_user(self, message: dict, user_id: str) -> bool:
        """Send a message to a specific user by user ID.
        Args:
            message: The message data to send
            user_id: The target user's ID
        Returns:
            bool: True if message sent successfully, False otherwise
        """
        websocket = self.active_connections.get(user_id)
        if websocket:
            return await self.send_personal_message(message, websocket)
        return False
    async def broadcast_to_users(self, message: dict, user_ids: List[str]) -> int:
        """Broadcast a message to multiple users.
        Args:
            message: The message data to send
            user_ids: List of user IDs to send the message to
        Returns:
            int: Number of users who received the message
        """
        sent_count = 0
        for user_id in user_ids:
            if await self.send_message_to_user(message, user_id):
                sent_count += 1
        return sent_count
    def get_connected_users(self) -> List[str]:
        """Get list of currently connected user IDs.
        Returns:
            List[str]: List of connected user IDs
        """
        return list(self.active_connections.keys())
    def is_user_connected(self, user_id: str) -> bool:
        """Check if a user is currently connected.
        Args:
            user_id: The user ID to check
        Returns:
            bool: True if user is connected, False otherwise
        """
        return user_id in self.active_connections
    async def handle_message(self, websocket: WebSocket, data: str) -> None:
        """Handle incoming WebSocket message.
        Args:
            websocket: The WebSocket connection
            data: The raw message data
        """
        try:
            message = json.loads(data)
            user_id = self.user_sessions.get(websocket)
            if not user_id:
                await self.send_personal_message(
                    {"type": "error", "message": "User not authenticated"},
                    websocket
                )
                return
            message_type = message.get("type")
            if message_type == "ping":
                await self.send_personal_message(
                    {"type": "pong", "timestamp": message.get("timestamp")},
                    websocket
                )
            elif message_type == "typing":
                # Handle typing indicators
                recipient_id = message.get("recipient_id")
                if recipient_id:
                    await self.send_message_to_user(
                        {
                            "type": "typing",
                            "sender_id": user_id,
                            "is_typing": message.get("is_typing", False)
                        },
                        recipient_id
                    )
            else:
                logger.warning(f"Unknown message type: {message_type}")
        except json.JSONDecodeError:
            await self.send_personal_message(
                {"type": "error", "message": "Invalid JSON format"},
                websocket
            )
        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await self.send_personal_message(
                {"type": "error", "message": "Internal server error"},
                websocket
            )
# Global connection manager instance
websocket_manager = ConnectionManager()
</file>

<file path="backend/app/main.py">
"""Main FastAPI application entry point.
This module initializes the FastAPI app with all necessary middleware,
routers, and configurations for the plant social platform.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
from pathlib import Path
from app.core.config import settings
from app.core.database import engine
from app.api.api_v1.api import api_router
from app.core.websocket import websocket_manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager for startup and shutdown events."""
    # Startup
    print("Starting Plant Social API...")
    # Initialize database tables
    from app.core.database import init_db
    await init_db()
    print("Database initialized successfully")
    yield
    # Shutdown
    print("Shutting down Plant Social API...")
    from app.core.database import close_db
    await close_db()
def create_application() -> FastAPI:
    """Create and configure the FastAPI application.
    Returns:
        FastAPI: Configured FastAPI application instance
    """
    app = FastAPI(
        title=settings.PROJECT_NAME,
        version=settings.VERSION,
        description="AI-Enhanced Plant Care Community API",
        openapi_url=f"{settings.API_V1_STR}/openapi.json",
        lifespan=lifespan,
    )
    # Set all CORS enabled origins
    cors_origins = settings.get_cors_origins()
    if cors_origins:
        app.add_middleware(
            CORSMiddleware,
            allow_origins=cors_origins,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    # Add trusted host middleware
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=settings.get_allowed_hosts(),
    )
    # Include API router
    app.include_router(api_router, prefix=settings.API_V1_STR)
    # Mount static files for media uploads
    uploads_dir = Path("uploads")
    uploads_dir.mkdir(exist_ok=True)
    app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")
    return app
app = create_application()
@app.get("/")
async def root():
    """Root endpoint for health check."""
    return {
        "message": "Plant Social API",
        "version": settings.VERSION,
        "status": "healthy"
    }
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}
</file>

<file path="backend/app/models/__init__.py">
"""Models package initialization.
This module imports all database models to ensure they are
registered with SQLAlchemy when the package is imported.
"""
from app.models.user import User
from app.models.message import Message
from app.models.story import Story, StoryView
from app.models.friendship import Friendship, FriendshipStatus
from app.models.plant_species import PlantSpecies
from app.models.user_plant import UserPlant
from app.models.plant_care_log import PlantCareLog
from app.models.plant_photo import PlantPhoto
from app.models.plant_identification import PlantIdentification
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_question import PlantQuestion, PlantAnswer
from app.models.plant_achievement import PlantAchievement, UserAchievement, PlantMilestone, UserStats
from app.models.local_nursery import LocalNursery, NurseryReview, NurseryEvent, UserNurseryFavorite
from app.models.rag_models import (
    PlantContentEmbedding, 
    UserPreferenceEmbedding, 
    RAGInteraction, 
    PlantKnowledgeBase,
    SemanticSearchCache
)
__all__ = [
    "User",
    "Message", 
    "Story",
    "StoryView",
    "Friendship",
    "FriendshipStatus",
    "PlantSpecies",
    "UserPlant",
    "PlantCareLog",
    "PlantPhoto",
    "PlantIdentification",
    "PlantTrade",
    "TradeStatus",
    "TradeType",
    "PlantQuestion",
    "PlantAnswer",
    "PlantAchievement",
    "UserAchievement", 
    "PlantMilestone",
    "UserStats",
    "LocalNursery",
    "NurseryReview",
    "NurseryEvent",
    "UserNurseryFavorite",
    "PlantContentEmbedding",
    "UserPreferenceEmbedding",
    "RAGInteraction",
    "PlantKnowledgeBase",
    "SemanticSearchCache"
]
</file>

<file path="backend/app/models/friendship.py">
"""Friendship model for managing user relationships.
This module defines the Friendship model for handling friend requests,
connections, and social relationships between users.
"""
import uuid
from datetime import datetime
from enum import Enum
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, String, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class FriendshipStatus(str, Enum):
    """Enumeration of friendship statuses."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    BLOCKED = "blocked"
class Friendship(Base):
    """Friendship model for managing user relationships.
    Handles friend requests, accepted friendships, and blocking.
    Each friendship is directional but creates bidirectional relationships.
    """
    __tablename__ = "friendships"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationships
    requester_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    addressee_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Friendship status
    status = Column(String(20), default=FriendshipStatus.PENDING, nullable=False)
    # Metadata
    is_close_friend = Column(Boolean, default=False)  # For story privacy
    is_blocked = Column(Boolean, default=False)
    blocked_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    accepted_at = Column(DateTime, nullable=True)
    blocked_at = Column(DateTime, nullable=True)
    # Relationships
    requester = relationship("User", foreign_keys=[requester_id], backref="sent_friend_requests")
    addressee = relationship("User", foreign_keys=[addressee_id], backref="received_friend_requests")
    blocked_by = relationship("User", foreign_keys=[blocked_by_id])
    # Ensure unique friendship pairs
    __table_args__ = (
        UniqueConstraint('requester_id', 'addressee_id', name='unique_friendship'),
    )
    def __repr__(self) -> str:
        """String representation of the friendship."""
        return f"<Friendship(requester={self.requester_id}, addressee={self.addressee_id}, status={self.status})>"
    @property
    def is_pending(self) -> bool:
        """Check if friendship request is pending.
        Returns:
            bool: True if status is pending, False otherwise
        """
        return self.status == FriendshipStatus.PENDING
    @property
    def is_accepted(self) -> bool:
        """Check if friendship is accepted.
        Returns:
            bool: True if status is accepted, False otherwise
        """
        return self.status == FriendshipStatus.ACCEPTED
    @property
    def is_declined(self) -> bool:
        """Check if friendship request was declined.
        Returns:
            bool: True if status is declined, False otherwise
        """
        return self.status == FriendshipStatus.DECLINED
    def accept(self) -> None:
        """Accept the friendship request."""
        self.status = FriendshipStatus.ACCEPTED
        self.accepted_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    def decline(self) -> None:
        """Decline the friendship request."""
        self.status = FriendshipStatus.DECLINED
        self.updated_at = datetime.utcnow()
    def block(self, blocked_by_user_id: uuid.UUID) -> None:
        """Block the user relationship.
        Args:
            blocked_by_user_id: ID of the user who initiated the block
        """
        self.status = FriendshipStatus.BLOCKED
        self.is_blocked = True
        self.blocked_by_id = blocked_by_user_id
        self.blocked_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    def unblock(self) -> None:
        """Unblock the user relationship."""
        self.is_blocked = False
        self.blocked_by_id = None
        self.blocked_at = None
        self.status = FriendshipStatus.DECLINED  # Reset to declined state
        self.updated_at = datetime.utcnow()
    def toggle_close_friend(self) -> None:
        """Toggle close friend status."""
        self.is_close_friend = not self.is_close_friend
        self.updated_at = datetime.utcnow()
    def get_other_user_id(self, current_user_id: uuid.UUID) -> uuid.UUID:
        """Get the other user's ID in the friendship.
        Args:
            current_user_id: ID of the current user
        Returns:
            UUID: ID of the other user in the friendship
        """
        if current_user_id == self.requester_id:
            return self.addressee_id
        return self.requester_id
    def is_user_involved(self, user_id: uuid.UUID) -> bool:
        """Check if a user is involved in this friendship.
        Args:
            user_id: ID of the user to check
        Returns:
            bool: True if user is involved, False otherwise
        """
        return user_id in [self.requester_id, self.addressee_id]
    def to_dict(self, current_user_id: Optional[uuid.UUID] = None) -> dict:
        """Convert friendship to dictionary for API responses.
        Args:
            current_user_id: ID of the current user viewing the friendship
        Returns:
            dict: Friendship data
        """
        data = {
            "id": str(self.id),
            "requester_id": str(self.requester_id),
            "addressee_id": str(self.addressee_id),
            "status": self.status,
            "is_close_friend": self.is_close_friend,
            "is_blocked": self.is_blocked,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "accepted_at": self.accepted_at.isoformat() if self.accepted_at else None,
        }
        # Add context for current user
        if current_user_id:
            data["other_user_id"] = str(self.get_other_user_id(current_user_id))
            data["is_requester"] = current_user_id == self.requester_id
            data["can_accept"] = (
                current_user_id == self.addressee_id and 
                self.status == FriendshipStatus.PENDING
            )
        return data
    @classmethod
    def create_friendship_request(
        cls, 
        requester_id: uuid.UUID, 
        addressee_id: uuid.UUID
    ) -> "Friendship":
        """Create a new friendship request.
        Args:
            requester_id: ID of the user sending the request
            addressee_id: ID of the user receiving the request
        Returns:
            Friendship: New friendship instance
        """
        return cls(
            requester_id=requester_id,
            addressee_id=addressee_id,
            status=FriendshipStatus.PENDING
        )
</file>

<file path="backend/app/models/message.py">
"""Message model for real-time messaging system.
This module defines the Message model for handling ephemeral
and persistent messages between users.
"""
import uuid
from datetime import datetime
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class Message(Base):
    """Message model for user-to-user communication.
    Supports both text messages and media messages with
    disappearing functionality similar to Snapchat.
    """
    __tablename__ = "messages"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationships
    sender_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    recipient_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Message content
    content_type = Column(String(20), nullable=False)  # text, image, video, audio
    text_content = Column(Text, nullable=True)  # For text messages
    media_url = Column(String(500), nullable=True)  # For media messages
    media_thumbnail_url = Column(String(500), nullable=True)  # Thumbnail for videos
    # Message metadata
    caption = Column(Text, nullable=True)  # Caption for media messages
    duration = Column(Integer, nullable=True)  # Duration for video/audio in seconds
    file_size = Column(Integer, nullable=True)  # File size in bytes
    # Disappearing message settings
    disappear_after = Column(Integer, nullable=True)  # Seconds after viewing
    is_disappearing = Column(Boolean, default=False)
    # Message status
    is_delivered = Column(Boolean, default=False)
    is_viewed = Column(Boolean, default=False)
    is_deleted = Column(Boolean, default=False)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    delivered_at = Column(DateTime, nullable=True)
    viewed_at = Column(DateTime, nullable=True)
    expires_at = Column(DateTime, nullable=True)  # When message should be deleted
    deleted_at = Column(DateTime, nullable=True)
    # Relationships
    sender = relationship("User", foreign_keys=[sender_id], backref="sent_messages")
    recipient = relationship("User", foreign_keys=[recipient_id], backref="received_messages")
    def __repr__(self) -> str:
        """String representation of the message."""
        return f"<Message(id={self.id}, sender={self.sender_id}, type={self.content_type})>"
    @property
    def is_expired(self) -> bool:
        """Check if the message has expired.
        Returns:
            bool: True if message has expired, False otherwise
        """
        if not self.expires_at:
            return False
        return datetime.utcnow() > self.expires_at
    @property
    def is_media(self) -> bool:
        """Check if the message contains media.
        Returns:
            bool: True if message is media type, False otherwise
        """
        return self.content_type in ["image", "video", "audio"]
    def mark_as_delivered(self) -> None:
        """Mark the message as delivered."""
        if not self.is_delivered:
            self.is_delivered = True
            self.delivered_at = datetime.utcnow()
    def mark_as_viewed(self) -> None:
        """Mark the message as viewed and set expiration if disappearing."""
        if not self.is_viewed:
            self.is_viewed = True
            self.viewed_at = datetime.utcnow()
            # Set expiration time for disappearing messages
            if self.is_disappearing and self.disappear_after:
                from datetime import timedelta
                self.expires_at = datetime.utcnow() + timedelta(seconds=self.disappear_after)
    def soft_delete(self) -> None:
        """Soft delete the message."""
        self.is_deleted = True
        self.deleted_at = datetime.utcnow()
    def to_dict(self, include_content: bool = True) -> dict:
        """Convert message to dictionary for API responses.
        Args:
            include_content: Whether to include message content
        Returns:
            dict: Message data
        """
        data = {
            "id": str(self.id),
            "sender_id": str(self.sender_id),
            "recipient_id": str(self.recipient_id),
            "content_type": self.content_type,
            "is_disappearing": self.is_disappearing,
            "disappear_after": self.disappear_after,
            "is_delivered": self.is_delivered,
            "is_viewed": self.is_viewed,
            "is_deleted": self.is_deleted,
            "created_at": self.created_at.isoformat(),
            "delivered_at": self.delivered_at.isoformat() if self.delivered_at else None,
            "viewed_at": self.viewed_at.isoformat() if self.viewed_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
        }
        # Include content only if not expired and requested
        if include_content and not self.is_expired and not self.is_deleted:
            data.update({
                "text_content": self.text_content,
                "media_url": self.media_url,
                "media_thumbnail_url": self.media_thumbnail_url,
                "caption": self.caption,
                "duration": self.duration,
                "file_size": self.file_size,
            })
        return data
    def to_notification_dict(self) -> dict:
        """Convert message to dictionary for push notifications.
        Returns:
            dict: Notification data
        """
        return {
            "id": str(self.id),
            "sender_id": str(self.sender_id),
            "content_type": self.content_type,
            "preview": self._get_preview_text(),
            "created_at": self.created_at.isoformat(),
        }
    def _get_preview_text(self) -> str:
        """Get preview text for notifications.
        Returns:
            str: Preview text based on message type
        """
        if self.content_type == "text":
            return self.text_content[:50] + "..." if len(self.text_content or "") > 50 else self.text_content or ""
        elif self.content_type == "image":
            return " Photo"
        elif self.content_type == "video":
            return " Video"
        elif self.content_type == "audio":
            return " Audio"
        else:
            return "Message"
</file>

<file path="backend/app/models/plant_care_log.py">
"""Plant care log database model.
This module defines the PlantCareLog model for tracking care activities
performed on user plants.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantCareLog(Base):
    """Plant care log model for tracking care activities."""
    __tablename__ = "plant_care_logs"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    care_type = Column(String(50), nullable=False)  # watering, fertilizing, repotting, pruning, etc.
    notes = Column(Text)
    performed_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    plant = relationship("UserPlant", back_populates="care_logs")
    def __repr__(self) -> str:
        return f"<PlantCareLog(id={self.id}, care_type='{self.care_type}', plant_id={self.plant_id})>"
</file>

<file path="backend/app/models/plant_identification.py">
"""Plant identification database model.
This module defines the PlantIdentification model for storing
AI-powered plant identification results.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Float, Boolean
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantIdentification(Base):
    """Plant identification model for AI identification results."""
    __tablename__ = "plant_identifications"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=True)
    image_path = Column(String(500), nullable=False)
    confidence_score = Column(Float)
    identified_name = Column(String(255))
    is_verified = Column(Boolean, default=False)
    verification_notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user = relationship("User")
    species = relationship("PlantSpecies", back_populates="identifications")
    def __repr__(self) -> str:
        return f"<PlantIdentification(id={self.id}, identified_name='{self.identified_name}', confidence={self.confidence_score})>"
</file>

<file path="backend/app/models/plant_photo.py">
"""Plant photo database model.
This module defines the PlantPhoto model for storing plant images
and progress photos.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantPhoto(Base):
    """Plant photo model for storing plant images."""
    __tablename__ = "plant_photos"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    plant_id = Column(PostgresUUID(as_uuid=True), ForeignKey("user_plants.id"), nullable=False)
    file_path = Column(String(500), nullable=False)
    caption = Column(Text)
    is_progress_photo = Column(Boolean, default=False)
    taken_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    plant = relationship("UserPlant", back_populates="photos")
    def __repr__(self) -> str:
        return f"<PlantPhoto(id={self.id}, plant_id={self.plant_id}, file_path='{self.file_path}')>"
</file>

<file path="backend/app/models/plant_question.py">
"""Plant question database model.
This module defines the PlantQuestion and PlantAnswer models
for the Q&A community functionality.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean, Integer
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantQuestion(Base):
    """Plant question model for Q&A functionality."""
    __tablename__ = "plant_questions"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=True)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    image_paths = Column(Text)  # JSON array of image paths
    tags = Column(Text)  # JSON array of tags
    is_solved = Column(Boolean, default=False)
    view_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    user = relationship("User")
    species = relationship("PlantSpecies", back_populates="questions")
    answers = relationship("PlantAnswer", back_populates="question")
    def __repr__(self) -> str:
        return f"<PlantQuestion(id={self.id}, title='{self.title}', user_id={self.user_id})>"
class PlantAnswer(Base):
    """Plant answer model for Q&A functionality."""
    __tablename__ = "plant_answers"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    question_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_questions.id"), nullable=False)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    is_accepted = Column(Boolean, default=False)
    upvotes = Column(Integer, default=0)
    downvotes = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    question = relationship("PlantQuestion", back_populates="answers")
    user = relationship("User")
    def __repr__(self) -> str:
        return f"<PlantAnswer(id={self.id}, question_id={self.question_id}, user_id={self.user_id})>"
</file>

<file path="backend/app/models/plant_species.py">
"""Plant species database model.
This module defines the PlantSpecies model for storing plant species information
including care requirements, toxicity info, and other plant characteristics.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Integer, Text, DateTime, Boolean, ARRAY
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class PlantSpecies(Base):
    """Plant species model for storing plant information."""
    __tablename__ = "plant_species"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    scientific_name = Column(String(255), nullable=False, unique=True)
    common_names = Column(ARRAY(String), nullable=False, default=[])
    family = Column(String(100))
    care_level = Column(String(20))  # easy, moderate, difficult
    light_requirements = Column(String(50))
    water_frequency_days = Column(Integer)
    humidity_preference = Column(String(20))
    temperature_range = Column(String(50))
    toxicity_info = Column(Text)
    care_notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    # Relationships
    user_plants = relationship("UserPlant", back_populates="species")
    identifications = relationship("PlantIdentification", back_populates="species")
    trades = relationship("PlantTrade", back_populates="species")
    questions = relationship("PlantQuestion", back_populates="species")
    knowledge_base_entries = relationship("PlantKnowledgeBase", back_populates="plant_species")
    def __repr__(self) -> str:
        return f"<PlantSpecies(id={self.id}, scientific_name='{self.scientific_name}')>"
</file>

<file path="backend/app/models/plant_trade.py">
"""Plant trade database model.
This module defines the PlantTrade model for the plant trading
marketplace functionality.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, ForeignKey, Boolean, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from enum import Enum
from app.core.database import Base
class TradeStatus(str, Enum):
    """Trade status enumeration."""
    AVAILABLE = "available"
    PENDING = "pending"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
class TradeType(str, Enum):
    """Trade type enumeration."""
    TRADE = "trade"
    SELL = "sell"
    GIVE_AWAY = "give_away"
class PlantTrade(Base):
    """Plant trade model for marketplace functionality."""
    __tablename__ = "plant_trades"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    owner_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    trade_type = Column(SQLEnum(TradeType), nullable=False)
    status = Column(SQLEnum(TradeStatus), default=TradeStatus.AVAILABLE)
    location = Column(String(100))
    price = Column(String(50))  # Can be "Free", "$10", "Trade only", etc.
    image_paths = Column(Text)  # JSON array of image paths
    interested_user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    completed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    owner = relationship("User", foreign_keys=[owner_id])
    interested_user = relationship("User", foreign_keys=[interested_user_id])
    species = relationship("PlantSpecies", back_populates="trades")
    def __repr__(self) -> str:
        return f"<PlantTrade(id={self.id}, title='{self.title}', trade_type='{self.trade_type}')>"
</file>

<file path="backend/app/models/story.py">
"""Story model for ephemeral content sharing.
This module defines the Story model for 24-hour disappearing
content similar to Snapchat stories.
"""
import uuid
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy import Boolean, Column, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class Story(Base):
    """Story model for 24-hour ephemeral content.
    Stories are visible to friends for 24 hours and then
    automatically expire and are deleted.
    """
    __tablename__ = "stories"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # User relationship
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Content
    content_type = Column(String(20), nullable=False)  # image, video
    media_url = Column(String(500), nullable=False)
    thumbnail_url = Column(String(500), nullable=True)
    caption = Column(Text, nullable=True)
    # Media metadata
    duration = Column(Integer, nullable=True)  # For videos, in seconds
    file_size = Column(Integer, nullable=True)  # File size in bytes
    # Privacy settings
    privacy_level = Column(String(20), default="friends")  # friends, public, custom
    # Story status
    is_active = Column(Boolean, default=True)
    is_archived = Column(Boolean, default=False)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    archived_at = Column(DateTime, nullable=True)
    # Relationships
    user = relationship("User", backref="stories")
    views = relationship("StoryView", back_populates="story", cascade="all, delete-orphan")
    def __init__(self, **kwargs):
        """Initialize story with automatic expiration time."""
        super().__init__(**kwargs)
        if not self.expires_at:
            self.expires_at = datetime.utcnow() + timedelta(hours=24)
    def __repr__(self) -> str:
        """String representation of the story."""
        return f"<Story(id={self.id}, user={self.user_id}, type={self.content_type})>"
    @property
    def is_expired(self) -> bool:
        """Check if the story has expired.
        Returns:
            bool: True if story has expired, False otherwise
        """
        return datetime.utcnow() > self.expires_at
    @property
    def view_count(self) -> int:
        """Get the number of views for this story.
        Returns:
            int: Number of unique views
        """
        return len(self.views)
    @property
    def time_remaining(self) -> Optional[timedelta]:
        """Get time remaining before story expires.
        Returns:
            timedelta: Time remaining, or None if expired
        """
        if self.is_expired:
            return None
        return self.expires_at - datetime.utcnow()
    def archive(self) -> None:
        """Archive the story."""
        self.is_archived = True
        self.archived_at = datetime.utcnow()
    def deactivate(self) -> None:
        """Deactivate the story (soft delete)."""
        self.is_active = False
    def to_dict(self, viewer_id: Optional[str] = None) -> dict:
        """Convert story to dictionary for API responses.
        Args:
            viewer_id: ID of the user viewing the story
        Returns:
            dict: Story data
        """
        data = {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "content_type": self.content_type,
            "media_url": self.media_url,
            "thumbnail_url": self.thumbnail_url,
            "caption": self.caption,
            "duration": self.duration,
            "privacy_level": self.privacy_level,
            "view_count": self.view_count,
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat(),
            "time_remaining_seconds": int(self.time_remaining.total_seconds()) if self.time_remaining else 0,
            "is_expired": self.is_expired,
        }
        # Add viewer-specific information
        if viewer_id:
            data["has_viewed"] = any(view.viewer_id == uuid.UUID(viewer_id) for view in self.views)
        return data
class StoryView(Base):
    """Story view tracking model.
    Tracks when users view stories for analytics
    and to show view status to story creators.
    """
    __tablename__ = "story_views"
    # Primary key
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Relationships
    story_id = Column(UUID(as_uuid=True), ForeignKey("stories.id"), nullable=False)
    viewer_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    # Timestamps
    viewed_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    # Relationships
    story = relationship("Story", back_populates="views")
    viewer = relationship("User", backref="story_views")
    def __repr__(self) -> str:
        """String representation of the story view."""
        return f"<StoryView(story={self.story_id}, viewer={self.viewer_id})>"
    def to_dict(self) -> dict:
        """Convert story view to dictionary.
        Returns:
            dict: Story view data
        """
        return {
            "id": str(self.id),
            "story_id": str(self.story_id),
            "viewer_id": str(self.viewer_id),
            "viewed_at": self.viewed_at.isoformat(),
        }
</file>

<file path="backend/app/models/user_plant.py">
"""User plant database model.
This module defines the UserPlant model for tracking individual plants
owned by users, including care schedules and plant health status.
"""
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from sqlalchemy import Column, String, Text, DateTime, Boolean, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class UserPlant(Base):
    """User plant model for tracking individual plants."""
    __tablename__ = "user_plants"
    id = Column(PostgresUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(PostgresUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    species_id = Column(PostgresUUID(as_uuid=True), ForeignKey("plant_species.id"), nullable=False)
    nickname = Column(String(100))
    location = Column(String(100))  # e.g., "Living room window", "Bedroom"
    acquired_date = Column(DateTime)
    last_watered = Column(DateTime)
    last_fertilized = Column(DateTime)
    last_repotted = Column(DateTime)
    health_status = Column(String(20), default="healthy")  # healthy, sick, recovering, dead
    notes = Column(Text)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    # Relationships
    user = relationship("User", back_populates="plants")
    species = relationship("PlantSpecies", back_populates="user_plants")
    care_logs = relationship("PlantCareLog", back_populates="plant")
    photos = relationship("PlantPhoto", back_populates="plant")
    milestones = relationship("PlantMilestone", back_populates="plant")
    def __repr__(self) -> str:
        return f"<UserPlant(id={self.id}, nickname='{self.nickname}', user_id={self.user_id})>"
</file>

<file path="backend/app/models/user.py">
"""User model and authentication setup.
This module defines the User model and integrates with FastAPI-Users
for authentication and user management.
"""
import uuid
from datetime import datetime
from typing import Optional
from fastapi_users.db import SQLAlchemyBaseUserTableUUID
from sqlalchemy import Boolean, Column, DateTime, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from app.core.database import Base
class User(SQLAlchemyBaseUserTableUUID, Base):
    """User model with authentication and profile information.
    Extends FastAPI-Users base user table with additional fields
    for the plant social platform.
    """
    __tablename__ = "users"
    # Additional profile fields
    username = Column(String(50), unique=True, nullable=False, index=True)
    display_name = Column(String(100), nullable=True)
    bio = Column(Text, nullable=True)
    profile_picture_url = Column(String(500), nullable=True)
    # Plant-specific profile fields
    gardening_experience = Column(String(20), nullable=True)  # beginner, intermediate, expert
    favorite_plants = Column(Text, nullable=True)  # JSON array of plant names
    location = Column(String(100), nullable=True)
    # Privacy and preferences
    is_private = Column(Boolean, default=False)
    allow_plant_identification = Column(Boolean, default=True)
    allow_friend_requests = Column(Boolean, default=True)
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_active = Column(DateTime, nullable=True)
    # Relationships (will be defined in other models)
    # sent_messages = relationship("Message", foreign_keys="Message.sender_id", back_populates="sender")
    # received_messages = relationship("Message", foreign_keys="Message.recipient_id", back_populates="recipient")
    # stories = relationship("Story", back_populates="user")
    # sent_friend_requests = relationship("Friendship", foreign_keys="Friendship.requester_id")
    # received_friend_requests = relationship("Friendship", foreign_keys="Friendship.addressee_id")
    # Plant-related relationships
    plants = relationship("UserPlant", back_populates="user")
    achievements = relationship("UserAchievement", back_populates="user")
    stats = relationship("UserStats", back_populates="user", uselist=False)
    nursery_reviews = relationship("NurseryReview", back_populates="user")
    favorite_nurseries = relationship("UserNurseryFavorite", back_populates="user")
    # RAG-related relationships
    preference_embeddings = relationship("UserPreferenceEmbedding", back_populates="user")
    rag_interactions = relationship("RAGInteraction", back_populates="user")
    knowledge_contributions = relationship("PlantKnowledgeBase", back_populates="author")
    def __repr__(self) -> str:
        """String representation of the user."""
        return f"<User(id={self.id}, username={self.username}, email={self.email})>"
    @property
    def full_name(self) -> str:
        """Get the user's display name or username."""
        return self.display_name or self.username
    def to_dict(self) -> dict:
        """Convert user to dictionary for API responses.
        Returns:
            dict: User data excluding sensitive information
        """
        return {
            "id": str(self.id),
            "username": self.username,
            "display_name": self.display_name,
            "bio": self.bio,
            "profile_picture_url": self.profile_picture_url,
            "gardening_experience": self.gardening_experience,
            "location": self.location,
            "is_private": self.is_private,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_active": self.last_active.isoformat() if self.last_active else None,
        }
    def to_public_dict(self) -> dict:
        """Convert user to public dictionary (limited information).
        Returns:
            dict: Public user data for display to other users
        """
        return {
            "id": str(self.id),
            "username": self.username,
            "display_name": self.display_name,
            "profile_picture_url": self.profile_picture_url,
            "gardening_experience": self.gardening_experience,
            "location": self.location if not self.is_private else None,
        }
</file>

<file path="backend/app/schemas/__init__.py">
"""Schemas package.
This module makes all Pydantic schemas available for import.
"""
from .auth import (
    UserBase,
    UserCreate,
    UserUpdate,
    UserRead,
    UserInDB,
    Token,
    TokenData,
    PasswordReset,
    PasswordResetConfirm,
    EmailVerification,
    ChangePassword,
    LoginRequest,
    RefreshTokenRequest,
    LogoutRequest,
)
from .user import (
    UserBase as UserSchemaBase,
    UserRead as UserSchemaRead,
    UserSearch,
    UserPublicResponse,
    UserUpdate as UserSchemaUpdate,
    UserProfile,
    UserStats,
    UserPreferences,
    UserActivity,
    UserBlock,
    UserReport,
    UserSearchFilters,
    UserBatchOperation,
)
from .message import (
    MessageType,
    MessageStatus,
    MessageBase,
    MessageCreate,
    MessageUpdate,
    MessageRead,
    MessageThread,
    MessageReaction,
    MessageReactionCreate,
    MessageSearch,
    MessageDeliveryStatus,
    MessageBatch,
    PlantIdentificationMessage,
    PlantCareMessage,
    MessageAnalytics,
)
from .story import (
    StoryType,
    StoryPrivacyLevel,
    StoryBase,
    StoryCreate,
    StoryUpdate,
    StoryRead,
    StoryViewCreate,
    StoryView,
    StoryFeed,
    StoryHighlight,
    StoryHighlightCreate,
    StoryHighlightUpdate,
    PlantStoryData,
    StoryAnalytics,
    StorySearch,
    StoryBatch,
)
from .friendship import (
    FriendshipStatus,
    FriendshipBase,
    FriendRequestCreate,
    FriendshipRead,
    FriendshipUpdate,
    FriendProfile,
    FriendsList,
    FriendRequestsList,
    MutualFriends,
    FriendshipStats,
    FriendSuggestion,
    FriendActivity,
    BlockedUser,
    FriendshipSearch,
    FriendshipBatch,
    FriendshipNotification,
    FriendshipAnalytics,
)
from .plant_species import (
    PlantSpeciesBase,
    PlantSpeciesCreate,
    PlantSpeciesUpdate,
    PlantSpeciesResponse,
    PlantSpeciesListResponse,
)
from .user_plant import (
    UserPlantBase,
    UserPlantCreate,
    UserPlantUpdate,
    UserPlantResponse,
    UserPlantListResponse,
    PlantCareReminderResponse,
)
from .plant_care_log import (
    PlantCareLogBase,
    PlantCareLogCreate,
    PlantCareLogUpdate,
    PlantCareLogResponse,
    PlantCareLogListResponse,
    CareTypeStatsResponse,
)
from .plant_identification import (
    PlantIdentificationBase,
    PlantIdentificationCreate,
    PlantIdentificationUpdate,
    PlantIdentificationResponse,
    PlantIdentificationListResponse,
    PlantIdentificationResultResponse,
)
from .plant_trade import (
    PlantTradeBase,
    PlantTradeCreate,
    PlantTradeUpdate,
    PlantTradeResponse,
    PlantTradeListResponse,
    PlantTradeSearchRequest,
    PlantTradeInterestRequest,
)
from .plant_question import (
    PlantQuestionBase,
    PlantQuestionCreate,
    PlantQuestionUpdate,
    PlantAnswerBase,
    PlantAnswerCreate,
    PlantAnswerUpdate,
    PlantAnswerResponse,
    PlantQuestionResponse,
    PlantQuestionListResponse,
    PlantQuestionSearchRequest,
    PlantAnswerVoteRequest,
)
__all__ = [
    # Auth schemas
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserRead",
    "UserInDB",
    "Token",
    "TokenData",
    "PasswordReset",
    "PasswordResetConfirm",
    "EmailVerification",
    "ChangePassword",
    "LoginRequest",
    "RefreshTokenRequest",
    "LogoutRequest",
    # User schemas
    "UserSchemaBase",
    "UserSchemaRead",
    "UserSearch",
    "UserPublicResponse",
    "UserSchemaUpdate",
    "UserProfile",
    "UserStats",
    "UserPreferences",
    "UserActivity",
    "UserBlock",
    "UserReport",
    "UserSearchFilters",
    "UserBatchOperation",
    # Message schemas
    "MessageType",
    "MessageStatus",
    "MessageBase",
    "MessageCreate",
    "MessageUpdate",
    "MessageRead",
    "MessageThread",
    "MessageReaction",
    "MessageReactionCreate",
    "MessageSearch",
    "MessageDeliveryStatus",
    "MessageBatch",
    "PlantIdentificationMessage",
    "PlantCareMessage",
    "MessageAnalytics",
    # Story schemas
    "StoryType",
    "StoryPrivacyLevel",
    "StoryBase",
    "StoryCreate",
    "StoryUpdate",
    "StoryRead",
    "StoryViewCreate",
    "StoryView",
    "StoryFeed",
    "StoryHighlight",
    "StoryHighlightCreate",
    "StoryHighlightUpdate",
    "PlantStoryData",
    "StoryAnalytics",
    "StorySearch",
    "StoryBatch",
    # Friendship schemas
    "FriendshipStatus",
    "FriendshipBase",
    "FriendRequestCreate",
    "FriendshipRead",
    "FriendshipUpdate",
    "FriendProfile",
    "FriendsList",
    "FriendRequestsList",
    "MutualFriends",
    "FriendshipStats",
    "FriendSuggestion",
    "FriendActivity",
    "BlockedUser",
    "FriendshipSearch",
    "FriendshipBatch",
    "FriendshipNotification",
    "FriendshipAnalytics",
    # Plant species schemas
    "PlantSpeciesBase",
    "PlantSpeciesCreate",
    "PlantSpeciesUpdate",
    "PlantSpeciesResponse",
    "PlantSpeciesListResponse",
    # User plant schemas
    "UserPlantBase",
    "UserPlantCreate",
    "UserPlantUpdate",
    "UserPlantResponse",
    "UserPlantListResponse",
    "PlantCareReminderResponse",
    # Plant care log schemas
    "PlantCareLogBase",
    "PlantCareLogCreate",
    "PlantCareLogUpdate",
    "PlantCareLogResponse",
    "PlantCareLogListResponse",
    "CareTypeStatsResponse",
    # Plant identification schemas
    "PlantIdentificationBase",
    "PlantIdentificationCreate",
    "PlantIdentificationUpdate",
    "PlantIdentificationResponse",
    "PlantIdentificationListResponse",
    "PlantIdentificationResultResponse",
    # Plant trade schemas
    "PlantTradeBase",
    "PlantTradeCreate",
    "PlantTradeUpdate",
    "PlantTradeResponse",
    "PlantTradeListResponse",
    "PlantTradeSearchRequest",
    "PlantTradeInterestRequest",
    # Plant question schemas
    "PlantQuestionBase",
    "PlantQuestionCreate",
    "PlantQuestionUpdate",
    "PlantAnswerBase",
    "PlantAnswerCreate",
    "PlantAnswerUpdate",
    "PlantAnswerResponse",
    "PlantQuestionResponse",
    "PlantQuestionListResponse",
    "PlantQuestionSearchRequest",
    "PlantAnswerVoteRequest",
]
</file>

<file path="backend/app/schemas/auth.py">
"""Authentication schemas.
This module defines Pydantic schemas for authentication-related
data validation and serialization.
"""
from typing import Optional
from pydantic import BaseModel, EmailStr, Field, field_validator
from datetime import datetime
class UserBase(BaseModel):
    """Base user schema with common fields."""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=30, pattern=r"^[a-zA-Z0-9_]+$")
    display_name: str = Field(..., min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: bool = False
    show_location: bool = True
    allow_plant_id_requests: bool = True
class UserCreate(UserBase):
    """Schema for user registration."""
    password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Passwords do not match')
        return v
    @field_validator('username')
    @classmethod
    def username_alphanumeric(cls, v):
        if not v.replace('_', '').isalnum():
            raise ValueError('Username must contain only letters, numbers, and underscores')
        return v.lower()
    @field_validator('email')
    @classmethod
    def email_lowercase(cls, v):
        return v.lower()
class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    display_name: Optional[str] = Field(None, min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: Optional[bool] = None
    show_location: Optional[bool] = None
    allow_plant_id_requests: Optional[bool] = None
class UserRead(UserBase):
    """Schema for reading user data."""
    id: str
    is_verified: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime
    model_config = {"from_attributes": True}
class UserInDB(UserRead):
    """Schema for user data stored in database (includes sensitive fields)."""
    hashed_password: str
class Token(BaseModel):
    """Schema for authentication tokens."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: Optional[int] = None
class TokenData(BaseModel):
    """Schema for token payload data."""
    user_id: Optional[str] = None
    username: Optional[str] = None
    exp: Optional[datetime] = None
class PasswordReset(BaseModel):
    """Schema for password reset request."""
    email: EmailStr
    @field_validator('email')
    @classmethod
    def email_lowercase(cls, v):
        return v.lower()
class PasswordResetConfirm(BaseModel):
    """Schema for password reset confirmation."""
    token: str
    new_password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v
class EmailVerification(BaseModel):
    """Schema for email verification."""
    token: str
class ChangePassword(BaseModel):
    """Schema for changing password."""
    current_password: str
    new_password: str = Field(..., min_length=8, max_length=100)
    confirm_password: str = Field(..., min_length=8, max_length=100)
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v
class LoginRequest(BaseModel):
    """Schema for login request."""
    username_or_email: str = Field(..., min_length=3)
    password: str = Field(..., min_length=1)
    remember_me: bool = False
class RefreshTokenRequest(BaseModel):
    """Schema for refresh token request."""
    refresh_token: str
class LogoutRequest(BaseModel):
    """Schema for logout request."""
    refresh_token: Optional[str] = None
    logout_all_devices: bool = False
</file>

<file path="backend/app/schemas/friendship.py">
"""Friendship schemas.
This module defines Pydantic schemas for friendship-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class FriendshipStatus(str, Enum):
    """Enum for friendship status."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    BLOCKED = "blocked"
class FriendshipBase(BaseModel):
    """Base friendship schema with common fields."""
    status: FriendshipStatus
    is_close_friend: bool = False
    created_at: datetime
    updated_at: datetime
class FriendRequestCreate(BaseModel):
    """Schema for creating a friend request."""
    user_id: str
    message: Optional[str] = Field(None, max_length=200)  # Optional message with request
    @validator('message')
    def validate_message(cls, v):
        if v is not None:
            v = v.strip()
            if len(v) == 0:
                return None
        return v
class FriendshipRead(FriendshipBase):
    """Schema for reading friendship data."""
    id: str
    requester_id: str
    addressee_id: str
    # User information for display
    requester_username: Optional[str] = None
    requester_display_name: Optional[str] = None
    requester_avatar_url: Optional[str] = None
    addressee_username: Optional[str] = None
    addressee_display_name: Optional[str] = None
    addressee_avatar_url: Optional[str] = None
    # Request metadata
    request_message: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipUpdate(BaseModel):
    """Schema for updating friendship data."""
    status: Optional[FriendshipStatus] = None
    is_close_friend: Optional[bool] = None
    @validator('status')
    def validate_status_transition(cls, v):
        # Add business logic for valid status transitions if needed
        return v
class FriendProfile(BaseModel):
    """Schema for friend profile information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    # Plant-specific info
    gardening_experience: Optional[str] = None
    favorite_plants: Optional[str] = None
    location: Optional[str] = None
    # Friendship info
    friendship_id: str
    is_close_friend: bool = False
    friends_since: datetime
    # Activity info
    last_active: Optional[datetime] = None
    is_online: bool = False
    # Statistics
    mutual_friends_count: int = 0
    stories_count: int = 0
    class Config:
        from_attributes = True
class FriendsList(BaseModel):
    """Schema for friends list with pagination."""
    friends: List[FriendProfile]
    total_count: int
    close_friends_count: int
    online_friends_count: int
    class Config:
        from_attributes = True
class FriendRequestsList(BaseModel):
    """Schema for friend requests list."""
    pending_requests: List[FriendshipRead]
    sent_requests: List[FriendshipRead]
    total_pending: int
    total_sent: int
    class Config:
        from_attributes = True
class MutualFriends(BaseModel):
    """Schema for mutual friends information."""
    user_id: str
    mutual_friends: List[FriendProfile]
    mutual_friends_count: int
    total_friends_count: int  # Total friends of the user
    class Config:
        from_attributes = True
class FriendshipStats(BaseModel):
    """Schema for friendship statistics."""
    user_id: str
    total_friends: int = 0
    close_friends: int = 0
    pending_requests_received: int = 0
    pending_requests_sent: int = 0
    blocked_users: int = 0
    # Activity stats
    friend_requests_sent_this_week: int = 0
    friend_requests_accepted_this_week: int = 0
    new_friends_this_month: int = 0
    # Plant community stats
    plant_enthusiast_friends: int = 0
    friends_by_experience: dict = {}  # beginner, intermediate, advanced, expert
    friends_by_location: dict = {}
    class Config:
        from_attributes = True
class FriendSuggestion(BaseModel):
    """Schema for friend suggestions."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    # Plant-specific info
    gardening_experience: Optional[str] = None
    favorite_plants: Optional[str] = None
    location: Optional[str] = None
    # Suggestion reasoning
    suggestion_reason: str  # mutual_friends, location, interests, etc.
    mutual_friends_count: int = 0
    compatibility_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    # Additional context
    mutual_friends_preview: Optional[List[str]] = None  # List of mutual friend usernames
    shared_interests: Optional[List[str]] = None
    class Config:
        from_attributes = True
class FriendActivity(BaseModel):
    """Schema for friend activity information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    # Activity info
    activity_type: str  # posted_story, sent_message, plant_identification, etc.
    activity_description: str
    activity_timestamp: datetime
    # Activity data
    story_id: Optional[str] = None
    message_preview: Optional[str] = None
    plant_name: Optional[str] = None
    class Config:
        from_attributes = True
class BlockedUser(BaseModel):
    """Schema for blocked user information."""
    user_id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    # Block info
    blocked_at: datetime
    block_reason: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipSearch(BaseModel):
    """Schema for searching friends."""
    query: str = Field(..., min_length=1, max_length=100)
    status: Optional[FriendshipStatus] = None
    is_close_friend: Optional[bool] = None
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    is_online: Optional[bool] = None
    # Sorting options
    sort_by: str = Field("display_name", pattern=r"^(display_name|username|friends_since|last_active)$")
    sort_order: str = Field("asc", pattern=r"^(asc|desc)$")
    @validator('sort_by')
    def validate_sort_by(cls, v):
        valid_options = ['display_name', 'username', 'friends_since', 'last_active']
        if v not in valid_options:
            raise ValueError(f'Invalid sort_by option. Must be one of: {valid_options}')
        return v
class FriendshipBatch(BaseModel):
    """Schema for batch friendship operations."""
    user_ids: List[str] = Field(..., min_items=1, max_items=50)
    operation: str = Field(..., pattern=r"^(add_to_close_friends|remove_from_close_friends|block|unblock|remove_friend)$")
    @validator('user_ids')
    def validate_unique_user_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('user_ids must be unique')
        return v
    @validator('operation')
    def validate_operation(cls, v):
        valid_operations = [
            'add_to_close_friends', 'remove_from_close_friends', 
            'block', 'unblock', 'remove_friend'
        ]
        if v not in valid_operations:
            raise ValueError(f'Invalid operation. Must be one of: {valid_operations}')
        return v
class FriendshipNotification(BaseModel):
    """Schema for friendship-related notifications."""
    id: str
    user_id: str  # User who will receive the notification
    from_user_id: str  # User who triggered the notification
    notification_type: str  # friend_request, friend_accepted, etc.
    # User info for display
    from_username: str
    from_display_name: str
    from_avatar_url: Optional[str] = None
    # Notification content
    title: str
    message: str
    # Metadata
    is_read: bool = False
    created_at: datetime
    # Related data
    friendship_id: Optional[str] = None
    class Config:
        from_attributes = True
class FriendshipAnalytics(BaseModel):
    """Schema for friendship analytics."""
    user_id: str
    # Growth metrics
    friends_gained_this_week: int = 0
    friends_gained_this_month: int = 0
    friends_lost_this_month: int = 0
    # Engagement metrics
    messages_sent_to_friends: int = 0
    stories_shared_with_friends: int = 0
    friend_stories_viewed: int = 0
    # Network metrics
    network_size: int = 0
    network_density: Optional[float] = None  # How interconnected friend network is
    most_connected_friend: Optional[str] = None  # Friend with most mutual connections
    # Plant community metrics
    plant_friends_percentage: Optional[float] = None
    plant_knowledge_exchanges: int = 0
    class Config:
        from_attributes = True
</file>

<file path="backend/app/schemas/message.py">
"""Message schemas.
This module defines Pydantic schemas for message-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class MessageType(str, Enum):
    """Enum for message content types."""
    TEXT = "text"
    IMAGE = "image"
    VIDEO = "video"
    AUDIO = "audio"
    PLANT_ID = "plant_id"  # Plant identification request/response
    PLANT_CARE = "plant_care"  # Plant care tip
    LOCATION = "location"
class MessageStatus(str, Enum):
    """Enum for message status."""
    SENT = "sent"
    DELIVERED = "delivered"
    READ = "read"
    DELETED = "deleted"
    EXPIRED = "expired"
class MessageBase(BaseModel):
    """Base message schema with common fields."""
    content_type: MessageType
    content: Optional[str] = Field(None, max_length=2000)
    media_url: Optional[str] = None
    caption: Optional[str] = Field(None, max_length=500)
    # Media metadata
    file_size: Optional[int] = Field(None, ge=0)
    duration: Optional[float] = Field(None, ge=0)  # For audio/video in seconds
    # Disappearing message settings
    disappears_at: Optional[int] = Field(None, ge=1, le=604800)  # 1 second to 1 week
    # Plant-specific fields
    plant_data: Optional[dict] = None  # For plant identification results
    care_tip_category: Optional[str] = None  # watering, lighting, fertilizing, etc.
class MessageCreate(MessageBase):
    """Schema for creating a new message."""
    recipient_id: str
    @validator('content')
    def validate_content(cls, v, values):
        content_type = values.get('content_type')
        if content_type == MessageType.TEXT and not v:
            raise ValueError('Text messages must have content')
        return v
    @validator('media_url')
    def validate_media_url(cls, v, values):
        content_type = values.get('content_type')
        if content_type in [MessageType.IMAGE, MessageType.VIDEO, MessageType.AUDIO] and not v:
            raise ValueError(f'{content_type.value} messages must have media_url')
        return v
    @validator('plant_data')
    def validate_plant_data(cls, v, values):
        content_type = values.get('content_type')
        if content_type == MessageType.PLANT_ID and not v:
            raise ValueError('Plant identification messages must have plant_data')
        return v
class MessageUpdate(BaseModel):
    """Schema for updating a message (limited fields)."""
    content: Optional[str] = Field(None, max_length=2000)
    caption: Optional[str] = Field(None, max_length=500)
    status: Optional[MessageStatus] = None
class MessageRead(MessageBase):
    """Schema for reading message data."""
    id: str
    sender_id: str
    recipient_id: str
    status: MessageStatus
    created_at: datetime
    updated_at: datetime
    read_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    # Sender information (for display)
    sender_username: Optional[str] = None
    sender_display_name: Optional[str] = None
    sender_avatar_url: Optional[str] = None
    # Recipient information (for display)
    recipient_username: Optional[str] = None
    recipient_display_name: Optional[str] = None
    recipient_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class MessageThread(BaseModel):
    """Schema for message thread/conversation."""
    participant_id: str
    participant_username: str
    participant_display_name: str
    participant_avatar_url: Optional[str] = None
    # Latest message info
    latest_message: Optional[MessageRead] = None
    latest_message_at: Optional[datetime] = None
    # Thread statistics
    total_messages: int = 0
    unread_count: int = 0
    # Thread settings
    is_muted: bool = False
    is_archived: bool = False
    class Config:
        from_attributes = True
class MessageReaction(BaseModel):
    """Schema for message reactions."""
    message_id: str
    user_id: str
    reaction_type: str = Field(..., pattern=r"^(like|love|laugh|wow|sad|angry|plant)$")
    created_at: datetime
    # User info for display
    user_username: Optional[str] = None
    user_display_name: Optional[str] = None
    user_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class MessageReactionCreate(BaseModel):
    """Schema for creating a message reaction."""
    reaction_type: str = Field(..., pattern=r"^(like|love|laugh|wow|sad|angry|plant)$")
    @validator('reaction_type')
    def validate_reaction_type(cls, v):
        valid_reactions = ['like', 'love', 'laugh', 'wow', 'sad', 'angry', 'plant']
        if v not in valid_reactions:
            raise ValueError(f'Invalid reaction type. Must be one of: {valid_reactions}')
        return v
class MessageSearch(BaseModel):
    """Schema for message search parameters."""
    query: str = Field(..., min_length=1, max_length=100)
    content_type: Optional[MessageType] = None
    sender_id: Optional[str] = None
    date_from: Optional[datetime] = None
    date_to: Optional[datetime] = None
    has_media: Optional[bool] = None
    @validator('date_to')
    def validate_date_range(cls, v, values):
        if v is not None and 'date_from' in values and values['date_from'] is not None:
            if v < values['date_from']:
                raise ValueError('date_to must be after date_from')
        return v
class MessageDeliveryStatus(BaseModel):
    """Schema for message delivery status."""
    message_id: str
    status: MessageStatus
    delivered_at: Optional[datetime] = None
    read_at: Optional[datetime] = None
    failed_reason: Optional[str] = None
    class Config:
        from_attributes = True
class MessageBatch(BaseModel):
    """Schema for batch message operations."""
    message_ids: List[str] = Field(..., min_items=1, max_items=100)
    operation: str = Field(..., pattern=r"^(mark_read|delete|archive)$")
    @validator('message_ids')
    def validate_unique_message_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('message_ids must be unique')
        return v
class PlantIdentificationMessage(BaseModel):
    """Schema for plant identification messages."""
    image_url: str
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    plant_name: Optional[str] = None
    scientific_name: Optional[str] = None
    plant_family: Optional[str] = None
    care_difficulty: Optional[str] = Field(None, pattern=r"^(easy|moderate|difficult)$")
    care_tips: Optional[List[str]] = None
    common_issues: Optional[List[str]] = None
    class Config:
        from_attributes = True
class PlantCareMessage(BaseModel):
    """Schema for plant care tip messages."""
    plant_name: Optional[str] = None
    care_category: str = Field(..., pattern=r"^(watering|lighting|fertilizing|pruning|repotting|pest_control|general)$")
    tip_content: str = Field(..., min_length=10, max_length=1000)
    difficulty_level: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced)$")
    season_specific: Optional[str] = Field(None, pattern=r"^(spring|summer|fall|winter|year_round)$")
    @validator('care_category')
    def validate_care_category(cls, v):
        valid_categories = ['watering', 'lighting', 'fertilizing', 'pruning', 'repotting', 'pest_control', 'general']
        if v not in valid_categories:
            raise ValueError(f'Invalid care category. Must be one of: {valid_categories}')
        return v
class MessageAnalytics(BaseModel):
    """Schema for message analytics."""
    user_id: str
    total_messages_sent: int = 0
    total_messages_received: int = 0
    messages_by_type: dict = {}
    average_response_time_minutes: Optional[float] = None
    most_active_conversation: Optional[str] = None
    plant_messages_sent: int = 0
    plant_identifications_requested: int = 0
    care_tips_shared: int = 0
    class Config:
        from_attributes = True
</file>

<file path="backend/app/schemas/plant_care_log.py">
"""Plant care log Pydantic schemas.
This module defines the Pydantic schemas for plant care log data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
class PlantCareLogBase(BaseModel):
    """Base plant care log schema with common fields."""
    care_type: str = Field(..., min_length=1, max_length=50)
    notes: Optional[str] = None
    performed_at: Optional[datetime] = None
class PlantCareLogCreate(PlantCareLogBase):
    """Schema for creating a new plant care log entry."""
    plant_id: UUID
class PlantCareLogUpdate(BaseModel):
    """Schema for updating a plant care log entry."""
    care_type: Optional[str] = Field(None, min_length=1, max_length=50)
    notes: Optional[str] = None
    performed_at: Optional[datetime] = None
class PlantCareLogResponse(PlantCareLogBase):
    """Schema for plant care log API responses."""
    id: UUID
    plant_id: UUID
    created_at: datetime
    class Config:
        from_attributes = True
class PlantCareLogListResponse(BaseModel):
    """Schema for paginated plant care log list responses."""
    items: List[PlantCareLogResponse]
    total: int
    page: int
    size: int
    pages: int
class CareTypeStatsResponse(BaseModel):
    """Schema for care type statistics responses."""
    care_type: str
    count: int
    last_performed: Optional[datetime]
    average_frequency_days: Optional[float]
</file>

<file path="backend/app/schemas/plant_identification.py">
"""Plant identification Pydantic schemas.
This module defines the Pydantic schemas for plant identification data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
class PlantIdentificationBase(BaseModel):
    """Base plant identification schema with common fields."""
    image_path: str = Field(..., min_length=1, max_length=500)
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    identified_name: Optional[str] = Field(None, max_length=255)
    is_verified: bool = False
    verification_notes: Optional[str] = None
class PlantIdentificationCreate(BaseModel):
    """Schema for creating a new plant identification request."""
    image_path: str = Field(..., min_length=1, max_length=500)
class PlantIdentificationUpdate(BaseModel):
    """Schema for updating a plant identification."""
    species_id: Optional[UUID] = None
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    identified_name: Optional[str] = Field(None, max_length=255)
    is_verified: Optional[bool] = None
    verification_notes: Optional[str] = None
class PlantIdentificationResponse(PlantIdentificationBase):
    """Schema for plant identification API responses."""
    id: UUID
    user_id: UUID
    species_id: Optional[UUID] = None
    species: Optional[PlantSpeciesResponse] = None
    created_at: datetime
    class Config:
        from_attributes = True
class PlantIdentificationListResponse(BaseModel):
    """Schema for paginated plant identification list responses."""
    items: List[PlantIdentificationResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantIdentificationResultResponse(BaseModel):
    """Schema for AI identification result responses."""
    identified_name: str
    confidence_score: float
    species_suggestions: List[PlantSpeciesResponse]
    care_recommendations: Optional[str] = None
</file>

<file path="backend/app/schemas/plant_question.py">
"""Plant question Pydantic schemas.
This module defines the Pydantic schemas for plant question and answer data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
from app.schemas.user import UserPublicResponse
class PlantQuestionBase(BaseModel):
    """Base plant question schema with common fields."""
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=1)
    species_id: Optional[UUID] = None
    image_paths: Optional[str] = None  # JSON array of image paths
    tags: Optional[str] = None  # JSON array of tags
class PlantQuestionCreate(PlantQuestionBase):
    """Schema for creating a new plant question."""
    pass
class PlantQuestionUpdate(BaseModel):
    """Schema for updating a plant question."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    content: Optional[str] = Field(None, min_length=1)
    species_id: Optional[UUID] = None
    image_paths: Optional[str] = None
    tags: Optional[str] = None
    is_solved: Optional[bool] = None
class PlantAnswerBase(BaseModel):
    """Base plant answer schema with common fields."""
    content: str = Field(..., min_length=1)
class PlantAnswerCreate(PlantAnswerBase):
    """Schema for creating a new plant answer."""
    question_id: UUID
class PlantAnswerUpdate(BaseModel):
    """Schema for updating a plant answer."""
    content: Optional[str] = Field(None, min_length=1)
    is_accepted: Optional[bool] = None
class PlantAnswerResponse(PlantAnswerBase):
    """Schema for plant answer API responses."""
    id: UUID
    question_id: UUID
    user_id: UUID
    user: Optional[UserPublicResponse] = None
    is_accepted: bool
    upvotes: int
    downvotes: int
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantQuestionResponse(PlantQuestionBase):
    """Schema for plant question API responses."""
    id: UUID
    user_id: UUID
    user: Optional[UserPublicResponse] = None
    species: Optional[PlantSpeciesResponse] = None
    is_solved: bool
    view_count: int
    answers: List[PlantAnswerResponse] = []
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantQuestionListResponse(BaseModel):
    """Schema for paginated plant question list responses."""
    items: List[PlantQuestionResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantQuestionSearchRequest(BaseModel):
    """Schema for plant question search requests."""
    query: Optional[str] = None
    species_id: Optional[UUID] = None
    tags: Optional[List[str]] = None
    is_solved: Optional[bool] = None
    user_id: Optional[UUID] = None
    page: int = Field(default=1, ge=1)
    size: int = Field(default=20, ge=1, le=100)
class PlantAnswerVoteRequest(BaseModel):
    """Schema for voting on plant answers."""
    vote_type: str = Field(..., pattern="^(upvote|downvote)$")
</file>

<file path="backend/app/schemas/plant_species.py">
"""Plant species Pydantic schemas.
This module defines the Pydantic schemas for plant species data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
class PlantSpeciesBase(BaseModel):
    """Base plant species schema with common fields."""
    scientific_name: str = Field(..., min_length=1, max_length=255)
    common_names: List[str] = Field(default_factory=list)
    family: Optional[str] = Field(None, max_length=100)
    care_level: Optional[str] = Field(None, pattern="^(easy|moderate|difficult)$")
    light_requirements: Optional[str] = Field(None, max_length=50)
    water_frequency_days: Optional[int] = Field(None, ge=1, le=365)
    humidity_preference: Optional[str] = Field(None, max_length=20)
    temperature_range: Optional[str] = Field(None, max_length=50)
    toxicity_info: Optional[str] = None
    care_notes: Optional[str] = None
class PlantSpeciesCreate(PlantSpeciesBase):
    """Schema for creating a new plant species."""
    pass
class PlantSpeciesUpdate(BaseModel):
    """Schema for updating a plant species."""
    scientific_name: Optional[str] = Field(None, min_length=1, max_length=255)
    common_names: Optional[List[str]] = None
    family: Optional[str] = Field(None, max_length=100)
    care_level: Optional[str] = Field(None, pattern="^(easy|moderate|difficult)$")
    light_requirements: Optional[str] = Field(None, max_length=50)
    water_frequency_days: Optional[int] = Field(None, ge=1, le=365)
    humidity_preference: Optional[str] = Field(None, max_length=20)
    temperature_range: Optional[str] = Field(None, max_length=50)
    toxicity_info: Optional[str] = None
    care_notes: Optional[str] = None
class PlantSpeciesResponse(PlantSpeciesBase):
    """Schema for plant species API responses."""
    id: UUID
    created_at: datetime
    class Config:
        from_attributes = True
class PlantSpeciesListResponse(BaseModel):
    """Schema for paginated plant species list responses."""
    items: List[PlantSpeciesResponse]
    total: int
    page: int
    size: int
    pages: int
</file>

<file path="backend/app/schemas/plant_trade.py">
"""Plant trade Pydantic schemas.
This module defines the Pydantic schemas for plant trade data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.models.plant_trade import TradeStatus, TradeType
from app.schemas.plant_species import PlantSpeciesResponse
from app.schemas.user import UserPublicResponse
class PlantTradeBase(BaseModel):
    """Base plant trade schema with common fields."""
    species_id: UUID
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = None
    trade_type: TradeType
    location: Optional[str] = Field(None, max_length=100)
    price: Optional[str] = Field(None, max_length=50)
    image_paths: Optional[str] = None  # JSON array of image paths
class PlantTradeCreate(PlantTradeBase):
    """Schema for creating a new plant trade listing."""
    pass
class PlantTradeUpdate(BaseModel):
    """Schema for updating a plant trade listing."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    trade_type: Optional[TradeType] = None
    status: Optional[TradeStatus] = None
    location: Optional[str] = Field(None, max_length=100)
    price: Optional[str] = Field(None, max_length=50)
    image_paths: Optional[str] = None
    interested_user_id: Optional[UUID] = None
class PlantTradeResponse(PlantTradeBase):
    """Schema for plant trade API responses."""
    id: UUID
    owner_id: UUID
    owner: Optional[UserPublicResponse] = None
    species: Optional[PlantSpeciesResponse] = None
    status: TradeStatus
    interested_user_id: Optional[UUID] = None
    interested_user: Optional[UserPublicResponse] = None
    completed_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class PlantTradeListResponse(BaseModel):
    """Schema for paginated plant trade list responses."""
    items: List[PlantTradeResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantTradeSearchRequest(BaseModel):
    """Schema for plant trade search requests."""
    query: Optional[str] = None
    trade_type: Optional[TradeType] = None
    location: Optional[str] = None
    species_id: Optional[UUID] = None
    max_price: Optional[float] = None
    page: int = Field(default=1, ge=1)
    size: int = Field(default=20, ge=1, le=100)
class PlantTradeInterestRequest(BaseModel):
    """Schema for expressing interest in a plant trade."""
    message: Optional[str] = Field(None, max_length=500)
</file>

<file path="backend/app/schemas/story.py">
"""Story schemas.
This module defines Pydantic schemas for story-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum
class StoryType(str, Enum):
    """Enum for story content types."""
    IMAGE = "image"
    VIDEO = "video"
    PLANT_SHOWCASE = "plant_showcase"  # Special plant-focused story
    PLANT_TIMELAPSE = "plant_timelapse"  # Plant growth timelapse
    GARDEN_TOUR = "garden_tour"  # Garden/collection showcase
class StoryPrivacyLevel(str, Enum):
    """Enum for story privacy levels."""
    PUBLIC = "public"
    FRIENDS = "friends"
    CLOSE_FRIENDS = "close_friends"
    PLANT_COMMUNITY = "plant_community"  # Visible to plant enthusiasts
class StoryBase(BaseModel):
    """Base story schema with common fields."""
    content_type: StoryType
    media_url: str
    caption: Optional[str] = Field(None, max_length=500)
    # Media metadata
    file_size: Optional[int] = Field(None, ge=0)
    duration: Optional[float] = Field(None, ge=0)  # For videos in seconds
    # Privacy settings
    privacy_level: StoryPrivacyLevel = StoryPrivacyLevel.FRIENDS
    # Plant-specific fields
    plant_data: Optional[dict] = None  # Plant identification/info
    plant_tags: Optional[List[str]] = None  # Plant-related hashtags
    care_tip: Optional[str] = Field(None, max_length=200)  # Quick care tip
    location_tag: Optional[str] = Field(None, max_length=100)  # Garden location
class StoryCreate(StoryBase):
    """Schema for creating a new story."""
    @validator('media_url')
    def validate_media_url(cls, v):
        if not v or not v.strip():
            raise ValueError('media_url is required')
        return v
    @validator('duration')
    def validate_duration(cls, v, values):
        content_type = values.get('content_type')
        if content_type == StoryType.VIDEO and v is None:
            raise ValueError('Video stories must have duration')
        if v is not None and v > 60:  # Max 60 seconds for stories
            raise ValueError('Story duration cannot exceed 60 seconds')
        return v
    @validator('plant_tags')
    def validate_plant_tags(cls, v):
        if v is not None:
            if len(v) > 10:
                raise ValueError('Maximum 10 plant tags allowed')
            for tag in v:
                if len(tag) > 30:
                    raise ValueError('Plant tags must be 30 characters or less')
        return v
class StoryUpdate(BaseModel):
    """Schema for updating a story (limited fields)."""
    caption: Optional[str] = Field(None, max_length=500)
    privacy_level: Optional[StoryPrivacyLevel] = None
    plant_tags: Optional[List[str]] = None
    care_tip: Optional[str] = Field(None, max_length=200)
    @validator('plant_tags')
    def validate_plant_tags(cls, v):
        if v is not None:
            if len(v) > 10:
                raise ValueError('Maximum 10 plant tags allowed')
            for tag in v:
                if len(tag) > 30:
                    raise ValueError('Plant tags must be 30 characters or less')
        return v
class StoryRead(StoryBase):
    """Schema for reading story data."""
    id: str
    user_id: str
    created_at: datetime
    expires_at: datetime
    is_active: bool
    view_count: int = 0
    # User information (for display)
    user_username: Optional[str] = None
    user_display_name: Optional[str] = None
    user_avatar_url: Optional[str] = None
    # Viewer-specific data
    has_viewed: Optional[bool] = None
    viewed_at: Optional[datetime] = None
    # Story analytics (for owner)
    unique_viewers: Optional[int] = None
    total_screenshots: Optional[int] = None
    class Config:
        from_attributes = True
class StoryViewCreate(BaseModel):
    """Schema for creating a story view."""
    story_id: str
    # Optional metadata
    view_duration: Optional[float] = Field(None, ge=0)  # How long they viewed
    screenshot_taken: bool = False
class StoryView(BaseModel):
    """Schema for story view data."""
    id: str
    story_id: str
    viewer_id: str
    viewed_at: datetime
    view_duration: Optional[float] = None
    screenshot_taken: bool = False
    # Viewer information (for story owner)
    viewer_username: Optional[str] = None
    viewer_display_name: Optional[str] = None
    viewer_avatar_url: Optional[str] = None
    class Config:
        from_attributes = True
class StoryFeed(BaseModel):
    """Schema for story feed data."""
    user_id: str
    user_username: str
    user_display_name: str
    user_avatar_url: Optional[str] = None
    # Story ring info
    has_unviewed_stories: bool = False
    total_stories: int = 0
    latest_story_at: Optional[datetime] = None
    # Stories list (if expanded)
    stories: Optional[List[StoryRead]] = None
    class Config:
        from_attributes = True
class StoryHighlight(BaseModel):
    """Schema for story highlights (saved stories)."""
    id: str
    user_id: str
    title: str = Field(..., min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: List[str] = Field(..., min_items=1, max_items=100)
    created_at: datetime
    updated_at: datetime
    # Display info
    story_count: int = 0
    class Config:
        from_attributes = True
class StoryHighlightCreate(BaseModel):
    """Schema for creating a story highlight."""
    title: str = Field(..., min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: List[str] = Field(..., min_items=1, max_items=100)
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
class StoryHighlightUpdate(BaseModel):
    """Schema for updating a story highlight."""
    title: Optional[str] = Field(None, min_length=1, max_length=50)
    cover_image_url: Optional[str] = None
    story_ids: Optional[List[str]] = Field(None, min_items=1, max_items=100)
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if v is not None and len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
class PlantStoryData(BaseModel):
    """Schema for plant-specific story data."""
    plant_name: Optional[str] = None
    scientific_name: Optional[str] = None
    plant_age: Optional[str] = None  # "2 months", "1 year", etc.
    growth_stage: Optional[str] = Field(None, pattern=r"^(seedling|juvenile|mature|flowering|fruiting)$")
    care_difficulty: Optional[str] = Field(None, pattern=r"^(easy|moderate|difficult)$")
    # Care information
    watering_frequency: Optional[str] = None
    light_requirements: Optional[str] = None
    soil_type: Optional[str] = None
    # Progress tracking
    is_before_after: bool = False
    progress_description: Optional[str] = Field(None, max_length=200)
    class Config:
        from_attributes = True
class StoryAnalytics(BaseModel):
    """Schema for story analytics."""
    story_id: str
    total_views: int = 0
    unique_viewers: int = 0
    view_completion_rate: Optional[float] = None  # Percentage who watched full video
    screenshots_taken: int = 0
    shares_count: int = 0
    # Viewer demographics
    viewers_by_experience: dict = {}  # beginner, intermediate, advanced, expert
    viewers_by_location: dict = {}
    # Engagement metrics
    average_view_duration: Optional[float] = None
    peak_viewing_time: Optional[datetime] = None
    class Config:
        from_attributes = True
class StorySearch(BaseModel):
    """Schema for story search parameters."""
    query: Optional[str] = Field(None, min_length=1, max_length=100)
    content_type: Optional[StoryType] = None
    privacy_level: Optional[StoryPrivacyLevel] = None
    plant_tags: Optional[List[str]] = None
    user_id: Optional[str] = None
    date_from: Optional[datetime] = None
    date_to: Optional[datetime] = None
    has_plant_data: Optional[bool] = None
    @validator('date_to')
    def validate_date_range(cls, v, values):
        if v is not None and 'date_from' in values and values['date_from'] is not None:
            if v < values['date_from']:
                raise ValueError('date_to must be after date_from')
        return v
class StoryBatch(BaseModel):
    """Schema for batch story operations."""
    story_ids: List[str] = Field(..., min_items=1, max_items=50)
    operation: str = Field(..., pattern=r"^(delete|archive|add_to_highlight)$")
    highlight_id: Optional[str] = None  # Required for add_to_highlight operation
    @validator('story_ids')
    def validate_unique_story_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('story_ids must be unique')
        return v
    @validator('highlight_id')
    def validate_highlight_id(cls, v, values):
        operation = values.get('operation')
        if operation == 'add_to_highlight' and not v:
            raise ValueError('highlight_id is required for add_to_highlight operation')
        return v
</file>

<file path="backend/app/schemas/user_plant.py">
"""User plant Pydantic schemas.
This module defines the Pydantic schemas for user plant data
validation and serialization in API requests and responses.
"""
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field
from app.schemas.plant_species import PlantSpeciesResponse
class UserPlantBase(BaseModel):
    """Base user plant schema with common fields."""
    species_id: UUID
    nickname: Optional[str] = Field(None, max_length=100)
    location: Optional[str] = Field(None, max_length=100)
    acquired_date: Optional[datetime] = None
    last_watered: Optional[datetime] = None
    last_fertilized: Optional[datetime] = None
    last_repotted: Optional[datetime] = None
    health_status: str = Field(default="healthy", pattern="^(healthy|sick|recovering|dead)$")
    notes: Optional[str] = None
    is_active: bool = True
class UserPlantCreate(UserPlantBase):
    """Schema for creating a new user plant."""
    pass
class UserPlantUpdate(BaseModel):
    """Schema for updating a user plant."""
    nickname: Optional[str] = Field(None, max_length=100)
    location: Optional[str] = Field(None, max_length=100)
    acquired_date: Optional[datetime] = None
    last_watered: Optional[datetime] = None
    last_fertilized: Optional[datetime] = None
    last_repotted: Optional[datetime] = None
    health_status: Optional[str] = Field(None, pattern="^(healthy|sick|recovering|dead)$")
    notes: Optional[str] = None
    is_active: Optional[bool] = None
class UserPlantResponse(UserPlantBase):
    """Schema for user plant API responses."""
    id: UUID
    user_id: UUID
    species: Optional[PlantSpeciesResponse] = None
    created_at: datetime
    updated_at: datetime
    class Config:
        from_attributes = True
class UserPlantListResponse(BaseModel):
    """Schema for paginated user plant list responses."""
    items: List[UserPlantResponse]
    total: int
    page: int
    size: int
    pages: int
class PlantCareReminderResponse(BaseModel):
    """Schema for plant care reminder responses."""
    plant_id: UUID
    plant_nickname: Optional[str]
    species_name: str
    care_type: str
    days_overdue: int
    last_care_date: Optional[datetime]
    recommended_frequency_days: Optional[int]
</file>

<file path="backend/app/schemas/user.py">
"""User schemas.
This module defines Pydantic schemas for user-related
data validation and serialization.
"""
from typing import Optional, List
from pydantic import BaseModel, Field, validator
from datetime import datetime
class UserBase(BaseModel):
    """Base user schema with common fields."""
    username: str = Field(..., min_length=3, max_length=30)
    display_name: str = Field(..., min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: bool = False
    show_location: bool = True
    allow_plant_id_requests: bool = True
class UserRead(UserBase):
    """Schema for reading user data (public view)."""
    id: str
    email: str  # Only shown to the user themselves or friends
    is_verified: bool
    is_active: bool
    created_at: datetime
    updated_at: datetime
    # Statistics (computed fields)
    friends_count: Optional[int] = None
    stories_count: Optional[int] = None
    class Config:
        from_attributes = True
class UserSearch(BaseModel):
    """Schema for user search results (limited public info)."""
    id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    gardening_experience: Optional[str] = None
    is_verified: bool = False
    is_private: bool = False
    # Friendship status (computed field)
    friendship_status: Optional[str] = None  # none, pending, accepted, blocked
    is_close_friend: Optional[bool] = None
    class Config:
        from_attributes = True
class UserPublicResponse(BaseModel):
    """Schema for public user information in API responses."""
    id: str
    username: str
    display_name: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    is_verified: bool = False
    class Config:
        from_attributes = True
class UserUpdate(BaseModel):
    """Schema for updating user profile."""
    display_name: Optional[str] = Field(None, min_length=1, max_length=50)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    # Plant-specific fields
    gardening_experience: Optional[str] = Field(None, pattern=r"^(beginner|intermediate|advanced|expert)$")
    favorite_plants: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    # Privacy settings
    is_private: Optional[bool] = None
    show_location: Optional[bool] = None
    allow_plant_id_requests: Optional[bool] = None
    @validator('gardening_experience')
    def validate_experience(cls, v):
        if v is not None:
            valid_levels = ['beginner', 'intermediate', 'advanced', 'expert']
            if v not in valid_levels:
                raise ValueError(f'Invalid gardening experience. Must be one of: {valid_levels}')
        return v
class UserProfile(UserRead):
    """Schema for detailed user profile (includes private info for owner)."""
    email: str
    phone_number: Optional[str] = None
    # Additional statistics
    total_messages_sent: Optional[int] = None
    total_stories_posted: Optional[int] = None
    account_created_days_ago: Optional[int] = None
    # Privacy and security
    two_factor_enabled: bool = False
    email_notifications: bool = True
    push_notifications: bool = True
    class Config:
        from_attributes = True
class UserStats(BaseModel):
    """Schema for user statistics."""
    user_id: str
    friends_count: int = 0
    close_friends_count: int = 0
    stories_count: int = 0
    active_stories_count: int = 0
    total_messages_sent: int = 0
    total_messages_received: int = 0
    account_age_days: int = 0
    last_active: Optional[datetime] = None
    # Plant-specific stats
    plants_identified: int = 0
    plant_care_tips_shared: int = 0
    plant_photos_shared: int = 0
class UserPreferences(BaseModel):
    """Schema for user preferences and settings."""
    # Notification preferences
    email_notifications: bool = True
    push_notifications: bool = True
    friend_request_notifications: bool = True
    message_notifications: bool = True
    story_notifications: bool = True
    # Privacy preferences
    discoverable_by_email: bool = True
    discoverable_by_username: bool = True
    show_online_status: bool = True
    # Plant-specific preferences
    auto_plant_identification: bool = True
    share_plant_care_tips: bool = True
    receive_plant_recommendations: bool = True
    # Content preferences
    content_language: str = "en"
    timezone: str = "UTC"
    class Config:
        from_attributes = True
class UserActivity(BaseModel):
    """Schema for user activity tracking."""
    user_id: str
    activity_type: str  # login, logout, message_sent, story_posted, etc.
    activity_data: Optional[dict] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    timestamp: datetime
    class Config:
        from_attributes = True
class UserBlock(BaseModel):
    """Schema for user blocking information."""
    blocked_user_id: str
    blocked_user: UserSearch
    blocked_at: datetime
    reason: Optional[str] = None
    class Config:
        from_attributes = True
class UserReport(BaseModel):
    """Schema for reporting users."""
    reported_user_id: str
    reason: str = Field(..., min_length=1, max_length=500)
    category: str = Field(..., pattern=r"^(spam|harassment|inappropriate_content|fake_account|other)$")
    additional_info: Optional[str] = Field(None, max_length=1000)
    @validator('category')
    def validate_category(cls, v):
        valid_categories = ['spam', 'harassment', 'inappropriate_content', 'fake_account', 'other']
        if v not in valid_categories:
            raise ValueError(f'Invalid report category. Must be one of: {valid_categories}')
        return v
class UserSearchFilters(BaseModel):
    """Schema for user search filters."""
    query: str = Field(..., min_length=2, max_length=100)
    gardening_experience: Optional[str] = None
    location: Optional[str] = None
    has_avatar: Optional[bool] = None
    is_verified: Optional[bool] = None
    min_friends_count: Optional[int] = Field(None, ge=0)
    max_friends_count: Optional[int] = Field(None, ge=0)
    @validator('max_friends_count')
    def validate_friends_count_range(cls, v, values):
        if v is not None and 'min_friends_count' in values and values['min_friends_count'] is not None:
            if v < values['min_friends_count']:
                raise ValueError('max_friends_count must be greater than or equal to min_friends_count')
        return v
class UserBatchOperation(BaseModel):
    """Schema for batch operations on users."""
    user_ids: List[str] = Field(..., min_items=1, max_items=100)
    operation: str = Field(..., pattern=r"^(block|unblock|add_friend|remove_friend)$")
    @validator('user_ids')
    def validate_unique_user_ids(cls, v):
        if len(v) != len(set(v)):
            raise ValueError('user_ids must be unique')
        return v
</file>

<file path="backend/app/services/__init__.py">
"""Services package.
This package contains business logic services for the application.
"""
# Plant services
from .plant_species_service import (
    PlantSpeciesService,
    get_species_by_id,
    get_species_by_scientific_name,
    search_species,
    create_species,
    update_species,
    get_popular_species
)
from .user_plant_service import (
    UserPlantService,
    get_plant_by_id,
    get_user_plants,
    create_plant,
    update_plant,
    get_care_reminders,
    update_care_activity,
    get_plant_stats
)
from .plant_care_log_service import (
    PlantCareLogService,
    create_care_log,
    get_care_log_by_id,
    get_plant_care_logs,
    get_user_care_logs,
    get_care_statistics
)
from .plant_identification_service import (
    PlantIdentificationService,
    create_identification,
    get_identification_by_id,
    get_user_identifications,
    verify_identification,
    get_pending_verifications,
    get_identification_statistics
)
from .plant_trade_service import (
    PlantTradeService,
    create_trade,
    get_trade_by_id,
    search_trades,
    express_interest,
    get_trade_statistics
)
from .plant_question_service import (
    PlantQuestionService,
    PlantAnswerService,
    create_question,
    get_question_by_id,
    search_questions,
    create_answer,
    vote_answer,
    mark_question_solved
)
__all__ = [
    # Plant species
    "PlantSpeciesService",
    "get_species_by_id",
    "get_species_by_scientific_name",
    "search_species",
    "create_species",
    "update_species",
    "get_popular_species",
    # User plants
    "UserPlantService",
    "get_plant_by_id",
    "get_user_plants",
    "create_plant",
    "update_plant",
    "get_care_reminders",
    "update_care_activity",
    "get_plant_stats",
    # Plant care logs
    "PlantCareLogService",
    "create_care_log",
    "get_care_log_by_id",
    "get_plant_care_logs",
    "get_user_care_logs",
    "get_care_statistics",
    # Plant identification
    "PlantIdentificationService",
    "create_identification",
    "get_identification_by_id",
    "get_user_identifications",
    "verify_identification",
    "get_pending_verifications",
    "get_identification_statistics",
    # Plant trades
    "PlantTradeService",
    "create_trade",
    "get_trade_by_id",
    "search_trades",
    "express_interest",
    "get_trade_statistics",
    # Plant questions and answers
    "PlantQuestionService",
    "PlantAnswerService",
    "create_question",
    "get_question_by_id",
    "search_questions",
    "create_answer",
    "vote_answer",
    "mark_question_solved",
]
</file>

<file path="backend/app/services/auth_service.py">
"""Authentication service.
This module provides authentication and user management services
using FastAPI-Users and custom business logic.
"""
import uuid
from typing import Optional, Dict, Any, AsyncGenerator
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from fastapi_users import BaseUserManager, UUIDIDMixin
from fastapi_users.db import SQLAlchemyUserDatabase
from fastapi_users.password import PasswordHelper
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from jose import JWTError, jwt
from passlib.context import CryptContext
import redis.asyncio as redis
from app.core.config import settings
from app.core.database import AsyncSessionLocal
from app.models.user import User
from app.schemas.auth import UserCreate, UserUpdate
class UserManager(UUIDIDMixin, BaseUserManager[User, uuid.UUID]):
    """Custom user manager for handling user operations."""
    reset_password_token_secret = settings.SECRET_KEY
    verification_token_secret = settings.SECRET_KEY
    async def on_after_register(self, user: User, request: Optional[Any] = None):
        """Called after user registration."""
        print(f"User {user.id} has registered.")
        # Here you can add logic like sending welcome email,
        # creating default user preferences, etc.
    async def on_after_login(
        self,
        user: User,
        request: Optional[Any] = None,
        response: Optional[Any] = None,
    ):
        """Called after user login."""
        print(f"User {user.id} logged in.")
        # Update last login timestamp
        user.last_login = datetime.utcnow()
        # Note: You'll need to commit this change in the calling code
    async def on_after_update(
        self,
        user: User,
        update_dict: Dict[str, Any],
        request: Optional[Any] = None,
    ):
        """Called after user update."""
        print(f"User {user.id} has been updated with {update_dict}.")
    async def on_after_request_verify(
        self, user: User, token: str, request: Optional[Any] = None
    ):
        """Called after verification request."""
        print(f"Verification requested for user {user.id}. Token: {token}")
        # Here you would send verification email
    async def on_after_verify(
        self, user: User, request: Optional[Any] = None
    ):
        """Called after user verification."""
        print(f"User {user.id} has been verified")
    async def validate_password(
        self,
        password: str,
        user: UserCreate | User,
    ) -> None:
        """Validate password strength."""
        if len(password) < 8:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must be at least 8 characters long"
            )
        # Check for at least one uppercase letter
        if not any(c.isupper() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one uppercase letter"
            )
        # Check for at least one lowercase letter
        if not any(c.islower() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one lowercase letter"
            )
        # Check for at least one digit
        if not any(c.isdigit() for c in password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must contain at least one digit"
            )
        # Check if password contains user's email or username
        if hasattr(user, 'email') and user.email:
            if user.email.lower() in password.lower():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Password cannot contain your email address"
                )
        if hasattr(user, 'username') and user.username:
            if user.username.lower() in password.lower():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Password cannot contain your username"
                )
async def get_user_db() -> AsyncGenerator[SQLAlchemyUserDatabase, None]:
    """Get user database dependency."""
    async with AsyncSessionLocal() as session:
        yield SQLAlchemyUserDatabase(session, User)
async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):
    """Get user manager dependency."""
    yield UserManager(user_db)
class AuthService:
    """Authentication service for custom auth operations."""
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.redis_client = None
    async def get_redis_client(self):
        """Get Redis client for session management."""
        if not self.redis_client:
            self.redis_client = redis.from_url(
                settings.REDIS_URL,
                encoding="utf-8",
                decode_responses=True
            )
        return self.redis_client
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash."""
        return self.pwd_context.verify(plain_password, hashed_password)
    def get_password_hash(self, password: str) -> str:
        """Hash a password."""
        return self.pwd_context.hash(password)
    def create_access_token(
        self, 
        data: dict, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """Create JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(
            to_encode, 
            settings.SECRET_KEY, 
            algorithm=settings.ALGORITHM
        )
        return encoded_jwt
    def create_refresh_token(
        self, 
        data: dict, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """Create JWT refresh token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(days=7)  # Refresh tokens last 7 days
        to_encode.update({"exp": expire, "type": "refresh"})
        encoded_jwt = jwt.encode(
            to_encode, 
            settings.SECRET_KEY, 
            algorithm=settings.ALGORITHM
        )
        return encoded_jwt
    async def verify_token(self, token: str) -> Optional[dict]:
        """Verify and decode JWT token."""
        try:
            payload = jwt.decode(
                token, 
                settings.SECRET_KEY, 
                algorithms=[settings.ALGORITHM]
            )
            return payload
        except JWTError:
            return None
    async def store_refresh_token(
        self, 
        user_id: str, 
        refresh_token: str, 
        expires_in: int = 7 * 24 * 60 * 60  # 7 days in seconds
    ):
        """Store refresh token in Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        await redis_client.setex(key, expires_in, refresh_token)
    async def get_stored_refresh_token(self, user_id: str) -> Optional[str]:
        """Get stored refresh token from Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        return await redis_client.get(key)
    async def revoke_refresh_token(self, user_id: str):
        """Revoke refresh token by deleting from Redis."""
        redis_client = await self.get_redis_client()
        key = f"refresh_token:{user_id}"
        await redis_client.delete(key)
    async def store_user_session(
        self, 
        user_id: str, 
        session_data: dict, 
        expires_in: int = 24 * 60 * 60  # 24 hours
    ):
        """Store user session data in Redis."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        await redis_client.setex(key, expires_in, str(session_data))
    async def get_user_session(self, user_id: str) -> Optional[dict]:
        """Get user session data from Redis."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        session_data = await redis_client.get(key)
        if session_data:
            try:
                return eval(session_data)  # Note: In production, use json.loads
            except:
                return None
        return None
    async def revoke_user_session(self, user_id: str):
        """Revoke user session."""
        redis_client = await self.get_redis_client()
        key = f"user_session:{user_id}"
        await redis_client.delete(key)
    async def is_user_online(self, user_id: str) -> bool:
        """Check if user is currently online."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        return await redis_client.exists(key) > 0
    async def set_user_online(
        self, 
        user_id: str, 
        expires_in: int = 5 * 60  # 5 minutes
    ):
        """Mark user as online."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        await redis_client.setex(key, expires_in, "1")
    async def set_user_offline(self, user_id: str):
        """Mark user as offline."""
        redis_client = await self.get_redis_client()
        key = f"user_online:{user_id}"
        await redis_client.delete(key)
    async def get_user_by_email(
        self, 
        email: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by email address."""
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()
    async def get_user_by_username(
        self, 
        username: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by username."""
        result = await session.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()
    async def check_username_availability(
        self, 
        username: str, 
        session: AsyncSession,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if username is available."""
        query = select(User).where(User.username == username)
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        result = await session.execute(query)
        return result.scalar_one_or_none() is None
    async def check_email_availability(
        self, 
        email: str, 
        session: AsyncSession,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if email is available."""
        query = select(User).where(User.email == email)
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        result = await session.execute(query)
        return result.scalar_one_or_none() is None
    async def update_last_active(
        self, 
        user_id: str, 
        session: AsyncSession
    ):
        """Update user's last active timestamp."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if user:
            user.last_active = datetime.utcnow()
            await session.commit()
    async def authenticate_user(
        self, 
        username: str, 
        password: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Authenticate user with username/email and password."""
        # Try to find user by username or email
        user = await self.get_user_by_username(username, session)
        if not user:
            user = await self.get_user_by_email(username, session)
        if not user:
            return None
        if not self.verify_password(password, user.hashed_password):
            return None
        return user
    async def get_current_user(
        self, 
        token: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get current user from JWT token."""
        payload = await self.verify_token(token)
        if not payload:
            return None
        user_id = payload.get("sub")
        if not user_id:
            return None
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()
    async def verify_refresh_token(
        self, 
        token: str
    ) -> Optional[dict]:
        """Verify refresh token and return payload."""
        payload = await self.verify_token(token)
        if not payload or payload.get("type") != "refresh":
            return None
        return payload
    async def get_current_user_from_token(self, token: str, session: AsyncSession) -> Optional[User]:
        """Get current user from token without Bearer prefix."""
        return await self.get_current_user(token, session)
    async def close(self):
        """Close Redis connection."""
        if self.redis_client:
            await self.redis_client.close()
# Global auth service instance
auth_service = AuthService()
async def get_auth_service() -> AuthService:
    """Get auth service dependency."""
    return auth_service
async def get_current_user_from_token(token: str, session: AsyncSession) -> Optional[User]:
    """Get current user from token without Bearer prefix."""
    return await auth_service.get_current_user_from_token(token, session)
</file>

<file path="backend/app/services/file_service.py">
"""File upload and media management service.
This module handles file uploads, media processing, and storage
for the messaging and story features.
"""
import os
import uuid
import mimetypes
from typing import Optional, Tuple
from pathlib import Path
from fastapi import UploadFile, HTTPException, status
from PIL import Image
import aiofiles
from app.core.config import settings
class FileService:
    """Service for handling file uploads and media processing."""
    def __init__(self):
        self.upload_dir = Path("uploads")
        self.max_file_size = 50 * 1024 * 1024  # 50MB
        self.allowed_image_types = {"image/jpeg", "image/png", "image/gif", "image/webp"}
        self.allowed_video_types = {"video/mp4", "video/quicktime", "video/x-msvideo"}
        self.allowed_audio_types = {"audio/mpeg", "audio/wav", "audio/ogg"}
        # Create upload directories
        self._create_upload_directories()
    def _create_upload_directories(self) -> None:
        """Create necessary upload directories."""
        directories = [
            self.upload_dir / "images",
            self.upload_dir / "videos", 
            self.upload_dir / "audio",
            self.upload_dir / "thumbnails"
        ]
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
    async def upload_media_file(
        self, 
        file: UploadFile
    ) -> Tuple[str, int, Optional[int]]:
        """Upload a media file and return URL, file size, and duration.
        Args:
            file: The uploaded file
        Returns:
            Tuple of (media_url, file_size, duration)
        Raises:
            HTTPException: If file validation fails
        """
        # Validate file
        await self._validate_file(file)
        # Generate unique filename
        file_extension = Path(file.filename).suffix.lower()
        unique_filename = f"{uuid.uuid4()}{file_extension}"
        # Determine file type and subdirectory
        content_type = file.content_type
        if content_type in self.allowed_image_types:
            subdirectory = "images"
        elif content_type in self.allowed_video_types:
            subdirectory = "videos"
        elif content_type in self.allowed_audio_types:
            subdirectory = "audio"
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Unsupported file type"
            )
        # Save file
        file_path = self.upload_dir / subdirectory / unique_filename
        file_size = await self._save_file(file, file_path)
        # Process file based on type
        duration = None
        if content_type in self.allowed_image_types:
            await self._process_image(file_path)
        elif content_type in self.allowed_video_types:
            duration = await self._process_video(file_path)
        elif content_type in self.allowed_audio_types:
            duration = await self._process_audio(file_path)
        # Return relative URL for the file
        media_url = f"/uploads/{subdirectory}/{unique_filename}"
        return media_url, file_size, duration
    async def _validate_file(self, file: UploadFile) -> None:
        """Validate uploaded file.
        Args:
            file: The uploaded file
        Raises:
            HTTPException: If validation fails
        """
        if not file.filename:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No file provided"
            )
        # Check file size
        file.file.seek(0, 2)  # Seek to end
        file_size = file.file.tell()
        file.file.seek(0)  # Reset to beginning
        if file_size > self.max_file_size:
            raise HTTPException(
                status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
                detail=f"File too large. Maximum size is {self.max_file_size // (1024*1024)}MB"
            )
        # Check content type
        content_type = file.content_type
        allowed_types = (
            self.allowed_image_types | 
            self.allowed_video_types | 
            self.allowed_audio_types
        )
        if content_type not in allowed_types:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Unsupported file type: {content_type}"
            )
    async def _save_file(self, file: UploadFile, file_path: Path) -> int:
        """Save uploaded file to disk.
        Args:
            file: The uploaded file
            file_path: Path where to save the file
        Returns:
            File size in bytes
        """
        file_size = 0
        async with aiofiles.open(file_path, 'wb') as f:
            while chunk := await file.read(8192):  # Read in 8KB chunks
                await f.write(chunk)
                file_size += len(chunk)
        return file_size
    async def _process_image(self, file_path: Path) -> None:
        """Process uploaded image (resize, optimize).
        Args:
            file_path: Path to the image file
        """
        try:
            with Image.open(file_path) as img:
                # Convert to RGB if necessary
                if img.mode in ('RGBA', 'LA', 'P'):
                    img = img.convert('RGB')
                # Resize if too large (max 1920x1920)
                max_size = (1920, 1920)
                if img.size[0] > max_size[0] or img.size[1] > max_size[1]:
                    img.thumbnail(max_size, Image.Resampling.LANCZOS)
                # Save optimized version
                img.save(file_path, optimize=True, quality=85)
                # Create thumbnail
                thumbnail_path = (
                    self.upload_dir / "thumbnails" / 
                    f"thumb_{file_path.name}"
                )
                img.thumbnail((300, 300), Image.Resampling.LANCZOS)
                img.save(thumbnail_path, optimize=True, quality=80)
        except Exception as e:
            # If image processing fails, keep original file
            print(f"Image processing failed for {file_path}: {e}")
    async def _process_video(self, file_path: Path) -> Optional[int]:
        """Process uploaded video (get duration, create thumbnail).
        Args:
            file_path: Path to the video file
        Returns:
            Video duration in seconds
        """
        # For now, return None as duration
        # In a production app, you'd use ffmpeg to get duration and create thumbnails
        return None
    async def _process_audio(self, file_path: Path) -> Optional[int]:
        """Process uploaded audio (get duration).
        Args:
            file_path: Path to the audio file
        Returns:
            Audio duration in seconds
        """
        # For now, return None as duration
        # In a production app, you'd use ffmpeg or similar to get duration
        return None
    async def delete_file(self, file_url: str) -> bool:
        """Delete a file from storage.
        Args:
            file_url: URL of the file to delete
        Returns:
            True if file was deleted, False otherwise
        """
        try:
            # Convert URL to file path
            if file_url.startswith("/uploads/"):
                relative_path = file_url[1:]  # Remove leading slash
                file_path = Path(relative_path)
                if file_path.exists():
                    file_path.unlink()
                    # Also delete thumbnail if it exists
                    if file_path.parent.name in ["images", "videos"]:
                        thumbnail_path = (
                            self.upload_dir / "thumbnails" / 
                            f"thumb_{file_path.name}"
                        )
                        if thumbnail_path.exists():
                            thumbnail_path.unlink()
                    return True
            return False
        except Exception as e:
            print(f"Error deleting file {file_url}: {e}")
            return False
# Global instance
file_service = FileService()
# Convenience functions for backward compatibility
async def upload_media_file(file: UploadFile) -> Tuple[str, int, Optional[int]]:
    """Upload a media file.
    Args:
        file: The uploaded file
    Returns:
        Tuple of (media_url, file_size, duration)
    """
    return await file_service.upload_media_file(file)
async def delete_media_file(file_url: str) -> bool:
    """Delete a media file.
    Args:
        file_url: URL of the file to delete
    Returns:
        True if file was deleted, False otherwise
    """
    return await file_service.delete_file(file_url)
</file>

<file path="backend/app/services/friendship_service.py">
"""Friendship service.
This module provides friendship management services including
friend requests, friend management, and social features.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.friendship import Friendship, FriendshipStatus
from app.models.user import User
from app.schemas.friendship import (
    FriendRequestCreate, FriendshipUpdate, FriendProfile,
    FriendsList, FriendRequestsList, MutualFriends,
    FriendshipStats, FriendSuggestion, FriendActivity
)
from app.core.websocket import websocket_manager
class FriendshipService:
    """Service for friendship management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def send_friend_request(
        self,
        requester_id: str,
        request_data: FriendRequestCreate,
        session: AsyncSession
    ) -> Optional[Friendship]:
        """Send a friend request."""
        addressee_id = request_data.user_id
        # Check if trying to add self
        if requester_id == addressee_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You cannot send a friend request to yourself"
            )
        # Check if addressee exists
        addressee = await session.get(User, addressee_id)
        if not addressee or not addressee.is_active:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        # Check if friendship already exists
        existing_friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == requester_id,
                        Friendship.addressee_id == addressee_id
                    ),
                    and_(
                        Friendship.requester_id == addressee_id,
                        Friendship.addressee_id == requester_id
                    )
                )
            )
        )
        existing_friendship = existing_friendship.scalar_one_or_none()
        if existing_friendship:
            if existing_friendship.status == FriendshipStatus.ACCEPTED:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="You are already friends with this user"
                )
            elif existing_friendship.status == FriendshipStatus.PENDING:
                if existing_friendship.requester_id == requester_id:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Friend request already sent"
                    )
                else:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="This user has already sent you a friend request"
                    )
            elif existing_friendship.status == FriendshipStatus.BLOCKED:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Cannot send friend request to this user"
                )
            elif existing_friendship.status == FriendshipStatus.DECLINED:
                # Allow sending new request after decline
                existing_friendship.status = FriendshipStatus.PENDING
                existing_friendship.requester_id = requester_id
                existing_friendship.addressee_id = addressee_id
                existing_friendship.updated_at = datetime.utcnow()
                await session.commit()
                await session.refresh(existing_friendship)
                # Send notification
                await self._send_friend_request_notification(
                    existing_friendship, request_data.message, session
                )
                return existing_friendship
        # Create new friend request
        friendship = Friendship(
            requester_id=requester_id,
            addressee_id=addressee_id,
            status=FriendshipStatus.PENDING
        )
        session.add(friendship)
        await session.commit()
        await session.refresh(friendship)
        # Send notification
        await self._send_friend_request_notification(
            friendship, request_data.message, session
        )
        return friendship
    async def accept_friend_request(
        self,
        friendship_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Accept a friend request."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.id == friendship_id,
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friend request not found"
            )
        # Accept the request
        friendship.status = FriendshipStatus.ACCEPTED
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        # Send acceptance notification
        await self._send_friend_request_accepted_notification(friendship, session)
        return True
    async def decline_friend_request(
        self,
        friendship_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Decline a friend request."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.id == friendship_id,
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friend request not found"
            )
        # Decline the request
        friendship.status = FriendshipStatus.DECLINED
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        return True
    async def remove_friend(
        self,
        user_id: str,
        friend_id: str,
        session: AsyncSession
    ) -> bool:
        """Remove a friend."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user_id,
                            Friendship.addressee_id == friend_id
                        ),
                        and_(
                            Friendship.requester_id == friend_id,
                            Friendship.addressee_id == user_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friendship not found"
            )
        # Remove the friendship
        await session.delete(friendship)
        await session.commit()
        return True
    async def get_friends_list(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 50,
        offset: int = 0,
        close_friends_only: bool = False
    ) -> FriendsList:
        """Get user's friends list."""
        # Build query for friends
        friends_query = (
            select(
                Friendship,
                User,
                func.case(
                    (Friendship.requester_id == user_id, Friendship.addressee_id),
                    else_=Friendship.requester_id
                ).label("friend_id")
            )
            .join(
                User,
                User.id == func.case(
                    (Friendship.requester_id == user_id, Friendship.addressee_id),
                    else_=Friendship.requester_id
                )
            )
            .where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    User.is_active == True
                )
            )
        )
        if close_friends_only:
            friends_query = friends_query.where(Friendship.is_close_friend == True)
        # Get total count
        count_query = select(func.count()).select_from(friends_query.subquery())
        total_count = await session.scalar(count_query) or 0
        # Add pagination and ordering
        friends_query = (
            friends_query
            .order_by(asc(User.display_name))
            .offset(offset)
            .limit(limit)
        )
        result = await session.execute(friends_query)
        friends_data = result.all()
        # Convert to FriendProfile format
        friends = []
        for friendship, user, friend_id in friends_data:
            # Get mutual friends count
            mutual_count = await self._get_mutual_friends_count(user_id, str(friend_id), session)
            friend_profile = FriendProfile(
                user_id=str(user.id),
                username=user.username,
                display_name=user.display_name,
                avatar_url=user.avatar_url,
                bio=user.bio,
                gardening_experience=user.gardening_experience,
                favorite_plants=user.favorite_plants,
                location=user.location,
                friendship_id=str(friendship.id),
                is_close_friend=friendship.is_close_friend,
                friends_since=friendship.created_at,
                last_active=user.last_active,
                is_online=False,  # Will be updated with real-time data
                mutual_friends_count=mutual_count,
                stories_count=0  # Could be calculated if needed
            )
            friends.append(friend_profile)
        # Get additional counts
        close_friends_count = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        ) or 0
        return FriendsList(
            friends=friends,
            total_count=total_count,
            close_friends_count=close_friends_count,
            online_friends_count=0  # Would need real-time data
        )
    async def get_friend_requests(
        self,
        user_id: str,
        session: AsyncSession
    ) -> FriendRequestsList:
        """Get pending friend requests for a user."""
        # Received requests
        received_query = (
            select(Friendship, User)
            .join(User, User.id == Friendship.requester_id)
            .where(
                and_(
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
            .order_by(desc(Friendship.created_at))
        )
        # Sent requests
        sent_query = (
            select(Friendship, User)
            .join(User, User.id == Friendship.addressee_id)
            .where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
            .order_by(desc(Friendship.created_at))
        )
        received_result = await session.execute(received_query)
        sent_result = await session.execute(sent_query)
        # Convert to FriendshipRead format
        from app.schemas.friendship import FriendshipRead
        pending_requests = []
        for friendship, user in received_result:
            request = FriendshipRead(
                id=str(friendship.id),
                requester_id=str(friendship.requester_id),
                addressee_id=str(friendship.addressee_id),
                status=friendship.status,
                is_close_friend=friendship.is_close_friend,
                created_at=friendship.created_at,
                updated_at=friendship.updated_at,
                requester_username=user.username,
                requester_display_name=user.display_name,
                requester_avatar_url=user.avatar_url
            )
            pending_requests.append(request)
        sent_requests = []
        for friendship, user in sent_result:
            request = FriendshipRead(
                id=str(friendship.id),
                requester_id=str(friendship.requester_id),
                addressee_id=str(friendship.addressee_id),
                status=friendship.status,
                is_close_friend=friendship.is_close_friend,
                created_at=friendship.created_at,
                updated_at=friendship.updated_at,
                addressee_username=user.username,
                addressee_display_name=user.display_name,
                addressee_avatar_url=user.avatar_url
            )
            sent_requests.append(request)
        return FriendRequestsList(
            pending_requests=pending_requests,
            sent_requests=sent_requests,
            total_pending=len(pending_requests),
            total_sent=len(sent_requests)
        )
    async def toggle_close_friend(
        self,
        user_id: str,
        friend_id: str,
        session: AsyncSession
    ) -> bool:
        """Toggle close friend status."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user_id,
                            Friendship.addressee_id == friend_id
                        ),
                        and_(
                            Friendship.requester_id == friend_id,
                            Friendship.addressee_id == user_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Friendship not found"
            )
        # Toggle close friend status
        friendship.is_close_friend = not friendship.is_close_friend
        friendship.updated_at = datetime.utcnow()
        await session.commit()
        return friendship.is_close_friend
    async def block_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Block a user."""
        if blocker_id == blocked_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You cannot block yourself"
            )
        # Check if user exists
        blocked_user = await session.get(User, blocked_id)
        if not blocked_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        # Check existing friendship
        existing_friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == blocker_id,
                        Friendship.addressee_id == blocked_id
                    ),
                    and_(
                        Friendship.requester_id == blocked_id,
                        Friendship.addressee_id == blocker_id
                    )
                )
            )
        )
        existing_friendship = existing_friendship.scalar_one_or_none()
        if existing_friendship:
            # Update existing relationship to blocked
            existing_friendship.status = FriendshipStatus.BLOCKED
            existing_friendship.requester_id = blocker_id  # Blocker becomes requester
            existing_friendship.addressee_id = blocked_id
            existing_friendship.is_close_friend = False
            existing_friendship.updated_at = datetime.utcnow()
        else:
            # Create new blocked relationship
            friendship = Friendship(
                requester_id=blocker_id,
                addressee_id=blocked_id,
                status=FriendshipStatus.BLOCKED
            )
            session.add(friendship)
        await session.commit()
        return True
    async def unblock_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Unblock a user."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.requester_id == blocker_id,
                    Friendship.addressee_id == blocked_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if not friendship:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Block relationship not found"
            )
        # Remove the block
        await session.delete(friendship)
        await session.commit()
        return True
    async def get_friendship_status(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> str:
        """Get friendship status between two users."""
        if user1_id == user2_id:
            return "self"
        result = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == user1_id,
                        Friendship.addressee_id == user2_id
                    ),
                    and_(
                        Friendship.requester_id == user2_id,
                        Friendship.addressee_id == user1_id
                    )
                )
            )
        )
        friendship = result.scalar_one_or_none()
        if not friendship:
            return "none"
        if friendship.status == FriendshipStatus.BLOCKED:
            if friendship.requester_id == user1_id:
                return "blocked_by_you"
            else:
                return "blocked_by_them"
        elif friendship.status == FriendshipStatus.PENDING:
            if friendship.requester_id == user1_id:
                return "pending_sent"
            else:
                return "pending_received"
        elif friendship.status == FriendshipStatus.ACCEPTED:
            return "friends"
        elif friendship.status == FriendshipStatus.DECLINED:
            return "declined"
        return "none"
    async def get_mutual_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession,
        limit: int = 10
    ) -> MutualFriends:
        """Get mutual friends between two users."""
        # This is a complex query - simplified implementation
        mutual_friends = []  # Would implement actual mutual friends logic
        return MutualFriends(
            user_id=user2_id,
            mutual_friends=mutual_friends,
            mutual_friends_count=len(mutual_friends),
            total_friends_count=0  # Would calculate actual count
        )
    async def get_friendship_stats(
        self,
        user_id: str,
        session: AsyncSession
    ) -> FriendshipStats:
        """Get friendship statistics for a user."""
        # Total friends
        total_friends = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        ) or 0
        # Close friends
        close_friends = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        ) or 0
        # Pending requests received
        pending_received = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.addressee_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        ) or 0
        # Pending requests sent
        pending_sent = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.PENDING
                )
            )
        ) or 0
        # Blocked users
        blocked_users = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        ) or 0
        return FriendshipStats(
            user_id=user_id,
            total_friends=total_friends,
            close_friends=close_friends,
            pending_requests_received=pending_received,
            pending_requests_sent=pending_sent,
            blocked_users=blocked_users
        )
    async def _get_mutual_friends_count(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> int:
        """Get count of mutual friends between two users."""
        # Simplified implementation - would need complex query for actual mutual friends
        return 0
    async def _send_friend_request_notification(
        self,
        friendship: Friendship,
        message: Optional[str],
        session: AsyncSession
    ):
        """Send friend request notification."""
        requester = await session.get(User, friendship.requester_id)
        if requester:
            notification_data = {
                "type": "friend_request",
                "friendship_id": str(friendship.id),
                "requester_id": str(friendship.requester_id),
                "requester_username": requester.username,
                "requester_display_name": requester.display_name,
                "requester_avatar_url": requester.avatar_url,
                "message": message,
                "timestamp": friendship.created_at.isoformat()
            }
            await self.connection_manager.send_personal_message(
                str(friendship.addressee_id),
                notification_data
            )
    async def _send_friend_request_accepted_notification(
        self,
        friendship: Friendship,
        session: AsyncSession
    ):
        """Send friend request accepted notification."""
        addressee = await session.get(User, friendship.addressee_id)
        if addressee:
            notification_data = {
                "type": "friend_request_accepted",
                "friendship_id": str(friendship.id),
                "accepter_id": str(friendship.addressee_id),
                "accepter_username": addressee.username,
                "accepter_display_name": addressee.display_name,
                "accepter_avatar_url": addressee.avatar_url,
                "timestamp": friendship.updated_at.isoformat()
            }
            await self.connection_manager.send_personal_message(
                str(friendship.requester_id),
                notification_data
            )
# Global friendship service instance
friendship_service = FriendshipService()
# Convenience functions for backward compatibility
async def check_friendship_status(
    user_id: str,
    other_user_id: str,
    session: AsyncSession
) -> Optional[str]:
    """Check friendship status between two users."""
    friendship = await session.execute(
        select(Friendship).where(
            or_(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == other_user_id
                ),
                and_(
                    Friendship.requester_id == other_user_id,
                    Friendship.addressee_id == user_id
                )
            )
        )
    )
    friendship = friendship.scalar_one_or_none()
    if not friendship:
        return None
    return friendship.status.value
async def send_friend_request(
    requester_id: str,
    addressee_id: str,
    session: AsyncSession
) -> dict:
    """Send a friend request."""
    return await friendship_service.send_friend_request(requester_id, addressee_id, session)
async def accept_friend_request(
    request_id: str,
    user_id: str,
    session: AsyncSession
) -> dict:
    """Accept a friend request."""
    return await friendship_service.accept_friend_request(request_id, user_id, session)
async def decline_friend_request(
    request_id: str,
    user_id: str,
    session: AsyncSession
) -> dict:
    """Decline a friend request."""
    return await friendship_service.decline_friend_request(request_id, user_id, session)
async def remove_friend(
    user_id: str,
    friend_id: str,
    session: AsyncSession
) -> dict:
    """Remove a friend."""
    return await friendship_service.remove_friend(user_id, friend_id, session)
async def block_user(
    user_id: str,
    blocked_user_id: str,
    session: AsyncSession
) -> dict:
    """Block a user."""
    return await friendship_service.block_user(user_id, blocked_user_id, session)
async def unblock_user(
    user_id: str,
    blocked_user_id: str,
    session: AsyncSession
) -> dict:
    """Unblock a user."""
    return await friendship_service.unblock_user(user_id, blocked_user_id, session)
async def get_friends_list(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get friends list."""
    return await friendship_service.get_friends_list(user_id, session)
async def get_pending_requests(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get pending friend requests."""
    return await friendship_service.get_pending_requests(user_id, session)
async def get_sent_requests(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get sent friend requests."""
    return await friendship_service.get_sent_requests(user_id, session)
async def get_blocked_users(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get blocked users."""
    return await friendship_service.get_blocked_users(user_id, session)
async def toggle_close_friend(
    user_id: str,
    friend_id: str,
    session: AsyncSession
) -> dict:
    """Toggle close friend status."""
    return await friendship_service.toggle_close_friend(user_id, friend_id, session)
async def get_close_friends(
    user_id: str,
    session: AsyncSession
) -> List[dict]:
    """Get close friends."""
    return await friendship_service.get_close_friends(user_id, session)
async def get_friendship_service() -> FriendshipService:
    """Get friendship service dependency."""
    return friendship_service
</file>

<file path="backend/app/services/message_service.py">
"""Message service.
This module provides messaging services including
sending, receiving, and managing messages.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.message import Message
from app.schemas.message import MessageType, MessageStatus
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.schemas.message import (
    MessageCreate, MessageUpdate, MessageRead, MessageThread,
    MessageSearch, MessageAnalytics
)
from app.core.websocket import websocket_manager
class MessageService:
    """Service for message management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def send_message(
        self,
        sender_id: str,
        message_data: MessageCreate,
        session: AsyncSession
    ) -> Optional[Message]:
        """Send a message to another user."""
        # Check if users are friends
        if not await self._are_users_friends(sender_id, message_data.recipient_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only send messages to friends"
            )
        # Check if recipient exists and is active
        recipient = await session.execute(
            select(User).where(
                and_(
                    User.id == message_data.recipient_id,
                    User.is_active == True
                )
            )
        )
        recipient = recipient.scalar_one_or_none()
        if not recipient:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Recipient not found"
            )
        # Validate message content based on type
        await self._validate_message_content(message_data)
        # Create message
        message = Message(
            sender_id=sender_id,
            recipient_id=message_data.recipient_id,
            content_type=message_data.content_type,
            content=message_data.content,
            media_url=message_data.media_url,
            caption=message_data.caption,
            duration=message_data.duration,
            file_size=message_data.file_size,
            disappears_at=message_data.disappears_at,
            status=MessageStatus.SENT
        )
        session.add(message)
        await session.commit()
        await session.refresh(message)
        # Send real-time notification
        await self._send_real_time_notification(message, session)
        return message
    async def get_message_by_id(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession
    ) -> Optional[Message]:
        """Get message by ID if user has access."""
        result = await session.execute(
            select(Message).where(
                and_(
                    Message.id == message_id,
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    )
                )
            )
        )
        return result.scalar_one_or_none()
    async def get_conversation(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession,
        limit: int = 50,
        offset: int = 0,
        before_message_id: Optional[str] = None
    ) -> List[MessageRead]:
        """Get conversation between two users."""
        # Check if users are friends
        if not await self._are_users_friends(user1_id, user2_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only view conversations with friends"
            )
        # Build query
        query = select(Message).where(
            and_(
                or_(
                    and_(
                        Message.sender_id == user1_id,
                        Message.recipient_id == user2_id
                    ),
                    and_(
                        Message.sender_id == user2_id,
                        Message.recipient_id == user1_id
                    )
                ),
                Message.status != MessageStatus.DELETED
            )
        )
        # Add before_message_id filter for pagination
        if before_message_id:
            before_message = await self.get_message_by_id(before_message_id, user1_id, session)
            if before_message:
                query = query.where(Message.created_at < before_message.created_at)
        # Add ordering and pagination
        query = query.order_by(desc(Message.created_at)).offset(offset).limit(limit)
        result = await session.execute(query)
        messages = result.scalars().all()
        # Convert to MessageRead format
        message_reads = []
        for message in messages:
            # Get sender and recipient info
            sender = await session.get(User, message.sender_id)
            recipient = await session.get(User, message.recipient_id)
            message_read = MessageRead(
                id=str(message.id),
                sender_id=str(message.sender_id),
                recipient_id=str(message.recipient_id),
                content_type=message.content_type,
                content=message.content,
                media_url=message.media_url,
                caption=message.caption,
                duration=message.duration,
                file_size=message.file_size,
                status=message.status,
                created_at=message.created_at,
                updated_at=message.updated_at,
                delivered_at=message.delivered_at,
                read_at=message.read_at,
                disappears_at=message.disappears_at,
                sender_username=sender.username if sender else None,
                sender_display_name=sender.display_name if sender else None,
                sender_avatar_url=sender.avatar_url if sender else None,
                recipient_username=recipient.username if recipient else None,
                recipient_display_name=recipient.display_name if recipient else None,
                recipient_avatar_url=recipient.avatar_url if recipient else None
            )
            message_reads.append(message_read)
        return message_reads
    async def get_user_conversations(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 20,
        offset: int = 0
    ) -> List[MessageThread]:
        """Get list of user's conversations with latest message."""
        # Get latest message for each conversation
        subquery = (
            select(
                func.max(Message.id).label("latest_message_id"),
                func.case(
                    (Message.sender_id == user_id, Message.recipient_id),
                    else_=Message.sender_id
                ).label("other_user_id")
            )
            .where(
                and_(
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    ),
                    Message.status != MessageStatus.DELETED
                )
            )
            .group_by("other_user_id")
            .subquery()
        )
        # Get the actual latest messages
        query = (
            select(Message, User)
            .join(subquery, Message.id == subquery.c.latest_message_id)
            .join(User, User.id == subquery.c.other_user_id)
            .order_by(desc(Message.created_at))
            .offset(offset)
            .limit(limit)
        )
        result = await session.execute(query)
        conversations = []
        for message, other_user in result:
            # Count unread messages
            unread_count = await session.scalar(
                select(func.count(Message.id)).where(
                    and_(
                        Message.sender_id == str(other_user.id),
                        Message.recipient_id == user_id,
                        Message.read_at.is_(None),
                        Message.status != MessageStatus.DELETED
                    )
                )
            ) or 0
            conversation = MessageThread(
                other_user_id=str(other_user.id),
                other_user_username=other_user.username,
                other_user_display_name=other_user.display_name,
                other_user_avatar_url=other_user.avatar_url,
                latest_message_id=str(message.id),
                latest_message_content=message.content,
                latest_message_type=message.content_type,
                latest_message_timestamp=message.created_at,
                unread_count=unread_count,
                is_other_user_online=False  # Will be updated with real-time data
            )
            conversations.append(conversation)
        return conversations
    async def mark_message_as_read(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Mark a message as read."""
        message = await session.execute(
            select(Message).where(
                and_(
                    Message.id == message_id,
                    Message.recipient_id == user_id,
                    Message.read_at.is_(None)
                )
            )
        )
        message = message.scalar_one_or_none()
        if message:
            message.read_at = datetime.utcnow()
            message.status = MessageStatus.READ
            await session.commit()
            # Send read receipt notification
            await self._send_read_receipt(message)
            return True
        return False
    async def mark_conversation_as_read(
        self,
        user_id: str,
        other_user_id: str,
        session: AsyncSession
    ) -> int:
        """Mark all messages in a conversation as read."""
        # Get unread messages
        result = await session.execute(
            select(Message).where(
                and_(
                    Message.sender_id == other_user_id,
                    Message.recipient_id == user_id,
                    Message.read_at.is_(None),
                    Message.status != MessageStatus.DELETED
                )
            )
        )
        messages = result.scalars().all()
        # Mark as read
        read_count = 0
        for message in messages:
            message.read_at = datetime.utcnow()
            message.status = MessageStatus.READ
            read_count += 1
        if read_count > 0:
            await session.commit()
            # Send read receipt for the latest message
            if messages:
                latest_message = max(messages, key=lambda m: m.created_at)
                await self._send_read_receipt(latest_message)
        return read_count
    async def delete_message(
        self,
        message_id: str,
        user_id: str,
        session: AsyncSession,
        delete_for_everyone: bool = False
    ) -> bool:
        """Delete a message."""
        message = await self.get_message_by_id(message_id, user_id, session)
        if not message:
            return False
        # Check permissions
        if delete_for_everyone and message.sender_id != user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You can only delete your own messages for everyone"
            )
        if delete_for_everyone:
            # Delete for everyone
            message.status = MessageStatus.DELETED
            message.content = "This message was deleted"
            message.media_url = None
            message.caption = None
        else:
            # For now, we'll implement soft delete for everyone
            # In a real app, you might want user-specific deletion
            message.status = MessageStatus.DELETED
        message.updated_at = datetime.utcnow()
        await session.commit()
        # Send deletion notification
        await self._send_message_deletion_notification(message)
        return True
    async def search_messages(
        self,
        user_id: str,
        search_params: MessageSearch,
        session: AsyncSession
    ) -> List[MessageRead]:
        """Search messages for a user."""
        query = select(Message).where(
            and_(
                or_(
                    Message.sender_id == user_id,
                    Message.recipient_id == user_id
                ),
                Message.status != MessageStatus.DELETED
            )
        )
        # Add search filters
        if search_params.query:
            query = query.where(
                or_(
                    Message.content.ilike(f"%{search_params.query}%"),
                    Message.caption.ilike(f"%{search_params.query}%")
                )
            )
        if search_params.content_type:
            query = query.where(Message.content_type == search_params.content_type)
        if search_params.sender_id:
            query = query.where(Message.sender_id == search_params.sender_id)
        if search_params.start_date:
            query = query.where(Message.created_at >= search_params.start_date)
        if search_params.end_date:
            query = query.where(Message.created_at <= search_params.end_date)
        # Add ordering and pagination
        query = query.order_by(desc(Message.created_at)).limit(50)
        result = await session.execute(query)
        messages = result.scalars().all()
        # Convert to MessageRead format (simplified)
        message_reads = []
        for message in messages:
            message_read = MessageRead(
                id=str(message.id),
                sender_id=str(message.sender_id),
                recipient_id=str(message.recipient_id),
                content_type=message.content_type,
                content=message.content,
                media_url=message.media_url,
                caption=message.caption,
                duration=message.duration,
                file_size=message.file_size,
                status=message.status,
                created_at=message.created_at,
                updated_at=message.updated_at,
                delivered_at=message.delivered_at,
                read_at=message.read_at,
                disappears_at=message.disappears_at
            )
            message_reads.append(message_read)
        return message_reads
    async def get_message_analytics(
        self,
        user_id: str,
        session: AsyncSession,
        days: int = 30
    ) -> MessageAnalytics:
        """Get message analytics for a user."""
        start_date = datetime.utcnow() - timedelta(days=days)
        # Messages sent
        messages_sent = await session.scalar(
            select(func.count(Message.id)).where(
                and_(
                    Message.sender_id == user_id,
                    Message.created_at >= start_date
                )
            )
        ) or 0
        # Messages received
        messages_received = await session.scalar(
            select(func.count(Message.id)).where(
                and_(
                    Message.recipient_id == user_id,
                    Message.created_at >= start_date
                )
            )
        ) or 0
        # Active conversations
        active_conversations = await session.scalar(
            select(func.count(func.distinct(
                func.case(
                    (Message.sender_id == user_id, Message.recipient_id),
                    else_=Message.sender_id
                )
            ))).where(
                and_(
                    or_(
                        Message.sender_id == user_id,
                        Message.recipient_id == user_id
                    ),
                    Message.created_at >= start_date
                )
            )
        ) or 0
        return MessageAnalytics(
            user_id=user_id,
            messages_sent=messages_sent,
            messages_received=messages_received,
            total_messages=messages_sent + messages_received,
            active_conversations=active_conversations,
            period_days=days
        )
    async def _are_users_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _validate_message_content(self, message_data: MessageCreate):
        """Validate message content based on type."""
        if message_data.content_type == MessageType.TEXT:
            if not message_data.content or len(message_data.content.strip()) == 0:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Text messages must have content"
                )
        elif message_data.content_type in [MessageType.IMAGE, MessageType.VIDEO, MessageType.AUDIO]:
            if not message_data.media_url:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"{message_data.content_type.value} messages must have media_url"
                )
    async def _send_real_time_notification(self, message: Message, session: AsyncSession):
        """Send real-time notification for new message."""
        # Get recipient info
        recipient = await session.get(User, message.recipient_id)
        sender = await session.get(User, message.sender_id)
        if recipient and sender:
            notification_data = {
                "type": "new_message",
                "message_id": str(message.id),
                "sender_id": str(message.sender_id),
                "sender_username": sender.username,
                "sender_display_name": sender.display_name,
                "content_type": message.content_type.value,
                "content": message.content if message.content_type == MessageType.TEXT else None,
                "timestamp": message.created_at.isoformat()
            }
            await websocket_manager.send_personal_message(
                str(message.recipient_id),
                notification_data
            )
    async def _send_read_receipt(self, message: Message):
        """Send read receipt notification."""
        notification_data = {
            "type": "message_read",
            "message_id": str(message.id),
            "read_at": message.read_at.isoformat() if message.read_at else None
        }
        await websocket_manager.send_personal_message(
            str(message.sender_id),
            notification_data
        )
    async def _send_message_deletion_notification(self, message: Message):
        """Send message deletion notification."""
        notification_data = {
            "type": "message_deleted",
            "message_id": str(message.id)
        }
        # Notify both sender and recipient
        await self.connection_manager.send_personal_message(
            str(message.sender_id),
            notification_data
        )
        await self.connection_manager.send_personal_message(
            str(message.recipient_id),
            notification_data
        )
# Global message service instance
message_service = MessageService()
# Convenience functions for backward compatibility
async def create_message(
    sender_id: str,
    message_data: MessageCreate,
    session: AsyncSession
) -> Optional[Message]:
    """Create a new message."""
    return await message_service.send_message(sender_id, message_data, session)
async def get_conversation_messages(
    user_id: str,
    other_user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> List[MessageRead]:
    """Get messages in a conversation."""
    return await message_service.get_conversation_messages(
        user_id, other_user_id, session, limit, offset
    )
async def get_user_conversations(
    user_id: str,
    session: AsyncSession
) -> List[MessageThread]:
    """Get user's conversations."""
    return await message_service.get_user_conversations(user_id, session)
async def mark_message_as_read(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Mark a message as read."""
    return await message_service.mark_message_as_read(message_id, user_id, session)
async def delete_message(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Delete a message."""
    return await message_service.delete_message(message_id, user_id, session)
async def get_message_by_id(
    message_id: str,
    user_id: str,
    session: AsyncSession
) -> Optional[MessageRead]:
    """Get a message by ID."""
    return await message_service.get_message_by_id(message_id, user_id, session)
async def get_message_service() -> MessageService:
    """Get message service dependency."""
    return message_service
</file>

<file path="backend/app/services/plant_care_log_service.py">
"""Plant care log service.
This module provides business logic for managing plant care logs,
including CRUD operations and care statistics.
"""
from datetime import datetime, timedelta
from typing import List, Optional, Dict
from uuid import UUID
from sqlalchemy import and_, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_care_log import PlantCareLog
from app.models.user_plant import UserPlant
from app.schemas.plant_care_log import PlantCareLogCreate, PlantCareLogUpdate
class PlantCareLogService:
    """Service for managing plant care logs."""
    @staticmethod
    async def create_care_log(
        db: AsyncSession,
        user_id: UUID,
        log_data: PlantCareLogCreate
    ) -> Optional[PlantCareLog]:
        """Create a new care log entry.
        Args:
            db: Database session
            user_id: User ID (for ownership verification)
            log_data: Care log creation data
        Returns:
            Created care log if plant is owned by user, None otherwise
        """
        # Verify plant ownership
        plant_result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == log_data.plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = plant_result.scalar_one_or_none()
        if not plant:
            return None
        # Create care log
        care_log = PlantCareLog(**log_data.dict())
        db.add(care_log)
        # Update plant's last care timestamp
        if log_data.care_type == "watering":
            plant.last_watered = log_data.performed_at or datetime.utcnow()
        elif log_data.care_type == "fertilizing":
            plant.last_fertilized = log_data.performed_at or datetime.utcnow()
        elif log_data.care_type == "repotting":
            plant.last_repotted = log_data.performed_at or datetime.utcnow()
        plant.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(care_log)
        return care_log
    @staticmethod
    async def get_care_log_by_id(
        db: AsyncSession,
        log_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[PlantCareLog]:
        """Get care log by ID.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: Optional user ID for ownership check
        Returns:
            Care log if found and accessible, None otherwise
        """
        query = select(PlantCareLog).options(
            selectinload(PlantCareLog.plant)
        ).where(PlantCareLog.id == log_id)
        result = await db.execute(query)
        care_log = result.scalar_one_or_none()
        # Check ownership if user_id provided
        if care_log and user_id:
            if care_log.plant.user_id != user_id:
                return None
        return care_log
    @staticmethod
    async def get_plant_care_logs(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        care_type: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantCareLog], int]:
        """Get care logs for a specific plant.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: User ID (for ownership verification)
            care_type: Optional care type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (care logs list, total count)
        """
        # Verify plant ownership
        plant_result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = plant_result.scalar_one_or_none()
        if not plant:
            return [], 0
        # Build base query
        base_query = select(PlantCareLog).where(
            PlantCareLog.plant_id == plant_id
        )
        count_query = select(func.count(PlantCareLog.id)).where(
            PlantCareLog.plant_id == plant_id
        )
        # Apply filters
        if care_type:
            base_query = base_query.where(PlantCareLog.care_type == care_type)
            count_query = count_query.where(PlantCareLog.care_type == care_type)
        if start_date:
            base_query = base_query.where(PlantCareLog.performed_at >= start_date)
            count_query = count_query.where(PlantCareLog.performed_at >= start_date)
        if end_date:
            base_query = base_query.where(PlantCareLog.performed_at <= end_date)
            count_query = count_query.where(PlantCareLog.performed_at <= end_date)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantCareLog.performed_at))
            .offset(skip)
            .limit(limit)
        )
        logs = result.scalars().all()
        return list(logs), total
    @staticmethod
    async def get_user_care_logs(
        db: AsyncSession,
        user_id: UUID,
        care_type: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantCareLog], int]:
        """Get care logs for all user's plants.
        Args:
            db: Database session
            user_id: User ID
            care_type: Optional care type filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (care logs list, total count)
        """
        # Build base query with join to user plants
        base_query = select(PlantCareLog).options(
            selectinload(PlantCareLog.plant)
        ).join(UserPlant).where(UserPlant.user_id == user_id)
        count_query = select(func.count(PlantCareLog.id)).join(UserPlant).where(
            UserPlant.user_id == user_id
        )
        # Apply filters
        if care_type:
            base_query = base_query.where(PlantCareLog.care_type == care_type)
            count_query = count_query.where(PlantCareLog.care_type == care_type)
        if start_date:
            base_query = base_query.where(PlantCareLog.performed_at >= start_date)
            count_query = count_query.where(PlantCareLog.performed_at >= start_date)
        if end_date:
            base_query = base_query.where(PlantCareLog.performed_at <= end_date)
            count_query = count_query.where(PlantCareLog.performed_at <= end_date)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantCareLog.performed_at))
            .offset(skip)
            .limit(limit)
        )
        logs = result.scalars().all()
        return list(logs), total
    @staticmethod
    async def update_care_log(
        db: AsyncSession,
        log_id: UUID,
        user_id: UUID,
        log_data: PlantCareLogUpdate
    ) -> Optional[PlantCareLog]:
        """Update care log.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: User ID (for ownership verification)
            log_data: Update data
        Returns:
            Updated care log if found and owned by user, None otherwise
        """
        # Get care log with plant info
        result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).where(PlantCareLog.id == log_id)
        )
        care_log = result.scalar_one_or_none()
        if not care_log or care_log.plant.user_id != user_id:
            return None
        # Update fields
        update_data = log_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(care_log, field, value)
        care_log.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(care_log)
        return care_log
    @staticmethod
    async def delete_care_log(
        db: AsyncSession,
        log_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete care log.
        Args:
            db: Database session
            log_id: Care log ID
            user_id: User ID (for ownership verification)
        Returns:
            True if deleted, False if not found or not owned
        """
        # Get care log with plant info
        result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).where(PlantCareLog.id == log_id)
        )
        care_log = result.scalar_one_or_none()
        if not care_log or care_log.plant.user_id != user_id:
            return False
        await db.delete(care_log)
        await db.commit()
        return True
    @staticmethod
    async def get_care_statistics(
        db: AsyncSession,
        user_id: UUID,
        plant_id: Optional[UUID] = None,
        days: int = 30
    ) -> Dict[str, any]:
        """Get care statistics for user's plants.
        Args:
            db: Database session
            user_id: User ID
            plant_id: Optional specific plant ID
            days: Number of days to look back
        Returns:
            Dictionary with care statistics
        """
        start_date = datetime.utcnow() - timedelta(days=days)
        # Build base query
        base_query = select(
            PlantCareLog.care_type,
            func.count(PlantCareLog.id).label('count')
        ).join(UserPlant).where(
            and_(
                UserPlant.user_id == user_id,
                PlantCareLog.performed_at >= start_date
            )
        )
        if plant_id:
            base_query = base_query.where(PlantCareLog.plant_id == plant_id)
        # Get care type statistics
        result = await db.execute(
            base_query.group_by(PlantCareLog.care_type)
        )
        care_type_stats = {care_type: count for care_type, count in result.all()}
        # Get total care activities
        total_result = await db.execute(
            select(func.count(PlantCareLog.id)).join(UserPlant).where(
                and_(
                    UserPlant.user_id == user_id,
                    PlantCareLog.performed_at >= start_date,
                    PlantCareLog.plant_id == plant_id if plant_id else True
                )
            )
        )
        total_activities = total_result.scalar()
        # Get most recent activity
        recent_result = await db.execute(
            select(PlantCareLog).options(
                selectinload(PlantCareLog.plant)
            ).join(UserPlant).where(
                and_(
                    UserPlant.user_id == user_id,
                    PlantCareLog.plant_id == plant_id if plant_id else True
                )
            ).order_by(desc(PlantCareLog.performed_at)).limit(1)
        )
        recent_activity = recent_result.scalar_one_or_none()
        return {
            "period_days": days,
            "total_activities": total_activities,
            "care_type_breakdown": care_type_stats,
            "most_recent_activity": {
                "care_type": recent_activity.care_type if recent_activity else None,
                "performed_at": recent_activity.performed_at if recent_activity else None,
                "plant_nickname": recent_activity.plant.nickname if recent_activity else None
            } if recent_activity else None,
            "average_activities_per_day": round(total_activities / days, 2) if days > 0 else 0
        }
# Convenience functions for dependency injection
async def create_care_log(
    db: AsyncSession,
    user_id: UUID,
    log_data: PlantCareLogCreate
) -> Optional[PlantCareLog]:
    """Create a new care log entry."""
    return await PlantCareLogService.create_care_log(db, user_id, log_data)
async def get_care_log_by_id(
    db: AsyncSession,
    log_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[PlantCareLog]:
    """Get care log by ID."""
    return await PlantCareLogService.get_care_log_by_id(db, log_id, user_id)
async def get_plant_care_logs(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    care_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    skip: int = 0,
    limit: int = 50
) -> tuple[List[PlantCareLog], int]:
    """Get care logs for a specific plant."""
    return await PlantCareLogService.get_plant_care_logs(
        db, plant_id, user_id, care_type, start_date, end_date, skip, limit
    )
async def get_user_care_logs(
    db: AsyncSession,
    user_id: UUID,
    care_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    skip: int = 0,
    limit: int = 50
) -> tuple[List[PlantCareLog], int]:
    """Get care logs for all user's plants."""
    return await PlantCareLogService.get_user_care_logs(
        db, user_id, care_type, start_date, end_date, skip, limit
    )
async def get_care_statistics(
    db: AsyncSession,
    user_id: UUID,
    plant_id: Optional[UUID] = None,
    days: int = 30
) -> Dict[str, any]:
    """Get care statistics for user's plants."""
    return await PlantCareLogService.get_care_statistics(db, user_id, plant_id, days)
async def update_care_log(
    db: AsyncSession,
    log_id: UUID,
    user_id: UUID,
    log_data: PlantCareLogUpdate
) -> Optional[PlantCareLog]:
    """Update care log."""
    return await PlantCareLogService.update_care_log(db, log_id, user_id, log_data)
async def delete_care_log(db: AsyncSession, log_id: UUID, user_id: UUID) -> bool:
    """Delete care log."""
    return await PlantCareLogService.delete_care_log(db, log_id, user_id)
</file>

<file path="backend/app/services/plant_identification_service.py">
"""Plant identification service.
This module provides business logic for AI-powered plant identification,
including image processing, species matching, and verification.
"""
import os
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_identification import PlantIdentification
from app.models.plant_species import PlantSpecies
from app.schemas.plant_identification import PlantIdentificationCreate, PlantIdentificationUpdate
class PlantIdentificationService:
    """Service for managing plant identification."""
    @staticmethod
    async def create_identification(
        db: AsyncSession,
        user_id: UUID,
        identification_data: PlantIdentificationCreate
    ) -> PlantIdentification:
        """Create a new plant identification record.
        Args:
            db: Database session
            user_id: User ID
            identification_data: Identification creation data
        Returns:
            Created identification record
        """
        identification = PlantIdentification(
            user_id=user_id,
            **identification_data.dict()
        )
        db.add(identification)
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def get_identification_by_id(
        db: AsyncSession,
        identification_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[PlantIdentification]:
        """Get identification by ID.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: Optional user ID for ownership check
        Returns:
            Identification if found and accessible, None otherwise
        """
        query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species),
            selectinload(PlantIdentification.user)
        ).where(PlantIdentification.id == identification_id)
        if user_id:
            query = query.where(PlantIdentification.user_id == user_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_identifications(
        db: AsyncSession,
        user_id: UUID,
        verified_only: Optional[bool] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantIdentification], int]:
        """Get identifications by user.
        Args:
            db: Database session
            user_id: User ID
            verified_only: Filter by verification status
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (identifications list, total count)
        """
        # Build base query
        base_query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species)
        ).where(PlantIdentification.user_id == user_id)
        count_query = select(func.count(PlantIdentification.id)).where(
            PlantIdentification.user_id == user_id
        )
        if verified_only is not None:
            base_query = base_query.where(PlantIdentification.is_verified == verified_only)
            count_query = count_query.where(PlantIdentification.is_verified == verified_only)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantIdentification.created_at))
            .offset(skip)
            .limit(limit)
        )
        identifications = result.scalars().all()
        return list(identifications), total
    @staticmethod
    async def update_identification(
        db: AsyncSession,
        identification_id: UUID,
        user_id: UUID,
        identification_data: PlantIdentificationUpdate
    ) -> Optional[PlantIdentification]:
        """Update identification record.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: User ID (for ownership verification)
            identification_data: Update data
        Returns:
            Updated identification if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantIdentification).where(
                and_(
                    PlantIdentification.id == identification_id,
                    PlantIdentification.user_id == user_id
                )
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return None
        # Update fields
        update_data = identification_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(identification, field, value)
        identification.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def verify_identification(
        db: AsyncSession,
        identification_id: UUID,
        verified_by_user_id: UUID,
        is_correct: bool,
        correct_species_id: Optional[UUID] = None
    ) -> Optional[PlantIdentification]:
        """Verify an identification (community verification).
        Args:
            db: Database session
            identification_id: Identification ID
            verified_by_user_id: User ID of verifier
            is_correct: Whether the identification is correct
            correct_species_id: Correct species ID if identification was wrong
        Returns:
            Updated identification if found, None otherwise
        """
        result = await db.execute(
            select(PlantIdentification).where(
                PlantIdentification.id == identification_id
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return None
        # Update verification status
        identification.is_verified = True
        identification.verified_at = datetime.utcnow()
        identification.verified_by_user_id = verified_by_user_id
        # If identification was incorrect, update with correct species
        if not is_correct and correct_species_id:
            identification.species_id = correct_species_id
            identification.confidence_score = 1.0  # Human verification is 100% confident
        identification.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(identification)
        return identification
    @staticmethod
    async def delete_identification(
        db: AsyncSession,
        identification_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete identification record.
        Args:
            db: Database session
            identification_id: Identification ID
            user_id: User ID (for ownership verification)
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantIdentification).where(
                and_(
                    PlantIdentification.id == identification_id,
                    PlantIdentification.user_id == user_id
                )
            )
        )
        identification = result.scalar_one_or_none()
        if not identification:
            return False
        # Delete image file if it exists
        if identification.image_path and os.path.exists(identification.image_path):
            try:
                os.remove(identification.image_path)
            except OSError:
                pass  # File might already be deleted
        await db.delete(identification)
        await db.commit()
        return True
    @staticmethod
    async def get_pending_verifications(
        db: AsyncSession,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantIdentification], int]:
        """Get identifications pending verification.
        Args:
            db: Database session
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (identifications list, total count)
        """
        # Build query for unverified identifications
        base_query = select(PlantIdentification).options(
            selectinload(PlantIdentification.species),
            selectinload(PlantIdentification.user)
        ).where(PlantIdentification.is_verified == False)
        count_query = select(func.count(PlantIdentification.id)).where(
            PlantIdentification.is_verified == False
        )
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results, ordered by confidence score (lowest first for review)
        result = await db.execute(
            base_query.order_by(PlantIdentification.confidence_score.asc())
            .offset(skip)
            .limit(limit)
        )
        identifications = result.scalars().all()
        return list(identifications), total
    @staticmethod
    async def get_identification_statistics(
        db: AsyncSession,
        user_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Get identification statistics.
        Args:
            db: Database session
            user_id: Optional user ID for user-specific stats
        Returns:
            Dictionary with identification statistics
        """
        base_query = select(PlantIdentification)
        if user_id:
            base_query = base_query.where(PlantIdentification.user_id == user_id)
        # Total identifications
        total_result = await db.execute(
            select(func.count(PlantIdentification.id)).where(
                PlantIdentification.user_id == user_id if user_id else True
            )
        )
        total_identifications = total_result.scalar()
        # Verified identifications
        verified_result = await db.execute(
            select(func.count(PlantIdentification.id)).where(
                and_(
                    PlantIdentification.is_verified == True,
                    PlantIdentification.user_id == user_id if user_id else True
                )
            )
        )
        verified_identifications = verified_result.scalar()
        # Average confidence score
        avg_confidence_result = await db.execute(
            select(func.avg(PlantIdentification.confidence_score)).where(
                PlantIdentification.user_id == user_id if user_id else True
            )
        )
        avg_confidence = avg_confidence_result.scalar() or 0.0
        # Most identified species
        species_result = await db.execute(
            select(
                PlantIdentification.species_id,
                func.count(PlantIdentification.id).label('count')
            ).where(
                PlantIdentification.user_id == user_id if user_id else True
            ).group_by(PlantIdentification.species_id)
            .order_by(desc('count'))
            .limit(5)
        )
        top_species = species_result.all()
        # Get species names for top species
        top_species_with_names = []
        for species_id, count in top_species:
            if species_id:
                species_result = await db.execute(
                    select(PlantSpecies).where(PlantSpecies.id == species_id)
                )
                species = species_result.scalar_one_or_none()
                if species:
                    top_species_with_names.append({
                        "species_id": species_id,
                        "scientific_name": species.scientific_name,
                        "common_names": species.common_names,
                        "count": count
                    })
        return {
            "total_identifications": total_identifications,
            "verified_identifications": verified_identifications,
            "pending_verification": total_identifications - verified_identifications,
            "verification_rate": round(
                (verified_identifications / total_identifications * 100) if total_identifications > 0 else 0, 2
            ),
            "average_confidence_score": round(float(avg_confidence), 3),
            "top_identified_species": top_species_with_names
        }
    @staticmethod
    async def search_similar_identifications(
        db: AsyncSession,
        species_id: UUID,
        confidence_threshold: float = 0.8,
        limit: int = 10
    ) -> List[PlantIdentification]:
        """Search for similar identifications of the same species.
        Args:
            db: Database session
            species_id: Species ID to search for
            confidence_threshold: Minimum confidence score
            limit: Maximum number of results
        Returns:
            List of similar identifications
        """
        result = await db.execute(
            select(PlantIdentification).options(
                selectinload(PlantIdentification.user)
            ).where(
                and_(
                    PlantIdentification.species_id == species_id,
                    PlantIdentification.confidence_score >= confidence_threshold,
                    PlantIdentification.is_verified == True
                )
            ).order_by(desc(PlantIdentification.confidence_score))
            .limit(limit)
        )
        return list(result.scalars().all())
# Convenience functions for dependency injection
async def create_identification(
    db: AsyncSession,
    user_id: UUID,
    identification_data: PlantIdentificationCreate
) -> PlantIdentification:
    """Create a new plant identification record."""
    return await PlantIdentificationService.create_identification(
        db, user_id, identification_data
    )
async def get_identification_by_id(
    db: AsyncSession,
    identification_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[PlantIdentification]:
    """Get identification by ID."""
    return await PlantIdentificationService.get_identification_by_id(
        db, identification_id, user_id
    )
async def get_user_identifications(
    db: AsyncSession,
    user_id: UUID,
    verified_only: Optional[bool] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantIdentification], int]:
    """Get identifications by user."""
    return await PlantIdentificationService.get_user_identifications(
        db, user_id, verified_only, skip, limit
    )
async def verify_identification(
    db: AsyncSession,
    identification_id: UUID,
    verified_by_user_id: UUID,
    is_correct: bool,
    correct_species_id: Optional[UUID] = None
) -> Optional[PlantIdentification]:
    """Verify an identification."""
    return await PlantIdentificationService.verify_identification(
        db, identification_id, verified_by_user_id, is_correct, correct_species_id
    )
async def get_pending_verifications(
    db: AsyncSession,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantIdentification], int]:
    """Get identifications pending verification."""
    return await PlantIdentificationService.get_pending_verifications(db, skip, limit)
async def get_identification_statistics(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get identification statistics."""
    return await PlantIdentificationService.get_identification_statistics(db, user_id)
async def update_identification(
    db: AsyncSession,
    identification_id: UUID,
    user_id: UUID,
    identification_data: PlantIdentificationUpdate
) -> Optional[PlantIdentification]:
    """Update identification record."""
    return await PlantIdentificationService.update_identification(
        db, identification_id, user_id, identification_data
    )
async def delete_identification(
    db: AsyncSession,
    identification_id: UUID,
    user_id: UUID
) -> bool:
    """Delete identification record."""
    return await PlantIdentificationService.delete_identification(
        db, identification_id, user_id
    )
</file>

<file path="backend/app/services/plant_question_service.py">
"""Plant question service.
This module provides business logic for the plant Q&A community,
including questions, answers, voting, and moderation.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_question import PlantQuestion, PlantAnswer
from app.models.plant_species import PlantSpecies
from app.schemas.plant_question import (
    PlantQuestionCreate, PlantQuestionUpdate,
    PlantAnswerCreate, PlantAnswerUpdate,
    PlantQuestionSearchRequest
)
class PlantQuestionService:
    """Service for managing plant questions."""
    @staticmethod
    async def create_question(
        db: AsyncSession,
        user_id: UUID,
        question_data: PlantQuestionCreate
    ) -> PlantQuestion:
        """Create a new plant question.
        Args:
            db: Database session
            user_id: Author user ID
            question_data: Question creation data
        Returns:
            Created question
        """
        question = PlantQuestion(
            author_id=user_id,
            **question_data.dict()
        )
        db.add(question)
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def get_question_by_id(
        db: AsyncSession,
        question_id: UUID,
        include_answers: bool = True
    ) -> Optional[PlantQuestion]:
        """Get question by ID.
        Args:
            db: Database session
            question_id: Question ID
            include_answers: Whether to include answers
        Returns:
            Question if found, None otherwise
        """
        query = select(PlantQuestion).options(
            selectinload(PlantQuestion.author),
            selectinload(PlantQuestion.species)
        )
        if include_answers:
            query = query.options(
                selectinload(PlantQuestion.answers).selectinload(PlantAnswer.author)
            )
        query = query.where(PlantQuestion.id == question_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def search_questions(
        db: AsyncSession,
        search_params: PlantQuestionSearchRequest,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantQuestion], int]:
        """Search plant questions with filters.
        Args:
            db: Database session
            search_params: Search parameters
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (questions list, total count)
        """
        # Build base query
        base_query = select(PlantQuestion).options(
            selectinload(PlantQuestion.author),
            selectinload(PlantQuestion.species)
        )
        count_query = select(func.count(PlantQuestion.id))
        # Apply search filters
        filters = []
        if search_params.query:
            search_filter = or_(
                PlantQuestion.title.ilike(f"%{search_params.query}%"),
                PlantQuestion.content.ilike(f"%{search_params.query}%")
            )
            filters.append(search_filter)
        if search_params.species_id:
            filters.append(PlantQuestion.species_id == search_params.species_id)
        if search_params.tags:
            # Search for questions that have any of the specified tags
            tag_filters = []
            for tag in search_params.tags:
                tag_filters.append(PlantQuestion.tags.contains([tag]))
            if tag_filters:
                filters.append(or_(*tag_filters))
        if search_params.is_solved is not None:
            filters.append(PlantQuestion.is_solved == search_params.is_solved)
        if search_params.author_id:
            filters.append(PlantQuestion.author_id == search_params.author_id)
        # Apply filters to queries
        if filters:
            filter_condition = and_(*filters)
            base_query = base_query.where(filter_condition)
            count_query = count_query.where(filter_condition)
        # Apply sorting
        if search_params.sort_by == "newest":
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        elif search_params.sort_by == "oldest":
            base_query = base_query.order_by(asc(PlantQuestion.created_at))
        elif search_params.sort_by == "most_answers":
            # Count answers for each question
            base_query = base_query.outerjoin(PlantAnswer).group_by(PlantQuestion.id)
            base_query = base_query.order_by(desc(func.count(PlantAnswer.id)))
        elif search_params.sort_by == "unsolved":
            base_query = base_query.where(PlantQuestion.is_solved == False)
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        else:  # Default to newest
            base_query = base_query.order_by(desc(PlantQuestion.created_at))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.offset(skip).limit(limit)
        )
        questions = result.scalars().all()
        return list(questions), total
    @staticmethod
    async def update_question(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID,
        question_data: PlantQuestionUpdate
    ) -> Optional[PlantQuestion]:
        """Update question.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
            question_data: Update data
        Returns:
            Updated question if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return None
        # Update fields
        update_data = question_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(question, field, value)
        question.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def mark_question_solved(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID,
        accepted_answer_id: Optional[UUID] = None
    ) -> Optional[PlantQuestion]:
        """Mark question as solved.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
            accepted_answer_id: Optional accepted answer ID
        Returns:
            Updated question if successful, None otherwise
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return None
        # Mark as solved
        question.is_solved = True
        question.solved_at = datetime.utcnow()
        question.updated_at = datetime.utcnow()
        # Mark accepted answer if provided
        if accepted_answer_id:
            answer_result = await db.execute(
                select(PlantAnswer).where(
                    and_(
                        PlantAnswer.id == accepted_answer_id,
                        PlantAnswer.question_id == question_id
                    )
                )
            )
            answer = answer_result.scalar_one_or_none()
            if answer:
                answer.is_accepted = True
                answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(question)
        return question
    @staticmethod
    async def delete_question(
        db: AsyncSession,
        question_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete question.
        Args:
            db: Database session
            question_id: Question ID
            user_id: Author user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantQuestion).where(
                and_(
                    PlantQuestion.id == question_id,
                    PlantQuestion.author_id == user_id
                )
            )
        )
        question = result.scalar_one_or_none()
        if not question:
            return False
        # Delete associated answers first
        await db.execute(
            select(PlantAnswer).where(PlantAnswer.question_id == question_id)
        )
        await db.delete(question)
        await db.commit()
        return True
class PlantAnswerService:
    """Service for managing plant answers."""
    @staticmethod
    async def create_answer(
        db: AsyncSession,
        user_id: UUID,
        answer_data: PlantAnswerCreate
    ) -> Optional[PlantAnswer]:
        """Create a new answer.
        Args:
            db: Database session
            user_id: Author user ID
            answer_data: Answer creation data
        Returns:
            Created answer if question exists, None otherwise
        """
        # Verify question exists
        question_result = await db.execute(
            select(PlantQuestion).where(PlantQuestion.id == answer_data.question_id)
        )
        question = question_result.scalar_one_or_none()
        if not question:
            return None
        answer = PlantAnswer(
            author_id=user_id,
            **answer_data.dict()
        )
        db.add(answer)
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def get_answer_by_id(
        db: AsyncSession,
        answer_id: UUID
    ) -> Optional[PlantAnswer]:
        """Get answer by ID.
        Args:
            db: Database session
            answer_id: Answer ID
        Returns:
            Answer if found, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).options(
                selectinload(PlantAnswer.author),
                selectinload(PlantAnswer.question)
            ).where(PlantAnswer.id == answer_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def get_question_answers(
        db: AsyncSession,
        question_id: UUID,
        skip: int = 0,
        limit: int = 50
    ) -> tuple[List[PlantAnswer], int]:
        """Get answers for a question.
        Args:
            db: Database session
            question_id: Question ID
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (answers list, total count)
        """
        # Build base query
        base_query = select(PlantAnswer).options(
            selectinload(PlantAnswer.author)
        ).where(PlantAnswer.question_id == question_id)
        count_query = select(func.count(PlantAnswer.id)).where(
            PlantAnswer.question_id == question_id
        )
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results, ordered by accepted first, then by votes
        result = await db.execute(
            base_query.order_by(
                desc(PlantAnswer.is_accepted),
                desc(PlantAnswer.upvotes - PlantAnswer.downvotes),
                asc(PlantAnswer.created_at)
            ).offset(skip).limit(limit)
        )
        answers = result.scalars().all()
        return list(answers), total
    @staticmethod
    async def update_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID,
        answer_data: PlantAnswerUpdate
    ) -> Optional[PlantAnswer]:
        """Update answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Author user ID
            answer_data: Update data
        Returns:
            Updated answer if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id == user_id
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return None
        # Update fields
        update_data = answer_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(answer, field, value)
        answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def vote_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID,
        is_upvote: bool
    ) -> Optional[PlantAnswer]:
        """Vote on an answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Voter user ID
            is_upvote: True for upvote, False for downvote
        Returns:
            Updated answer if found, None otherwise
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id != user_id  # Can't vote on own answer
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return None
        # Update vote counts
        if is_upvote:
            answer.upvotes += 1
        else:
            answer.downvotes += 1
        answer.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(answer)
        return answer
    @staticmethod
    async def delete_answer(
        db: AsyncSession,
        answer_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete answer.
        Args:
            db: Database session
            answer_id: Answer ID
            user_id: Author user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantAnswer).where(
                and_(
                    PlantAnswer.id == answer_id,
                    PlantAnswer.author_id == user_id
                )
            )
        )
        answer = result.scalar_one_or_none()
        if not answer:
            return False
        await db.delete(answer)
        await db.commit()
        return True
# Convenience functions for dependency injection
async def create_question(
    db: AsyncSession,
    user_id: UUID,
    question_data: PlantQuestionCreate
) -> PlantQuestion:
    """Create a new plant question."""
    return await PlantQuestionService.create_question(db, user_id, question_data)
async def get_question_by_id(
    db: AsyncSession,
    question_id: UUID,
    include_answers: bool = True
) -> Optional[PlantQuestion]:
    """Get question by ID."""
    return await PlantQuestionService.get_question_by_id(db, question_id, include_answers)
async def search_questions(
    db: AsyncSession,
    search_params: PlantQuestionSearchRequest,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantQuestion], int]:
    """Search plant questions."""
    return await PlantQuestionService.search_questions(db, search_params, skip, limit)
async def create_answer(
    db: AsyncSession,
    user_id: UUID,
    answer_data: PlantAnswerCreate
) -> Optional[PlantAnswer]:
    """Create a new answer."""
    return await PlantAnswerService.create_answer(db, user_id, answer_data)
async def vote_answer(
    db: AsyncSession,
    answer_id: UUID,
    user_id: UUID,
    is_upvote: bool
) -> Optional[PlantAnswer]:
    """Vote on an answer."""
    return await PlantAnswerService.vote_answer(db, answer_id, user_id, is_upvote)
async def mark_question_solved(
    db: AsyncSession,
    question_id: UUID,
    user_id: UUID,
    accepted_answer_id: Optional[UUID] = None
) -> Optional[PlantQuestion]:
    """Mark question as solved."""
    return await PlantQuestionService.mark_question_solved(
        db, question_id, user_id, accepted_answer_id
    )
def get_plant_question_service() -> PlantQuestionService:
    """Get plant question service instance."""
    return PlantQuestionService()
def get_plant_answer_service() -> PlantAnswerService:
    """Get plant answer service instance."""
    return PlantAnswerService()
</file>

<file path="backend/app/services/plant_species_service.py">
"""Plant species service.
This module provides business logic for managing plant species data,
including CRUD operations and search functionality.
"""
from typing import List, Optional
from uuid import UUID
from sqlalchemy import and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_species import PlantSpecies
from app.schemas.plant_species import PlantSpeciesCreate, PlantSpeciesUpdate
class PlantSpeciesService:
    """Service for managing plant species."""
    @staticmethod
    async def create_species(
        db: AsyncSession,
        species_data: PlantSpeciesCreate
    ) -> PlantSpecies:
        """Create a new plant species.
        Args:
            db: Database session
            species_data: Plant species creation data
        Returns:
            Created plant species
        """
        species = PlantSpecies(**species_data.dict())
        db.add(species)
        await db.commit()
        await db.refresh(species)
        return species
    @staticmethod
    async def get_species_by_id(
        db: AsyncSession,
        species_id: UUID
    ) -> Optional[PlantSpecies]:
        """Get plant species by ID.
        Args:
            db: Database session
            species_id: Species ID
        Returns:
            Plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def get_species_by_scientific_name(
        db: AsyncSession,
        scientific_name: str
    ) -> Optional[PlantSpecies]:
        """Get plant species by scientific name.
        Args:
            db: Database session
            scientific_name: Scientific name
        Returns:
            Plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(
                PlantSpecies.scientific_name.ilike(f"%{scientific_name}%")
            )
        )
        return result.scalar_one_or_none()
    @staticmethod
    async def search_species(
        db: AsyncSession,
        query: Optional[str] = None,
        care_level: Optional[str] = None,
        family: Optional[str] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantSpecies], int]:
        """Search plant species with filters.
        Args:
            db: Database session
            query: Search query for name matching
            care_level: Filter by care level
            family: Filter by plant family
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (species list, total count)
        """
        # Build base query
        base_query = select(PlantSpecies)
        count_query = select(func.count(PlantSpecies.id))
        # Apply filters
        conditions = []
        if query:
            search_condition = or_(
                PlantSpecies.scientific_name.ilike(f"%{query}%"),
                PlantSpecies.common_names.op("@>")(f'["{query}"]'),
                PlantSpecies.family.ilike(f"%{query}%")
            )
            conditions.append(search_condition)
        if care_level:
            conditions.append(PlantSpecies.care_level == care_level)
        if family:
            conditions.append(PlantSpecies.family.ilike(f"%{family}%"))
        if conditions:
            base_query = base_query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(PlantSpecies.scientific_name)
            .offset(skip)
            .limit(limit)
        )
        species = result.scalars().all()
        return list(species), total
    @staticmethod
    async def update_species(
        db: AsyncSession,
        species_id: UUID,
        species_data: PlantSpeciesUpdate
    ) -> Optional[PlantSpecies]:
        """Update plant species.
        Args:
            db: Database session
            species_id: Species ID
            species_data: Update data
        Returns:
            Updated plant species if found, None otherwise
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        species = result.scalar_one_or_none()
        if not species:
            return None
        # Update fields
        update_data = species_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(species, field, value)
        await db.commit()
        await db.refresh(species)
        return species
    @staticmethod
    async def delete_species(
        db: AsyncSession,
        species_id: UUID
    ) -> bool:
        """Delete plant species.
        Args:
            db: Database session
            species_id: Species ID
        Returns:
            True if deleted, False if not found
        """
        result = await db.execute(
            select(PlantSpecies).where(PlantSpecies.id == species_id)
        )
        species = result.scalar_one_or_none()
        if not species:
            return False
        await db.delete(species)
        await db.commit()
        return True
    @staticmethod
    async def get_popular_species(
        db: AsyncSession,
        limit: int = 10
    ) -> List[PlantSpecies]:
        """Get most popular plant species based on user plants.
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular plant species
        """
        # This would require a join with user_plants table
        # For now, return species ordered by creation date
        result = await db.execute(
            select(PlantSpecies)
            .order_by(PlantSpecies.created_at.desc())
            .limit(limit)
        )
        return list(result.scalars().all())
# Convenience functions for dependency injection
async def get_species_by_id(db: AsyncSession, species_id: UUID) -> Optional[PlantSpecies]:
    """Get plant species by ID."""
    return await PlantSpeciesService.get_species_by_id(db, species_id)
async def get_species_by_scientific_name(db: AsyncSession, scientific_name: str) -> Optional[PlantSpecies]:
    """Get plant species by scientific name."""
    return await PlantSpeciesService.get_species_by_scientific_name(db, scientific_name)
async def search_species(
    db: AsyncSession,
    query: Optional[str] = None,
    care_level: Optional[str] = None,
    family: Optional[str] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantSpecies], int]:
    """Search plant species."""
    return await PlantSpeciesService.search_species(
        db, query, care_level, family, skip, limit
    )
async def create_species(db: AsyncSession, species_data: PlantSpeciesCreate) -> PlantSpecies:
    """Create a new plant species."""
    return await PlantSpeciesService.create_species(db, species_data)
async def update_species(
    db: AsyncSession,
    species_id: UUID,
    species_data: PlantSpeciesUpdate
) -> Optional[PlantSpecies]:
    """Update plant species."""
    return await PlantSpeciesService.update_species(db, species_id, species_data)
async def delete_species(db: AsyncSession, species_id: UUID) -> bool:
    """Delete plant species."""
    return await PlantSpeciesService.delete_species(db, species_id)
async def get_popular_species(db: AsyncSession, limit: int = 10) -> List[PlantSpecies]:
    """Get popular plant species."""
    return await PlantSpeciesService.get_popular_species(db, limit)
</file>

<file path="backend/app/services/plant_trade_service.py">
"""Plant trade service.
This module provides business logic for the plant trading marketplace,
including CRUD operations, search, and trade management.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import and_, or_, func, desc, asc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.plant_trade import PlantTrade, TradeStatus, TradeType
from app.models.plant_species import PlantSpecies
from app.schemas.plant_trade import PlantTradeCreate, PlantTradeUpdate, PlantTradeSearchRequest
class PlantTradeService:
    """Service for managing plant trades."""
    @staticmethod
    async def create_trade(
        db: AsyncSession,
        user_id: UUID,
        trade_data: PlantTradeCreate
    ) -> PlantTrade:
        """Create a new plant trade listing.
        Args:
            db: Database session
            user_id: Owner user ID
            trade_data: Trade creation data
        Returns:
            Created trade listing
        """
        trade = PlantTrade(
            owner_id=user_id,
            **trade_data.dict()
        )
        db.add(trade)
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def get_trade_by_id(
        db: AsyncSession,
        trade_id: UUID,
        include_inactive: bool = False
    ) -> Optional[PlantTrade]:
        """Get trade by ID.
        Args:
            db: Database session
            trade_id: Trade ID
            include_inactive: Whether to include inactive trades
        Returns:
            Trade if found, None otherwise
        """
        query = select(PlantTrade).options(
            selectinload(PlantTrade.owner),
            selectinload(PlantTrade.species),
            selectinload(PlantTrade.interested_user)
        ).where(PlantTrade.id == trade_id)
        if not include_inactive:
            query = query.where(PlantTrade.is_active == True)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_trades(
        db: AsyncSession,
        user_id: UUID,
        status: Optional[TradeStatus] = None,
        trade_type: Optional[TradeType] = None,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantTrade], int]:
        """Get trades owned by a user.
        Args:
            db: Database session
            user_id: User ID
            status: Optional status filter
            trade_type: Optional trade type filter
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (trades list, total count)
        """
        # Build base query
        base_query = select(PlantTrade).options(
            selectinload(PlantTrade.species),
            selectinload(PlantTrade.interested_user)
        ).where(
            and_(
                PlantTrade.owner_id == user_id,
                PlantTrade.is_active == True
            )
        )
        count_query = select(func.count(PlantTrade.id)).where(
            and_(
                PlantTrade.owner_id == user_id,
                PlantTrade.is_active == True
            )
        )
        # Apply filters
        if status:
            base_query = base_query.where(PlantTrade.status == status)
            count_query = count_query.where(PlantTrade.status == status)
        if trade_type:
            base_query = base_query.where(PlantTrade.trade_type == trade_type)
            count_query = count_query.where(PlantTrade.trade_type == trade_type)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(desc(PlantTrade.created_at))
            .offset(skip)
            .limit(limit)
        )
        trades = result.scalars().all()
        return list(trades), total
    @staticmethod
    async def search_trades(
        db: AsyncSession,
        search_params: PlantTradeSearchRequest,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[PlantTrade], int]:
        """Search plant trades with filters.
        Args:
            db: Database session
            search_params: Search parameters
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (trades list, total count)
        """
        # Build base query
        base_query = select(PlantTrade).options(
            selectinload(PlantTrade.owner),
            selectinload(PlantTrade.species)
        ).where(
            and_(
                PlantTrade.is_active == True,
                PlantTrade.status == TradeStatus.AVAILABLE
            )
        )
        count_query = select(func.count(PlantTrade.id)).where(
            and_(
                PlantTrade.is_active == True,
                PlantTrade.status == TradeStatus.AVAILABLE
            )
        )
        # Apply search filters
        if search_params.query:
            search_filter = or_(
                PlantTrade.title.ilike(f"%{search_params.query}%"),
                PlantTrade.description.ilike(f"%{search_params.query}%")
            )
            base_query = base_query.where(search_filter)
            count_query = count_query.where(search_filter)
        if search_params.trade_type:
            base_query = base_query.where(PlantTrade.trade_type == search_params.trade_type)
            count_query = count_query.where(PlantTrade.trade_type == search_params.trade_type)
        if search_params.species_id:
            base_query = base_query.where(PlantTrade.species_id == search_params.species_id)
            count_query = count_query.where(PlantTrade.species_id == search_params.species_id)
        if search_params.location:
            base_query = base_query.where(
                PlantTrade.location.ilike(f"%{search_params.location}%")
            )
            count_query = count_query.where(
                PlantTrade.location.ilike(f"%{search_params.location}%")
            )
        if search_params.max_price is not None:
            base_query = base_query.where(
                or_(
                    PlantTrade.price <= search_params.max_price,
                    PlantTrade.price.is_(None)  # Include free items
                )
            )
            count_query = count_query.where(
                or_(
                    PlantTrade.price <= search_params.max_price,
                    PlantTrade.price.is_(None)
                )
            )
        # Apply sorting
        if search_params.sort_by == "price_low":
            base_query = base_query.order_by(asc(PlantTrade.price.nulls_first()))
        elif search_params.sort_by == "price_high":
            base_query = base_query.order_by(desc(PlantTrade.price.nulls_last()))
        elif search_params.sort_by == "newest":
            base_query = base_query.order_by(desc(PlantTrade.created_at))
        else:  # Default to newest
            base_query = base_query.order_by(desc(PlantTrade.created_at))
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.offset(skip).limit(limit)
        )
        trades = result.scalars().all()
        return list(trades), total
    @staticmethod
    async def update_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID,
        trade_data: PlantTradeUpdate
    ) -> Optional[PlantTrade]:
        """Update trade listing.
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Owner user ID
            trade_data: Update data
        Returns:
            Updated trade if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == user_id
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Update fields
        update_data = trade_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(trade, field, value)
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def express_interest(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> Optional[PlantTrade]:
        """Express interest in a trade.
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Interested user ID
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.status == TradeStatus.AVAILABLE,
                    PlantTrade.is_active == True,
                    PlantTrade.owner_id != user_id  # Can't be interested in own trade
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Update trade status and interested user
        trade.status = TradeStatus.PENDING
        trade.interested_user_id = user_id
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def accept_trade(
        db: AsyncSession,
        trade_id: UUID,
        owner_id: UUID
    ) -> Optional[PlantTrade]:
        """Accept a trade (mark as completed).
        Args:
            db: Database session
            trade_id: Trade ID
            owner_id: Owner user ID
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == owner_id,
                    PlantTrade.status == TradeStatus.PENDING
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # Mark trade as completed
        trade.status = TradeStatus.COMPLETED
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def cancel_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> Optional[PlantTrade]:
        """Cancel a trade (owner can cancel, interested user can withdraw).
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: User ID (owner or interested user)
        Returns:
            Updated trade if successful, None otherwise
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    or_(
                        PlantTrade.owner_id == user_id,
                        PlantTrade.interested_user_id == user_id
                    )
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return None
        # If owner cancels, mark as cancelled
        # If interested user withdraws, reset to available
        if trade.owner_id == user_id:
            trade.status = TradeStatus.CANCELLED
        else:
            trade.status = TradeStatus.AVAILABLE
            trade.interested_user_id = None
        trade.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(trade)
        return trade
    @staticmethod
    async def delete_trade(
        db: AsyncSession,
        trade_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete trade listing (soft delete).
        Args:
            db: Database session
            trade_id: Trade ID
            user_id: Owner user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(PlantTrade).where(
                and_(
                    PlantTrade.id == trade_id,
                    PlantTrade.owner_id == user_id
                )
            )
        )
        trade = result.scalar_one_or_none()
        if not trade:
            return False
        trade.is_active = False
        trade.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_trade_statistics(
        db: AsyncSession,
        user_id: Optional[UUID] = None
    ) -> Dict[str, Any]:
        """Get trade statistics.
        Args:
            db: Database session
            user_id: Optional user ID for user-specific stats
        Returns:
            Dictionary with trade statistics
        """
        base_filter = PlantTrade.is_active == True
        if user_id:
            base_filter = and_(base_filter, PlantTrade.owner_id == user_id)
        # Total active trades
        total_result = await db.execute(
            select(func.count(PlantTrade.id)).where(base_filter)
        )
        total_trades = total_result.scalar()
        # Trades by status
        status_result = await db.execute(
            select(
                PlantTrade.status,
                func.count(PlantTrade.id)
            ).where(base_filter)
            .group_by(PlantTrade.status)
        )
        status_stats = {status.value: count for status, count in status_result.all()}
        # Trades by type
        type_result = await db.execute(
            select(
                PlantTrade.trade_type,
                func.count(PlantTrade.id)
            ).where(base_filter)
            .group_by(PlantTrade.trade_type)
        )
        type_stats = {trade_type.value: count for trade_type, count in type_result.all()}
        # Average price for sell trades
        avg_price_result = await db.execute(
            select(func.avg(PlantTrade.price)).where(
                and_(
                    base_filter,
                    PlantTrade.trade_type == TradeType.SELL,
                    PlantTrade.price.is_not(None)
                )
            )
        )
        avg_price = avg_price_result.scalar() or 0.0
        return {
            "total_trades": total_trades,
            "status_breakdown": status_stats,
            "type_breakdown": type_stats,
            "available_trades": status_stats.get(TradeStatus.AVAILABLE.value, 0),
            "completed_trades": status_stats.get(TradeStatus.COMPLETED.value, 0),
            "average_sell_price": round(float(avg_price), 2) if avg_price else 0.0
        }
    @staticmethod
    async def get_popular_species(
        db: AsyncSession,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get most popular species in trades.
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular species with trade counts
        """
        result = await db.execute(
            select(
                PlantTrade.species_id,
                func.count(PlantTrade.id).label('trade_count')
            ).join(PlantSpecies)
            .where(
                and_(
                    PlantTrade.is_active == True,
                    PlantTrade.status == TradeStatus.AVAILABLE
                )
            )
            .group_by(PlantTrade.species_id)
            .order_by(desc('trade_count'))
            .limit(limit)
        )
        popular_species = []
        for species_id, count in result.all():
            # Get species details
            species_result = await db.execute(
                select(PlantSpecies).where(PlantSpecies.id == species_id)
            )
            species = species_result.scalar_one_or_none()
            if species:
                popular_species.append({
                    "species_id": species_id,
                    "scientific_name": species.scientific_name,
                    "common_names": species.common_names,
                    "trade_count": count
                })
        return popular_species
    @staticmethod
    async def get_popular_species_in_trades(
        db: AsyncSession,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get most popular species in trades (alias for get_popular_species).
        Args:
            db: Database session
            limit: Maximum number of species to return
        Returns:
            List of popular species with trade counts
        """
        return await PlantTradeService.get_popular_species(db, limit)
# Convenience functions for dependency injection
async def create_trade(
    db: AsyncSession,
    user_id: UUID,
    trade_data: PlantTradeCreate
) -> PlantTrade:
    """Create a new plant trade listing."""
    return await PlantTradeService.create_trade(db, user_id, trade_data)
async def get_trade_by_id(
    db: AsyncSession,
    trade_id: UUID,
    include_inactive: bool = False
) -> Optional[PlantTrade]:
    """Get trade by ID."""
    return await PlantTradeService.get_trade_by_id(db, trade_id, include_inactive)
async def search_trades(
    db: AsyncSession,
    search_params: PlantTradeSearchRequest,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantTrade], int]:
    """Search plant trades."""
    return await PlantTradeService.search_trades(db, search_params, skip, limit)
async def express_interest(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Express interest in a trade."""
    return await PlantTradeService.express_interest(db, trade_id, user_id)
async def get_trade_statistics(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get trade statistics."""
    return await PlantTradeService.get_trade_statistics(db, user_id)
async def get_user_trades(
    db: AsyncSession,
    user_id: UUID,
    status: Optional[TradeStatus] = None,
    trade_type: Optional[TradeType] = None,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[PlantTrade], int]:
    """Get trades owned by a user."""
    return await PlantTradeService.get_user_trades(
        db, user_id, status, trade_type, skip, limit
    )
async def update_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID,
    trade_data: PlantTradeUpdate
) -> Optional[PlantTrade]:
    """Update trade listing."""
    return await PlantTradeService.update_trade(db, trade_id, user_id, trade_data)
async def accept_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Accept a trade offer."""
    return await PlantTradeService.accept_trade(db, trade_id, user_id)
async def cancel_trade(
    db: AsyncSession,
    trade_id: UUID,
    user_id: UUID
) -> Optional[PlantTrade]:
    """Cancel a trade."""
    return await PlantTradeService.cancel_trade(db, trade_id, user_id)
async def delete_trade(db: AsyncSession, trade_id: UUID, user_id: UUID) -> bool:
    """Delete trade listing (soft delete)."""
    return await PlantTradeService.delete_trade(db, trade_id, user_id)
async def get_popular_species_in_trades(
    db: AsyncSession,
    limit: int = 10
) -> List[Dict[str, Any]]:
    """Get popular species in trades."""
    return await PlantTradeService.get_popular_species_in_trades(db, limit)
async def get_trade_stats(
    db: AsyncSession,
    user_id: Optional[UUID] = None
) -> Dict[str, Any]:
    """Get trade statistics."""
    return await PlantTradeService.get_trade_statistics(db, user_id)
async def get_popular_trade_species(
    db: AsyncSession,
    limit: int = 10
) -> List[Dict[str, Any]]:
    """Get popular species in trades."""
    return await PlantTradeService.get_popular_species(db, limit)
</file>

<file path="backend/app/services/story_service.py">
"""Story service.
This module provides story management services including
creating, viewing, and managing ephemeral content.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.story import Story, StoryView
from app.schemas.story import StoryType, StoryPrivacyLevel
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.schemas.story import (
    StoryCreate, StoryUpdate, StoryRead, StoryFeed,
    StoryViewCreate, StoryView, StoryAnalytics, StorySearch
)
from app.core.websocket import websocket_manager
class StoryService:
    """Service for story management operations."""
    def __init__(self):
        self.connection_manager = websocket_manager
    async def create_story(
        self,
        user_id: str,
        story_data: StoryCreate,
        session: AsyncSession
    ) -> Optional[Story]:
        """Create a new story."""
        # Validate story content
        await self._validate_story_content(story_data)
        # Calculate expiration time (24 hours from now)
        expires_at = datetime.utcnow() + timedelta(hours=24)
        # Create story
        story = Story(
            user_id=user_id,
            content_type=story_data.content_type,
            media_url=story_data.media_url,
            caption=story_data.caption,
            duration=story_data.duration,
            file_size=story_data.file_size,
            privacy_level=story_data.privacy_level,
            expires_at=expires_at,
            plant_tags=story_data.plant_tags,
            location=story_data.location
        )
        session.add(story)
        await session.commit()
        await session.refresh(story)
        # Send real-time notification to friends
        await self._notify_friends_of_new_story(story, session)
        return story
    async def get_story_by_id(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> Optional[StoryRead]:
        """Get story by ID if viewer has access."""
        # Get story with user info
        result = await session.execute(
            select(Story, User).join(User, User.id == Story.user_id).where(
                and_(
                    Story.id == story_id,
                    Story.is_active == True,
                    Story.expires_at > datetime.utcnow()
                )
            )
        )
        story_user = result.first()
        if not story_user:
            return None
        story, user = story_user
        # Check if viewer has access to this story
        if not await self._can_view_story(story, viewer_id, session):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to view this story"
            )
        # Check if viewer has already viewed this story
        has_viewed = await self._has_user_viewed_story(story_id, viewer_id, session)
        # Get view count
        view_count = await session.scalar(
            select(func.count(StoryView.id)).where(StoryView.story_id == story_id)
        ) or 0
        # Convert to StoryRead
        story_read = StoryRead(
            id=str(story.id),
            user_id=str(story.user_id),
            content_type=story.content_type,
            media_url=story.media_url,
            caption=story.caption,
            duration=story.duration,
            file_size=story.file_size,
            privacy_level=story.privacy_level,
            created_at=story.created_at,
            expires_at=story.expires_at,
            plant_tags=story.plant_tags,
            location=story.location,
            user_username=user.username,
            user_display_name=user.display_name,
            user_avatar_url=user.avatar_url,
            view_count=view_count,
            has_viewed=has_viewed
        )
        return story_read
    async def get_user_stories(
        self,
        user_id: str,
        viewer_id: str,
        session: AsyncSession,
        include_expired: bool = False
    ) -> List[StoryRead]:
        """Get all stories for a specific user."""
        # Build query
        query = select(Story, User).join(User, User.id == Story.user_id).where(
            and_(
                Story.user_id == user_id,
                Story.is_active == True
            )
        )
        if not include_expired:
            query = query.where(Story.expires_at > datetime.utcnow())
        # Check if viewer can see this user's stories
        if viewer_id != user_id:
            can_view = await self._can_view_user_stories(user_id, viewer_id, session)
            if not can_view:
                return []
        query = query.order_by(desc(Story.created_at))
        result = await session.execute(query)
        stories_users = result.all()
        story_reads = []
        for story, user in stories_users:
            # Check individual story permissions
            if await self._can_view_story(story, viewer_id, session):
                has_viewed = await self._has_user_viewed_story(str(story.id), viewer_id, session)
                view_count = await session.scalar(
                    select(func.count(StoryView.id)).where(StoryView.story_id == str(story.id))
                ) or 0
                story_read = StoryRead(
                    id=str(story.id),
                    user_id=str(story.user_id),
                    content_type=story.content_type,
                    media_url=story.media_url,
                    caption=story.caption,
                    duration=story.duration,
                    file_size=story.file_size,
                    privacy_level=story.privacy_level,
                    created_at=story.created_at,
                    expires_at=story.expires_at,
                    plant_tags=story.plant_tags,
                    location=story.location,
                    user_username=user.username,
                    user_display_name=user.display_name,
                    user_avatar_url=user.avatar_url,
                    view_count=view_count,
                    has_viewed=has_viewed
                )
                story_reads.append(story_read)
        return story_reads
    async def get_stories_feed(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 50
    ) -> List[StoryFeed]:
        """Get stories feed for a user (friends' stories)."""
        # Get user's friends
        friends_query = select(
            func.case(
                (Friendship.requester_id == user_id, Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == user_id
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        friends_result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in friends_result]
        if not friend_ids:
            return []
        # Get active stories from friends
        stories_query = (
            select(Story, User)
            .join(User, User.id == Story.user_id)
            .where(
                and_(
                    Story.user_id.in_(friend_ids),
                    Story.is_active == True,
                    Story.expires_at > datetime.utcnow(),
                    or_(
                        Story.privacy_level == StoryPrivacyLevel.FRIENDS,
                        Story.privacy_level == StoryPrivacyLevel.PUBLIC
                    )
                )
            )
            .order_by(desc(Story.created_at))
            .limit(limit)
        )
        result = await session.execute(stories_query)
        stories_users = result.all()
        # Group stories by user
        user_stories = {}
        for story, user in stories_users:
            user_key = str(user.id)
            if user_key not in user_stories:
                user_stories[user_key] = {
                    "user": user,
                    "stories": []
                }
            user_stories[user_key]["stories"].append(story)
        # Convert to StoryFeed format
        story_feeds = []
        for user_key, data in user_stories.items():
            user = data["user"]
            stories = data["stories"]
            # Check if user has viewed any stories from this user
            has_unviewed = False
            for story in stories:
                if not await self._has_user_viewed_story(str(story.id), user_id, session):
                    has_unviewed = True
                    break
            story_feed = StoryFeed(
                user_id=str(user.id),
                user_username=user.username,
                user_display_name=user.display_name,
                user_avatar_url=user.avatar_url,
                stories_count=len(stories),
                latest_story_timestamp=max(story.created_at for story in stories),
                has_unviewed_stories=has_unviewed
            )
            story_feeds.append(story_feed)
        # Sort by latest story timestamp
        story_feeds.sort(key=lambda x: x.latest_story_timestamp, reverse=True)
        return story_feeds
    async def view_story(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Mark a story as viewed by a user."""
        # Check if story exists and is accessible
        story_read = await self.get_story_by_id(story_id, viewer_id, session)
        if not story_read:
            return False
        # Check if already viewed
        if await self._has_user_viewed_story(story_id, viewer_id, session):
            return True  # Already viewed
        # Create story view record
        story_view = StoryView(
            story_id=story_id,
            viewer_id=viewer_id
        )
        session.add(story_view)
        await session.commit()
        # Send view notification to story owner (if not viewing own story)
        if story_read.user_id != viewer_id:
            await self._send_story_view_notification(story_read, viewer_id, session)
        return True
    async def delete_story(
        self,
        story_id: str,
        user_id: str,
        session: AsyncSession
    ) -> bool:
        """Delete a story (only by owner)."""
        story = await session.execute(
            select(Story).where(
                and_(
                    Story.id == story_id,
                    Story.user_id == user_id
                )
            )
        )
        story = story.scalar_one_or_none()
        if not story:
            return False
        # Soft delete
        story.is_active = False
        story.updated_at = datetime.utcnow()
        await session.commit()
        return True
    async def get_story_analytics(
        self,
        story_id: str,
        user_id: str,
        session: AsyncSession
    ) -> Optional[StoryAnalytics]:
        """Get analytics for a story (only for owner)."""
        # Verify ownership
        story = await session.execute(
            select(Story).where(
                and_(
                    Story.id == story_id,
                    Story.user_id == user_id
                )
            )
        )
        story = story.scalar_one_or_none()
        if not story:
            return None
        # Get view analytics
        total_views = await session.scalar(
            select(func.count(StoryView.id)).where(StoryView.story_id == story_id)
        ) or 0
        unique_viewers = await session.scalar(
            select(func.count(func.distinct(StoryView.viewer_id))).where(
                StoryView.story_id == story_id
            )
        ) or 0
        # Get viewers list (recent viewers)
        recent_viewers_query = (
            select(StoryView, User)
            .join(User, User.id == StoryView.viewer_id)
            .where(StoryView.story_id == story_id)
            .order_by(desc(StoryView.viewed_at))
            .limit(10)
        )
        result = await session.execute(recent_viewers_query)
        recent_viewers = []
        for view, user in result:
            recent_viewers.append({
                "user_id": str(user.id),
                "username": user.username,
                "display_name": user.display_name,
                "avatar_url": user.avatar_url,
                "viewed_at": view.viewed_at
            })
        return StoryAnalytics(
            story_id=story_id,
            total_views=total_views,
            unique_viewers=unique_viewers,
            recent_viewers=recent_viewers,
            created_at=story.created_at,
            expires_at=story.expires_at
        )
    async def search_stories(
        self,
        user_id: str,
        search_params: StorySearch,
        session: AsyncSession
    ) -> List[StoryRead]:
        """Search stories accessible to the user."""
        # Get user's friends for privacy filtering
        friends_query = select(
            func.case(
                (Friendship.requester_id == user_id, Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == user_id,
                    Friendship.addressee_id == user_id
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        friends_result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in friends_result]
        friend_ids.append(user_id)  # Include own stories
        # Build search query
        query = select(Story, User).join(User, User.id == Story.user_id).where(
            and_(
                Story.is_active == True,
                Story.expires_at > datetime.utcnow(),
                or_(
                    Story.privacy_level == StoryPrivacyLevel.PUBLIC,
                    and_(
                        Story.privacy_level == StoryPrivacyLevel.FRIENDS,
                        Story.user_id.in_(friend_ids)
                    ),
                    Story.user_id == user_id  # Own stories
                )
            )
        )
        # Apply search filters
        if search_params.query:
            query = query.where(
                or_(
                    Story.caption.ilike(f"%{search_params.query}%"),
                    Story.plant_tags.ilike(f"%{search_params.query}%")
                )
            )
        if search_params.content_type:
            query = query.where(Story.content_type == search_params.content_type)
        if search_params.user_id:
            query = query.where(Story.user_id == search_params.user_id)
        if search_params.start_date:
            query = query.where(Story.created_at >= search_params.start_date)
        if search_params.end_date:
            query = query.where(Story.created_at <= search_params.end_date)
        # Add ordering and limit
        query = query.order_by(desc(Story.created_at)).limit(50)
        result = await session.execute(query)
        stories_users = result.all()
        # Convert to StoryRead format
        story_reads = []
        for story, user in stories_users:
            has_viewed = await self._has_user_viewed_story(str(story.id), user_id, session)
            view_count = await session.scalar(
                select(func.count(StoryView.id)).where(StoryView.story_id == str(story.id))
            ) or 0
            story_read = StoryRead(
                id=str(story.id),
                user_id=str(story.user_id),
                content_type=story.content_type,
                media_url=story.media_url,
                caption=story.caption,
                duration=story.duration,
                file_size=story.file_size,
                privacy_level=story.privacy_level,
                created_at=story.created_at,
                expires_at=story.expires_at,
                plant_tags=story.plant_tags,
                location=story.location,
                user_username=user.username,
                user_display_name=user.display_name,
                user_avatar_url=user.avatar_url,
                view_count=view_count,
                has_viewed=has_viewed
            )
            story_reads.append(story_read)
        return story_reads
    async def cleanup_expired_stories(self, session: AsyncSession) -> int:
        """Clean up expired stories (background task)."""
        result = await session.execute(
            select(Story).where(
                and_(
                    Story.is_active == True,
                    Story.expires_at <= datetime.utcnow()
                )
            )
        )
        expired_stories = result.scalars().all()
        count = 0
        for story in expired_stories:
            story.is_active = False
            story.updated_at = datetime.utcnow()
            count += 1
        if count > 0:
            await session.commit()
        return count
    async def _validate_story_content(self, story_data: StoryCreate):
        """Validate story content."""
        if story_data.content_type in [StoryType.IMAGE, StoryType.VIDEO]:
            if not story_data.media_url:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"{story_data.content_type.value} stories must have media_url"
                )
        if story_data.duration and story_data.duration > 60:  # Max 60 seconds
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Story duration cannot exceed 60 seconds"
            )
    async def _can_view_story(
        self,
        story: Story,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can access this story."""
        # Owner can always view
        if str(story.user_id) == viewer_id:
            return True
        # Public stories
        if story.privacy_level == StoryPrivacyLevel.PUBLIC:
            return True
        # Friends only stories
        if story.privacy_level == StoryPrivacyLevel.FRIENDS:
            return await self._are_users_friends(str(story.user_id), viewer_id, session)
        # Close friends stories
        if story.privacy_level == StoryPrivacyLevel.CLOSE_FRIENDS:
            return await self._are_close_friends(str(story.user_id), viewer_id, session)
        return False
    async def _can_view_user_stories(
        self,
        user_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can see user's stories in general."""
        if user_id == viewer_id:
            return True
        # Check if they are friends
        return await self._are_users_friends(user_id, viewer_id, session)
    async def _are_users_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _are_close_friends(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if two users are close friends."""
        result = await session.execute(
            select(Friendship).where(
                and_(
                    or_(
                        and_(
                            Friendship.requester_id == user1_id,
                            Friendship.addressee_id == user2_id
                        ),
                        and_(
                            Friendship.requester_id == user2_id,
                            Friendship.addressee_id == user1_id
                        )
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED,
                    Friendship.is_close_friend == True
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _has_user_viewed_story(
        self,
        story_id: str,
        viewer_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if user has viewed a story."""
        result = await session.execute(
            select(StoryView).where(
                and_(
                    StoryView.story_id == story_id,
                    StoryView.viewer_id == viewer_id
                )
            )
        )
        return result.scalar_one_or_none() is not None
    async def _notify_friends_of_new_story(self, story: Story, session: AsyncSession):
        """Send notifications to friends about new story."""
        # Get friends based on privacy level
        if story.privacy_level == StoryPrivacyLevel.PUBLIC:
            # For public stories, we might not notify everyone
            # This could be a setting or limited to close friends
            return
        friends_query = select(
            func.case(
                (Friendship.requester_id == str(story.user_id), Friendship.addressee_id),
                else_=Friendship.requester_id
            ).label("friend_id")
        ).where(
            and_(
                or_(
                    Friendship.requester_id == str(story.user_id),
                    Friendship.addressee_id == str(story.user_id)
                ),
                Friendship.status == FriendshipStatus.ACCEPTED
            )
        )
        if story.privacy_level == StoryPrivacyLevel.CLOSE_FRIENDS:
            friends_query = friends_query.where(Friendship.is_close_friend == True)
        result = await session.execute(friends_query)
        friend_ids = [row.friend_id for row in result]
        # Get story owner info
        owner = await session.get(User, story.user_id)
        if owner and friend_ids:
            notification_data = {
                "type": "new_story",
                "story_id": str(story.id),
                "user_id": str(story.user_id),
                "username": owner.username,
                "display_name": owner.display_name,
                "content_type": story.content_type.value,
                "timestamp": story.created_at.isoformat()
            }
            # Send to all friends
            await self.connection_manager.broadcast_to_users(
                friend_ids,
                notification_data
            )
    async def _send_story_view_notification(
        self,
        story: StoryRead,
        viewer_id: str,
        session: AsyncSession
    ):
        """Send notification to story owner about view."""
        viewer = await session.get(User, viewer_id)
        if viewer:
            notification_data = {
                "type": "story_viewed",
                "story_id": story.id,
                "viewer_id": str(viewer.id),
                "viewer_username": viewer.username,
                "viewer_display_name": viewer.display_name,
                "timestamp": datetime.utcnow().isoformat()
            }
            await self.connection_manager.send_personal_message(
                story.user_id,
                notification_data
            )
# Global story service instance
story_service = StoryService()
# Convenience functions for backward compatibility
async def create_story(
    user_id: str,
    story_data: StoryCreate,
    session: AsyncSession
) -> Optional[Story]:
    """Create a new story."""
    return await story_service.create_story(user_id, story_data, session)
async def get_user_stories(
    user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> List[StoryRead]:
    """Get user's stories."""
    return await story_service.get_user_stories(user_id, session, limit, offset)
async def get_friends_stories(
    user_id: str,
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0
) -> StoryFeed:
    """Get friends' stories."""
    return await story_service.get_friends_stories(user_id, session, limit, offset)
async def get_story_by_id(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> Optional[StoryRead]:
    """Get a story by ID."""
    return await story_service.get_story_by_id(story_id, user_id, session)
async def view_story(
    story_id: str,
    viewer_id: str,
    session: AsyncSession
) -> bool:
    """View a story."""
    return await story_service.view_story(story_id, viewer_id, session)
async def delete_story(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> bool:
    """Delete a story."""
    return await story_service.delete_story(story_id, user_id, session)
async def get_story_views(
    story_id: str,
    user_id: str,
    session: AsyncSession
) -> List[StoryView]:
    """Get story views."""
    return await story_service.get_story_views(story_id, user_id, session)
async def get_story_service() -> StoryService:
    """Get story service dependency."""
    return story_service
</file>

<file path="backend/app/services/user_plant_service.py">
"""User plant service.
This module provides business logic for managing user plants,
including CRUD operations, care tracking, and reminders.
"""
from datetime import datetime, timedelta
from typing import List, Optional
from uuid import UUID
from sqlalchemy import and_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from app.models.user_plant import UserPlant
from app.models.plant_species import PlantSpecies
from app.models.plant_care_log import PlantCareLog
from app.schemas.user_plant import UserPlantCreate, UserPlantUpdate
class UserPlantService:
    """Service for managing user plants."""
    @staticmethod
    async def create_plant(
        db: AsyncSession,
        user_id: UUID,
        plant_data: UserPlantCreate
    ) -> UserPlant:
        """Create a new user plant.
        Args:
            db: Database session
            user_id: Owner user ID
            plant_data: Plant creation data
        Returns:
            Created user plant
        """
        plant = UserPlant(
            user_id=user_id,
            **plant_data.dict()
        )
        db.add(plant)
        await db.commit()
        await db.refresh(plant)
        return plant
    @staticmethod
    async def get_plant_by_id(
        db: AsyncSession,
        plant_id: UUID,
        user_id: Optional[UUID] = None
    ) -> Optional[UserPlant]:
        """Get user plant by ID.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Optional user ID for ownership check
        Returns:
            User plant if found, None otherwise
        """
        query = select(UserPlant).options(
            selectinload(UserPlant.species)
        ).where(UserPlant.id == plant_id)
        if user_id:
            query = query.where(UserPlant.user_id == user_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    @staticmethod
    async def get_user_plants(
        db: AsyncSession,
        user_id: UUID,
        is_active: Optional[bool] = True,
        skip: int = 0,
        limit: int = 20
    ) -> tuple[List[UserPlant], int]:
        """Get plants owned by a user.
        Args:
            db: Database session
            user_id: User ID
            is_active: Filter by active status
            skip: Number of records to skip
            limit: Maximum number of records to return
        Returns:
            Tuple of (plants list, total count)
        """
        # Build base query
        base_query = select(UserPlant).options(
            selectinload(UserPlant.species)
        ).where(UserPlant.user_id == user_id)
        count_query = select(func.count(UserPlant.id)).where(
            UserPlant.user_id == user_id
        )
        if is_active is not None:
            base_query = base_query.where(UserPlant.is_active == is_active)
            count_query = count_query.where(UserPlant.is_active == is_active)
        # Get total count
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        # Get paginated results
        result = await db.execute(
            base_query.order_by(UserPlant.created_at.desc())
            .offset(skip)
            .limit(limit)
        )
        plants = result.scalars().all()
        return list(plants), total
    @staticmethod
    async def update_plant(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        plant_data: UserPlantUpdate
    ) -> Optional[UserPlant]:
        """Update user plant.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
            plant_data: Update data
        Returns:
            Updated plant if found and owned by user, None otherwise
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return None
        # Update fields
        update_data = plant_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(plant, field, value)
        plant.updated_at = datetime.utcnow()
        await db.commit()
        await db.refresh(plant)
        return plant
    @staticmethod
    async def delete_plant(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID
    ) -> bool:
        """Delete user plant (soft delete by setting is_active=False).
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
        Returns:
            True if deleted, False if not found or not owned
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return False
        plant.is_active = False
        plant.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_care_reminders(
        db: AsyncSession,
        user_id: UUID
    ) -> List[dict]:
        """Get care reminders for user's plants.
        Args:
            db: Database session
            user_id: User ID
        Returns:
            List of care reminder data
        """
        # Get plants with species info
        result = await db.execute(
            select(UserPlant).options(
                selectinload(UserPlant.species)
            ).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            )
        )
        plants = result.scalars().all()
        reminders = []
        current_time = datetime.utcnow()
        for plant in plants:
            if not plant.species or not plant.species.water_frequency_days:
                continue
            # Check watering reminder
            if plant.last_watered:
                days_since_watered = (current_time - plant.last_watered).days
                if days_since_watered >= plant.species.water_frequency_days:
                    reminders.append({
                        "plant_id": plant.id,
                        "plant_nickname": plant.nickname,
                        "species_name": plant.species.scientific_name,
                        "care_type": "watering",
                        "days_overdue": days_since_watered - plant.species.water_frequency_days,
                        "last_care_date": plant.last_watered,
                        "recommended_frequency_days": plant.species.water_frequency_days
                    })
        return reminders
    @staticmethod
    async def update_care_activity(
        db: AsyncSession,
        plant_id: UUID,
        user_id: UUID,
        care_type: str,
        care_date: Optional[datetime] = None
    ) -> bool:
        """Update plant care activity timestamp.
        Args:
            db: Database session
            plant_id: Plant ID
            user_id: Owner user ID
            care_type: Type of care (watering, fertilizing, etc.)
            care_date: Date of care activity
        Returns:
            True if updated, False if plant not found or not owned
        """
        result = await db.execute(
            select(UserPlant).where(
                and_(
                    UserPlant.id == plant_id,
                    UserPlant.user_id == user_id
                )
            )
        )
        plant = result.scalar_one_or_none()
        if not plant:
            return False
        if care_date is None:
            care_date = datetime.utcnow()
        # Update appropriate timestamp
        if care_type == "watering":
            plant.last_watered = care_date
        elif care_type == "fertilizing":
            plant.last_fertilized = care_date
        elif care_type == "repotting":
            plant.last_repotted = care_date
        plant.updated_at = datetime.utcnow()
        await db.commit()
        return True
    @staticmethod
    async def get_plant_stats(
        db: AsyncSession,
        user_id: UUID
    ) -> dict:
        """Get plant statistics for a user.
        Args:
            db: Database session
            user_id: User ID
        Returns:
            Dictionary with plant statistics
        """
        # Get total plants count
        total_result = await db.execute(
            select(func.count(UserPlant.id)).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            )
        )
        total_plants = total_result.scalar()
        # Get plants by health status
        health_result = await db.execute(
            select(
                UserPlant.health_status,
                func.count(UserPlant.id)
            ).where(
                and_(
                    UserPlant.user_id == user_id,
                    UserPlant.is_active == True
                )
            ).group_by(UserPlant.health_status)
        )
        health_stats = {status: count for status, count in health_result.all()}
        return {
            "total_plants": total_plants,
            "health_distribution": health_stats,
            "healthy_plants": health_stats.get("healthy", 0),
            "sick_plants": health_stats.get("sick", 0),
            "recovering_plants": health_stats.get("recovering", 0)
        }
# Convenience functions for dependency injection
async def get_plant_by_id(
    db: AsyncSession,
    plant_id: UUID,
    user_id: Optional[UUID] = None
) -> Optional[UserPlant]:
    """Get user plant by ID."""
    return await UserPlantService.get_plant_by_id(db, plant_id, user_id)
async def get_user_plants(
    db: AsyncSession,
    user_id: UUID,
    is_active: Optional[bool] = True,
    skip: int = 0,
    limit: int = 20
) -> tuple[List[UserPlant], int]:
    """Get user's plants."""
    return await UserPlantService.get_user_plants(db, user_id, is_active, skip, limit)
async def create_plant(
    db: AsyncSession,
    user_id: UUID,
    plant_data: UserPlantCreate
) -> UserPlant:
    """Create a new user plant."""
    return await UserPlantService.create_plant(db, user_id, plant_data)
async def update_plant(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    plant_data: UserPlantUpdate
) -> Optional[UserPlant]:
    """Update user plant."""
    return await UserPlantService.update_plant(db, plant_id, user_id, plant_data)
async def get_care_reminders(db: AsyncSession, user_id: UUID) -> List[dict]:
    """Get care reminders for user's plants."""
    return await UserPlantService.get_care_reminders(db, user_id)
async def update_care_activity(
    db: AsyncSession,
    plant_id: UUID,
    user_id: UUID,
    care_type: str,
    care_date: Optional[datetime] = None
) -> bool:
    """Update plant care activity."""
    return await UserPlantService.update_care_activity(
        db, plant_id, user_id, care_type, care_date
    )
async def get_plant_stats(db: AsyncSession, user_id: UUID) -> dict:
    """Get plant statistics for a user."""
    return await UserPlantService.get_plant_stats(db, user_id)
async def delete_plant(db: AsyncSession, plant_id: UUID, user_id: UUID) -> bool:
    """Delete user plant (soft delete)."""
    return await UserPlantService.delete_plant(db, plant_id, user_id)
</file>

<file path="backend/app/services/user_service.py">
"""User service.
This module provides user management services including
profile management, search, and user statistics.
"""
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func, desc, asc
from sqlalchemy.orm import selectinload
from fastapi import HTTPException, status
from app.models.user import User
from app.models.friendship import Friendship, FriendshipStatus
from app.models.message import Message
from app.models.story import Story
from app.schemas.user import (
    UserUpdate, UserSearch, UserStats, UserSearchFilters,
    UserActivity, UserPreferences
)
from app.schemas.auth import UserCreate
from app.schemas.friendship import FriendProfile
from app.services.auth_service import auth_service
class UserService:
    """Service for user management operations."""
    def __init__(self):
        self.auth_service = auth_service
    async def create_user(
        self, 
        user_data: UserCreate, 
        session: AsyncSession
    ) -> User:
        """Create a new user."""
        # Hash the password
        hashed_password = self.auth_service.get_password_hash(user_data.password)
        # Create user instance
        user = User(
            email=user_data.email,
            username=user_data.username,
            display_name=user_data.display_name or user_data.username,
            hashed_password=hashed_password,
            bio=user_data.bio,
            location=user_data.location,
            gardening_experience=user_data.gardening_experience
        )
        session.add(user)
        await session.commit()
        await session.refresh(user)
        return user
    async def get_user_by_id(
        self, 
        user_id: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by ID."""
        result = await session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()
    async def get_user_by_username(
        self, 
        username: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by username."""
        result = await session.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()
    async def get_user_by_email(
        self, 
        email: str, 
        session: AsyncSession
    ) -> Optional[User]:
        """Get user by email."""
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()
    async def search_users(
        self,
        query: str,
        current_user_id: str,
        session: AsyncSession,
        filters: Optional[UserSearchFilters] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[UserSearch]:
        """Search for users with optional filters."""
        # Base query
        base_query = select(User).where(
            and_(
                User.id != current_user_id,  # Exclude current user
                User.is_active == True,
                or_(
                    User.username.ilike(f"%{query}%"),
                    User.display_name.ilike(f"%{query}%"),
                    User.bio.ilike(f"%{query}%")
                )
            )
        )
        # Apply filters if provided
        if filters:
            if filters.gardening_experience:
                base_query = base_query.where(
                    User.gardening_experience == filters.gardening_experience
                )
            if filters.location:
                base_query = base_query.where(
                    User.location.ilike(f"%{filters.location}%")
                )
            if filters.has_avatar is not None:
                if filters.has_avatar:
                    base_query = base_query.where(User.avatar_url.isnot(None))
                else:
                    base_query = base_query.where(User.avatar_url.is_(None))
        # Add pagination
        base_query = base_query.offset(offset).limit(limit)
        # Execute query
        result = await session.execute(base_query)
        users = result.scalars().all()
        # Get friendship status for each user
        user_searches = []
        for user in users:
            friendship_status = await self._get_friendship_status(
                current_user_id, str(user.id), session
            )
            user_search = UserSearch(
                id=str(user.id),
                username=user.username,
                display_name=user.display_name,
                avatar_url=user.avatar_url,
                bio=user.bio,
                gardening_experience=user.gardening_experience,
                location=user.location,
                is_verified=user.is_verified,
                friendship_status=friendship_status,
                mutual_friends_count=await self._get_mutual_friends_count(
                    current_user_id, str(user.id), session
                )
            )
            user_searches.append(user_search)
        return user_searches
    async def get_user_profile(
        self,
        user_id: str,
        current_user_id: str,
        session: AsyncSession
    ) -> Optional[Dict[str, Any]]:
        """Get detailed user profile."""
        user = await self.get_user_by_id(user_id, session)
        if not user:
            return None
        # Check if current user can view this profile
        can_view_full_profile = await self._can_view_full_profile(
            current_user_id, user_id, session
        )
        # Get friendship status
        friendship_status = await self._get_friendship_status(
            current_user_id, user_id, session
        )
        # Get user statistics
        stats = await self.get_user_stats(user_id, session)
        # Build profile data
        profile_data = {
            "id": str(user.id),
            "username": user.username,
            "display_name": user.display_name,
            "avatar_url": user.avatar_url,
            "bio": user.bio if can_view_full_profile else None,
            "gardening_experience": user.gardening_experience,
            "favorite_plants": user.favorite_plants if can_view_full_profile else None,
            "location": user.location if can_view_full_profile or user.show_location else None,
            "is_verified": user.is_verified,
            "created_at": user.created_at,
            "last_active": user.last_active if can_view_full_profile else None,
            "friendship_status": friendship_status,
            "stats": stats,
            "is_online": await self.auth_service.is_user_online(user_id)
        }
        # Add mutual friends count if not the same user
        if current_user_id != user_id:
            profile_data["mutual_friends_count"] = await self._get_mutual_friends_count(
                current_user_id, user_id, session
            )
        return profile_data
    async def update_user_profile(
        self,
        user_id: str,
        update_data: UserUpdate,
        session: AsyncSession
    ) -> Optional[User]:
        """Update user profile."""
        user = await self.get_user_by_id(user_id, session)
        if not user:
            return None
        # Check username availability if being updated
        if update_data.username and update_data.username != user.username:
            is_available = await self.auth_service.check_username_availability(
                update_data.username, session, exclude_user_id=user_id
            )
            if not is_available:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Username is already taken"
                )
        # Update fields
        update_dict = update_data.dict(exclude_unset=True)
        for field, value in update_dict.items():
            if hasattr(user, field):
                setattr(user, field, value)
        user.updated_at = datetime.utcnow()
        await session.commit()
        await session.refresh(user)
        return user
    async def get_user_stats(
        self,
        user_id: str,
        session: AsyncSession
    ) -> UserStats:
        """Get user statistics."""
        # Count friends
        friends_count = await session.scalar(
            select(func.count(Friendship.id)).where(
                and_(
                    or_(
                        Friendship.requester_id == user_id,
                        Friendship.addressee_id == user_id
                    ),
                    Friendship.status == FriendshipStatus.ACCEPTED
                )
            )
        ) or 0
        # Count stories
        stories_count = await session.scalar(
            select(func.count(Story.id)).where(
                and_(
                    Story.user_id == user_id,
                    Story.is_active == True
                )
            )
        ) or 0
        # Count messages sent
        messages_sent = await session.scalar(
            select(func.count(Message.id)).where(
                Message.sender_id == user_id
            )
        ) or 0
        # Count messages received
        messages_received = await session.scalar(
            select(func.count(Message.id)).where(
                Message.recipient_id == user_id
            )
        ) or 0
        return UserStats(
            user_id=user_id,
            friends_count=friends_count,
            stories_count=stories_count,
            messages_sent=messages_sent,
            messages_received=messages_received,
            total_messages=messages_sent + messages_received
        )
    async def get_user_suggestions(
        self,
        user_id: str,
        session: AsyncSession,
        limit: int = 10
    ) -> List[UserSearch]:
        """Get user suggestions based on mutual friends and interests."""
        # Get users who are friends of friends but not direct friends
        mutual_friends_query = """
        SELECT DISTINCT u.id, u.username, u.display_name, u.avatar_url, u.bio,
               u.gardening_experience, u.location, u.is_verified,
               COUNT(mf.friend_id) as mutual_count
        FROM users u
        JOIN (
            SELECT CASE 
                WHEN f1.requester_id = :user_id THEN f1.addressee_id
                ELSE f1.requester_id
            END as friend_id
            FROM friendships f1
            WHERE (f1.requester_id = :user_id OR f1.addressee_id = :user_id)
            AND f1.status = 'accepted'
        ) mf ON (
            (u.id IN (
                SELECT CASE 
                    WHEN f2.requester_id = mf.friend_id THEN f2.addressee_id
                    ELSE f2.requester_id
                END
                FROM friendships f2
                WHERE (f2.requester_id = mf.friend_id OR f2.addressee_id = mf.friend_id)
                AND f2.status = 'accepted'
            ))
        )
        WHERE u.id != :user_id
        AND u.is_active = true
        AND u.id NOT IN (
            SELECT CASE 
                WHEN f3.requester_id = :user_id THEN f3.addressee_id
                ELSE f3.requester_id
            END
            FROM friendships f3
            WHERE (f3.requester_id = :user_id OR f3.addressee_id = :user_id)
        )
        GROUP BY u.id, u.username, u.display_name, u.avatar_url, u.bio,
                 u.gardening_experience, u.location, u.is_verified
        ORDER BY mutual_count DESC, u.created_at DESC
        LIMIT :limit
        """
        result = await session.execute(
            mutual_friends_query,
            {"user_id": user_id, "limit": limit}
        )
        suggestions = []
        for row in result:
            suggestion = UserSearch(
                id=str(row.id),
                username=row.username,
                display_name=row.display_name,
                avatar_url=row.avatar_url,
                bio=row.bio,
                gardening_experience=row.gardening_experience,
                location=row.location,
                is_verified=row.is_verified,
                friendship_status="none",
                mutual_friends_count=row.mutual_count
            )
            suggestions.append(suggestion)
        return suggestions
    async def block_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Block a user."""
        # Check if friendship exists
        friendship = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == blocker_id,
                        Friendship.addressee_id == blocked_id
                    ),
                    and_(
                        Friendship.requester_id == blocked_id,
                        Friendship.addressee_id == blocker_id
                    )
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if friendship:
            # Update existing friendship to blocked
            friendship.status = FriendshipStatus.BLOCKED
            friendship.updated_at = datetime.utcnow()
        else:
            # Create new blocked relationship
            new_friendship = Friendship(
                requester_id=blocker_id,
                addressee_id=blocked_id,
                status=FriendshipStatus.BLOCKED
            )
            session.add(new_friendship)
        await session.commit()
        return True
    async def unblock_user(
        self,
        blocker_id: str,
        blocked_id: str,
        session: AsyncSession
    ) -> bool:
        """Unblock a user."""
        friendship = await session.execute(
            select(Friendship).where(
                and_(
                    Friendship.requester_id == blocker_id,
                    Friendship.addressee_id == blocked_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        friendship = friendship.scalar_one_or_none()
        if friendship:
            await session.delete(friendship)
            await session.commit()
            return True
        return False
    async def get_blocked_users(
        self,
        user_id: str,
        session: AsyncSession
    ) -> List[Dict[str, Any]]:
        """Get list of blocked users."""
        result = await session.execute(
            select(Friendship, User).join(
                User, User.id == Friendship.addressee_id
            ).where(
                and_(
                    Friendship.requester_id == user_id,
                    Friendship.status == FriendshipStatus.BLOCKED
                )
            )
        )
        blocked_users = []
        for friendship, user in result:
            blocked_users.append({
                "user_id": str(user.id),
                "username": user.username,
                "display_name": user.display_name,
                "avatar_url": user.avatar_url,
                "blocked_at": friendship.created_at
            })
        return blocked_users
    async def _get_friendship_status(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> str:
        """Get friendship status between two users."""
        if user1_id == user2_id:
            return "self"
        result = await session.execute(
            select(Friendship).where(
                or_(
                    and_(
                        Friendship.requester_id == user1_id,
                        Friendship.addressee_id == user2_id
                    ),
                    and_(
                        Friendship.requester_id == user2_id,
                        Friendship.addressee_id == user1_id
                    )
                )
            )
        )
        friendship = result.scalar_one_or_none()
        if not friendship:
            return "none"
        if friendship.status == FriendshipStatus.BLOCKED:
            return "blocked"
        elif friendship.status == FriendshipStatus.PENDING:
            if friendship.requester_id == user1_id:
                return "pending_sent"
            else:
                return "pending_received"
        elif friendship.status == FriendshipStatus.ACCEPTED:
            return "friends"
        elif friendship.status == FriendshipStatus.DECLINED:
            return "declined"
        return "none"
    async def _get_mutual_friends_count(
        self,
        user1_id: str,
        user2_id: str,
        session: AsyncSession
    ) -> int:
        """Get count of mutual friends between two users."""
        # This is a complex query - for now return 0
        # In a real implementation, you'd query for mutual friends
        return 0
    async def _can_view_full_profile(
        self,
        viewer_id: str,
        profile_user_id: str,
        session: AsyncSession
    ) -> bool:
        """Check if viewer can see full profile details."""
        if viewer_id == profile_user_id:
            return True
        # Check if they are friends
        friendship_status = await self._get_friendship_status(
            viewer_id, profile_user_id, session
        )
        return friendship_status == "friends"
# Global user service instance
user_service = UserService()
async def get_user_by_id(
    user_id: str,
    session: AsyncSession
) -> Optional[User]:
    """Get user by ID."""
    return await user_service.get_user_by_id(user_id, session)
async def get_user_by_username(
    username: str,
    session: AsyncSession
) -> Optional[User]:
    """Get user by username."""
    return await user_service.get_user_by_username(username, session)
async def search_users(
    query: str,
    current_user_id: str,
    session: AsyncSession,
    limit: int = 20
) -> List[dict]:
    """Search users."""
    return await user_service.search_users(query, current_user_id, session, limit)
async def update_user_profile(
    user_id: str,
    profile_data: dict,
    session: AsyncSession
) -> User:
    """Update user profile."""
    return await user_service.update_user_profile(user_id, profile_data, session)
async def get_user_stats(
    user_id: str,
    session: AsyncSession
) -> dict:
    """Get user stats."""
    return await user_service.get_user_stats(user_id, session)
async def get_user_service() -> UserService:
    """Get user service dependency."""
    return user_service
</file>

<file path="backend/database/init.sql">
-- Database initialization script for Plant Social platform
-- This script sets up the database with necessary extensions
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-- Enable pgvector extension for future RAG features
CREATE EXTENSION IF NOT EXISTS vector;
-- Create indexes for better performance (will be created by Alembic migrations)
-- This file serves as documentation for manual setup if needed
-- Grant necessary permissions
GRANT ALL PRIVILEGES ON DATABASE plant_social_db TO postgres;
-- Set timezone
SET timezone = 'UTC';
-- Create custom types that might be needed
DO $$
BEGIN
    -- Create enum types if they don't exist
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'friendship_status') THEN
        CREATE TYPE friendship_status AS ENUM ('pending', 'accepted', 'declined', 'blocked');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_type') THEN
        CREATE TYPE message_type AS ENUM ('text', 'image', 'video', 'audio', 'plant_id', 'plant_care', 'location');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_status') THEN
        CREATE TYPE message_status AS ENUM ('sent', 'delivered', 'read', 'deleted', 'expired');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'story_type') THEN
        CREATE TYPE story_type AS ENUM ('image', 'video', 'plant_showcase', 'plant_timelapse', 'garden_tour');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'story_privacy_level') THEN
        CREATE TYPE story_privacy_level AS ENUM ('public', 'friends', 'close_friends', 'plant_community');
    END IF;
END$$;
</file>

<file path="backend/Dockerfile">
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create upload directories
RUN mkdir -p uploads/images uploads/thumbnails uploads/videos uploads/audio

# Set environment variables
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# Expose port
EXPOSE 8000

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
</file>

<file path="backend/README.md">
# Plant Social API Backend

FastAPI-based backend for the Plant Social platform with real-time messaging, stories, and AI-enhanced plant care features.

## Features

- **Authentication & User Management**: JWT-based auth with FastAPI-Users
- **Real-time Messaging**: WebSocket-based chat with disappearing messages
- **Stories System**: 24-hour ephemeral content sharing
- **Friend Management**: Friend requests, blocking, and social connections
- **File Storage**: AWS S3 integration with LocalStack for development
- **Database**: PostgreSQL with async SQLAlchemy and pgvector for future RAG
- **Caching**: Redis for sessions and real-time features

## Quick Start

### Prerequisites

- Python 3.11+
- Docker and Docker Compose
- PostgreSQL (or use Docker)
- Redis (or use Docker)

### Development Setup

1. **Clone and navigate to backend**:
   ```bash
   cd backend
   ```

2. **Install dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

3. **Set up environment**:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. **Start services with Docker**:
   ```bash
   # From project root
   docker-compose up postgres redis localstack
   ```

5. **Run database migrations**:
   ```bash
   # Initialize Alembic (first time only)
   alembic revision --autogenerate -m "Initial migration"
   
   # Apply migrations
   alembic upgrade head
   ```

6. **Start the API server**:
   ```bash
   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
   ```

### Using Docker (Full Stack)

```bash
# Start all services including backend
docker-compose --profile full up
```

## API Documentation

Once running, visit:
- **Interactive API Docs**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc
- **OpenAPI JSON**: http://localhost:8000/api/v1/openapi.json

## Project Structure

```
backend/
 app/
    api/                 # API routes and endpoints
       api_v1/
           endpoints/   # Individual endpoint modules
           api.py       # Main API router
    core/                # Core configuration
       config.py        # Settings and configuration
       database.py      # Database setup
       websocket.py     # WebSocket manager
    models/              # SQLAlchemy models
    schemas/             # Pydantic schemas
    services/            # Business logic
    main.py              # FastAPI application
 alembic/                 # Database migrations
 database/                # Database scripts
 .env                     # Environment variables
 requirements.txt         # Python dependencies
 Dockerfile              # Container configuration
```

## API Endpoints

### Authentication
- `POST /api/v1/auth/register` - User registration
- `POST /api/v1/auth/login` - User login
- `POST /api/v1/auth/refresh` - Refresh access token
- `GET /api/v1/auth/me` - Get current user info
- `PUT /api/v1/auth/me` - Update user profile
- `POST /api/v1/auth/logout` - Logout user

### Users
- `GET /api/v1/users/search` - Search users
- `GET /api/v1/users/{username}` - Get user profile
- `GET /api/v1/users/{user_id}/profile` - Get user by ID
- `PUT /api/v1/users/profile` - Update profile
- `GET /api/v1/users/stats` - Get user statistics
- `GET /api/v1/users/suggestions` - Get friend suggestions

### Messages
- `POST /api/v1/messages/send` - Send message
- `GET /api/v1/messages/conversations` - Get conversations
- `GET /api/v1/messages/conversation/{user_id}` - Get conversation
- `PUT /api/v1/messages/{message_id}/read` - Mark as read
- `DELETE /api/v1/messages/{message_id}` - Delete message

### Stories
- `POST /api/v1/stories/create` - Create story
- `GET /api/v1/stories/feed` - Get stories feed
- `GET /api/v1/stories/user/{user_id}` - Get user stories
- `GET /api/v1/stories/my` - Get own stories
- `PUT /api/v1/stories/{story_id}/view` - Mark story as viewed
- `DELETE /api/v1/stories/{story_id}` - Delete story

### Friends
- `POST /api/v1/friends/request` - Send friend request
- `PUT /api/v1/friends/accept/{request_id}` - Accept request
- `PUT /api/v1/friends/decline/{request_id}` - Decline request
- `DELETE /api/v1/friends/{friend_id}` - Remove friend
- `GET /api/v1/friends/list` - Get friends list
- `POST /api/v1/friends/block/{user_id}` - Block user

### WebSocket
- `WS /api/v1/ws/connect` - WebSocket connection for real-time messaging

## Database Schema

The application uses PostgreSQL with the following main tables:

- **users**: User accounts and profiles
- **messages**: Chat messages with disappearing functionality
- **stories**: 24-hour ephemeral content
- **story_views**: Story view tracking
- **friendships**: Friend relationships and requests

## Environment Variables

Key environment variables (see `.env.example`):

```bash
# Database
POSTGRES_SERVER=localhost
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_DB=plant_social_db

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Security
SECRET_KEY=your-secret-key
ACCESS_TOKEN_EXPIRE_MINUTES=11520

# AWS S3 (LocalStack for dev)
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
S3_BUCKET_NAME=plant-social-media
```

## Development Commands

```bash
# Database migrations
alembic revision --autogenerate -m "Description"
alembic upgrade head
alembic downgrade -1

# Code formatting
black app/
isort app/
flake8 app/

# Testing
pytest
pytest --cov=app

# Run with auto-reload
uvicorn app.main:app --reload
```

## WebSocket Usage

Connect to WebSocket for real-time features:

```javascript
const ws = new WebSocket('ws://localhost:8000/api/v1/ws/connect?token=YOUR_JWT_TOKEN');

// Send message
ws.send(JSON.stringify({
  type: 'send_message',
  data: {
    recipient_id: 'user-uuid',
    content: 'Hello!',
    message_type: 'text'
  }
}));

// Handle incoming messages
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  console.log('Received:', message);
};
```

## Production Deployment

1. **Environment Setup**:
   - Set production environment variables
   - Configure real AWS S3 credentials
   - Set strong SECRET_KEY
   - Configure production database

2. **Database**:
   - Run migrations: `alembic upgrade head`
   - Set up database backups
   - Configure connection pooling

3. **Security**:
   - Enable HTTPS
   - Configure CORS properly
   - Set up rate limiting
   - Enable security headers

4. **Monitoring**:
   - Set up logging
   - Configure health checks
   - Monitor database performance
   - Track API metrics

## Troubleshooting

### Common Issues

1. **Database Connection Error**:
   - Ensure PostgreSQL is running
   - Check connection string in `.env`
   - Verify database exists

2. **Redis Connection Error**:
   - Ensure Redis is running
   - Check Redis host/port configuration

3. **Migration Issues**:
   - Check Alembic configuration
   - Ensure models are imported in `env.py`
   - Verify database permissions

4. **WebSocket Connection Issues**:
   - Check JWT token validity
   - Verify WebSocket URL
   - Check CORS configuration

### Logs

```bash
# View application logs
docker-compose logs backend

# View database logs
docker-compose logs postgres

# View Redis logs
docker-compose logs redis
```

## Contributing

1. Follow the existing code style
2. Add tests for new features
3. Update documentation
4. Run linting before committing
5. Create meaningful commit messages

## License

This project is part of the Plant Social platform development challenge.
</file>

<file path="backend/requirements.txt">
# Core FastAPI dependencies
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.23
asyncpg==0.29.0
psycopg2==2.9.9
alembic==1.12.1

# Authentication
fastapi-users[sqlalchemy]==12.1.2
fastapi-users[oauth]==12.1.2
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# Redis for caching and real-time
redis==5.0.1
aioredis==2.0.1

# WebSocket support
websockets==12.0

# File handling and AWS
boto3==1.34.0
pillow==10.1.0
python-magic==0.4.27

# Environment and configuration
python-dotenv==1.0.0
pydantic-settings==2.1.0

# Development and testing
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2
black==23.11.0
isort==5.12.0
flake8==6.1.0

# Vector database for future RAG
pgvector==0.2.4

# AI/ML and RAG
openai==1.3.7
numpy==1.25.2
scikit-learn==1.3.2
sentence-transformers==2.2.2
tiktoken==0.5.2
</file>

<file path="backend/test_config.py">
#!/usr/bin/env python3
"""
Simple test script to verify configuration loading.
"""
try:
    from app.core.config import settings
    print(" Configuration loaded successfully")
    print(f"Project: {settings.PROJECT_NAME}")
    print(f"CORS Origins: {settings.BACKEND_CORS_ORIGINS}")
    print(f"Database URI: {settings.SQLALCHEMY_DATABASE_URI}")
except Exception as e:
    print(f" Configuration failed: {e}")
    import traceback
    traceback.print_exc()
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  # PostgreSQL Database
  postgres:
    build:
      context: ./backend
      dockerfile: Dockerfile.postgres
    container_name: plant_social_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: plant_social_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/database/init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
  # Redis for caching and real-time messaging
  redis:
    image: redis:7
    container_name: plant_social_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
  # LocalStack for AWS S3 simulation (development only)
  localstack:
    image: localstack/localstack:latest
    container_name: plant_social_localstack
    ports:
      - "4566:4566"
    environment:
      - SERVICES=s3
      - DEBUG=1
      - DATA_DIR=/tmp/localstack/data
      - DOCKER_HOST=unix:///var/run/docker.sock
    volumes:
      - localstack_data:/tmp/localstack
      - "/var/run/docker.sock:/var/run/docker.sock"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4566/health"]
      interval: 30s
      timeout: 10s
      retries: 3
  # FastAPI Backend (optional for development)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: plant_social_backend
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:password@postgres:5432/plant_social_db
      - REDIS_URL=redis://redis:6379/0
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
      - ./backend/uploads:/app/uploads
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
volumes:
  postgres_data:
  redis_data:
  localstack_data:
networks:
  default:
    name: plant_social_network
</file>

<file path="frontend/.gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release
</file>

<file path="frontend/.metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "fcf2c11572af6f390246c056bc905eca609533a0"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: web
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="frontend/analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.
# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml
linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="frontend/lib/core/constants/app_constants.dart">
class AppConstants {
  // App Info
  static const String appName = 'Plant Social';
  static const String appVersion = '1.0.0';
  static const String appDescription = 'A plant-focused social messaging platform';
  // API Configuration
  static const String baseUrl = 'http://localhost:8000';
  static const String apiVersion = 'v1';
  static const String apiBaseUrl = '$baseUrl/api/$apiVersion';
  static const String wsBaseUrl = 'ws://localhost:8000/api/$apiVersion/ws';
  // Storage Keys
  static const String accessTokenKey = 'access_token';
  static const String refreshTokenKey = 'refresh_token';
  static const String userIdKey = 'user_id';
  static const String userDataKey = 'user_data';
  // Message Types
  static const String messageTypeText = 'text';
  static const String messageTypeImage = 'image';
  static const String messageTypeVideo = 'video';
  // Story Types
  static const String storyTypePhoto = 'photo';
  static const String storyTypeVideo = 'video';
  static const String storyTypePlantShowcase = 'plant_showcase';
  static const String storyTypePlantCare = 'plant_care';
  // Privacy Levels
  static const String privacyPublic = 'public';
  static const String privacyFriends = 'friends';
  static const String privacyCloseFriends = 'close_friends';
  // Friendship Status
  static const String friendshipPending = 'pending';
  static const String friendshipAccepted = 'accepted';
  static const String friendshipBlocked = 'blocked';
  // Media Constraints
  static const int maxImageSizeMB = 10;
  static const int maxVideoSizeMB = 50;
  static const int maxVideoDurationSeconds = 60;
  static const int storyDurationHours = 24;
  // Disappearing Message Timers (seconds)
  static const List<int> disappearTimers = [1, 3, 5, 10, 30, 60];
  // Plant Care Types
  static const String careTypeWatering = 'watering';
  static const String careTypeFertilizing = 'fertilizing';
  static const String careTypePruning = 'pruning';
  static const String careTypeRepotting = 'repotting';
  // Plant Difficulty Levels
  static const String difficultyEasy = 'easy';
  static const String difficultyModerate = 'moderate';
  static const String difficultyDifficult = 'difficult';
  // Error Messages
  static const String networkError = 'Network connection error';
  static const String serverError = 'Server error occurred';
  static const String authError = 'Authentication failed';
  static const String permissionError = 'Permission denied';
  // Success Messages
  static const String loginSuccess = 'Login successful';
  static const String registrationSuccess = 'Registration successful';
  static const String messageSent = 'Message sent';
  static const String storyPosted = 'Story posted successfully';
  // Validation
  static const int minPasswordLength = 8;
  static const int maxUsernameLength = 30;
  static const int maxDisplayNameLength = 50;
  static const int maxBioLength = 150;
  // Animation Durations
  static const Duration shortAnimation = Duration(milliseconds: 200);
  static const Duration mediumAnimation = Duration(milliseconds: 300);
  static const Duration longAnimation = Duration(milliseconds: 500);
  // Pagination
  static const int defaultPageSize = 20;
  static const int storiesPageSize = 10;
  static const int messagesPageSize = 50;
}
</file>

<file path="frontend/lib/core/exceptions/api_exception.dart">
enum ApiExceptionType {
  network,
  timeout,
  server,
  badRequest,
  unauthorized,
  forbidden,
  notFound,
  conflict,
  validation,
  tooManyRequests,
  cancel,
  unknown,
}
class ApiException implements Exception {
  final String message;
  final int statusCode;
  final ApiExceptionType type;
  final Map<String, dynamic>? details;
  const ApiException({
    required this.message,
    required this.statusCode,
    required this.type,
    this.details,
  });
  @override
  String toString() {
    return 'ApiException: $message (Status: $statusCode, Type: $type)';
  }
  bool get isNetworkError => type == ApiExceptionType.network;
  bool get isTimeoutError => type == ApiExceptionType.timeout;
  bool get isServerError => type == ApiExceptionType.server;
  bool get isClientError => [
        ApiExceptionType.badRequest,
        ApiExceptionType.unauthorized,
        ApiExceptionType.forbidden,
        ApiExceptionType.notFound,
        ApiExceptionType.conflict,
        ApiExceptionType.validation,
        ApiExceptionType.tooManyRequests,
      ].contains(type);
  bool get isAuthError => [
        ApiExceptionType.unauthorized,
        ApiExceptionType.forbidden,
      ].contains(type);
  bool get isValidationError => type == ApiExceptionType.validation;
}
class NetworkException extends ApiException {
  const NetworkException({
    String message = 'Network error occurred',
  }) : super(
          message: message,
          statusCode: 0,
          type: ApiExceptionType.network,
        );
}
class TimeoutException extends ApiException {
  const TimeoutException({
    String message = 'Request timeout',
  }) : super(
          message: message,
          statusCode: 408,
          type: ApiExceptionType.timeout,
        );
}
class ServerException extends ApiException {
  const ServerException({
    String message = 'Server error occurred',
    int statusCode = 500,
  }) : super(
          message: message,
          statusCode: statusCode,
          type: ApiExceptionType.server,
        );
}
class UnauthorizedException extends ApiException {
  const UnauthorizedException({
    String message = 'Authentication required',
  }) : super(
          message: message,
          statusCode: 401,
          type: ApiExceptionType.unauthorized,
        );
}
class ForbiddenException extends ApiException {
  const ForbiddenException({
    String message = 'Access forbidden',
  }) : super(
          message: message,
          statusCode: 403,
          type: ApiExceptionType.forbidden,
        );
}
class NotFoundException extends ApiException {
  const NotFoundException({
    String message = 'Resource not found',
  }) : super(
          message: message,
          statusCode: 404,
          type: ApiExceptionType.notFound,
        );
}
class ValidationException extends ApiException {
  const ValidationException({
    String message = 'Validation failed',
    Map<String, dynamic>? details,
  }) : super(
          message: message,
          statusCode: 422,
          type: ApiExceptionType.validation,
          details: details,
        );
}
class ConflictException extends ApiException {
  const ConflictException({
    String message = 'Resource conflict',
  }) : super(
          message: message,
          statusCode: 409,
          type: ApiExceptionType.conflict,
        );
}
</file>

<file path="frontend/lib/core/models/friendship.dart">
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:plant_social/core/models/user.dart';
part 'friendship.freezed.dart';
part 'friendship.g.dart';
enum FriendshipStatus {
  pending,
  accepted,
  blocked,
  declined,
}
@freezed
class Friendship with _$Friendship {
  const factory Friendship({
    required String id,
    required String requesterId,
    required String addresseeId,
    @Default(FriendshipStatus.pending) FriendshipStatus status,
    String? message,
    DateTime? acceptedAt,
    DateTime? blockedAt,
    DateTime? declinedAt,
    required DateTime createdAt,
    DateTime? updatedAt,
    // User info (populated from join)
    User? requester,
    User? addressee,
  }) = _Friendship;
  factory Friendship.fromJson(Map<String, dynamic> json) => _$FriendshipFromJson(json);
}
@freezed
class FriendRequest with _$FriendRequest {
  const factory FriendRequest({
    required String id,
    required String fromUserId,
    required String toUserId,
    String? message,
    @Default(FriendshipStatus.pending) FriendshipStatus status,
    required DateTime createdAt,
    // User info (populated from join)
    User? fromUser,
    User? toUser,
  }) = _FriendRequest;
  factory FriendRequest.fromJson(Map<String, dynamic> json) => _$FriendRequestFromJson(json);
}
@freezed
class SendFriendRequestRequest with _$SendFriendRequestRequest {
  const factory SendFriendRequestRequest({
    required String toUserId,
    String? message,
  }) = _SendFriendRequestRequest;
  factory SendFriendRequestRequest.fromJson(Map<String, dynamic> json) => _$SendFriendRequestRequestFromJson(json);
}
@freezed
class FriendshipResponse with _$FriendshipResponse {
  const factory FriendshipResponse({
    required String friendshipId,
    required FriendshipStatus status,
  }) = _FriendshipResponse;
  factory FriendshipResponse.fromJson(Map<String, dynamic> json) => _$FriendshipResponseFromJson(json);
}
@freezed
class FriendsList with _$FriendsList {
  const factory FriendsList({
    @Default([]) List<User> friends,
    @Default(0) int totalCount,
    @Default(false) bool hasMore,
    String? nextCursor,
  }) = _FriendsList;
  factory FriendsList.fromJson(Map<String, dynamic> json) => _$FriendsListFromJson(json);
}
@freezed
class FriendRequestsList with _$FriendRequestsList {
  const factory FriendRequestsList({
    @Default([]) List<FriendRequest> requests,
    @Default(0) int totalCount,
    @Default(false) bool hasMore,
    String? nextCursor,
  }) = _FriendRequestsList;
  factory FriendRequestsList.fromJson(Map<String, dynamic> json) => _$FriendRequestsListFromJson(json);
}
@freezed
class MutualFriends with _$MutualFriends {
  const factory MutualFriends({
    @Default([]) List<User> friends,
    @Default(0) int count,
  }) = _MutualFriends;
  factory MutualFriends.fromJson(Map<String, dynamic> json) => _$MutualFriendsFromJson(json);
}
</file>

<file path="frontend/lib/core/models/friendship.freezed.dart">
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
part of 'friendship.dart';
// **************************************************************************
// FreezedGenerator
// **************************************************************************
T _$identity<T>(T value) => value;
final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');
Friendship _$FriendshipFromJson(Map<String, dynamic> json) {
  return _Friendship.fromJson(json);
}
/// @nodoc
mixin _$Friendship {
  String get id => throw _privateConstructorUsedError;
  String get requesterId => throw _privateConstructorUsedError;
  String get addresseeId => throw _privateConstructorUsedError;
  FriendshipStatus get status => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  DateTime? get acceptedAt => throw _privateConstructorUsedError;
  DateTime? get blockedAt => throw _privateConstructorUsedError;
  DateTime? get declinedAt => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get requester => throw _privateConstructorUsedError;
  User? get addressee => throw _privateConstructorUsedError;
  /// Serializes this Friendship to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FriendshipCopyWith<Friendship> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $FriendshipCopyWith<$Res> {
  factory $FriendshipCopyWith(
          Friendship value, $Res Function(Friendship) then) =
      _$FriendshipCopyWithImpl<$Res, Friendship>;
  @useResult
  $Res call(
      {String id,
      String requesterId,
      String addresseeId,
      FriendshipStatus status,
      String? message,
      DateTime? acceptedAt,
      DateTime? blockedAt,
      DateTime? declinedAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? requester,
      User? addressee});
  $UserCopyWith<$Res>? get requester;
  $UserCopyWith<$Res>? get addressee;
}
/// @nodoc
class _$FriendshipCopyWithImpl<$Res, $Val extends Friendship>
    implements $FriendshipCopyWith<$Res> {
  _$FriendshipCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? requesterId = null,
    Object? addresseeId = null,
    Object? status = null,
    Object? message = freezed,
    Object? acceptedAt = freezed,
    Object? blockedAt = freezed,
    Object? declinedAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? requester = freezed,
    Object? addressee = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      requesterId: null == requesterId
          ? _value.requesterId
          : requesterId // ignore: cast_nullable_to_non_nullable
              as String,
      addresseeId: null == addresseeId
          ? _value.addresseeId
          : addresseeId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      acceptedAt: freezed == acceptedAt
          ? _value.acceptedAt
          : acceptedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      blockedAt: freezed == blockedAt
          ? _value.blockedAt
          : blockedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      declinedAt: freezed == declinedAt
          ? _value.declinedAt
          : declinedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      requester: freezed == requester
          ? _value.requester
          : requester // ignore: cast_nullable_to_non_nullable
              as User?,
      addressee: freezed == addressee
          ? _value.addressee
          : addressee // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get requester {
    if (_value.requester == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.requester!, (value) {
      return _then(_value.copyWith(requester: value) as $Val);
    });
  }
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get addressee {
    if (_value.addressee == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.addressee!, (value) {
      return _then(_value.copyWith(addressee: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$FriendshipImplCopyWith<$Res>
    implements $FriendshipCopyWith<$Res> {
  factory _$$FriendshipImplCopyWith(
          _$FriendshipImpl value, $Res Function(_$FriendshipImpl) then) =
      __$$FriendshipImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String requesterId,
      String addresseeId,
      FriendshipStatus status,
      String? message,
      DateTime? acceptedAt,
      DateTime? blockedAt,
      DateTime? declinedAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? requester,
      User? addressee});
  @override
  $UserCopyWith<$Res>? get requester;
  @override
  $UserCopyWith<$Res>? get addressee;
}
/// @nodoc
class __$$FriendshipImplCopyWithImpl<$Res>
    extends _$FriendshipCopyWithImpl<$Res, _$FriendshipImpl>
    implements _$$FriendshipImplCopyWith<$Res> {
  __$$FriendshipImplCopyWithImpl(
      _$FriendshipImpl _value, $Res Function(_$FriendshipImpl) _then)
      : super(_value, _then);
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? requesterId = null,
    Object? addresseeId = null,
    Object? status = null,
    Object? message = freezed,
    Object? acceptedAt = freezed,
    Object? blockedAt = freezed,
    Object? declinedAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? requester = freezed,
    Object? addressee = freezed,
  }) {
    return _then(_$FriendshipImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      requesterId: null == requesterId
          ? _value.requesterId
          : requesterId // ignore: cast_nullable_to_non_nullable
              as String,
      addresseeId: null == addresseeId
          ? _value.addresseeId
          : addresseeId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      acceptedAt: freezed == acceptedAt
          ? _value.acceptedAt
          : acceptedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      blockedAt: freezed == blockedAt
          ? _value.blockedAt
          : blockedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      declinedAt: freezed == declinedAt
          ? _value.declinedAt
          : declinedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      requester: freezed == requester
          ? _value.requester
          : requester // ignore: cast_nullable_to_non_nullable
              as User?,
      addressee: freezed == addressee
          ? _value.addressee
          : addressee // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$FriendshipImpl implements _Friendship {
  const _$FriendshipImpl(
      {required this.id,
      required this.requesterId,
      required this.addresseeId,
      this.status = FriendshipStatus.pending,
      this.message,
      this.acceptedAt,
      this.blockedAt,
      this.declinedAt,
      required this.createdAt,
      this.updatedAt,
      this.requester,
      this.addressee});
  factory _$FriendshipImpl.fromJson(Map<String, dynamic> json) =>
      _$$FriendshipImplFromJson(json);
  @override
  final String id;
  @override
  final String requesterId;
  @override
  final String addresseeId;
  @override
  @JsonKey()
  final FriendshipStatus status;
  @override
  final String? message;
  @override
  final DateTime? acceptedAt;
  @override
  final DateTime? blockedAt;
  @override
  final DateTime? declinedAt;
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
// User info (populated from join)
  @override
  final User? requester;
  @override
  final User? addressee;
  @override
  String toString() {
    return 'Friendship(id: $id, requesterId: $requesterId, addresseeId: $addresseeId, status: $status, message: $message, acceptedAt: $acceptedAt, blockedAt: $blockedAt, declinedAt: $declinedAt, createdAt: $createdAt, updatedAt: $updatedAt, requester: $requester, addressee: $addressee)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FriendshipImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.requesterId, requesterId) ||
                other.requesterId == requesterId) &&
            (identical(other.addresseeId, addresseeId) ||
                other.addresseeId == addresseeId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.acceptedAt, acceptedAt) ||
                other.acceptedAt == acceptedAt) &&
            (identical(other.blockedAt, blockedAt) ||
                other.blockedAt == blockedAt) &&
            (identical(other.declinedAt, declinedAt) ||
                other.declinedAt == declinedAt) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.requester, requester) ||
                other.requester == requester) &&
            (identical(other.addressee, addressee) ||
                other.addressee == addressee));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      requesterId,
      addresseeId,
      status,
      message,
      acceptedAt,
      blockedAt,
      declinedAt,
      createdAt,
      updatedAt,
      requester,
      addressee);
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FriendshipImplCopyWith<_$FriendshipImpl> get copyWith =>
      __$$FriendshipImplCopyWithImpl<_$FriendshipImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$FriendshipImplToJson(
      this,
    );
  }
}
abstract class _Friendship implements Friendship {
  const factory _Friendship(
      {required final String id,
      required final String requesterId,
      required final String addresseeId,
      final FriendshipStatus status,
      final String? message,
      final DateTime? acceptedAt,
      final DateTime? blockedAt,
      final DateTime? declinedAt,
      required final DateTime createdAt,
      final DateTime? updatedAt,
      final User? requester,
      final User? addressee}) = _$FriendshipImpl;
  factory _Friendship.fromJson(Map<String, dynamic> json) =
      _$FriendshipImpl.fromJson;
  @override
  String get id;
  @override
  String get requesterId;
  @override
  String get addresseeId;
  @override
  FriendshipStatus get status;
  @override
  String? get message;
  @override
  DateTime? get acceptedAt;
  @override
  DateTime? get blockedAt;
  @override
  DateTime? get declinedAt;
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // User info (populated from join)
  @override
  User? get requester;
  @override
  User? get addressee;
  /// Create a copy of Friendship
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FriendshipImplCopyWith<_$FriendshipImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
FriendRequest _$FriendRequestFromJson(Map<String, dynamic> json) {
  return _FriendRequest.fromJson(json);
}
/// @nodoc
mixin _$FriendRequest {
  String get id => throw _privateConstructorUsedError;
  String get fromUserId => throw _privateConstructorUsedError;
  String get toUserId => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  FriendshipStatus get status => throw _privateConstructorUsedError;
  DateTime get createdAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get fromUser => throw _privateConstructorUsedError;
  User? get toUser => throw _privateConstructorUsedError;
  /// Serializes this FriendRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FriendRequestCopyWith<FriendRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $FriendRequestCopyWith<$Res> {
  factory $FriendRequestCopyWith(
          FriendRequest value, $Res Function(FriendRequest) then) =
      _$FriendRequestCopyWithImpl<$Res, FriendRequest>;
  @useResult
  $Res call(
      {String id,
      String fromUserId,
      String toUserId,
      String? message,
      FriendshipStatus status,
      DateTime createdAt,
      User? fromUser,
      User? toUser});
  $UserCopyWith<$Res>? get fromUser;
  $UserCopyWith<$Res>? get toUser;
}
/// @nodoc
class _$FriendRequestCopyWithImpl<$Res, $Val extends FriendRequest>
    implements $FriendRequestCopyWith<$Res> {
  _$FriendRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? fromUserId = null,
    Object? toUserId = null,
    Object? message = freezed,
    Object? status = null,
    Object? createdAt = null,
    Object? fromUser = freezed,
    Object? toUser = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      fromUserId: null == fromUserId
          ? _value.fromUserId
          : fromUserId // ignore: cast_nullable_to_non_nullable
              as String,
      toUserId: null == toUserId
          ? _value.toUserId
          : toUserId // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      fromUser: freezed == fromUser
          ? _value.fromUser
          : fromUser // ignore: cast_nullable_to_non_nullable
              as User?,
      toUser: freezed == toUser
          ? _value.toUser
          : toUser // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get fromUser {
    if (_value.fromUser == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.fromUser!, (value) {
      return _then(_value.copyWith(fromUser: value) as $Val);
    });
  }
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get toUser {
    if (_value.toUser == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.toUser!, (value) {
      return _then(_value.copyWith(toUser: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$FriendRequestImplCopyWith<$Res>
    implements $FriendRequestCopyWith<$Res> {
  factory _$$FriendRequestImplCopyWith(
          _$FriendRequestImpl value, $Res Function(_$FriendRequestImpl) then) =
      __$$FriendRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String fromUserId,
      String toUserId,
      String? message,
      FriendshipStatus status,
      DateTime createdAt,
      User? fromUser,
      User? toUser});
  @override
  $UserCopyWith<$Res>? get fromUser;
  @override
  $UserCopyWith<$Res>? get toUser;
}
/// @nodoc
class __$$FriendRequestImplCopyWithImpl<$Res>
    extends _$FriendRequestCopyWithImpl<$Res, _$FriendRequestImpl>
    implements _$$FriendRequestImplCopyWith<$Res> {
  __$$FriendRequestImplCopyWithImpl(
      _$FriendRequestImpl _value, $Res Function(_$FriendRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? fromUserId = null,
    Object? toUserId = null,
    Object? message = freezed,
    Object? status = null,
    Object? createdAt = null,
    Object? fromUser = freezed,
    Object? toUser = freezed,
  }) {
    return _then(_$FriendRequestImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      fromUserId: null == fromUserId
          ? _value.fromUserId
          : fromUserId // ignore: cast_nullable_to_non_nullable
              as String,
      toUserId: null == toUserId
          ? _value.toUserId
          : toUserId // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      fromUser: freezed == fromUser
          ? _value.fromUser
          : fromUser // ignore: cast_nullable_to_non_nullable
              as User?,
      toUser: freezed == toUser
          ? _value.toUser
          : toUser // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$FriendRequestImpl implements _FriendRequest {
  const _$FriendRequestImpl(
      {required this.id,
      required this.fromUserId,
      required this.toUserId,
      this.message,
      this.status = FriendshipStatus.pending,
      required this.createdAt,
      this.fromUser,
      this.toUser});
  factory _$FriendRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$FriendRequestImplFromJson(json);
  @override
  final String id;
  @override
  final String fromUserId;
  @override
  final String toUserId;
  @override
  final String? message;
  @override
  @JsonKey()
  final FriendshipStatus status;
  @override
  final DateTime createdAt;
// User info (populated from join)
  @override
  final User? fromUser;
  @override
  final User? toUser;
  @override
  String toString() {
    return 'FriendRequest(id: $id, fromUserId: $fromUserId, toUserId: $toUserId, message: $message, status: $status, createdAt: $createdAt, fromUser: $fromUser, toUser: $toUser)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FriendRequestImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.fromUserId, fromUserId) ||
                other.fromUserId == fromUserId) &&
            (identical(other.toUserId, toUserId) ||
                other.toUserId == toUserId) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.fromUser, fromUser) ||
                other.fromUser == fromUser) &&
            (identical(other.toUser, toUser) || other.toUser == toUser));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, fromUserId, toUserId,
      message, status, createdAt, fromUser, toUser);
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FriendRequestImplCopyWith<_$FriendRequestImpl> get copyWith =>
      __$$FriendRequestImplCopyWithImpl<_$FriendRequestImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$FriendRequestImplToJson(
      this,
    );
  }
}
abstract class _FriendRequest implements FriendRequest {
  const factory _FriendRequest(
      {required final String id,
      required final String fromUserId,
      required final String toUserId,
      final String? message,
      final FriendshipStatus status,
      required final DateTime createdAt,
      final User? fromUser,
      final User? toUser}) = _$FriendRequestImpl;
  factory _FriendRequest.fromJson(Map<String, dynamic> json) =
      _$FriendRequestImpl.fromJson;
  @override
  String get id;
  @override
  String get fromUserId;
  @override
  String get toUserId;
  @override
  String? get message;
  @override
  FriendshipStatus get status;
  @override
  DateTime get createdAt; // User info (populated from join)
  @override
  User? get fromUser;
  @override
  User? get toUser;
  /// Create a copy of FriendRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FriendRequestImplCopyWith<_$FriendRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
SendFriendRequestRequest _$SendFriendRequestRequestFromJson(
    Map<String, dynamic> json) {
  return _SendFriendRequestRequest.fromJson(json);
}
/// @nodoc
mixin _$SendFriendRequestRequest {
  String get toUserId => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  /// Serializes this SendFriendRequestRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of SendFriendRequestRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SendFriendRequestRequestCopyWith<SendFriendRequestRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $SendFriendRequestRequestCopyWith<$Res> {
  factory $SendFriendRequestRequestCopyWith(SendFriendRequestRequest value,
          $Res Function(SendFriendRequestRequest) then) =
      _$SendFriendRequestRequestCopyWithImpl<$Res, SendFriendRequestRequest>;
  @useResult
  $Res call({String toUserId, String? message});
}
/// @nodoc
class _$SendFriendRequestRequestCopyWithImpl<$Res,
        $Val extends SendFriendRequestRequest>
    implements $SendFriendRequestRequestCopyWith<$Res> {
  _$SendFriendRequestRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of SendFriendRequestRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toUserId = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      toUserId: null == toUserId
          ? _value.toUserId
          : toUserId // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$SendFriendRequestRequestImplCopyWith<$Res>
    implements $SendFriendRequestRequestCopyWith<$Res> {
  factory _$$SendFriendRequestRequestImplCopyWith(
          _$SendFriendRequestRequestImpl value,
          $Res Function(_$SendFriendRequestRequestImpl) then) =
      __$$SendFriendRequestRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String toUserId, String? message});
}
/// @nodoc
class __$$SendFriendRequestRequestImplCopyWithImpl<$Res>
    extends _$SendFriendRequestRequestCopyWithImpl<$Res,
        _$SendFriendRequestRequestImpl>
    implements _$$SendFriendRequestRequestImplCopyWith<$Res> {
  __$$SendFriendRequestRequestImplCopyWithImpl(
      _$SendFriendRequestRequestImpl _value,
      $Res Function(_$SendFriendRequestRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of SendFriendRequestRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toUserId = null,
    Object? message = freezed,
  }) {
    return _then(_$SendFriendRequestRequestImpl(
      toUserId: null == toUserId
          ? _value.toUserId
          : toUserId // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$SendFriendRequestRequestImpl implements _SendFriendRequestRequest {
  const _$SendFriendRequestRequestImpl({required this.toUserId, this.message});
  factory _$SendFriendRequestRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$SendFriendRequestRequestImplFromJson(json);
  @override
  final String toUserId;
  @override
  final String? message;
  @override
  String toString() {
    return 'SendFriendRequestRequest(toUserId: $toUserId, message: $message)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SendFriendRequestRequestImpl &&
            (identical(other.toUserId, toUserId) ||
                other.toUserId == toUserId) &&
            (identical(other.message, message) || other.message == message));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, toUserId, message);
  /// Create a copy of SendFriendRequestRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SendFriendRequestRequestImplCopyWith<_$SendFriendRequestRequestImpl>
      get copyWith => __$$SendFriendRequestRequestImplCopyWithImpl<
          _$SendFriendRequestRequestImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$SendFriendRequestRequestImplToJson(
      this,
    );
  }
}
abstract class _SendFriendRequestRequest implements SendFriendRequestRequest {
  const factory _SendFriendRequestRequest(
      {required final String toUserId,
      final String? message}) = _$SendFriendRequestRequestImpl;
  factory _SendFriendRequestRequest.fromJson(Map<String, dynamic> json) =
      _$SendFriendRequestRequestImpl.fromJson;
  @override
  String get toUserId;
  @override
  String? get message;
  /// Create a copy of SendFriendRequestRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SendFriendRequestRequestImplCopyWith<_$SendFriendRequestRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}
FriendshipResponse _$FriendshipResponseFromJson(Map<String, dynamic> json) {
  return _FriendshipResponse.fromJson(json);
}
/// @nodoc
mixin _$FriendshipResponse {
  String get friendshipId => throw _privateConstructorUsedError;
  FriendshipStatus get status => throw _privateConstructorUsedError;
  /// Serializes this FriendshipResponse to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of FriendshipResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FriendshipResponseCopyWith<FriendshipResponse> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $FriendshipResponseCopyWith<$Res> {
  factory $FriendshipResponseCopyWith(
          FriendshipResponse value, $Res Function(FriendshipResponse) then) =
      _$FriendshipResponseCopyWithImpl<$Res, FriendshipResponse>;
  @useResult
  $Res call({String friendshipId, FriendshipStatus status});
}
/// @nodoc
class _$FriendshipResponseCopyWithImpl<$Res, $Val extends FriendshipResponse>
    implements $FriendshipResponseCopyWith<$Res> {
  _$FriendshipResponseCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of FriendshipResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friendshipId = null,
    Object? status = null,
  }) {
    return _then(_value.copyWith(
      friendshipId: null == friendshipId
          ? _value.friendshipId
          : friendshipId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$FriendshipResponseImplCopyWith<$Res>
    implements $FriendshipResponseCopyWith<$Res> {
  factory _$$FriendshipResponseImplCopyWith(_$FriendshipResponseImpl value,
          $Res Function(_$FriendshipResponseImpl) then) =
      __$$FriendshipResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String friendshipId, FriendshipStatus status});
}
/// @nodoc
class __$$FriendshipResponseImplCopyWithImpl<$Res>
    extends _$FriendshipResponseCopyWithImpl<$Res, _$FriendshipResponseImpl>
    implements _$$FriendshipResponseImplCopyWith<$Res> {
  __$$FriendshipResponseImplCopyWithImpl(_$FriendshipResponseImpl _value,
      $Res Function(_$FriendshipResponseImpl) _then)
      : super(_value, _then);
  /// Create a copy of FriendshipResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friendshipId = null,
    Object? status = null,
  }) {
    return _then(_$FriendshipResponseImpl(
      friendshipId: null == friendshipId
          ? _value.friendshipId
          : friendshipId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FriendshipStatus,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$FriendshipResponseImpl implements _FriendshipResponse {
  const _$FriendshipResponseImpl(
      {required this.friendshipId, required this.status});
  factory _$FriendshipResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$FriendshipResponseImplFromJson(json);
  @override
  final String friendshipId;
  @override
  final FriendshipStatus status;
  @override
  String toString() {
    return 'FriendshipResponse(friendshipId: $friendshipId, status: $status)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FriendshipResponseImpl &&
            (identical(other.friendshipId, friendshipId) ||
                other.friendshipId == friendshipId) &&
            (identical(other.status, status) || other.status == status));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, friendshipId, status);
  /// Create a copy of FriendshipResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FriendshipResponseImplCopyWith<_$FriendshipResponseImpl> get copyWith =>
      __$$FriendshipResponseImplCopyWithImpl<_$FriendshipResponseImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$FriendshipResponseImplToJson(
      this,
    );
  }
}
abstract class _FriendshipResponse implements FriendshipResponse {
  const factory _FriendshipResponse(
      {required final String friendshipId,
      required final FriendshipStatus status}) = _$FriendshipResponseImpl;
  factory _FriendshipResponse.fromJson(Map<String, dynamic> json) =
      _$FriendshipResponseImpl.fromJson;
  @override
  String get friendshipId;
  @override
  FriendshipStatus get status;
  /// Create a copy of FriendshipResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FriendshipResponseImplCopyWith<_$FriendshipResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
FriendsList _$FriendsListFromJson(Map<String, dynamic> json) {
  return _FriendsList.fromJson(json);
}
/// @nodoc
mixin _$FriendsList {
  List<User> get friends => throw _privateConstructorUsedError;
  int get totalCount => throw _privateConstructorUsedError;
  bool get hasMore => throw _privateConstructorUsedError;
  String? get nextCursor => throw _privateConstructorUsedError;
  /// Serializes this FriendsList to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of FriendsList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FriendsListCopyWith<FriendsList> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $FriendsListCopyWith<$Res> {
  factory $FriendsListCopyWith(
          FriendsList value, $Res Function(FriendsList) then) =
      _$FriendsListCopyWithImpl<$Res, FriendsList>;
  @useResult
  $Res call(
      {List<User> friends, int totalCount, bool hasMore, String? nextCursor});
}
/// @nodoc
class _$FriendsListCopyWithImpl<$Res, $Val extends FriendsList>
    implements $FriendsListCopyWith<$Res> {
  _$FriendsListCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of FriendsList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? totalCount = null,
    Object? hasMore = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_value.copyWith(
      friends: null == friends
          ? _value.friends
          : friends // ignore: cast_nullable_to_non_nullable
              as List<User>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      nextCursor: freezed == nextCursor
          ? _value.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$FriendsListImplCopyWith<$Res>
    implements $FriendsListCopyWith<$Res> {
  factory _$$FriendsListImplCopyWith(
          _$FriendsListImpl value, $Res Function(_$FriendsListImpl) then) =
      __$$FriendsListImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<User> friends, int totalCount, bool hasMore, String? nextCursor});
}
/// @nodoc
class __$$FriendsListImplCopyWithImpl<$Res>
    extends _$FriendsListCopyWithImpl<$Res, _$FriendsListImpl>
    implements _$$FriendsListImplCopyWith<$Res> {
  __$$FriendsListImplCopyWithImpl(
      _$FriendsListImpl _value, $Res Function(_$FriendsListImpl) _then)
      : super(_value, _then);
  /// Create a copy of FriendsList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? totalCount = null,
    Object? hasMore = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_$FriendsListImpl(
      friends: null == friends
          ? _value._friends
          : friends // ignore: cast_nullable_to_non_nullable
              as List<User>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      nextCursor: freezed == nextCursor
          ? _value.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$FriendsListImpl implements _FriendsList {
  const _$FriendsListImpl(
      {final List<User> friends = const [],
      this.totalCount = 0,
      this.hasMore = false,
      this.nextCursor})
      : _friends = friends;
  factory _$FriendsListImpl.fromJson(Map<String, dynamic> json) =>
      _$$FriendsListImplFromJson(json);
  final List<User> _friends;
  @override
  @JsonKey()
  List<User> get friends {
    if (_friends is EqualUnmodifiableListView) return _friends;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_friends);
  }
  @override
  @JsonKey()
  final int totalCount;
  @override
  @JsonKey()
  final bool hasMore;
  @override
  final String? nextCursor;
  @override
  String toString() {
    return 'FriendsList(friends: $friends, totalCount: $totalCount, hasMore: $hasMore, nextCursor: $nextCursor)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FriendsListImpl &&
            const DeepCollectionEquality().equals(other._friends, _friends) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.nextCursor, nextCursor) ||
                other.nextCursor == nextCursor));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_friends),
      totalCount,
      hasMore,
      nextCursor);
  /// Create a copy of FriendsList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FriendsListImplCopyWith<_$FriendsListImpl> get copyWith =>
      __$$FriendsListImplCopyWithImpl<_$FriendsListImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$FriendsListImplToJson(
      this,
    );
  }
}
abstract class _FriendsList implements FriendsList {
  const factory _FriendsList(
      {final List<User> friends,
      final int totalCount,
      final bool hasMore,
      final String? nextCursor}) = _$FriendsListImpl;
  factory _FriendsList.fromJson(Map<String, dynamic> json) =
      _$FriendsListImpl.fromJson;
  @override
  List<User> get friends;
  @override
  int get totalCount;
  @override
  bool get hasMore;
  @override
  String? get nextCursor;
  /// Create a copy of FriendsList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FriendsListImplCopyWith<_$FriendsListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
FriendRequestsList _$FriendRequestsListFromJson(Map<String, dynamic> json) {
  return _FriendRequestsList.fromJson(json);
}
/// @nodoc
mixin _$FriendRequestsList {
  List<FriendRequest> get requests => throw _privateConstructorUsedError;
  int get totalCount => throw _privateConstructorUsedError;
  bool get hasMore => throw _privateConstructorUsedError;
  String? get nextCursor => throw _privateConstructorUsedError;
  /// Serializes this FriendRequestsList to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of FriendRequestsList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FriendRequestsListCopyWith<FriendRequestsList> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $FriendRequestsListCopyWith<$Res> {
  factory $FriendRequestsListCopyWith(
          FriendRequestsList value, $Res Function(FriendRequestsList) then) =
      _$FriendRequestsListCopyWithImpl<$Res, FriendRequestsList>;
  @useResult
  $Res call(
      {List<FriendRequest> requests,
      int totalCount,
      bool hasMore,
      String? nextCursor});
}
/// @nodoc
class _$FriendRequestsListCopyWithImpl<$Res, $Val extends FriendRequestsList>
    implements $FriendRequestsListCopyWith<$Res> {
  _$FriendRequestsListCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of FriendRequestsList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requests = null,
    Object? totalCount = null,
    Object? hasMore = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_value.copyWith(
      requests: null == requests
          ? _value.requests
          : requests // ignore: cast_nullable_to_non_nullable
              as List<FriendRequest>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      nextCursor: freezed == nextCursor
          ? _value.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$FriendRequestsListImplCopyWith<$Res>
    implements $FriendRequestsListCopyWith<$Res> {
  factory _$$FriendRequestsListImplCopyWith(_$FriendRequestsListImpl value,
          $Res Function(_$FriendRequestsListImpl) then) =
      __$$FriendRequestsListImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FriendRequest> requests,
      int totalCount,
      bool hasMore,
      String? nextCursor});
}
/// @nodoc
class __$$FriendRequestsListImplCopyWithImpl<$Res>
    extends _$FriendRequestsListCopyWithImpl<$Res, _$FriendRequestsListImpl>
    implements _$$FriendRequestsListImplCopyWith<$Res> {
  __$$FriendRequestsListImplCopyWithImpl(_$FriendRequestsListImpl _value,
      $Res Function(_$FriendRequestsListImpl) _then)
      : super(_value, _then);
  /// Create a copy of FriendRequestsList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requests = null,
    Object? totalCount = null,
    Object? hasMore = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_$FriendRequestsListImpl(
      requests: null == requests
          ? _value._requests
          : requests // ignore: cast_nullable_to_non_nullable
              as List<FriendRequest>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      nextCursor: freezed == nextCursor
          ? _value.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$FriendRequestsListImpl implements _FriendRequestsList {
  const _$FriendRequestsListImpl(
      {final List<FriendRequest> requests = const [],
      this.totalCount = 0,
      this.hasMore = false,
      this.nextCursor})
      : _requests = requests;
  factory _$FriendRequestsListImpl.fromJson(Map<String, dynamic> json) =>
      _$$FriendRequestsListImplFromJson(json);
  final List<FriendRequest> _requests;
  @override
  @JsonKey()
  List<FriendRequest> get requests {
    if (_requests is EqualUnmodifiableListView) return _requests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requests);
  }
  @override
  @JsonKey()
  final int totalCount;
  @override
  @JsonKey()
  final bool hasMore;
  @override
  final String? nextCursor;
  @override
  String toString() {
    return 'FriendRequestsList(requests: $requests, totalCount: $totalCount, hasMore: $hasMore, nextCursor: $nextCursor)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FriendRequestsListImpl &&
            const DeepCollectionEquality().equals(other._requests, _requests) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.nextCursor, nextCursor) ||
                other.nextCursor == nextCursor));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_requests),
      totalCount,
      hasMore,
      nextCursor);
  /// Create a copy of FriendRequestsList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FriendRequestsListImplCopyWith<_$FriendRequestsListImpl> get copyWith =>
      __$$FriendRequestsListImplCopyWithImpl<_$FriendRequestsListImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$FriendRequestsListImplToJson(
      this,
    );
  }
}
abstract class _FriendRequestsList implements FriendRequestsList {
  const factory _FriendRequestsList(
      {final List<FriendRequest> requests,
      final int totalCount,
      final bool hasMore,
      final String? nextCursor}) = _$FriendRequestsListImpl;
  factory _FriendRequestsList.fromJson(Map<String, dynamic> json) =
      _$FriendRequestsListImpl.fromJson;
  @override
  List<FriendRequest> get requests;
  @override
  int get totalCount;
  @override
  bool get hasMore;
  @override
  String? get nextCursor;
  /// Create a copy of FriendRequestsList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FriendRequestsListImplCopyWith<_$FriendRequestsListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
MutualFriends _$MutualFriendsFromJson(Map<String, dynamic> json) {
  return _MutualFriends.fromJson(json);
}
/// @nodoc
mixin _$MutualFriends {
  List<User> get friends => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;
  /// Serializes this MutualFriends to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of MutualFriends
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MutualFriendsCopyWith<MutualFriends> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $MutualFriendsCopyWith<$Res> {
  factory $MutualFriendsCopyWith(
          MutualFriends value, $Res Function(MutualFriends) then) =
      _$MutualFriendsCopyWithImpl<$Res, MutualFriends>;
  @useResult
  $Res call({List<User> friends, int count});
}
/// @nodoc
class _$MutualFriendsCopyWithImpl<$Res, $Val extends MutualFriends>
    implements $MutualFriendsCopyWith<$Res> {
  _$MutualFriendsCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of MutualFriends
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? count = null,
  }) {
    return _then(_value.copyWith(
      friends: null == friends
          ? _value.friends
          : friends // ignore: cast_nullable_to_non_nullable
              as List<User>,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$MutualFriendsImplCopyWith<$Res>
    implements $MutualFriendsCopyWith<$Res> {
  factory _$$MutualFriendsImplCopyWith(
          _$MutualFriendsImpl value, $Res Function(_$MutualFriendsImpl) then) =
      __$$MutualFriendsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<User> friends, int count});
}
/// @nodoc
class __$$MutualFriendsImplCopyWithImpl<$Res>
    extends _$MutualFriendsCopyWithImpl<$Res, _$MutualFriendsImpl>
    implements _$$MutualFriendsImplCopyWith<$Res> {
  __$$MutualFriendsImplCopyWithImpl(
      _$MutualFriendsImpl _value, $Res Function(_$MutualFriendsImpl) _then)
      : super(_value, _then);
  /// Create a copy of MutualFriends
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? friends = null,
    Object? count = null,
  }) {
    return _then(_$MutualFriendsImpl(
      friends: null == friends
          ? _value._friends
          : friends // ignore: cast_nullable_to_non_nullable
              as List<User>,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$MutualFriendsImpl implements _MutualFriends {
  const _$MutualFriendsImpl(
      {final List<User> friends = const [], this.count = 0})
      : _friends = friends;
  factory _$MutualFriendsImpl.fromJson(Map<String, dynamic> json) =>
      _$$MutualFriendsImplFromJson(json);
  final List<User> _friends;
  @override
  @JsonKey()
  List<User> get friends {
    if (_friends is EqualUnmodifiableListView) return _friends;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_friends);
  }
  @override
  @JsonKey()
  final int count;
  @override
  String toString() {
    return 'MutualFriends(friends: $friends, count: $count)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MutualFriendsImpl &&
            const DeepCollectionEquality().equals(other._friends, _friends) &&
            (identical(other.count, count) || other.count == count));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_friends), count);
  /// Create a copy of MutualFriends
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MutualFriendsImplCopyWith<_$MutualFriendsImpl> get copyWith =>
      __$$MutualFriendsImplCopyWithImpl<_$MutualFriendsImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$MutualFriendsImplToJson(
      this,
    );
  }
}
abstract class _MutualFriends implements MutualFriends {
  const factory _MutualFriends({final List<User> friends, final int count}) =
      _$MutualFriendsImpl;
  factory _MutualFriends.fromJson(Map<String, dynamic> json) =
      _$MutualFriendsImpl.fromJson;
  @override
  List<User> get friends;
  @override
  int get count;
  /// Create a copy of MutualFriends
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MutualFriendsImplCopyWith<_$MutualFriendsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
</file>

<file path="frontend/lib/core/models/message.dart">
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:plant_social/core/models/user.dart';
part 'message.freezed.dart';
part 'message.g.dart';
enum MessageType {
  text,
  image,
  video,
  audio,
  file,
  location,
  plant_identification, // Phase 2
  plant_care_tip, // Phase 2
}
enum MessageStatus {
  sending,
  sent,
  delivered,
  read,
  failed,
}
@freezed
class Message with _$Message {
  const factory Message({
    required String id,
    required String senderId,
    required String receiverId,
    required String content,
    @Default(MessageType.text) MessageType type,
    @Default(MessageStatus.sending) MessageStatus status,
    String? mediaUrl,
    String? thumbnailUrl,
    Map<String, dynamic>? metadata,
    DateTime? expiresAt, // For disappearing messages
    String? replyToMessageId,
    @Default(false) bool isEdited,
    DateTime? editedAt,
    required DateTime createdAt,
    DateTime? updatedAt,
    // Sender info (populated from join)
    User? sender,
    // Plant-specific fields for Phase 2
    String? plantId,
    Map<String, dynamic>? plantData,
  }) = _Message;
  factory Message.fromJson(Map<String, dynamic> json) => _$MessageFromJson(json);
}
@freezed
class Conversation with _$Conversation {
  const factory Conversation({
    required String id,
    required String userId,
    required String otherUserId,
    Message? lastMessage,
    @Default(0) int unreadCount,
    @Default(false) bool isMuted,
    @Default(false) bool isArchived,
    @Default(false) bool isBlocked,
    DateTime? lastReadAt,
    required DateTime createdAt,
    DateTime? updatedAt,
    // Other user info (populated from join)
    User? otherUser,
  }) = _Conversation;
  factory Conversation.fromJson(Map<String, dynamic> json) => _$ConversationFromJson(json);
}
@freezed
class SendMessageRequest with _$SendMessageRequest {
  const factory SendMessageRequest({
    required String receiverId,
    required String content,
    @Default(MessageType.text) MessageType type,
    String? mediaUrl,
    Map<String, dynamic>? metadata,
    DateTime? expiresAt,
    String? replyToMessageId,
    String? plantId,
    Map<String, dynamic>? plantData,
  }) = _SendMessageRequest;
  factory SendMessageRequest.fromJson(Map<String, dynamic> json) => _$SendMessageRequestFromJson(json);
}
@freezed
class MessageReaction with _$MessageReaction {
  const factory MessageReaction({
    required String id,
    required String messageId,
    required String userId,
    required String emoji,
    required DateTime createdAt,
    // User info (populated from join)
    User? user,
  }) = _MessageReaction;
  factory MessageReaction.fromJson(Map<String, dynamic> json) => _$MessageReactionFromJson(json);
}
</file>

<file path="frontend/lib/core/models/message.freezed.dart">
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
part of 'message.dart';
// **************************************************************************
// FreezedGenerator
// **************************************************************************
T _$identity<T>(T value) => value;
final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');
Message _$MessageFromJson(Map<String, dynamic> json) {
  return _Message.fromJson(json);
}
/// @nodoc
mixin _$Message {
  String get id => throw _privateConstructorUsedError;
  String get senderId => throw _privateConstructorUsedError;
  String get receiverId => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  MessageType get type => throw _privateConstructorUsedError;
  MessageStatus get status => throw _privateConstructorUsedError;
  String? get mediaUrl => throw _privateConstructorUsedError;
  String? get thumbnailUrl => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  DateTime? get expiresAt =>
      throw _privateConstructorUsedError; // For disappearing messages
  String? get replyToMessageId => throw _privateConstructorUsedError;
  bool get isEdited => throw _privateConstructorUsedError;
  DateTime? get editedAt => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // Sender info (populated from join)
  User? get sender =>
      throw _privateConstructorUsedError; // Plant-specific fields for Phase 2
  String? get plantId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get plantData => throw _privateConstructorUsedError;
  /// Serializes this Message to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MessageCopyWith<Message> get copyWith => throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $MessageCopyWith<$Res> {
  factory $MessageCopyWith(Message value, $Res Function(Message) then) =
      _$MessageCopyWithImpl<$Res, Message>;
  @useResult
  $Res call(
      {String id,
      String senderId,
      String receiverId,
      String content,
      MessageType type,
      MessageStatus status,
      String? mediaUrl,
      String? thumbnailUrl,
      Map<String, dynamic>? metadata,
      DateTime? expiresAt,
      String? replyToMessageId,
      bool isEdited,
      DateTime? editedAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? sender,
      String? plantId,
      Map<String, dynamic>? plantData});
  $UserCopyWith<$Res>? get sender;
}
/// @nodoc
class _$MessageCopyWithImpl<$Res, $Val extends Message>
    implements $MessageCopyWith<$Res> {
  _$MessageCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? senderId = null,
    Object? receiverId = null,
    Object? content = null,
    Object? type = null,
    Object? status = null,
    Object? mediaUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? metadata = freezed,
    Object? expiresAt = freezed,
    Object? replyToMessageId = freezed,
    Object? isEdited = null,
    Object? editedAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? sender = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      senderId: null == senderId
          ? _value.senderId
          : senderId // ignore: cast_nullable_to_non_nullable
              as String,
      receiverId: null == receiverId
          ? _value.receiverId
          : receiverId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageStatus,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      replyToMessageId: freezed == replyToMessageId
          ? _value.replyToMessageId
          : replyToMessageId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEdited: null == isEdited
          ? _value.isEdited
          : isEdited // ignore: cast_nullable_to_non_nullable
              as bool,
      editedAt: freezed == editedAt
          ? _value.editedAt
          : editedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      sender: freezed == sender
          ? _value.sender
          : sender // ignore: cast_nullable_to_non_nullable
              as User?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value.plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get sender {
    if (_value.sender == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.sender!, (value) {
      return _then(_value.copyWith(sender: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$MessageImplCopyWith<$Res> implements $MessageCopyWith<$Res> {
  factory _$$MessageImplCopyWith(
          _$MessageImpl value, $Res Function(_$MessageImpl) then) =
      __$$MessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String senderId,
      String receiverId,
      String content,
      MessageType type,
      MessageStatus status,
      String? mediaUrl,
      String? thumbnailUrl,
      Map<String, dynamic>? metadata,
      DateTime? expiresAt,
      String? replyToMessageId,
      bool isEdited,
      DateTime? editedAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? sender,
      String? plantId,
      Map<String, dynamic>? plantData});
  @override
  $UserCopyWith<$Res>? get sender;
}
/// @nodoc
class __$$MessageImplCopyWithImpl<$Res>
    extends _$MessageCopyWithImpl<$Res, _$MessageImpl>
    implements _$$MessageImplCopyWith<$Res> {
  __$$MessageImplCopyWithImpl(
      _$MessageImpl _value, $Res Function(_$MessageImpl) _then)
      : super(_value, _then);
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? senderId = null,
    Object? receiverId = null,
    Object? content = null,
    Object? type = null,
    Object? status = null,
    Object? mediaUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? metadata = freezed,
    Object? expiresAt = freezed,
    Object? replyToMessageId = freezed,
    Object? isEdited = null,
    Object? editedAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? sender = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
  }) {
    return _then(_$MessageImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      senderId: null == senderId
          ? _value.senderId
          : senderId // ignore: cast_nullable_to_non_nullable
              as String,
      receiverId: null == receiverId
          ? _value.receiverId
          : receiverId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageStatus,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      replyToMessageId: freezed == replyToMessageId
          ? _value.replyToMessageId
          : replyToMessageId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEdited: null == isEdited
          ? _value.isEdited
          : isEdited // ignore: cast_nullable_to_non_nullable
              as bool,
      editedAt: freezed == editedAt
          ? _value.editedAt
          : editedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      sender: freezed == sender
          ? _value.sender
          : sender // ignore: cast_nullable_to_non_nullable
              as User?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value._plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$MessageImpl implements _Message {
  const _$MessageImpl(
      {required this.id,
      required this.senderId,
      required this.receiverId,
      required this.content,
      this.type = MessageType.text,
      this.status = MessageStatus.sending,
      this.mediaUrl,
      this.thumbnailUrl,
      final Map<String, dynamic>? metadata,
      this.expiresAt,
      this.replyToMessageId,
      this.isEdited = false,
      this.editedAt,
      required this.createdAt,
      this.updatedAt,
      this.sender,
      this.plantId,
      final Map<String, dynamic>? plantData})
      : _metadata = metadata,
        _plantData = plantData;
  factory _$MessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageImplFromJson(json);
  @override
  final String id;
  @override
  final String senderId;
  @override
  final String receiverId;
  @override
  final String content;
  @override
  @JsonKey()
  final MessageType type;
  @override
  @JsonKey()
  final MessageStatus status;
  @override
  final String? mediaUrl;
  @override
  final String? thumbnailUrl;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  final DateTime? expiresAt;
// For disappearing messages
  @override
  final String? replyToMessageId;
  @override
  @JsonKey()
  final bool isEdited;
  @override
  final DateTime? editedAt;
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
// Sender info (populated from join)
  @override
  final User? sender;
// Plant-specific fields for Phase 2
  @override
  final String? plantId;
  final Map<String, dynamic>? _plantData;
  @override
  Map<String, dynamic>? get plantData {
    final value = _plantData;
    if (value == null) return null;
    if (_plantData is EqualUnmodifiableMapView) return _plantData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  String toString() {
    return 'Message(id: $id, senderId: $senderId, receiverId: $receiverId, content: $content, type: $type, status: $status, mediaUrl: $mediaUrl, thumbnailUrl: $thumbnailUrl, metadata: $metadata, expiresAt: $expiresAt, replyToMessageId: $replyToMessageId, isEdited: $isEdited, editedAt: $editedAt, createdAt: $createdAt, updatedAt: $updatedAt, sender: $sender, plantId: $plantId, plantData: $plantData)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.senderId, senderId) ||
                other.senderId == senderId) &&
            (identical(other.receiverId, receiverId) ||
                other.receiverId == receiverId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.mediaUrl, mediaUrl) ||
                other.mediaUrl == mediaUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.replyToMessageId, replyToMessageId) ||
                other.replyToMessageId == replyToMessageId) &&
            (identical(other.isEdited, isEdited) ||
                other.isEdited == isEdited) &&
            (identical(other.editedAt, editedAt) ||
                other.editedAt == editedAt) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.sender, sender) || other.sender == sender) &&
            (identical(other.plantId, plantId) || other.plantId == plantId) &&
            const DeepCollectionEquality()
                .equals(other._plantData, _plantData));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      senderId,
      receiverId,
      content,
      type,
      status,
      mediaUrl,
      thumbnailUrl,
      const DeepCollectionEquality().hash(_metadata),
      expiresAt,
      replyToMessageId,
      isEdited,
      editedAt,
      createdAt,
      updatedAt,
      sender,
      plantId,
      const DeepCollectionEquality().hash(_plantData));
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageImplCopyWith<_$MessageImpl> get copyWith =>
      __$$MessageImplCopyWithImpl<_$MessageImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$MessageImplToJson(
      this,
    );
  }
}
abstract class _Message implements Message {
  const factory _Message(
      {required final String id,
      required final String senderId,
      required final String receiverId,
      required final String content,
      final MessageType type,
      final MessageStatus status,
      final String? mediaUrl,
      final String? thumbnailUrl,
      final Map<String, dynamic>? metadata,
      final DateTime? expiresAt,
      final String? replyToMessageId,
      final bool isEdited,
      final DateTime? editedAt,
      required final DateTime createdAt,
      final DateTime? updatedAt,
      final User? sender,
      final String? plantId,
      final Map<String, dynamic>? plantData}) = _$MessageImpl;
  factory _Message.fromJson(Map<String, dynamic> json) = _$MessageImpl.fromJson;
  @override
  String get id;
  @override
  String get senderId;
  @override
  String get receiverId;
  @override
  String get content;
  @override
  MessageType get type;
  @override
  MessageStatus get status;
  @override
  String? get mediaUrl;
  @override
  String? get thumbnailUrl;
  @override
  Map<String, dynamic>? get metadata;
  @override
  DateTime? get expiresAt; // For disappearing messages
  @override
  String? get replyToMessageId;
  @override
  bool get isEdited;
  @override
  DateTime? get editedAt;
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // Sender info (populated from join)
  @override
  User? get sender; // Plant-specific fields for Phase 2
  @override
  String? get plantId;
  @override
  Map<String, dynamic>? get plantData;
  /// Create a copy of Message
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MessageImplCopyWith<_$MessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
Conversation _$ConversationFromJson(Map<String, dynamic> json) {
  return _Conversation.fromJson(json);
}
/// @nodoc
mixin _$Conversation {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get otherUserId => throw _privateConstructorUsedError;
  Message? get lastMessage => throw _privateConstructorUsedError;
  int get unreadCount => throw _privateConstructorUsedError;
  bool get isMuted => throw _privateConstructorUsedError;
  bool get isArchived => throw _privateConstructorUsedError;
  bool get isBlocked => throw _privateConstructorUsedError;
  DateTime? get lastReadAt => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // Other user info (populated from join)
  User? get otherUser => throw _privateConstructorUsedError;
  /// Serializes this Conversation to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ConversationCopyWith<Conversation> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $ConversationCopyWith<$Res> {
  factory $ConversationCopyWith(
          Conversation value, $Res Function(Conversation) then) =
      _$ConversationCopyWithImpl<$Res, Conversation>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String otherUserId,
      Message? lastMessage,
      int unreadCount,
      bool isMuted,
      bool isArchived,
      bool isBlocked,
      DateTime? lastReadAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? otherUser});
  $MessageCopyWith<$Res>? get lastMessage;
  $UserCopyWith<$Res>? get otherUser;
}
/// @nodoc
class _$ConversationCopyWithImpl<$Res, $Val extends Conversation>
    implements $ConversationCopyWith<$Res> {
  _$ConversationCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? otherUserId = null,
    Object? lastMessage = freezed,
    Object? unreadCount = null,
    Object? isMuted = null,
    Object? isArchived = null,
    Object? isBlocked = null,
    Object? lastReadAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? otherUser = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      otherUserId: null == otherUserId
          ? _value.otherUserId
          : otherUserId // ignore: cast_nullable_to_non_nullable
              as String,
      lastMessage: freezed == lastMessage
          ? _value.lastMessage
          : lastMessage // ignore: cast_nullable_to_non_nullable
              as Message?,
      unreadCount: null == unreadCount
          ? _value.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int,
      isMuted: null == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool,
      isArchived: null == isArchived
          ? _value.isArchived
          : isArchived // ignore: cast_nullable_to_non_nullable
              as bool,
      isBlocked: null == isBlocked
          ? _value.isBlocked
          : isBlocked // ignore: cast_nullable_to_non_nullable
              as bool,
      lastReadAt: freezed == lastReadAt
          ? _value.lastReadAt
          : lastReadAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      otherUser: freezed == otherUser
          ? _value.otherUser
          : otherUser // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageCopyWith<$Res>? get lastMessage {
    if (_value.lastMessage == null) {
      return null;
    }
    return $MessageCopyWith<$Res>(_value.lastMessage!, (value) {
      return _then(_value.copyWith(lastMessage: value) as $Val);
    });
  }
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get otherUser {
    if (_value.otherUser == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.otherUser!, (value) {
      return _then(_value.copyWith(otherUser: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$ConversationImplCopyWith<$Res>
    implements $ConversationCopyWith<$Res> {
  factory _$$ConversationImplCopyWith(
          _$ConversationImpl value, $Res Function(_$ConversationImpl) then) =
      __$$ConversationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String otherUserId,
      Message? lastMessage,
      int unreadCount,
      bool isMuted,
      bool isArchived,
      bool isBlocked,
      DateTime? lastReadAt,
      DateTime createdAt,
      DateTime? updatedAt,
      User? otherUser});
  @override
  $MessageCopyWith<$Res>? get lastMessage;
  @override
  $UserCopyWith<$Res>? get otherUser;
}
/// @nodoc
class __$$ConversationImplCopyWithImpl<$Res>
    extends _$ConversationCopyWithImpl<$Res, _$ConversationImpl>
    implements _$$ConversationImplCopyWith<$Res> {
  __$$ConversationImplCopyWithImpl(
      _$ConversationImpl _value, $Res Function(_$ConversationImpl) _then)
      : super(_value, _then);
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? otherUserId = null,
    Object? lastMessage = freezed,
    Object? unreadCount = null,
    Object? isMuted = null,
    Object? isArchived = null,
    Object? isBlocked = null,
    Object? lastReadAt = freezed,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? otherUser = freezed,
  }) {
    return _then(_$ConversationImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      otherUserId: null == otherUserId
          ? _value.otherUserId
          : otherUserId // ignore: cast_nullable_to_non_nullable
              as String,
      lastMessage: freezed == lastMessage
          ? _value.lastMessage
          : lastMessage // ignore: cast_nullable_to_non_nullable
              as Message?,
      unreadCount: null == unreadCount
          ? _value.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int,
      isMuted: null == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool,
      isArchived: null == isArchived
          ? _value.isArchived
          : isArchived // ignore: cast_nullable_to_non_nullable
              as bool,
      isBlocked: null == isBlocked
          ? _value.isBlocked
          : isBlocked // ignore: cast_nullable_to_non_nullable
              as bool,
      lastReadAt: freezed == lastReadAt
          ? _value.lastReadAt
          : lastReadAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      otherUser: freezed == otherUser
          ? _value.otherUser
          : otherUser // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$ConversationImpl implements _Conversation {
  const _$ConversationImpl(
      {required this.id,
      required this.userId,
      required this.otherUserId,
      this.lastMessage,
      this.unreadCount = 0,
      this.isMuted = false,
      this.isArchived = false,
      this.isBlocked = false,
      this.lastReadAt,
      required this.createdAt,
      this.updatedAt,
      this.otherUser});
  factory _$ConversationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ConversationImplFromJson(json);
  @override
  final String id;
  @override
  final String userId;
  @override
  final String otherUserId;
  @override
  final Message? lastMessage;
  @override
  @JsonKey()
  final int unreadCount;
  @override
  @JsonKey()
  final bool isMuted;
  @override
  @JsonKey()
  final bool isArchived;
  @override
  @JsonKey()
  final bool isBlocked;
  @override
  final DateTime? lastReadAt;
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
// Other user info (populated from join)
  @override
  final User? otherUser;
  @override
  String toString() {
    return 'Conversation(id: $id, userId: $userId, otherUserId: $otherUserId, lastMessage: $lastMessage, unreadCount: $unreadCount, isMuted: $isMuted, isArchived: $isArchived, isBlocked: $isBlocked, lastReadAt: $lastReadAt, createdAt: $createdAt, updatedAt: $updatedAt, otherUser: $otherUser)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConversationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.otherUserId, otherUserId) ||
                other.otherUserId == otherUserId) &&
            (identical(other.lastMessage, lastMessage) ||
                other.lastMessage == lastMessage) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.isMuted, isMuted) || other.isMuted == isMuted) &&
            (identical(other.isArchived, isArchived) ||
                other.isArchived == isArchived) &&
            (identical(other.isBlocked, isBlocked) ||
                other.isBlocked == isBlocked) &&
            (identical(other.lastReadAt, lastReadAt) ||
                other.lastReadAt == lastReadAt) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.otherUser, otherUser) ||
                other.otherUser == otherUser));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      userId,
      otherUserId,
      lastMessage,
      unreadCount,
      isMuted,
      isArchived,
      isBlocked,
      lastReadAt,
      createdAt,
      updatedAt,
      otherUser);
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConversationImplCopyWith<_$ConversationImpl> get copyWith =>
      __$$ConversationImplCopyWithImpl<_$ConversationImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$ConversationImplToJson(
      this,
    );
  }
}
abstract class _Conversation implements Conversation {
  const factory _Conversation(
      {required final String id,
      required final String userId,
      required final String otherUserId,
      final Message? lastMessage,
      final int unreadCount,
      final bool isMuted,
      final bool isArchived,
      final bool isBlocked,
      final DateTime? lastReadAt,
      required final DateTime createdAt,
      final DateTime? updatedAt,
      final User? otherUser}) = _$ConversationImpl;
  factory _Conversation.fromJson(Map<String, dynamic> json) =
      _$ConversationImpl.fromJson;
  @override
  String get id;
  @override
  String get userId;
  @override
  String get otherUserId;
  @override
  Message? get lastMessage;
  @override
  int get unreadCount;
  @override
  bool get isMuted;
  @override
  bool get isArchived;
  @override
  bool get isBlocked;
  @override
  DateTime? get lastReadAt;
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // Other user info (populated from join)
  @override
  User? get otherUser;
  /// Create a copy of Conversation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConversationImplCopyWith<_$ConversationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
SendMessageRequest _$SendMessageRequestFromJson(Map<String, dynamic> json) {
  return _SendMessageRequest.fromJson(json);
}
/// @nodoc
mixin _$SendMessageRequest {
  String get receiverId => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  MessageType get type => throw _privateConstructorUsedError;
  String? get mediaUrl => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  DateTime? get expiresAt => throw _privateConstructorUsedError;
  String? get replyToMessageId => throw _privateConstructorUsedError;
  String? get plantId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get plantData => throw _privateConstructorUsedError;
  /// Serializes this SendMessageRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of SendMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SendMessageRequestCopyWith<SendMessageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $SendMessageRequestCopyWith<$Res> {
  factory $SendMessageRequestCopyWith(
          SendMessageRequest value, $Res Function(SendMessageRequest) then) =
      _$SendMessageRequestCopyWithImpl<$Res, SendMessageRequest>;
  @useResult
  $Res call(
      {String receiverId,
      String content,
      MessageType type,
      String? mediaUrl,
      Map<String, dynamic>? metadata,
      DateTime? expiresAt,
      String? replyToMessageId,
      String? plantId,
      Map<String, dynamic>? plantData});
}
/// @nodoc
class _$SendMessageRequestCopyWithImpl<$Res, $Val extends SendMessageRequest>
    implements $SendMessageRequestCopyWith<$Res> {
  _$SendMessageRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of SendMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? receiverId = null,
    Object? content = null,
    Object? type = null,
    Object? mediaUrl = freezed,
    Object? metadata = freezed,
    Object? expiresAt = freezed,
    Object? replyToMessageId = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
  }) {
    return _then(_value.copyWith(
      receiverId: null == receiverId
          ? _value.receiverId
          : receiverId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageType,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      replyToMessageId: freezed == replyToMessageId
          ? _value.replyToMessageId
          : replyToMessageId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value.plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$SendMessageRequestImplCopyWith<$Res>
    implements $SendMessageRequestCopyWith<$Res> {
  factory _$$SendMessageRequestImplCopyWith(_$SendMessageRequestImpl value,
          $Res Function(_$SendMessageRequestImpl) then) =
      __$$SendMessageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String receiverId,
      String content,
      MessageType type,
      String? mediaUrl,
      Map<String, dynamic>? metadata,
      DateTime? expiresAt,
      String? replyToMessageId,
      String? plantId,
      Map<String, dynamic>? plantData});
}
/// @nodoc
class __$$SendMessageRequestImplCopyWithImpl<$Res>
    extends _$SendMessageRequestCopyWithImpl<$Res, _$SendMessageRequestImpl>
    implements _$$SendMessageRequestImplCopyWith<$Res> {
  __$$SendMessageRequestImplCopyWithImpl(_$SendMessageRequestImpl _value,
      $Res Function(_$SendMessageRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of SendMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? receiverId = null,
    Object? content = null,
    Object? type = null,
    Object? mediaUrl = freezed,
    Object? metadata = freezed,
    Object? expiresAt = freezed,
    Object? replyToMessageId = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
  }) {
    return _then(_$SendMessageRequestImpl(
      receiverId: null == receiverId
          ? _value.receiverId
          : receiverId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageType,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      replyToMessageId: freezed == replyToMessageId
          ? _value.replyToMessageId
          : replyToMessageId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value._plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$SendMessageRequestImpl implements _SendMessageRequest {
  const _$SendMessageRequestImpl(
      {required this.receiverId,
      required this.content,
      this.type = MessageType.text,
      this.mediaUrl,
      final Map<String, dynamic>? metadata,
      this.expiresAt,
      this.replyToMessageId,
      this.plantId,
      final Map<String, dynamic>? plantData})
      : _metadata = metadata,
        _plantData = plantData;
  factory _$SendMessageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$SendMessageRequestImplFromJson(json);
  @override
  final String receiverId;
  @override
  final String content;
  @override
  @JsonKey()
  final MessageType type;
  @override
  final String? mediaUrl;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  final DateTime? expiresAt;
  @override
  final String? replyToMessageId;
  @override
  final String? plantId;
  final Map<String, dynamic>? _plantData;
  @override
  Map<String, dynamic>? get plantData {
    final value = _plantData;
    if (value == null) return null;
    if (_plantData is EqualUnmodifiableMapView) return _plantData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  String toString() {
    return 'SendMessageRequest(receiverId: $receiverId, content: $content, type: $type, mediaUrl: $mediaUrl, metadata: $metadata, expiresAt: $expiresAt, replyToMessageId: $replyToMessageId, plantId: $plantId, plantData: $plantData)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SendMessageRequestImpl &&
            (identical(other.receiverId, receiverId) ||
                other.receiverId == receiverId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.mediaUrl, mediaUrl) ||
                other.mediaUrl == mediaUrl) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.replyToMessageId, replyToMessageId) ||
                other.replyToMessageId == replyToMessageId) &&
            (identical(other.plantId, plantId) || other.plantId == plantId) &&
            const DeepCollectionEquality()
                .equals(other._plantData, _plantData));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      receiverId,
      content,
      type,
      mediaUrl,
      const DeepCollectionEquality().hash(_metadata),
      expiresAt,
      replyToMessageId,
      plantId,
      const DeepCollectionEquality().hash(_plantData));
  /// Create a copy of SendMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SendMessageRequestImplCopyWith<_$SendMessageRequestImpl> get copyWith =>
      __$$SendMessageRequestImplCopyWithImpl<_$SendMessageRequestImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$SendMessageRequestImplToJson(
      this,
    );
  }
}
abstract class _SendMessageRequest implements SendMessageRequest {
  const factory _SendMessageRequest(
      {required final String receiverId,
      required final String content,
      final MessageType type,
      final String? mediaUrl,
      final Map<String, dynamic>? metadata,
      final DateTime? expiresAt,
      final String? replyToMessageId,
      final String? plantId,
      final Map<String, dynamic>? plantData}) = _$SendMessageRequestImpl;
  factory _SendMessageRequest.fromJson(Map<String, dynamic> json) =
      _$SendMessageRequestImpl.fromJson;
  @override
  String get receiverId;
  @override
  String get content;
  @override
  MessageType get type;
  @override
  String? get mediaUrl;
  @override
  Map<String, dynamic>? get metadata;
  @override
  DateTime? get expiresAt;
  @override
  String? get replyToMessageId;
  @override
  String? get plantId;
  @override
  Map<String, dynamic>? get plantData;
  /// Create a copy of SendMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SendMessageRequestImplCopyWith<_$SendMessageRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
MessageReaction _$MessageReactionFromJson(Map<String, dynamic> json) {
  return _MessageReaction.fromJson(json);
}
/// @nodoc
mixin _$MessageReaction {
  String get id => throw _privateConstructorUsedError;
  String get messageId => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get emoji => throw _privateConstructorUsedError;
  DateTime get createdAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get user => throw _privateConstructorUsedError;
  /// Serializes this MessageReaction to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MessageReactionCopyWith<MessageReaction> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $MessageReactionCopyWith<$Res> {
  factory $MessageReactionCopyWith(
          MessageReaction value, $Res Function(MessageReaction) then) =
      _$MessageReactionCopyWithImpl<$Res, MessageReaction>;
  @useResult
  $Res call(
      {String id,
      String messageId,
      String userId,
      String emoji,
      DateTime createdAt,
      User? user});
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class _$MessageReactionCopyWithImpl<$Res, $Val extends MessageReaction>
    implements $MessageReactionCopyWith<$Res> {
  _$MessageReactionCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? messageId = null,
    Object? userId = null,
    Object? emoji = null,
    Object? createdAt = null,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$MessageReactionImplCopyWith<$Res>
    implements $MessageReactionCopyWith<$Res> {
  factory _$$MessageReactionImplCopyWith(_$MessageReactionImpl value,
          $Res Function(_$MessageReactionImpl) then) =
      __$$MessageReactionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String messageId,
      String userId,
      String emoji,
      DateTime createdAt,
      User? user});
  @override
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class __$$MessageReactionImplCopyWithImpl<$Res>
    extends _$MessageReactionCopyWithImpl<$Res, _$MessageReactionImpl>
    implements _$$MessageReactionImplCopyWith<$Res> {
  __$$MessageReactionImplCopyWithImpl(
      _$MessageReactionImpl _value, $Res Function(_$MessageReactionImpl) _then)
      : super(_value, _then);
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? messageId = null,
    Object? userId = null,
    Object? emoji = null,
    Object? createdAt = null,
    Object? user = freezed,
  }) {
    return _then(_$MessageReactionImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$MessageReactionImpl implements _MessageReaction {
  const _$MessageReactionImpl(
      {required this.id,
      required this.messageId,
      required this.userId,
      required this.emoji,
      required this.createdAt,
      this.user});
  factory _$MessageReactionImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageReactionImplFromJson(json);
  @override
  final String id;
  @override
  final String messageId;
  @override
  final String userId;
  @override
  final String emoji;
  @override
  final DateTime createdAt;
// User info (populated from join)
  @override
  final User? user;
  @override
  String toString() {
    return 'MessageReaction(id: $id, messageId: $messageId, userId: $userId, emoji: $emoji, createdAt: $createdAt, user: $user)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageReactionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.emoji, emoji) || other.emoji == emoji) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.user, user) || other.user == user));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, messageId, userId, emoji, createdAt, user);
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageReactionImplCopyWith<_$MessageReactionImpl> get copyWith =>
      __$$MessageReactionImplCopyWithImpl<_$MessageReactionImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$MessageReactionImplToJson(
      this,
    );
  }
}
abstract class _MessageReaction implements MessageReaction {
  const factory _MessageReaction(
      {required final String id,
      required final String messageId,
      required final String userId,
      required final String emoji,
      required final DateTime createdAt,
      final User? user}) = _$MessageReactionImpl;
  factory _MessageReaction.fromJson(Map<String, dynamic> json) =
      _$MessageReactionImpl.fromJson;
  @override
  String get id;
  @override
  String get messageId;
  @override
  String get userId;
  @override
  String get emoji;
  @override
  DateTime get createdAt; // User info (populated from join)
  @override
  User? get user;
  /// Create a copy of MessageReaction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MessageReactionImplCopyWith<_$MessageReactionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
</file>

<file path="frontend/lib/core/models/story.dart">
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:plant_social/core/models/user.dart';
part 'story.freezed.dart';
part 'story.g.dart';
enum StoryType {
  image,
  video,
  text,
  plant_progress, // Phase 2
  plant_care_tip, // Phase 2
  plant_identification, // Phase 2
}
enum StoryPrivacyLevel {
  public,
  friends,
  close_friends,
  private,
}
@freezed
class Story with _$Story {
  const factory Story({
    required String id,
    required String userId,
    required String content,
    @Default(StoryType.image) StoryType type,
    @Default(StoryPrivacyLevel.public) StoryPrivacyLevel privacyLevel,
    String? mediaUrl,
    String? thumbnailUrl,
    Map<String, dynamic>? metadata,
    @Default([]) List<String> tags,
    String? location,
    @Default(0) int viewsCount,
    @Default(0) int likesCount,
    @Default(0) int commentsCount,
    DateTime? expiresAt,
    @Default(false) bool isArchived,
    required DateTime createdAt,
    DateTime? updatedAt,
    // User info (populated from join)
    User? user,
    // Viewer's interaction status
    @Default(false) bool hasViewed,
    @Default(false) bool hasLiked,
    // Plant-specific fields for Phase 2
    String? plantId,
    Map<String, dynamic>? plantData,
    String? careStage, // 'seedling', 'growing', 'flowering', 'fruiting'
    List<String>? careTips,
  }) = _Story;
  factory Story.fromJson(Map<String, dynamic> json) => _$StoryFromJson(json);
}
@freezed
class StoryView with _$StoryView {
  const factory StoryView({
    required String id,
    required String storyId,
    required String userId,
    required DateTime viewedAt,
    // User info (populated from join)
    User? user,
  }) = _StoryView;
  factory StoryView.fromJson(Map<String, dynamic> json) => _$StoryViewFromJson(json);
}
@freezed
class StoryLike with _$StoryLike {
  const factory StoryLike({
    required String id,
    required String storyId,
    required String userId,
    required DateTime createdAt,
    // User info (populated from join)
    User? user,
  }) = _StoryLike;
  factory StoryLike.fromJson(Map<String, dynamic> json) => _$StoryLikeFromJson(json);
}
@freezed
class StoryComment with _$StoryComment {
  const factory StoryComment({
    required String id,
    required String storyId,
    required String userId,
    required String content,
    String? parentCommentId,
    @Default(0) int likesCount,
    @Default(false) bool hasLiked,
    required DateTime createdAt,
    DateTime? updatedAt,
    // User info (populated from join)
    User? user,
    // Replies (if it's a parent comment)
    @Default([]) List<StoryComment> replies,
  }) = _StoryComment;
  factory StoryComment.fromJson(Map<String, dynamic> json) => _$StoryCommentFromJson(json);
}
@freezed
class CreateStoryRequest with _$CreateStoryRequest {
  const factory CreateStoryRequest({
    required String content,
    @Default(StoryType.image) StoryType type,
    @Default(StoryPrivacyLevel.public) StoryPrivacyLevel privacyLevel,
    String? mediaUrl,
    Map<String, dynamic>? metadata,
    List<String>? tags,
    String? location,
    DateTime? expiresAt,
    String? plantId,
    Map<String, dynamic>? plantData,
    String? careStage,
    List<String>? careTips,
  }) = _CreateStoryRequest;
  factory CreateStoryRequest.fromJson(Map<String, dynamic> json) => _$CreateStoryRequestFromJson(json);
}
@freezed
class StoryFeed with _$StoryFeed {
  const factory StoryFeed({
    required String userId,
    required User user,
    @Default([]) List<Story> stories,
    @Default(false) bool hasUnviewedStories,
  }) = _StoryFeed;
  factory StoryFeed.fromJson(Map<String, dynamic> json) => _$StoryFeedFromJson(json);
}
</file>

<file path="frontend/lib/core/models/story.freezed.dart">
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
part of 'story.dart';
// **************************************************************************
// FreezedGenerator
// **************************************************************************
T _$identity<T>(T value) => value;
final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');
Story _$StoryFromJson(Map<String, dynamic> json) {
  return _Story.fromJson(json);
}
/// @nodoc
mixin _$Story {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  StoryType get type => throw _privateConstructorUsedError;
  StoryPrivacyLevel get privacyLevel => throw _privateConstructorUsedError;
  String? get mediaUrl => throw _privateConstructorUsedError;
  String? get thumbnailUrl => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;
  String? get location => throw _privateConstructorUsedError;
  int get viewsCount => throw _privateConstructorUsedError;
  int get likesCount => throw _privateConstructorUsedError;
  int get commentsCount => throw _privateConstructorUsedError;
  DateTime? get expiresAt => throw _privateConstructorUsedError;
  bool get isArchived => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get user =>
      throw _privateConstructorUsedError; // Viewer's interaction status
  bool get hasViewed => throw _privateConstructorUsedError;
  bool get hasLiked =>
      throw _privateConstructorUsedError; // Plant-specific fields for Phase 2
  String? get plantId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get plantData => throw _privateConstructorUsedError;
  String? get careStage =>
      throw _privateConstructorUsedError; // 'seedling', 'growing', 'flowering', 'fruiting'
  List<String>? get careTips => throw _privateConstructorUsedError;
  /// Serializes this Story to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryCopyWith<Story> get copyWith => throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $StoryCopyWith<$Res> {
  factory $StoryCopyWith(Story value, $Res Function(Story) then) =
      _$StoryCopyWithImpl<$Res, Story>;
  @useResult
  $Res call(
      {String id,
      String userId,
      String content,
      StoryType type,
      StoryPrivacyLevel privacyLevel,
      String? mediaUrl,
      String? thumbnailUrl,
      Map<String, dynamic>? metadata,
      List<String> tags,
      String? location,
      int viewsCount,
      int likesCount,
      int commentsCount,
      DateTime? expiresAt,
      bool isArchived,
      DateTime createdAt,
      DateTime? updatedAt,
      User? user,
      bool hasViewed,
      bool hasLiked,
      String? plantId,
      Map<String, dynamic>? plantData,
      String? careStage,
      List<String>? careTips});
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class _$StoryCopyWithImpl<$Res, $Val extends Story>
    implements $StoryCopyWith<$Res> {
  _$StoryCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? content = null,
    Object? type = null,
    Object? privacyLevel = null,
    Object? mediaUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? metadata = freezed,
    Object? tags = null,
    Object? location = freezed,
    Object? viewsCount = null,
    Object? likesCount = null,
    Object? commentsCount = null,
    Object? expiresAt = freezed,
    Object? isArchived = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? user = freezed,
    Object? hasViewed = null,
    Object? hasLiked = null,
    Object? plantId = freezed,
    Object? plantData = freezed,
    Object? careStage = freezed,
    Object? careTips = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StoryType,
      privacyLevel: null == privacyLevel
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as StoryPrivacyLevel,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      viewsCount: null == viewsCount
          ? _value.viewsCount
          : viewsCount // ignore: cast_nullable_to_non_nullable
              as int,
      likesCount: null == likesCount
          ? _value.likesCount
          : likesCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentsCount: null == commentsCount
          ? _value.commentsCount
          : commentsCount // ignore: cast_nullable_to_non_nullable
              as int,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isArchived: null == isArchived
          ? _value.isArchived
          : isArchived // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      hasViewed: null == hasViewed
          ? _value.hasViewed
          : hasViewed // ignore: cast_nullable_to_non_nullable
              as bool,
      hasLiked: null == hasLiked
          ? _value.hasLiked
          : hasLiked // ignore: cast_nullable_to_non_nullable
              as bool,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value.plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      careStage: freezed == careStage
          ? _value.careStage
          : careStage // ignore: cast_nullable_to_non_nullable
              as String?,
      careTips: freezed == careTips
          ? _value.careTips
          : careTips // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$StoryImplCopyWith<$Res> implements $StoryCopyWith<$Res> {
  factory _$$StoryImplCopyWith(
          _$StoryImpl value, $Res Function(_$StoryImpl) then) =
      __$$StoryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      String content,
      StoryType type,
      StoryPrivacyLevel privacyLevel,
      String? mediaUrl,
      String? thumbnailUrl,
      Map<String, dynamic>? metadata,
      List<String> tags,
      String? location,
      int viewsCount,
      int likesCount,
      int commentsCount,
      DateTime? expiresAt,
      bool isArchived,
      DateTime createdAt,
      DateTime? updatedAt,
      User? user,
      bool hasViewed,
      bool hasLiked,
      String? plantId,
      Map<String, dynamic>? plantData,
      String? careStage,
      List<String>? careTips});
  @override
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class __$$StoryImplCopyWithImpl<$Res>
    extends _$StoryCopyWithImpl<$Res, _$StoryImpl>
    implements _$$StoryImplCopyWith<$Res> {
  __$$StoryImplCopyWithImpl(
      _$StoryImpl _value, $Res Function(_$StoryImpl) _then)
      : super(_value, _then);
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? content = null,
    Object? type = null,
    Object? privacyLevel = null,
    Object? mediaUrl = freezed,
    Object? thumbnailUrl = freezed,
    Object? metadata = freezed,
    Object? tags = null,
    Object? location = freezed,
    Object? viewsCount = null,
    Object? likesCount = null,
    Object? commentsCount = null,
    Object? expiresAt = freezed,
    Object? isArchived = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? user = freezed,
    Object? hasViewed = null,
    Object? hasLiked = null,
    Object? plantId = freezed,
    Object? plantData = freezed,
    Object? careStage = freezed,
    Object? careTips = freezed,
  }) {
    return _then(_$StoryImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StoryType,
      privacyLevel: null == privacyLevel
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as StoryPrivacyLevel,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      viewsCount: null == viewsCount
          ? _value.viewsCount
          : viewsCount // ignore: cast_nullable_to_non_nullable
              as int,
      likesCount: null == likesCount
          ? _value.likesCount
          : likesCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentsCount: null == commentsCount
          ? _value.commentsCount
          : commentsCount // ignore: cast_nullable_to_non_nullable
              as int,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isArchived: null == isArchived
          ? _value.isArchived
          : isArchived // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      hasViewed: null == hasViewed
          ? _value.hasViewed
          : hasViewed // ignore: cast_nullable_to_non_nullable
              as bool,
      hasLiked: null == hasLiked
          ? _value.hasLiked
          : hasLiked // ignore: cast_nullable_to_non_nullable
              as bool,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value._plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      careStage: freezed == careStage
          ? _value.careStage
          : careStage // ignore: cast_nullable_to_non_nullable
              as String?,
      careTips: freezed == careTips
          ? _value._careTips
          : careTips // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$StoryImpl implements _Story {
  const _$StoryImpl(
      {required this.id,
      required this.userId,
      required this.content,
      this.type = StoryType.image,
      this.privacyLevel = StoryPrivacyLevel.public,
      this.mediaUrl,
      this.thumbnailUrl,
      final Map<String, dynamic>? metadata,
      final List<String> tags = const [],
      this.location,
      this.viewsCount = 0,
      this.likesCount = 0,
      this.commentsCount = 0,
      this.expiresAt,
      this.isArchived = false,
      required this.createdAt,
      this.updatedAt,
      this.user,
      this.hasViewed = false,
      this.hasLiked = false,
      this.plantId,
      final Map<String, dynamic>? plantData,
      this.careStage,
      final List<String>? careTips})
      : _metadata = metadata,
        _tags = tags,
        _plantData = plantData,
        _careTips = careTips;
  factory _$StoryImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryImplFromJson(json);
  @override
  final String id;
  @override
  final String userId;
  @override
  final String content;
  @override
  @JsonKey()
  final StoryType type;
  @override
  @JsonKey()
  final StoryPrivacyLevel privacyLevel;
  @override
  final String? mediaUrl;
  @override
  final String? thumbnailUrl;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  final List<String> _tags;
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }
  @override
  final String? location;
  @override
  @JsonKey()
  final int viewsCount;
  @override
  @JsonKey()
  final int likesCount;
  @override
  @JsonKey()
  final int commentsCount;
  @override
  final DateTime? expiresAt;
  @override
  @JsonKey()
  final bool isArchived;
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
// User info (populated from join)
  @override
  final User? user;
// Viewer's interaction status
  @override
  @JsonKey()
  final bool hasViewed;
  @override
  @JsonKey()
  final bool hasLiked;
// Plant-specific fields for Phase 2
  @override
  final String? plantId;
  final Map<String, dynamic>? _plantData;
  @override
  Map<String, dynamic>? get plantData {
    final value = _plantData;
    if (value == null) return null;
    if (_plantData is EqualUnmodifiableMapView) return _plantData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  final String? careStage;
// 'seedling', 'growing', 'flowering', 'fruiting'
  final List<String>? _careTips;
// 'seedling', 'growing', 'flowering', 'fruiting'
  @override
  List<String>? get careTips {
    final value = _careTips;
    if (value == null) return null;
    if (_careTips is EqualUnmodifiableListView) return _careTips;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }
  @override
  String toString() {
    return 'Story(id: $id, userId: $userId, content: $content, type: $type, privacyLevel: $privacyLevel, mediaUrl: $mediaUrl, thumbnailUrl: $thumbnailUrl, metadata: $metadata, tags: $tags, location: $location, viewsCount: $viewsCount, likesCount: $likesCount, commentsCount: $commentsCount, expiresAt: $expiresAt, isArchived: $isArchived, createdAt: $createdAt, updatedAt: $updatedAt, user: $user, hasViewed: $hasViewed, hasLiked: $hasLiked, plantId: $plantId, plantData: $plantData, careStage: $careStage, careTips: $careTips)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.privacyLevel, privacyLevel) ||
                other.privacyLevel == privacyLevel) &&
            (identical(other.mediaUrl, mediaUrl) ||
                other.mediaUrl == mediaUrl) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.viewsCount, viewsCount) ||
                other.viewsCount == viewsCount) &&
            (identical(other.likesCount, likesCount) ||
                other.likesCount == likesCount) &&
            (identical(other.commentsCount, commentsCount) ||
                other.commentsCount == commentsCount) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.isArchived, isArchived) ||
                other.isArchived == isArchived) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.hasViewed, hasViewed) ||
                other.hasViewed == hasViewed) &&
            (identical(other.hasLiked, hasLiked) ||
                other.hasLiked == hasLiked) &&
            (identical(other.plantId, plantId) || other.plantId == plantId) &&
            const DeepCollectionEquality()
                .equals(other._plantData, _plantData) &&
            (identical(other.careStage, careStage) ||
                other.careStage == careStage) &&
            const DeepCollectionEquality().equals(other._careTips, _careTips));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        userId,
        content,
        type,
        privacyLevel,
        mediaUrl,
        thumbnailUrl,
        const DeepCollectionEquality().hash(_metadata),
        const DeepCollectionEquality().hash(_tags),
        location,
        viewsCount,
        likesCount,
        commentsCount,
        expiresAt,
        isArchived,
        createdAt,
        updatedAt,
        user,
        hasViewed,
        hasLiked,
        plantId,
        const DeepCollectionEquality().hash(_plantData),
        careStage,
        const DeepCollectionEquality().hash(_careTips)
      ]);
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryImplCopyWith<_$StoryImpl> get copyWith =>
      __$$StoryImplCopyWithImpl<_$StoryImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$StoryImplToJson(
      this,
    );
  }
}
abstract class _Story implements Story {
  const factory _Story(
      {required final String id,
      required final String userId,
      required final String content,
      final StoryType type,
      final StoryPrivacyLevel privacyLevel,
      final String? mediaUrl,
      final String? thumbnailUrl,
      final Map<String, dynamic>? metadata,
      final List<String> tags,
      final String? location,
      final int viewsCount,
      final int likesCount,
      final int commentsCount,
      final DateTime? expiresAt,
      final bool isArchived,
      required final DateTime createdAt,
      final DateTime? updatedAt,
      final User? user,
      final bool hasViewed,
      final bool hasLiked,
      final String? plantId,
      final Map<String, dynamic>? plantData,
      final String? careStage,
      final List<String>? careTips}) = _$StoryImpl;
  factory _Story.fromJson(Map<String, dynamic> json) = _$StoryImpl.fromJson;
  @override
  String get id;
  @override
  String get userId;
  @override
  String get content;
  @override
  StoryType get type;
  @override
  StoryPrivacyLevel get privacyLevel;
  @override
  String? get mediaUrl;
  @override
  String? get thumbnailUrl;
  @override
  Map<String, dynamic>? get metadata;
  @override
  List<String> get tags;
  @override
  String? get location;
  @override
  int get viewsCount;
  @override
  int get likesCount;
  @override
  int get commentsCount;
  @override
  DateTime? get expiresAt;
  @override
  bool get isArchived;
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // User info (populated from join)
  @override
  User? get user; // Viewer's interaction status
  @override
  bool get hasViewed;
  @override
  bool get hasLiked; // Plant-specific fields for Phase 2
  @override
  String? get plantId;
  @override
  Map<String, dynamic>? get plantData;
  @override
  String? get careStage; // 'seedling', 'growing', 'flowering', 'fruiting'
  @override
  List<String>? get careTips;
  /// Create a copy of Story
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryImplCopyWith<_$StoryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
StoryView _$StoryViewFromJson(Map<String, dynamic> json) {
  return _StoryView.fromJson(json);
}
/// @nodoc
mixin _$StoryView {
  String get id => throw _privateConstructorUsedError;
  String get storyId => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  DateTime get viewedAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get user => throw _privateConstructorUsedError;
  /// Serializes this StoryView to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryViewCopyWith<StoryView> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $StoryViewCopyWith<$Res> {
  factory $StoryViewCopyWith(StoryView value, $Res Function(StoryView) then) =
      _$StoryViewCopyWithImpl<$Res, StoryView>;
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      DateTime viewedAt,
      User? user});
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class _$StoryViewCopyWithImpl<$Res, $Val extends StoryView>
    implements $StoryViewCopyWith<$Res> {
  _$StoryViewCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? viewedAt = null,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      viewedAt: null == viewedAt
          ? _value.viewedAt
          : viewedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$StoryViewImplCopyWith<$Res>
    implements $StoryViewCopyWith<$Res> {
  factory _$$StoryViewImplCopyWith(
          _$StoryViewImpl value, $Res Function(_$StoryViewImpl) then) =
      __$$StoryViewImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      DateTime viewedAt,
      User? user});
  @override
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class __$$StoryViewImplCopyWithImpl<$Res>
    extends _$StoryViewCopyWithImpl<$Res, _$StoryViewImpl>
    implements _$$StoryViewImplCopyWith<$Res> {
  __$$StoryViewImplCopyWithImpl(
      _$StoryViewImpl _value, $Res Function(_$StoryViewImpl) _then)
      : super(_value, _then);
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? viewedAt = null,
    Object? user = freezed,
  }) {
    return _then(_$StoryViewImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      viewedAt: null == viewedAt
          ? _value.viewedAt
          : viewedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$StoryViewImpl implements _StoryView {
  const _$StoryViewImpl(
      {required this.id,
      required this.storyId,
      required this.userId,
      required this.viewedAt,
      this.user});
  factory _$StoryViewImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryViewImplFromJson(json);
  @override
  final String id;
  @override
  final String storyId;
  @override
  final String userId;
  @override
  final DateTime viewedAt;
// User info (populated from join)
  @override
  final User? user;
  @override
  String toString() {
    return 'StoryView(id: $id, storyId: $storyId, userId: $userId, viewedAt: $viewedAt, user: $user)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryViewImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.storyId, storyId) || other.storyId == storyId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.viewedAt, viewedAt) ||
                other.viewedAt == viewedAt) &&
            (identical(other.user, user) || other.user == user));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, storyId, userId, viewedAt, user);
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryViewImplCopyWith<_$StoryViewImpl> get copyWith =>
      __$$StoryViewImplCopyWithImpl<_$StoryViewImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$StoryViewImplToJson(
      this,
    );
  }
}
abstract class _StoryView implements StoryView {
  const factory _StoryView(
      {required final String id,
      required final String storyId,
      required final String userId,
      required final DateTime viewedAt,
      final User? user}) = _$StoryViewImpl;
  factory _StoryView.fromJson(Map<String, dynamic> json) =
      _$StoryViewImpl.fromJson;
  @override
  String get id;
  @override
  String get storyId;
  @override
  String get userId;
  @override
  DateTime get viewedAt; // User info (populated from join)
  @override
  User? get user;
  /// Create a copy of StoryView
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryViewImplCopyWith<_$StoryViewImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
StoryLike _$StoryLikeFromJson(Map<String, dynamic> json) {
  return _StoryLike.fromJson(json);
}
/// @nodoc
mixin _$StoryLike {
  String get id => throw _privateConstructorUsedError;
  String get storyId => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  DateTime get createdAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get user => throw _privateConstructorUsedError;
  /// Serializes this StoryLike to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryLikeCopyWith<StoryLike> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $StoryLikeCopyWith<$Res> {
  factory $StoryLikeCopyWith(StoryLike value, $Res Function(StoryLike) then) =
      _$StoryLikeCopyWithImpl<$Res, StoryLike>;
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      DateTime createdAt,
      User? user});
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class _$StoryLikeCopyWithImpl<$Res, $Val extends StoryLike>
    implements $StoryLikeCopyWith<$Res> {
  _$StoryLikeCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? createdAt = null,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$StoryLikeImplCopyWith<$Res>
    implements $StoryLikeCopyWith<$Res> {
  factory _$$StoryLikeImplCopyWith(
          _$StoryLikeImpl value, $Res Function(_$StoryLikeImpl) then) =
      __$$StoryLikeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      DateTime createdAt,
      User? user});
  @override
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class __$$StoryLikeImplCopyWithImpl<$Res>
    extends _$StoryLikeCopyWithImpl<$Res, _$StoryLikeImpl>
    implements _$$StoryLikeImplCopyWith<$Res> {
  __$$StoryLikeImplCopyWithImpl(
      _$StoryLikeImpl _value, $Res Function(_$StoryLikeImpl) _then)
      : super(_value, _then);
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? createdAt = null,
    Object? user = freezed,
  }) {
    return _then(_$StoryLikeImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$StoryLikeImpl implements _StoryLike {
  const _$StoryLikeImpl(
      {required this.id,
      required this.storyId,
      required this.userId,
      required this.createdAt,
      this.user});
  factory _$StoryLikeImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryLikeImplFromJson(json);
  @override
  final String id;
  @override
  final String storyId;
  @override
  final String userId;
  @override
  final DateTime createdAt;
// User info (populated from join)
  @override
  final User? user;
  @override
  String toString() {
    return 'StoryLike(id: $id, storyId: $storyId, userId: $userId, createdAt: $createdAt, user: $user)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryLikeImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.storyId, storyId) || other.storyId == storyId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.user, user) || other.user == user));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, storyId, userId, createdAt, user);
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryLikeImplCopyWith<_$StoryLikeImpl> get copyWith =>
      __$$StoryLikeImplCopyWithImpl<_$StoryLikeImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$StoryLikeImplToJson(
      this,
    );
  }
}
abstract class _StoryLike implements StoryLike {
  const factory _StoryLike(
      {required final String id,
      required final String storyId,
      required final String userId,
      required final DateTime createdAt,
      final User? user}) = _$StoryLikeImpl;
  factory _StoryLike.fromJson(Map<String, dynamic> json) =
      _$StoryLikeImpl.fromJson;
  @override
  String get id;
  @override
  String get storyId;
  @override
  String get userId;
  @override
  DateTime get createdAt; // User info (populated from join)
  @override
  User? get user;
  /// Create a copy of StoryLike
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryLikeImplCopyWith<_$StoryLikeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
StoryComment _$StoryCommentFromJson(Map<String, dynamic> json) {
  return _StoryComment.fromJson(json);
}
/// @nodoc
mixin _$StoryComment {
  String get id => throw _privateConstructorUsedError;
  String get storyId => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get content => throw _privateConstructorUsedError;
  String? get parentCommentId => throw _privateConstructorUsedError;
  int get likesCount => throw _privateConstructorUsedError;
  bool get hasLiked => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // User info (populated from join)
  User? get user =>
      throw _privateConstructorUsedError; // Replies (if it's a parent comment)
  List<StoryComment> get replies => throw _privateConstructorUsedError;
  /// Serializes this StoryComment to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryCommentCopyWith<StoryComment> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $StoryCommentCopyWith<$Res> {
  factory $StoryCommentCopyWith(
          StoryComment value, $Res Function(StoryComment) then) =
      _$StoryCommentCopyWithImpl<$Res, StoryComment>;
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      String content,
      String? parentCommentId,
      int likesCount,
      bool hasLiked,
      DateTime createdAt,
      DateTime? updatedAt,
      User? user,
      List<StoryComment> replies});
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class _$StoryCommentCopyWithImpl<$Res, $Val extends StoryComment>
    implements $StoryCommentCopyWith<$Res> {
  _$StoryCommentCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? content = null,
    Object? parentCommentId = freezed,
    Object? likesCount = null,
    Object? hasLiked = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? user = freezed,
    Object? replies = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      parentCommentId: freezed == parentCommentId
          ? _value.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      likesCount: null == likesCount
          ? _value.likesCount
          : likesCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasLiked: null == hasLiked
          ? _value.hasLiked
          : hasLiked // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      replies: null == replies
          ? _value.replies
          : replies // ignore: cast_nullable_to_non_nullable
              as List<StoryComment>,
    ) as $Val);
  }
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }
    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$StoryCommentImplCopyWith<$Res>
    implements $StoryCommentCopyWith<$Res> {
  factory _$$StoryCommentImplCopyWith(
          _$StoryCommentImpl value, $Res Function(_$StoryCommentImpl) then) =
      __$$StoryCommentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String storyId,
      String userId,
      String content,
      String? parentCommentId,
      int likesCount,
      bool hasLiked,
      DateTime createdAt,
      DateTime? updatedAt,
      User? user,
      List<StoryComment> replies});
  @override
  $UserCopyWith<$Res>? get user;
}
/// @nodoc
class __$$StoryCommentImplCopyWithImpl<$Res>
    extends _$StoryCommentCopyWithImpl<$Res, _$StoryCommentImpl>
    implements _$$StoryCommentImplCopyWith<$Res> {
  __$$StoryCommentImplCopyWithImpl(
      _$StoryCommentImpl _value, $Res Function(_$StoryCommentImpl) _then)
      : super(_value, _then);
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? storyId = null,
    Object? userId = null,
    Object? content = null,
    Object? parentCommentId = freezed,
    Object? likesCount = null,
    Object? hasLiked = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? user = freezed,
    Object? replies = null,
  }) {
    return _then(_$StoryCommentImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      storyId: null == storyId
          ? _value.storyId
          : storyId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      parentCommentId: freezed == parentCommentId
          ? _value.parentCommentId
          : parentCommentId // ignore: cast_nullable_to_non_nullable
              as String?,
      likesCount: null == likesCount
          ? _value.likesCount
          : likesCount // ignore: cast_nullable_to_non_nullable
              as int,
      hasLiked: null == hasLiked
          ? _value.hasLiked
          : hasLiked // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      replies: null == replies
          ? _value._replies
          : replies // ignore: cast_nullable_to_non_nullable
              as List<StoryComment>,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$StoryCommentImpl implements _StoryComment {
  const _$StoryCommentImpl(
      {required this.id,
      required this.storyId,
      required this.userId,
      required this.content,
      this.parentCommentId,
      this.likesCount = 0,
      this.hasLiked = false,
      required this.createdAt,
      this.updatedAt,
      this.user,
      final List<StoryComment> replies = const []})
      : _replies = replies;
  factory _$StoryCommentImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryCommentImplFromJson(json);
  @override
  final String id;
  @override
  final String storyId;
  @override
  final String userId;
  @override
  final String content;
  @override
  final String? parentCommentId;
  @override
  @JsonKey()
  final int likesCount;
  @override
  @JsonKey()
  final bool hasLiked;
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
// User info (populated from join)
  @override
  final User? user;
// Replies (if it's a parent comment)
  final List<StoryComment> _replies;
// Replies (if it's a parent comment)
  @override
  @JsonKey()
  List<StoryComment> get replies {
    if (_replies is EqualUnmodifiableListView) return _replies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_replies);
  }
  @override
  String toString() {
    return 'StoryComment(id: $id, storyId: $storyId, userId: $userId, content: $content, parentCommentId: $parentCommentId, likesCount: $likesCount, hasLiked: $hasLiked, createdAt: $createdAt, updatedAt: $updatedAt, user: $user, replies: $replies)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryCommentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.storyId, storyId) || other.storyId == storyId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.parentCommentId, parentCommentId) ||
                other.parentCommentId == parentCommentId) &&
            (identical(other.likesCount, likesCount) ||
                other.likesCount == likesCount) &&
            (identical(other.hasLiked, hasLiked) ||
                other.hasLiked == hasLiked) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.user, user) || other.user == user) &&
            const DeepCollectionEquality().equals(other._replies, _replies));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      storyId,
      userId,
      content,
      parentCommentId,
      likesCount,
      hasLiked,
      createdAt,
      updatedAt,
      user,
      const DeepCollectionEquality().hash(_replies));
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryCommentImplCopyWith<_$StoryCommentImpl> get copyWith =>
      __$$StoryCommentImplCopyWithImpl<_$StoryCommentImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$StoryCommentImplToJson(
      this,
    );
  }
}
abstract class _StoryComment implements StoryComment {
  const factory _StoryComment(
      {required final String id,
      required final String storyId,
      required final String userId,
      required final String content,
      final String? parentCommentId,
      final int likesCount,
      final bool hasLiked,
      required final DateTime createdAt,
      final DateTime? updatedAt,
      final User? user,
      final List<StoryComment> replies}) = _$StoryCommentImpl;
  factory _StoryComment.fromJson(Map<String, dynamic> json) =
      _$StoryCommentImpl.fromJson;
  @override
  String get id;
  @override
  String get storyId;
  @override
  String get userId;
  @override
  String get content;
  @override
  String? get parentCommentId;
  @override
  int get likesCount;
  @override
  bool get hasLiked;
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // User info (populated from join)
  @override
  User? get user; // Replies (if it's a parent comment)
  @override
  List<StoryComment> get replies;
  /// Create a copy of StoryComment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryCommentImplCopyWith<_$StoryCommentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
CreateStoryRequest _$CreateStoryRequestFromJson(Map<String, dynamic> json) {
  return _CreateStoryRequest.fromJson(json);
}
/// @nodoc
mixin _$CreateStoryRequest {
  String get content => throw _privateConstructorUsedError;
  StoryType get type => throw _privateConstructorUsedError;
  StoryPrivacyLevel get privacyLevel => throw _privateConstructorUsedError;
  String? get mediaUrl => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  List<String>? get tags => throw _privateConstructorUsedError;
  String? get location => throw _privateConstructorUsedError;
  DateTime? get expiresAt => throw _privateConstructorUsedError;
  String? get plantId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get plantData => throw _privateConstructorUsedError;
  String? get careStage => throw _privateConstructorUsedError;
  List<String>? get careTips => throw _privateConstructorUsedError;
  /// Serializes this CreateStoryRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of CreateStoryRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CreateStoryRequestCopyWith<CreateStoryRequest> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $CreateStoryRequestCopyWith<$Res> {
  factory $CreateStoryRequestCopyWith(
          CreateStoryRequest value, $Res Function(CreateStoryRequest) then) =
      _$CreateStoryRequestCopyWithImpl<$Res, CreateStoryRequest>;
  @useResult
  $Res call(
      {String content,
      StoryType type,
      StoryPrivacyLevel privacyLevel,
      String? mediaUrl,
      Map<String, dynamic>? metadata,
      List<String>? tags,
      String? location,
      DateTime? expiresAt,
      String? plantId,
      Map<String, dynamic>? plantData,
      String? careStage,
      List<String>? careTips});
}
/// @nodoc
class _$CreateStoryRequestCopyWithImpl<$Res, $Val extends CreateStoryRequest>
    implements $CreateStoryRequestCopyWith<$Res> {
  _$CreateStoryRequestCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of CreateStoryRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? type = null,
    Object? privacyLevel = null,
    Object? mediaUrl = freezed,
    Object? metadata = freezed,
    Object? tags = freezed,
    Object? location = freezed,
    Object? expiresAt = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
    Object? careStage = freezed,
    Object? careTips = freezed,
  }) {
    return _then(_value.copyWith(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StoryType,
      privacyLevel: null == privacyLevel
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as StoryPrivacyLevel,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value.plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      careStage: freezed == careStage
          ? _value.careStage
          : careStage // ignore: cast_nullable_to_non_nullable
              as String?,
      careTips: freezed == careTips
          ? _value.careTips
          : careTips // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}
/// @nodoc
abstract class _$$CreateStoryRequestImplCopyWith<$Res>
    implements $CreateStoryRequestCopyWith<$Res> {
  factory _$$CreateStoryRequestImplCopyWith(_$CreateStoryRequestImpl value,
          $Res Function(_$CreateStoryRequestImpl) then) =
      __$$CreateStoryRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String content,
      StoryType type,
      StoryPrivacyLevel privacyLevel,
      String? mediaUrl,
      Map<String, dynamic>? metadata,
      List<String>? tags,
      String? location,
      DateTime? expiresAt,
      String? plantId,
      Map<String, dynamic>? plantData,
      String? careStage,
      List<String>? careTips});
}
/// @nodoc
class __$$CreateStoryRequestImplCopyWithImpl<$Res>
    extends _$CreateStoryRequestCopyWithImpl<$Res, _$CreateStoryRequestImpl>
    implements _$$CreateStoryRequestImplCopyWith<$Res> {
  __$$CreateStoryRequestImplCopyWithImpl(_$CreateStoryRequestImpl _value,
      $Res Function(_$CreateStoryRequestImpl) _then)
      : super(_value, _then);
  /// Create a copy of CreateStoryRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
    Object? type = null,
    Object? privacyLevel = null,
    Object? mediaUrl = freezed,
    Object? metadata = freezed,
    Object? tags = freezed,
    Object? location = freezed,
    Object? expiresAt = freezed,
    Object? plantId = freezed,
    Object? plantData = freezed,
    Object? careStage = freezed,
    Object? careTips = freezed,
  }) {
    return _then(_$CreateStoryRequestImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StoryType,
      privacyLevel: null == privacyLevel
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as StoryPrivacyLevel,
      mediaUrl: freezed == mediaUrl
          ? _value.mediaUrl
          : mediaUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      plantId: freezed == plantId
          ? _value.plantId
          : plantId // ignore: cast_nullable_to_non_nullable
              as String?,
      plantData: freezed == plantData
          ? _value._plantData
          : plantData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      careStage: freezed == careStage
          ? _value.careStage
          : careStage // ignore: cast_nullable_to_non_nullable
              as String?,
      careTips: freezed == careTips
          ? _value._careTips
          : careTips // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$CreateStoryRequestImpl implements _CreateStoryRequest {
  const _$CreateStoryRequestImpl(
      {required this.content,
      this.type = StoryType.image,
      this.privacyLevel = StoryPrivacyLevel.public,
      this.mediaUrl,
      final Map<String, dynamic>? metadata,
      final List<String>? tags,
      this.location,
      this.expiresAt,
      this.plantId,
      final Map<String, dynamic>? plantData,
      this.careStage,
      final List<String>? careTips})
      : _metadata = metadata,
        _tags = tags,
        _plantData = plantData,
        _careTips = careTips;
  factory _$CreateStoryRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateStoryRequestImplFromJson(json);
  @override
  final String content;
  @override
  @JsonKey()
  final StoryType type;
  @override
  @JsonKey()
  final StoryPrivacyLevel privacyLevel;
  @override
  final String? mediaUrl;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  final List<String>? _tags;
  @override
  List<String>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }
  @override
  final String? location;
  @override
  final DateTime? expiresAt;
  @override
  final String? plantId;
  final Map<String, dynamic>? _plantData;
  @override
  Map<String, dynamic>? get plantData {
    final value = _plantData;
    if (value == null) return null;
    if (_plantData is EqualUnmodifiableMapView) return _plantData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }
  @override
  final String? careStage;
  final List<String>? _careTips;
  @override
  List<String>? get careTips {
    final value = _careTips;
    if (value == null) return null;
    if (_careTips is EqualUnmodifiableListView) return _careTips;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }
  @override
  String toString() {
    return 'CreateStoryRequest(content: $content, type: $type, privacyLevel: $privacyLevel, mediaUrl: $mediaUrl, metadata: $metadata, tags: $tags, location: $location, expiresAt: $expiresAt, plantId: $plantId, plantData: $plantData, careStage: $careStage, careTips: $careTips)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateStoryRequestImpl &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.privacyLevel, privacyLevel) ||
                other.privacyLevel == privacyLevel) &&
            (identical(other.mediaUrl, mediaUrl) ||
                other.mediaUrl == mediaUrl) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.plantId, plantId) || other.plantId == plantId) &&
            const DeepCollectionEquality()
                .equals(other._plantData, _plantData) &&
            (identical(other.careStage, careStage) ||
                other.careStage == careStage) &&
            const DeepCollectionEquality().equals(other._careTips, _careTips));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      content,
      type,
      privacyLevel,
      mediaUrl,
      const DeepCollectionEquality().hash(_metadata),
      const DeepCollectionEquality().hash(_tags),
      location,
      expiresAt,
      plantId,
      const DeepCollectionEquality().hash(_plantData),
      careStage,
      const DeepCollectionEquality().hash(_careTips));
  /// Create a copy of CreateStoryRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateStoryRequestImplCopyWith<_$CreateStoryRequestImpl> get copyWith =>
      __$$CreateStoryRequestImplCopyWithImpl<_$CreateStoryRequestImpl>(
          this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$CreateStoryRequestImplToJson(
      this,
    );
  }
}
abstract class _CreateStoryRequest implements CreateStoryRequest {
  const factory _CreateStoryRequest(
      {required final String content,
      final StoryType type,
      final StoryPrivacyLevel privacyLevel,
      final String? mediaUrl,
      final Map<String, dynamic>? metadata,
      final List<String>? tags,
      final String? location,
      final DateTime? expiresAt,
      final String? plantId,
      final Map<String, dynamic>? plantData,
      final String? careStage,
      final List<String>? careTips}) = _$CreateStoryRequestImpl;
  factory _CreateStoryRequest.fromJson(Map<String, dynamic> json) =
      _$CreateStoryRequestImpl.fromJson;
  @override
  String get content;
  @override
  StoryType get type;
  @override
  StoryPrivacyLevel get privacyLevel;
  @override
  String? get mediaUrl;
  @override
  Map<String, dynamic>? get metadata;
  @override
  List<String>? get tags;
  @override
  String? get location;
  @override
  DateTime? get expiresAt;
  @override
  String? get plantId;
  @override
  Map<String, dynamic>? get plantData;
  @override
  String? get careStage;
  @override
  List<String>? get careTips;
  /// Create a copy of CreateStoryRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreateStoryRequestImplCopyWith<_$CreateStoryRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
StoryFeed _$StoryFeedFromJson(Map<String, dynamic> json) {
  return _StoryFeed.fromJson(json);
}
/// @nodoc
mixin _$StoryFeed {
  String get userId => throw _privateConstructorUsedError;
  User get user => throw _privateConstructorUsedError;
  List<Story> get stories => throw _privateConstructorUsedError;
  bool get hasUnviewedStories => throw _privateConstructorUsedError;
  /// Serializes this StoryFeed to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoryFeedCopyWith<StoryFeed> get copyWith =>
      throw _privateConstructorUsedError;
}
/// @nodoc
abstract class $StoryFeedCopyWith<$Res> {
  factory $StoryFeedCopyWith(StoryFeed value, $Res Function(StoryFeed) then) =
      _$StoryFeedCopyWithImpl<$Res, StoryFeed>;
  @useResult
  $Res call(
      {String userId, User user, List<Story> stories, bool hasUnviewedStories});
  $UserCopyWith<$Res> get user;
}
/// @nodoc
class _$StoryFeedCopyWithImpl<$Res, $Val extends StoryFeed>
    implements $StoryFeedCopyWith<$Res> {
  _$StoryFeedCopyWithImpl(this._value, this._then);
  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? user = null,
    Object? stories = null,
    Object? hasUnviewedStories = null,
  }) {
    return _then(_value.copyWith(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      stories: null == stories
          ? _value.stories
          : stories // ignore: cast_nullable_to_non_nullable
              as List<Story>,
      hasUnviewedStories: null == hasUnviewedStories
          ? _value.hasUnviewedStories
          : hasUnviewedStories // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get user {
    return $UserCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}
/// @nodoc
abstract class _$$StoryFeedImplCopyWith<$Res>
    implements $StoryFeedCopyWith<$Res> {
  factory _$$StoryFeedImplCopyWith(
          _$StoryFeedImpl value, $Res Function(_$StoryFeedImpl) then) =
      __$$StoryFeedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String userId, User user, List<Story> stories, bool hasUnviewedStories});
  @override
  $UserCopyWith<$Res> get user;
}
/// @nodoc
class __$$StoryFeedImplCopyWithImpl<$Res>
    extends _$StoryFeedCopyWithImpl<$Res, _$StoryFeedImpl>
    implements _$$StoryFeedImplCopyWith<$Res> {
  __$$StoryFeedImplCopyWithImpl(
      _$StoryFeedImpl _value, $Res Function(_$StoryFeedImpl) _then)
      : super(_value, _then);
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? user = null,
    Object? stories = null,
    Object? hasUnviewedStories = null,
  }) {
    return _then(_$StoryFeedImpl(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      stories: null == stories
          ? _value._stories
          : stories // ignore: cast_nullable_to_non_nullable
              as List<Story>,
      hasUnviewedStories: null == hasUnviewedStories
          ? _value.hasUnviewedStories
          : hasUnviewedStories // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}
/// @nodoc
@JsonSerializable()
class _$StoryFeedImpl implements _StoryFeed {
  const _$StoryFeedImpl(
      {required this.userId,
      required this.user,
      final List<Story> stories = const [],
      this.hasUnviewedStories = false})
      : _stories = stories;
  factory _$StoryFeedImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoryFeedImplFromJson(json);
  @override
  final String userId;
  @override
  final User user;
  final List<Story> _stories;
  @override
  @JsonKey()
  List<Story> get stories {
    if (_stories is EqualUnmodifiableListView) return _stories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_stories);
  }
  @override
  @JsonKey()
  final bool hasUnviewedStories;
  @override
  String toString() {
    return 'StoryFeed(userId: $userId, user: $user, stories: $stories, hasUnviewedStories: $hasUnviewedStories)';
  }
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoryFeedImpl &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            const DeepCollectionEquality().equals(other._stories, _stories) &&
            (identical(other.hasUnviewedStories, hasUnviewedStories) ||
                other.hasUnviewedStories == hasUnviewedStories));
  }
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, userId, user,
      const DeepCollectionEquality().hash(_stories), hasUnviewedStories);
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoryFeedImplCopyWith<_$StoryFeedImpl> get copyWith =>
      __$$StoryFeedImplCopyWithImpl<_$StoryFeedImpl>(this, _$identity);
  @override
  Map<String, dynamic> toJson() {
    return _$$StoryFeedImplToJson(
      this,
    );
  }
}
abstract class _StoryFeed implements StoryFeed {
  const factory _StoryFeed(
      {required final String userId,
      required final User user,
      final List<Story> stories,
      final bool hasUnviewedStories}) = _$StoryFeedImpl;
  factory _StoryFeed.fromJson(Map<String, dynamic> json) =
      _$StoryFeedImpl.fromJson;
  @override
  String get userId;
  @override
  User get user;
  @override
  List<Story> get stories;
  @override
  bool get hasUnviewedStories;
  /// Create a copy of StoryFeed
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoryFeedImplCopyWith<_$StoryFeedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
</file>

<file path="frontend/lib/core/network/api_client.dart">
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:plant_social/core/constants/app_constants.dart';
import 'package:plant_social/core/network/interceptors/auth_interceptor.dart';
import 'package:plant_social/core/network/interceptors/logging_interceptor.dart';
import 'package:plant_social/core/network/interceptors/error_interceptor.dart';
class ApiClient {
  late final Dio _dio;
  final FlutterSecureStorage _storage;
  ApiClient(this._storage) {
    _dio = Dio(
      BaseOptions(
        baseUrl: AppConstants.apiBaseUrl,
        connectTimeout: const Duration(seconds: 30),
        receiveTimeout: const Duration(seconds: 30),
        sendTimeout: const Duration(seconds: 30),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ),
    );
    // Add interceptors
    _dio.interceptors.addAll([
      AuthInterceptor(_storage),
      ErrorInterceptor(),
      LoggingInterceptor(),
    ]);
  }
  Dio get dio => _dio;
  // GET request
  Future<Response<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.get<T>(
        path,
        queryParameters: queryParameters,
        options: options,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
  // POST request
  Future<Response<T>> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.post<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
  // PUT request
  Future<Response<T>> put<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.put<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
  // PATCH request
  Future<Response<T>> patch<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.patch<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
  // DELETE request
  Future<Response<T>> delete<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.delete<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
  // Upload file
  Future<Response<T>> uploadFile<T>(
    String path,
    String filePath, {
    String? fileName,
    Map<String, dynamic>? data,
    ProgressCallback? onSendProgress,
    CancelToken? cancelToken,
  }) async {
    try {
      final formData = FormData.fromMap({
        'file': await MultipartFile.fromFile(
          filePath,
          filename: fileName,
        ),
        if (data != null) ...data,
      });
      return await _dio.post<T>(
        path,
        data: formData,
        onSendProgress: onSendProgress,
        cancelToken: cancelToken,
        options: Options(
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        ),
      );
    } catch (e) {
      rethrow;
    }
  }
  // Download file
  Future<Response> downloadFile(
    String path,
    String savePath, {
    Map<String, dynamic>? queryParameters,
    ProgressCallback? onReceiveProgress,
    CancelToken? cancelToken,
  }) async {
    try {
      return await _dio.download(
        path,
        savePath,
        queryParameters: queryParameters,
        onReceiveProgress: onReceiveProgress,
        cancelToken: cancelToken,
      );
    } catch (e) {
      rethrow;
    }
  }
}
// Provider for ApiClient
final apiClientProvider = Provider<ApiClient>((ref) {
  const storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      accessibility: KeychainAccessibility.first_unlock_this_device,
    ),
  );
  return ApiClient(storage);
});
</file>

<file path="frontend/lib/core/network/interceptors/auth_interceptor.dart">
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:plant_social/core/constants/app_constants.dart';
class AuthInterceptor extends Interceptor {
  final FlutterSecureStorage _storage;
  AuthInterceptor(this._storage);
  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    // Get access token from secure storage
    final accessToken = await _storage.read(key: AppConstants.accessTokenKey);
    if (accessToken != null && accessToken.isNotEmpty) {
      options.headers['Authorization'] = 'Bearer $accessToken';
    }
    handler.next(options);
  }
  @override
  void onError(
    DioException err,
    ErrorInterceptorHandler handler,
  ) async {
    // Handle 401 Unauthorized errors
    if (err.response?.statusCode == 401) {
      // Try to refresh token
      final refreshed = await _refreshToken();
      if (refreshed) {
        // Retry the original request
        final requestOptions = err.requestOptions;
        final accessToken = await _storage.read(key: AppConstants.accessTokenKey);
        if (accessToken != null) {
          requestOptions.headers['Authorization'] = 'Bearer $accessToken';
          try {
            final dio = Dio();
            final response = await dio.fetch(requestOptions);
            handler.resolve(response);
            return;
          } catch (e) {
            // If retry fails, continue with original error
          }
        }
      }
      // If refresh failed or no refresh token, clear tokens and redirect to login
      await _clearTokens();
    }
    handler.next(err);
  }
  Future<bool> _refreshToken() async {
    try {
      final refreshToken = await _storage.read(key: AppConstants.refreshTokenKey);
      if (refreshToken == null || refreshToken.isEmpty) {
        return false;
      }
      final dio = Dio();
      final response = await dio.post(
        '${AppConstants.apiBaseUrl}/auth/refresh',
        data: {'refresh_token': refreshToken},
      );
      if (response.statusCode == 200) {
        final data = response.data;
        final newAccessToken = data['access_token'];
        final newRefreshToken = data['refresh_token'];
        if (newAccessToken != null) {
          await _storage.write(key: AppConstants.accessTokenKey, value: newAccessToken);
        }
        if (newRefreshToken != null) {
          await _storage.write(key: AppConstants.refreshTokenKey, value: newRefreshToken);
        }
        return true;
      }
    } catch (e) {
      // Refresh failed
      print('Token refresh failed: $e');
    }
    return false;
  }
  Future<void> _clearTokens() async {
    await Future.wait([
      _storage.delete(key: AppConstants.accessTokenKey),
      _storage.delete(key: AppConstants.refreshTokenKey),
      _storage.delete(key: AppConstants.userDataKey),
    ]);
  }
}
</file>

<file path="frontend/lib/core/network/interceptors/error_interceptor.dart">
import 'package:dio/dio.dart';
import 'package:plant_social/core/exceptions/api_exception.dart';
class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    final apiException = _handleError(err);
    handler.reject(DioException(
      requestOptions: err.requestOptions,
      error: apiException,
      type: err.type,
      response: err.response,
    ));
  }
  ApiException _handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return const ApiException(
          message: 'Connection timeout. Please check your internet connection.',
          statusCode: 408,
          type: ApiExceptionType.timeout,
        );
      case DioExceptionType.badResponse:
        return _handleResponseError(error);
      case DioExceptionType.cancel:
        return const ApiException(
          message: 'Request was cancelled.',
          statusCode: 0,
          type: ApiExceptionType.cancel,
        );
      case DioExceptionType.connectionError:
        return const ApiException(
          message: 'No internet connection. Please check your network settings.',
          statusCode: 0,
          type: ApiExceptionType.network,
        );
      case DioExceptionType.badCertificate:
        return const ApiException(
          message: 'Certificate verification failed.',
          statusCode: 0,
          type: ApiExceptionType.network,
        );
      case DioExceptionType.unknown:
      default:
        return const ApiException(
          message: 'An unexpected error occurred. Please try again.',
          statusCode: 0,
          type: ApiExceptionType.unknown,
        );
    }
  }
  ApiException _handleResponseError(DioException error) {
    final response = error.response;
    final statusCode = response?.statusCode ?? 0;
    final data = response?.data;
    String message = 'An error occurred. Please try again.';
    ApiExceptionType type = ApiExceptionType.server;
    // Try to extract error message from response
    if (data is Map<String, dynamic>) {
      if (data.containsKey('detail')) {
        message = data['detail'].toString();
      } else if (data.containsKey('message')) {
        message = data['message'].toString();
      } else if (data.containsKey('error')) {
        message = data['error'].toString();
      }
    } else if (data is String) {
      message = data;
    }
    // Handle specific status codes
    switch (statusCode) {
      case 400:
        type = ApiExceptionType.badRequest;
        if (message.isEmpty) {
          message = 'Invalid request. Please check your input.';
        }
        break;
      case 401:
        type = ApiExceptionType.unauthorized;
        message = 'Authentication failed. Please log in again.';
        break;
      case 403:
        type = ApiExceptionType.forbidden;
        message = 'Access denied. You don\'t have permission to perform this action.';
        break;
      case 404:
        type = ApiExceptionType.notFound;
        message = 'The requested resource was not found.';
        break;
      case 409:
        type = ApiExceptionType.conflict;
        if (message.isEmpty) {
          message = 'A conflict occurred. The resource may already exist.';
        }
        break;
      case 422:
        type = ApiExceptionType.validation;
        if (message.isEmpty) {
          message = 'Validation failed. Please check your input.';
        }
        break;
      case 429:
        type = ApiExceptionType.tooManyRequests;
        message = 'Too many requests. Please try again later.';
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        type = ApiExceptionType.server;
        message = 'Server error. Please try again later.';
        break;
      default:
        type = ApiExceptionType.server;
        if (message.isEmpty) {
          message = 'An unexpected error occurred. Please try again.';
        }
    }
    return ApiException(
      message: message,
      statusCode: statusCode,
      type: type,
      details: data is Map<String, dynamic> ? data : null,
    );
  }
}
</file>

<file path="frontend/lib/core/network/interceptors/logging_interceptor.dart">
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    if (kDebugMode) {
      print('\n REQUEST[${options.method}] => PATH: ${options.path}');
      print('Headers:');
      options.headers.forEach((k, v) => print('  $k: $v'));
      if (options.queryParameters.isNotEmpty) {
        print('Query Parameters:');
        options.queryParameters.forEach((k, v) => print('  $k: $v'));
      }
      if (options.data != null) {
        print('Body: ${options.data}');
      }
      print('\n');
    }
    handler.next(options);
  }
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    if (kDebugMode) {
      print('\n RESPONSE[${response.statusCode}] => PATH: ${response.requestOptions.path}');
      print('Data: ${response.data}');
      print('\n');
    }
    handler.next(response);
  }
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    if (kDebugMode) {
      print('\n ERROR[${err.response?.statusCode}] => PATH: ${err.requestOptions.path}');
      print('Error: ${err.error}');
      print('Message: ${err.message}');
      if (err.response?.data != null) {
        print('Response Data: ${err.response?.data}');
      }
      print('\n');
    }
    handler.next(err);
  }
}
</file>

<file path="frontend/lib/core/providers/api_provider.dart">
/**
 * Core API provider for dependency injection
 * Provides centralized access to API service throughout the app
 */
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_service.dart';
/**
 * Provider for API service - re-exported for convenience
 */
final apiServiceProvider = Provider<ApiService>((ref) {
  return ApiService();
});
/**
 * Provider for API client state management
 */
final apiStateProvider = StateProvider<ApiState>((ref) {
  return const ApiState.idle();
});
/**
 * API state management for loading states
 */
class ApiState {
  final bool isLoading;
  final String? error;
  final String? message;
  const ApiState({
    required this.isLoading,
    this.error,
    this.message,
  });
  const ApiState.idle() : this(isLoading: false);
  const ApiState.loading() : this(isLoading: true);
  const ApiState.error(String error) : this(isLoading: false, error: error);
  const ApiState.success(String message) : this(isLoading: false, message: message);
  ApiState copyWith({
    bool? isLoading,
    String? error,
    String? message,
  }) {
    return ApiState(
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      message: message ?? this.message,
    );
  }
}
</file>

<file path="frontend/lib/core/providers/storage_provider.dart">
/**
 * Core storage provider for dependency injection
 * Provides centralized access to storage service throughout the app
 */
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/storage_service.dart';
/**
 * Provider for storage service - re-exported for convenience
 */
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService();
});
/**
 * Provider for user preferences state
 */
final userPreferencesProvider = StateNotifierProvider<UserPreferencesNotifier, UserPreferences>((ref) {
  final storageService = ref.watch(storageServiceProvider);
  return UserPreferencesNotifier(storageService);
});
/**
 * User preferences state model
 */
class UserPreferences {
  final bool isDarkMode;
  final String language;
  final bool notificationsEnabled;
  final bool locationEnabled;
  const UserPreferences({
    this.isDarkMode = false,
    this.language = 'en',
    this.notificationsEnabled = true,
    this.locationEnabled = false,
  });
  UserPreferences copyWith({
    bool? isDarkMode,
    String? language,
    bool? notificationsEnabled,
    bool? locationEnabled,
  }) {
    return UserPreferences(
      isDarkMode: isDarkMode ?? this.isDarkMode,
      language: language ?? this.language,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      locationEnabled: locationEnabled ?? this.locationEnabled,
    );
  }
}
/**
 * User preferences state notifier
 */
class UserPreferencesNotifier extends StateNotifier<UserPreferences> {
  final StorageService _storageService;
  UserPreferencesNotifier(this._storageService) : super(const UserPreferences()) {
    _loadPreferences();
  }
  /**
   * Load preferences from storage
   */
  Future<void> _loadPreferences() async {
    final isDarkMode = await _storageService.getBool('isDarkMode');
    final language = await _storageService.getString('language') ?? 'en';
    final notificationsEnabled = await _storageService.getBool('notificationsEnabled', defaultValue: true);
    final locationEnabled = await _storageService.getBool('locationEnabled');
    state = UserPreferences(
      isDarkMode: isDarkMode,
      language: language,
      notificationsEnabled: notificationsEnabled,
      locationEnabled: locationEnabled,
    );
  }
  /**
   * Update dark mode preference
   */
  Future<void> setDarkMode(bool isDarkMode) async {
    await _storageService.setBool('isDarkMode', isDarkMode);
    state = state.copyWith(isDarkMode: isDarkMode);
  }
  /**
   * Update language preference
   */
  Future<void> setLanguage(String language) async {
    await _storageService.setString('language', language);
    state = state.copyWith(language: language);
  }
  /**
   * Update notifications preference
   */
  Future<void> setNotificationsEnabled(bool enabled) async {
    await _storageService.setBool('notificationsEnabled', enabled);
    state = state.copyWith(notificationsEnabled: enabled);
  }
  /**
   * Update location preference
   */
  Future<void> setLocationEnabled(bool enabled) async {
    await _storageService.setBool('locationEnabled', enabled);
    state = state.copyWith(locationEnabled: enabled);
  }
}
</file>

<file path="frontend/lib/core/services/storage_service.dart">
/**
 * Core storage service for handling local data persistence
 * Provides secure storage for user data, preferences, and cached content
 */
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
/**
 * Provider for the storage service singleton
 */
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService();
});
/**
 * Main storage service class for handling local data operations
 */
class StorageService {
  static const _secureStorage = FlutterSecureStorage();
  SharedPreferences? _prefs;
  /**
   * Initialize shared preferences
   */
  Future<void> init() async {
    _prefs ??= await SharedPreferences.getInstance();
  }
  /**
   * Store sensitive data securely (tokens, passwords)
   */
  Future<void> storeSecure(String key, String value) async {
    await _secureStorage.write(key: key, value: value);
  }
  /**
   * Retrieve sensitive data securely
   */
  Future<String?> getSecure(String key) async {
    return await _secureStorage.read(key: key);
  }
  /**
   * Delete sensitive data
   */
  Future<void> deleteSecure(String key) async {
    await _secureStorage.delete(key: key);
  }
  /**
   * Clear all secure storage
   */
  Future<void> clearSecure() async {
    await _secureStorage.deleteAll();
  }
  /**
   * Store regular preferences data
   */
  Future<bool> setString(String key, String value) async {
    await init();
    return _prefs!.setString(key, value);
  }
  /**
   * Get regular preferences data
   */
  Future<String?> getString(String key) async {
    await init();
    return _prefs!.getString(key);
  }
  /**
   * Store boolean preferences
   */
  Future<bool> setBool(String key, bool value) async {
    await init();
    return _prefs!.setBool(key, value);
  }
  /**
   * Get boolean preferences
   */
  Future<bool> getBool(String key, {bool defaultValue = false}) async {
    await init();
    return _prefs!.getBool(key) ?? defaultValue;
  }
  /**
   * Store integer preferences
   */
  Future<bool> setInt(String key, int value) async {
    await init();
    return _prefs!.setInt(key, value);
  }
  /**
   * Get integer preferences
   */
  Future<int> getInt(String key, {int defaultValue = 0}) async {
    await init();
    return _prefs!.getInt(key) ?? defaultValue;
  }
  /**
   * Store list of strings
   */
  Future<bool> setStringList(String key, List<String> value) async {
    await init();
    return _prefs!.setStringList(key, value);
  }
  /**
   * Get list of strings
   */
  Future<List<String>> getStringList(String key) async {
    await init();
    return _prefs!.getStringList(key) ?? [];
  }
  /**
   * Remove a preference key
   */
  Future<bool> remove(String key) async {
    await init();
    return _prefs!.remove(key);
  }
  /**
   * Clear all preferences
   */
  Future<bool> clear() async {
    await init();
    return _prefs!.clear();
  }
  /**
   * Check if a key exists in preferences
   */
  Future<bool> containsKey(String key) async {
    await init();
    return _prefs!.containsKey(key);
  }
}
</file>

<file path="frontend/lib/core/utils/date_utils.dart">
class DateUtils {
  /// Formats a DateTime to a relative time string (e.g., "2 hours ago", "3 days ago")
  static String formatRelativeTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    if (difference.inDays > 365) {
      final years = (difference.inDays / 365).floor();
      return years == 1 ? '1 year ago' : '$years years ago';
    } else if (difference.inDays > 30) {
      final months = (difference.inDays / 30).floor();
      return months == 1 ? '1 month ago' : '$months months ago';
    } else if (difference.inDays > 0) {
      return difference.inDays == 1 ? '1 day ago' : '${difference.inDays} days ago';
    } else if (difference.inHours > 0) {
      return difference.inHours == 1 ? '1 hour ago' : '${difference.inHours} hours ago';
    } else if (difference.inMinutes > 0) {
      return difference.inMinutes == 1 ? '1 minute ago' : '${difference.inMinutes} minutes ago';
    } else {
      return 'Just now';
    }
  }
  /// Formats a DateTime to a short date string (e.g., "Mar 15", "Dec 3, 2023")
  static String formatShortDate(DateTime dateTime) {
    final now = DateTime.now();
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    final month = months[dateTime.month - 1];
    final day = dateTime.day;
    if (dateTime.year == now.year) {
      return '$month $day';
    } else {
      return '$month $day, ${dateTime.year}';
    }
  }
  /// Formats a DateTime to a full date string (e.g., "March 15, 2024")
  static String formatFullDate(DateTime dateTime) {
    final months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    final month = months[dateTime.month - 1];
    final day = dateTime.day;
    final year = dateTime.year;
    return '$month $day, $year';
  }
  /// Formats a DateTime to a time string (e.g., "2:30 PM", "14:30")
  static String formatTime(DateTime dateTime, {bool use24Hour = false}) {
    if (use24Hour) {
      final hour = dateTime.hour.toString().padLeft(2, '0');
      final minute = dateTime.minute.toString().padLeft(2, '0');
      return '$hour:$minute';
    } else {
      final hour = dateTime.hour == 0
          ? 12
          : dateTime.hour > 12
              ? dateTime.hour - 12
              : dateTime.hour;
      final minute = dateTime.minute.toString().padLeft(2, '0');
      final period = dateTime.hour >= 12 ? 'PM' : 'AM';
      return '$hour:$minute $period';
    }
  }
  /// Formats a DateTime to a date and time string (e.g., "Mar 15, 2:30 PM")
  static String formatDateTime(DateTime dateTime, {bool use24Hour = false}) {
    final date = formatShortDate(dateTime);
    final time = formatTime(dateTime, use24Hour: use24Hour);
    return '$date, $time';
  }
  /// Checks if a date is today
  static bool isToday(DateTime dateTime) {
    final now = DateTime.now();
    return dateTime.year == now.year &&
        dateTime.month == now.month &&
        dateTime.day == now.day;
  }
  /// Checks if a date is yesterday
  static bool isYesterday(DateTime dateTime) {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return dateTime.year == yesterday.year &&
        dateTime.month == yesterday.month &&
        dateTime.day == yesterday.day;
  }
  /// Checks if a date is this week
  static bool isThisWeek(DateTime dateTime) {
    final now = DateTime.now();
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final endOfWeek = startOfWeek.add(const Duration(days: 6));
    return dateTime.isAfter(startOfWeek.subtract(const Duration(days: 1))) &&
        dateTime.isBefore(endOfWeek.add(const Duration(days: 1)));
  }
  /// Gets the start of the day for a given DateTime
  static DateTime startOfDay(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, dateTime.day);
  }
  /// Gets the end of the day for a given DateTime
  static DateTime endOfDay(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, dateTime.day, 23, 59, 59, 999);
  }
  /// Calculates the number of days between two dates
  static int daysBetween(DateTime from, DateTime to) {
    from = startOfDay(from);
    to = startOfDay(to);
    return to.difference(from).inDays;
  }
  /// Formats a duration to a human-readable string
  static String formatDuration(Duration duration) {
    if (duration.inDays > 0) {
      return '${duration.inDays}d ${duration.inHours % 24}h';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    } else if (duration.inMinutes > 0) {
      return '${duration.inMinutes}m';
    } else {
      return '${duration.inSeconds}s';
    }
  }
  /// Parses an ISO 8601 string to DateTime
  static DateTime? parseIso8601(String? dateString) {
    if (dateString == null || dateString.isEmpty) {
      return null;
    }
    try {
      return DateTime.parse(dateString);
    } catch (e) {
      return null;
    }
  }
  /// Formats a DateTime to ISO 8601 string
  static String toIso8601(DateTime dateTime) {
    return dateTime.toIso8601String();
  }
  /// Gets a user-friendly format based on how recent the date is
  static String formatSmart(DateTime dateTime) {
    if (isToday(dateTime)) {
      return formatTime(dateTime);
    } else if (isYesterday(dateTime)) {
      return 'Yesterday';
    } else if (isThisWeek(dateTime)) {
      final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      return weekdays[dateTime.weekday - 1];
    } else {
      return formatShortDate(dateTime);
    }
  }
  /// Formats a date range
  static String formatDateRange(DateTime start, DateTime end) {
    if (startOfDay(start) == startOfDay(end)) {
      // Same day
      return '${formatShortDate(start)}, ${formatTime(start)} - ${formatTime(end)}';
    } else if (start.year == end.year) {
      // Same year
      return '${formatShortDate(start)} - ${formatShortDate(end)}';
    } else {
      // Different years
      return '${formatShortDate(start)}, ${start.year} - ${formatShortDate(end)}, ${end.year}';
    }
  }
}
</file>

<file path="frontend/lib/core/widgets/custom_search_bar.dart">
import 'package:flutter/material.dart';
class CustomSearchBar extends StatefulWidget {
  final TextEditingController? controller;
  final String? hintText;
  final Function(String)? onChanged;
  final Function(String)? onSubmitted;
  final VoidCallback? onClear;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final bool enabled;
  final bool autofocus;
  final TextInputAction textInputAction;
  const CustomSearchBar({
    super.key,
    this.controller,
    this.hintText,
    this.onChanged,
    this.onSubmitted,
    this.onClear,
    this.prefixIcon,
    this.suffixIcon,
    this.enabled = true,
    this.autofocus = false,
    this.textInputAction = TextInputAction.search,
  });
  @override
  State<CustomSearchBar> createState() => _CustomSearchBarState();
}
class _CustomSearchBarState extends State<CustomSearchBar> {
  late TextEditingController _controller;
  bool _showClearButton = false;
  @override
  void initState() {
    super.initState();
    _controller = widget.controller ?? TextEditingController();
    _controller.addListener(_onTextChanged);
    _showClearButton = _controller.text.isNotEmpty;
  }
  @override
  void dispose() {
    if (widget.controller == null) {
      _controller.dispose();
    } else {
      _controller.removeListener(_onTextChanged);
    }
    super.dispose();
  }
  void _onTextChanged() {
    final hasText = _controller.text.isNotEmpty;
    if (_showClearButton != hasText) {
      setState(() {
        _showClearButton = hasText;
      });
    }
    widget.onChanged?.call(_controller.text);
  }
  void _onClear() {
    _controller.clear();
    widget.onClear?.call();
    widget.onChanged?.call('');
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Colors.grey[300]!,
          width: 1,
        ),
      ),
      child: TextField(
        controller: _controller,
        enabled: widget.enabled,
        autofocus: widget.autofocus,
        textInputAction: widget.textInputAction,
        onSubmitted: widget.onSubmitted,
        decoration: InputDecoration(
          hintText: widget.hintText ?? 'Search...',
          hintStyle: TextStyle(
            color: Colors.grey[500],
            fontSize: 16,
          ),
          prefixIcon: widget.prefixIcon ??
              Icon(
                Icons.search,
                color: Colors.grey[500],
                size: 20,
              ),
          suffixIcon: _buildSuffixIcon(),
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
        style: const TextStyle(
          fontSize: 16,
        ),
      ),
    );
  }
  Widget? _buildSuffixIcon() {
    if (widget.suffixIcon != null) {
      return widget.suffixIcon;
    }
    if (_showClearButton) {
      return IconButton(
        onPressed: _onClear,
        icon: Icon(
          Icons.clear,
          color: Colors.grey[500],
          size: 20,
        ),
        constraints: const BoxConstraints(
          minWidth: 32,
          minHeight: 32,
        ),
        padding: EdgeInsets.zero,
      );
    }
    return null;
  }
}
</file>

<file path="frontend/lib/core/widgets/custom_text_field.dart">
/**
 * Reusable custom text field widgets for consistent form styling across the app
 * Provides various input types with validation and customization options
 */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
/**
 * Primary custom text field with validation support
 */
class CustomTextField extends StatefulWidget {
  final String? label;
  final String? hint;
  final String? initialValue;
  final TextEditingController? controller;
  final String? Function(String?)? validator;
  final void Function(String)? onChanged;
  final void Function(String)? onSubmitted;
  final VoidCallback? onTap;
  final TextInputType? keyboardType;
  final TextInputAction? textInputAction;
  final bool obscureText;
  final bool readOnly;
  final bool enabled;
  final int? maxLines;
  final int? minLines;
  final int? maxLength;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final String? prefixText;
  final String? suffixText;
  final List<TextInputFormatter>? inputFormatters;
  final FocusNode? focusNode;
  final EdgeInsets? contentPadding;
  final TextStyle? textStyle;
  final TextStyle? labelStyle;
  final TextStyle? hintStyle;
  final Color? fillColor;
  final Color? borderColor;
  final double? borderRadius;
  final bool filled;
  const CustomTextField({
    super.key,
    this.label,
    this.hint,
    this.initialValue,
    this.controller,
    this.validator,
    this.onChanged,
    this.onSubmitted,
    this.onTap,
    this.keyboardType,
    this.textInputAction,
    this.obscureText = false,
    this.readOnly = false,
    this.enabled = true,
    this.maxLines = 1,
    this.minLines,
    this.maxLength,
    this.prefixIcon,
    this.suffixIcon,
    this.prefixText,
    this.suffixText,
    this.inputFormatters,
    this.focusNode,
    this.contentPadding,
    this.textStyle,
    this.labelStyle,
    this.hintStyle,
    this.fillColor,
    this.borderColor,
    this.borderRadius,
    this.filled = true,
  });
  @override
  State<CustomTextField> createState() => _CustomTextFieldState();
}
class _CustomTextFieldState extends State<CustomTextField> {
  late TextEditingController _controller;
  bool _obscureText = false;
  @override
  void initState() {
    super.initState();
    _controller = widget.controller ?? TextEditingController(text: widget.initialValue);
    _obscureText = widget.obscureText;
  }
  @override
  void dispose() {
    if (widget.controller == null) {
      _controller.dispose();
    }
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return TextFormField(
      controller: _controller,
      validator: widget.validator,
      onChanged: widget.onChanged,
      onFieldSubmitted: widget.onSubmitted,
      onTap: widget.onTap,
      keyboardType: widget.keyboardType,
      textInputAction: widget.textInputAction,
      obscureText: _obscureText,
      readOnly: widget.readOnly,
      enabled: widget.enabled,
      maxLines: widget.obscureText ? 1 : widget.maxLines,
      minLines: widget.minLines,
      maxLength: widget.maxLength,
      inputFormatters: widget.inputFormatters,
      focusNode: widget.focusNode,
      style: widget.textStyle ?? theme.textTheme.bodyLarge,
      decoration: InputDecoration(
        labelText: widget.label,
        hintText: widget.hint,
        prefixIcon: widget.prefixIcon,
        suffixIcon: widget.obscureText
            ? IconButton(
                icon: Icon(
                  _obscureText ? Icons.visibility : Icons.visibility_off,
                  color: colorScheme.onSurfaceVariant,
                ),
                onPressed: () {
                  setState(() {
                    _obscureText = !_obscureText;
                  });
                },
              )
            : widget.suffixIcon,
        prefixText: widget.prefixText,
        suffixText: widget.suffixText,
        contentPadding: widget.contentPadding ??
            const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        filled: widget.filled,
        fillColor: widget.fillColor ?? colorScheme.surfaceVariant.withValues(alpha: 0.3),
        labelStyle: widget.labelStyle ?? theme.textTheme.bodyMedium?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
        hintStyle: widget.hintStyle ?? theme.textTheme.bodyMedium?.copyWith(
          color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),
        ),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: widget.borderColor ?? colorScheme.outline,
          ),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: widget.borderColor ?? colorScheme.outline.withValues(alpha: 0.5),
          ),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: widget.borderColor ?? colorScheme.primary,
            width: 2,
          ),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: colorScheme.error,
          ),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: colorScheme.error,
            width: 2,
          ),
        ),
        disabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(widget.borderRadius ?? 8),
          borderSide: BorderSide(
            color: colorScheme.outline.withValues(alpha: 0.3),
          ),
        ),
      ),
    );
  }
}
/**
 * Search text field variant
 */
class SearchTextField extends StatelessWidget {
  final String? hint;
  final TextEditingController? controller;
  final void Function(String)? onChanged;
  final void Function(String)? onSubmitted;
  final VoidCallback? onClear;
  final bool showClearButton;
  final EdgeInsets? margin;
  const SearchTextField({
    super.key,
    this.hint,
    this.controller,
    this.onChanged,
    this.onSubmitted,
    this.onClear,
    this.showClearButton = true,
    this.margin,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Container(
      margin: margin,
      child: CustomTextField(
        hint: hint ?? 'Search...',
        controller: controller,
        onChanged: onChanged,
        onSubmitted: onSubmitted,
        keyboardType: TextInputType.text,
        textInputAction: TextInputAction.search,
        prefixIcon: Icon(
          Icons.search,
          color: colorScheme.onSurfaceVariant,
        ),
        suffixIcon: showClearButton && controller?.text.isNotEmpty == true
            ? IconButton(
                icon: Icon(
                  Icons.clear,
                  color: colorScheme.onSurfaceVariant,
                ),
                onPressed: () {
                  controller?.clear();
                  onClear?.call();
                },
              )
            : null,
        borderRadius: 24,
        contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
      ),
    );
  }
}
/**
 * Multiline text field for longer content
 */
class MultilineTextField extends StatelessWidget {
  final String? label;
  final String? hint;
  final TextEditingController? controller;
  final String? Function(String?)? validator;
  final void Function(String)? onChanged;
  final int maxLines;
  final int? maxLength;
  final bool enabled;
  const MultilineTextField({
    super.key,
    this.label,
    this.hint,
    this.controller,
    this.validator,
    this.onChanged,
    this.maxLines = 5,
    this.maxLength,
    this.enabled = true,
  });
  @override
  Widget build(BuildContext context) {
    return CustomTextField(
      label: label,
      hint: hint,
      controller: controller,
      validator: validator,
      onChanged: onChanged,
      maxLines: maxLines,
      minLines: 3,
      maxLength: maxLength,
      enabled: enabled,
      keyboardType: TextInputType.multiline,
      textInputAction: TextInputAction.newline,
      contentPadding: const EdgeInsets.all(16),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/presentation/screens/login_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/features/auth/providers/auth_provider.dart';
import 'package:plant_social/features/auth/presentation/widgets/auth_text_field.dart';
import 'package:plant_social/features/auth/presentation/widgets/auth_button.dart';
import 'package:plant_social/core/exceptions/api_exception.dart';
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});
  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}
class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;
  bool _rememberMe = false;
  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;
    try {
      await ref.read(authProvider.notifier).login(
        _emailController.text.trim(),
        _passwordController.text,
      );
      if (mounted) {
        context.go(AppRoutes.home);
      }
    } on ApiException catch (e) {
      if (mounted) {
        _showErrorSnackBar(e.message);
      }
    } catch (e) {
      if (mounted) {
        _showErrorSnackBar('An unexpected error occurred. Please try again.');
      }
    }
  }
  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Theme.of(context).colorScheme.error,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Email is required';
    }
    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
      return 'Please enter a valid email address';
    }
    return null;
  }
  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Password is required';
    }
    return null;
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authState = ref.watch(authProvider);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 40),
                // Logo and Welcome Text
                Center(
                  child: Column(
                    children: [
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: theme.colorScheme.primary,
                          borderRadius: BorderRadius.circular(20),
                        ),
                        child: Icon(
                          Icons.eco,
                          size: 40,
                          color: theme.colorScheme.onPrimary,
                        ),
                      ),
                      const SizedBox(height: 24),
                      Text(
                        'Welcome Back',
                        style: theme.textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.onSurface,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Sign in to continue growing with your plant community',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 48),
                // Email Field
                AuthTextField(
                  controller: _emailController,
                  label: 'Email',
                  hintText: 'Enter your email',
                  keyboardType: TextInputType.emailAddress,
                  prefixIcon: Icons.email_outlined,
                  validator: _validateEmail,
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 16),
                // Password Field
                AuthTextField(
                  controller: _passwordController,
                  label: 'Password',
                  hintText: 'Enter your password',
                  obscureText: _obscurePassword,
                  prefixIcon: Icons.lock_outlined,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                  validator: _validatePassword,
                  textInputAction: TextInputAction.done,
                  onSubmitted: (_) => _handleLogin(),
                ),
                const SizedBox(height: 16),
                // Remember Me and Forgot Password
                Row(
                  children: [
                    Checkbox(
                      value: _rememberMe,
                      onChanged: (value) {
                        setState(() {
                          _rememberMe = value ?? false;
                        });
                      },
                    ),
                    Text(
                      'Remember me',
                      style: theme.textTheme.bodyMedium,
                    ),
                    const Spacer(),
                    TextButton(
                      onPressed: () {
                        // TODO: Navigate to forgot password screen
                        _showErrorSnackBar('Forgot password feature coming soon!');
                      },
                      child: Text(
                        'Forgot Password?',
                        style: TextStyle(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 32),
                // Login Button
                AuthButton(
                  text: 'Sign In',
                  onPressed: authState.isLoading ? null : _handleLogin,
                  isLoading: authState.isLoading,
                ),
                const SizedBox(height: 24),
                // Divider
                Row(
                  children: [
                    Expanded(
                      child: Divider(
                        color: theme.colorScheme.outline.withOpacity(0.3),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: Text(
                        'OR',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ),
                    Expanded(
                      child: Divider(
                        color: theme.colorScheme.outline.withOpacity(0.3),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                // Social Login Buttons (Placeholder)
                OutlinedButton.icon(
                  onPressed: () {
                    _showErrorSnackBar('Social login coming soon!');
                  },
                  icon: const Icon(Icons.g_mobiledata, size: 24),
                  label: const Text('Continue with Google'),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    side: BorderSide(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                    ),
                  ),
                ),
                const SizedBox(height: 32),
                // Sign Up Link
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      'Don\'t have an account? ',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                    ),
                    TextButton(
                      onPressed: () {
                        context.go(AppRoutes.register);
                      },
                      child: Text(
                        'Sign Up',
                        style: TextStyle(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/presentation/screens/register_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/features/auth/providers/auth_provider.dart';
import 'package:plant_social/features/auth/models/auth_models.dart';
import 'package:plant_social/features/auth/presentation/widgets/auth_text_field.dart';
import 'package:plant_social/features/auth/presentation/widgets/auth_button.dart';
import 'package:plant_social/core/exceptions/api_exception.dart';
class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});
  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}
class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _usernameController = TextEditingController();
  final _displayNameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _acceptTerms = false;
  @override
  void dispose() {
    _emailController.dispose();
    _usernameController.dispose();
    _displayNameController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }
  Future<void> _handleRegister() async {
    if (!_formKey.currentState!.validate()) return;
    if (!_acceptTerms) {
      _showErrorSnackBar('Please accept the Terms of Service and Privacy Policy');
      return;
    }
    try {
      final request = RegisterRequest(
        email: _emailController.text.trim(),
        username: _usernameController.text.trim(),
        password: _passwordController.text,
        confirmPassword: _confirmPasswordController.text,
        displayName: _displayNameController.text.trim().isNotEmpty 
            ? _displayNameController.text.trim() 
            : null,
      );
      await ref.read(authProvider.notifier).register(request);
      if (mounted) {
        context.go(AppRoutes.home);
      }
    } on ApiException catch (e) {
      if (mounted) {
        _showErrorSnackBar(e.message);
      }
    } catch (e) {
      if (mounted) {
        _showErrorSnackBar('An unexpected error occurred. Please try again.');
      }
    }
  }
  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Theme.of(context).colorScheme.error,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  String? _validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Email is required';
    }
    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
      return 'Please enter a valid email address';
    }
    return null;
  }
  String? _validateUsername(String? value) {
    if (value == null || value.isEmpty) {
      return 'Username is required';
    }
    if (!RegExp(r'^[a-zA-Z0-9_]{3,30}$').hasMatch(value)) {
      return 'Username must be 3-30 characters and contain only letters, numbers, and underscores';
    }
    return null;
  }
  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Password is required';
    }
    if (value.length < 8) {
      return 'Password must be at least 8 characters';
    }
    if (!RegExp(r'^(?=.*[A-Za-z])(?=.*\d)').hasMatch(value)) {
      return 'Password must contain at least one letter and one number';
    }
    return null;
  }
  String? _validateConfirmPassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please confirm your password';
    }
    if (value != _passwordController.text) {
      return 'Passwords do not match';
    }
    return null;
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authState = ref.watch(authProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Register'),
        leading: IconButton(
          onPressed: () => context.go(AppRoutes.login),
          icon: const Icon(Icons.arrow_back),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Center(
                  child: Column(
                    children: [
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: theme.colorScheme.primary,
                          borderRadius: BorderRadius.circular(20),
                        ),
                        child: Icon(
                          Icons.eco,
                          size: 40,
                          color: theme.colorScheme.onPrimary,
                        ),
                      ),
                      const SizedBox(height: 24),
                      Text(
                        'Join Plant Social',
                        style: theme.textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.onSurface,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Create your account and start your plant journey',
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 32),
                // Email Field
                AuthTextField(
                  controller: _emailController,
                  label: 'Email',
                  hintText: 'Enter your email',
                  keyboardType: TextInputType.emailAddress,
                  prefixIcon: Icons.email_outlined,
                  validator: _validateEmail,
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 16),
                // Username Field
                AuthTextField(
                  controller: _usernameController,
                  label: 'Username',
                  hintText: 'Choose a username',
                  prefixIcon: Icons.person_outlined,
                  validator: _validateUsername,
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 16),
                // Display Name Field (Optional)
                AuthTextField(
                  controller: _displayNameController,
                  label: 'Display Name (Optional)',
                  hintText: 'Enter your display name',
                  prefixIcon: Icons.badge_outlined,
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 16),
                // Password Field
                AuthTextField(
                  controller: _passwordController,
                  label: 'Password',
                  hintText: 'Create a password',
                  obscureText: _obscurePassword,
                  prefixIcon: Icons.lock_outlined,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscurePassword = !_obscurePassword;
                      });
                    },
                  ),
                  validator: _validatePassword,
                  textInputAction: TextInputAction.next,
                ),
                const SizedBox(height: 16),
                // Confirm Password Field
                AuthTextField(
                  controller: _confirmPasswordController,
                  label: 'Confirm Password',
                  hintText: 'Confirm your password',
                  obscureText: _obscureConfirmPassword,
                  prefixIcon: Icons.lock_outlined,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscureConfirmPassword ? Icons.visibility_outlined : Icons.visibility_off_outlined,
                    ),
                    onPressed: () {
                      setState(() {
                        _obscureConfirmPassword = !_obscureConfirmPassword;
                      });
                    },
                  ),
                  validator: _validateConfirmPassword,
                  textInputAction: TextInputAction.done,
                  onSubmitted: (_) => _handleRegister(),
                ),
                const SizedBox(height: 24),
                // Terms and Conditions
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Checkbox(
                      value: _acceptTerms,
                      onChanged: (value) {
                        setState(() {
                          _acceptTerms = value ?? false;
                        });
                      },
                    ),
                    Expanded(
                      child: Padding(
                        padding: const EdgeInsets.only(top: 12),
                        child: RichText(
                          text: TextSpan(
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurface.withOpacity(0.7),
                            ),
                            children: [
                              const TextSpan(text: 'I agree to the '),
                              TextSpan(
                                text: 'Terms of Service',
                                style: TextStyle(
                                  color: theme.colorScheme.primary,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              const TextSpan(text: ' and '),
                              TextSpan(
                                text: 'Privacy Policy',
                                style: TextStyle(
                                  color: theme.colorScheme.primary,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 32),
                // Register Button
                AuthButton(
                  text: 'Create Account',
                  onPressed: authState.isLoading ? null : _handleRegister,
                  isLoading: authState.isLoading,
                ),
                const SizedBox(height: 24),
                // Sign In Link
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      'Already have an account? ',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                    ),
                    TextButton(
                      onPressed: () {
                        context.go(AppRoutes.login);
                      },
                      child: Text(
                        'Sign In',
                        style: TextStyle(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/presentation/screens/splash_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/features/auth/providers/auth_provider.dart';
class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});
  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}
class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _checkAuthStatus();
  }
  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.6, curve: Curves.easeIn),
    ));
    _scaleAnimation = Tween<double>(
      begin: 0.8,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.2, 0.8, curve: Curves.elasticOut),
    ));
    _animationController.forward();
  }
  void _checkAuthStatus() {
    // Listen to auth state changes
    ref.listen<AuthState>(authProvider, (previous, next) {
      if (next.isInitialized) {
        _navigateToNextScreen(next.isAuthenticated);
      }
    });
  }
  void _navigateToNextScreen(bool isAuthenticated) {
    Future.delayed(const Duration(milliseconds: 1500), () {
      if (mounted) {
        if (isAuthenticated) {
          context.go(AppRoutes.home);
        } else {
          context.go(AppRoutes.login);
        }
      }
    });
  }
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.colorScheme.primary,
      body: Center(
        child: AnimatedBuilder(
          animation: _animationController,
          builder: (context, child) {
            return FadeTransition(
              opacity: _fadeAnimation,
              child: ScaleTransition(
                scale: _scaleAnimation,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // App Logo
                    Container(
                      width: 120,
                      height: 120,
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(30),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.1),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                        ],
                      ),
                      child: const Icon(
                        Icons.eco,
                        size: 60,
                        color: Color(0xFF2E7D32),
                      ),
                    ),
                    const SizedBox(height: 32),
                    // App Name
                    Text(
                      'Plant Social',
                      style: theme.textTheme.headlineLarge?.copyWith(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        letterSpacing: 1.2,
                      ),
                    ),
                    const SizedBox(height: 8),
                    // Tagline
                    Text(
                      'Grow Together',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: Colors.white.withOpacity(0.9),
                        letterSpacing: 0.5,
                      ),
                    ),
                    const SizedBox(height: 64),
                    // Loading Indicator
                    SizedBox(
                      width: 40,
                      height: 40,
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(
                          Colors.white.withOpacity(0.8),
                        ),
                        strokeWidth: 3,
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/presentation/widgets/auth_text_field.dart">
import 'package:flutter/material.dart';
class AuthTextField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String? hintText;
  final bool obscureText;
  final TextInputType? keyboardType;
  final IconData? prefixIcon;
  final Widget? suffixIcon;
  final String? Function(String?)? validator;
  final TextInputAction? textInputAction;
  final void Function(String)? onSubmitted;
  final void Function(String)? onChanged;
  final bool enabled;
  final int? maxLines;
  final int? minLines;
  final FocusNode? focusNode;
  final bool autofocus;
  const AuthTextField({
    super.key,
    required this.controller,
    required this.label,
    this.hintText,
    this.obscureText = false,
    this.keyboardType,
    this.prefixIcon,
    this.suffixIcon,
    this.validator,
    this.textInputAction,
    this.onSubmitted,
    this.onChanged,
    this.enabled = true,
    this.maxLines = 1,
    this.minLines,
    this.focusNode,
    this.autofocus = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: theme.textTheme.labelMedium?.copyWith(
            fontWeight: FontWeight.w500,
            color: theme.colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 8),
        TextFormField(
          controller: controller,
          obscureText: obscureText,
          keyboardType: keyboardType,
          textInputAction: textInputAction,
          validator: validator,
          onFieldSubmitted: onSubmitted,
          onChanged: onChanged,
          enabled: enabled,
          maxLines: maxLines,
          minLines: minLines,
          focusNode: focusNode,
          autofocus: autofocus,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: theme.colorScheme.onSurface,
          ),
          decoration: InputDecoration(
            hintText: hintText,
            hintStyle: theme.textTheme.bodyLarge?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.5),
            ),
            prefixIcon: prefixIcon != null
                ? Icon(
                    prefixIcon,
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  )
                : null,
            suffixIcon: suffixIcon,
            filled: true,
            fillColor: theme.colorScheme.surface,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.3),
                width: 1,
              ),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.3),
                width: 1,
              ),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              ),
            ),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.error,
                width: 1,
              ),
            ),
            focusedErrorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.error,
                width: 2,
              ),
            ),
            disabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.2),
                width: 1,
              ),
            ),
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 16,
              vertical: 16,
            ),
            errorStyle: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.error,
            ),
          ),
        ),
      ],
    );
  }
}
</file>

<file path="frontend/lib/features/auth/repositories/auth_repository.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/core/models/user.dart';
import 'package:plant_social/core/network/api_client.dart';
import 'package:plant_social/features/auth/models/auth_models.dart';
abstract class AuthRepository {
  Future<AuthResponse> login(LoginRequest request);
  Future<AuthResponse> register(RegisterRequest request);
  Future<void> logout();
  Future<AuthResponse> refreshToken(String refreshToken);
  Future<User> getCurrentUser();
  Future<MessageResponse> forgotPassword(String email);
  Future<MessageResponse> resetPassword(String token, String newPassword);
  Future<MessageResponse> changePassword(String currentPassword, String newPassword);
}
class AuthRepositoryImpl implements AuthRepository {
  final ApiClient _apiClient;
  AuthRepositoryImpl(this._apiClient);
  @override
  Future<AuthResponse> login(LoginRequest request) async {
    try {
      final response = await _apiClient.post(
        '/auth/login',
        data: request.toJson(),
      );
      return AuthResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<AuthResponse> register(RegisterRequest request) async {
    try {
      final response = await _apiClient.post(
        '/auth/register',
        data: request.toJson(),
      );
      return AuthResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<void> logout() async {
    try {
      await _apiClient.post('/auth/logout');
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<AuthResponse> refreshToken(String refreshToken) async {
    try {
      final request = RefreshTokenRequest(refreshToken: refreshToken);
      final response = await _apiClient.post(
        '/auth/refresh',
        data: request.toJson(),
      );
      return AuthResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<User> getCurrentUser() async {
    try {
      final response = await _apiClient.get('/auth/me');
      return User.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<MessageResponse> forgotPassword(String email) async {
    try {
      final request = ForgotPasswordRequest(email: email);
      final response = await _apiClient.post(
        '/auth/forgot-password',
        data: request.toJson(),
      );
      return MessageResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<MessageResponse> resetPassword(String token, String newPassword) async {
    try {
      final request = ResetPasswordRequest(
        token: token,
        newPassword: newPassword,
        confirmPassword: newPassword,
      );
      final response = await _apiClient.post(
        '/auth/reset-password',
        data: request.toJson(),
      );
      return MessageResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
  @override
  Future<MessageResponse> changePassword(String currentPassword, String newPassword) async {
    try {
      final request = ChangePasswordRequest(
        currentPassword: currentPassword,
        newPassword: newPassword,
        confirmPassword: newPassword,
      );
      final response = await _apiClient.post(
        '/auth/change-password',
        data: request.toJson(),
      );
      return MessageResponse.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }
}
// Provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepositoryImpl(apiClient);
});
</file>

<file path="frontend/lib/features/camera/presentation/screens/camera_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:camera/camera.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
/// Camera screen for capturing photos and videos
/// Implements basic camera functionality with permission handling
class CameraScreen extends ConsumerStatefulWidget {
  const CameraScreen({super.key});
  @override
  ConsumerState<CameraScreen> createState() => _CameraScreenState();
}
class _CameraScreenState extends ConsumerState<CameraScreen> {
  CameraController? _cameraController;
  List<CameraDescription>? _cameras;
  bool _isInitialized = false;
  bool _isLoading = true;
  String? _error;
  bool _isCapturing = false;
  int _selectedCameraIndex = 0;
  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }
  @override
  void dispose() {
    _cameraController?.dispose();
    super.dispose();
  }
  /// Initialize camera with permission checks
  Future<void> _initializeCamera() async {
    try {
      // Request camera permission
      final cameraPermission = await Permission.camera.request();
      if (cameraPermission != PermissionStatus.granted) {
        setState(() {
          _error = 'Camera permission is required to use this feature';
          _isLoading = false;
        });
        return;
      }
      // Get available cameras
      _cameras = await availableCameras();
      if (_cameras == null || _cameras!.isEmpty) {
        setState(() {
          _error = 'No cameras found on this device';
          _isLoading = false;
        });
        return;
      }
      // Initialize camera controller
      await _setupCamera(_selectedCameraIndex);
    } catch (e) {
      setState(() {
        _error = 'Failed to initialize camera: ${e.toString()}';
        _isLoading = false;
      });
    }
  }
  /// Setup camera controller for specified camera index
  Future<void> _setupCamera(int cameraIndex) async {
    if (_cameras == null || _cameras!.isEmpty) return;
    // Dispose existing controller
    await _cameraController?.dispose();
    // Create new controller
    _cameraController = CameraController(
      _cameras![cameraIndex],
      ResolutionPreset.high,
      enableAudio: false,
    );
    try {
      await _cameraController!.initialize();
      if (mounted) {
        setState(() {
          _isInitialized = true;
          _isLoading = false;
          _error = null;
        });
      }
    } catch (e) {
      setState(() {
        _error = 'Failed to initialize camera: ${e.toString()}';
        _isLoading = false;
      });
    }
  }
  /// Switch between front and back cameras
  Future<void> _switchCamera() async {
    if (_cameras == null || _cameras!.length < 2) return;
    setState(() {
      _selectedCameraIndex = _selectedCameraIndex == 0 ? 1 : 0;
      _isLoading = true;
    });
    await _setupCamera(_selectedCameraIndex);
  }
  /// Capture photo
  Future<void> _capturePhoto() async {
    if (_cameraController == null || !_cameraController!.value.isInitialized) {
      return;
    }
    if (_isCapturing) return;
    try {
      setState(() {
        _isCapturing = true;
      });
      final XFile photo = await _cameraController!.takePicture();
      if (mounted) {
        // Navigate to story creation with captured image
        context.push(
          '${AppRoutes.storyCreation}?imagePath=${photo.path}',
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to capture photo: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      setState(() {
        _isCapturing = false;
      });
    }
  }
  /// Request camera permission
  Future<void> _requestPermission() async {
    final permission = await Permission.camera.request();
    if (permission == PermissionStatus.granted) {
      _initializeCamera();
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          onPressed: () => context.pop(),
          icon: const Icon(Icons.close, color: Colors.white),
        ),
        actions: [
          if (_cameras != null && _cameras!.length > 1)
            IconButton(
              onPressed: _isLoading ? null : _switchCamera,
              icon: const Icon(Icons.flip_camera_ios, color: Colors.white),
            ),
        ],
      ),
      body: _buildBody(theme),
    );
  }
  Widget _buildBody(ThemeData theme) {
    if (_isLoading) {
      return const Center(
        child: CircularProgressIndicator(color: Colors.white),
      );
    }
    if (_error != null) {
      return _buildErrorState(theme);
    }
    if (!_isInitialized || _cameraController == null) {
      return const Center(
        child: Text(
          'Camera not available',
          style: TextStyle(color: Colors.white),
        ),
      );
    }
    return Stack(
      children: [
        // Camera preview
        Positioned.fill(
          child: CameraPreview(_cameraController!),
        ),
        // Camera controls
        Positioned(
          bottom: 0,
          left: 0,
          right: 0,
          child: _buildCameraControls(theme),
        ),
      ],
    );
  }
  Widget _buildErrorState(ThemeData theme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.camera_alt_outlined,
              size: 64,
              color: Colors.white,
            ),
            const SizedBox(height: 16),
            Text(
              'Camera Error',
              style: theme.textTheme.headlineSmall?.copyWith(
                color: Colors.white,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _error!,
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: Colors.white70,
              ),
            ),
            const SizedBox(height: 24),
            if (_error!.contains('permission'))
              ElevatedButton(
                onPressed: _requestPermission,
                child: const Text('Grant Permission'),
              )
            else
              ElevatedButton(
                onPressed: _initializeCamera,
                child: const Text('Retry'),
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildCameraControls(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(24.0),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.bottomCenter,
          end: Alignment.topCenter,
          colors: [
            Colors.black.withOpacity(0.8),
            Colors.transparent,
          ],
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          // Gallery button placeholder
          Container(
            width: 56,
            height: 56,
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.2),
              borderRadius: BorderRadius.circular(28),
            ),
            child: const Icon(
              Icons.photo_library,
              color: Colors.white,
            ),
          ),
          // Capture button
          GestureDetector(
            onTap: _isCapturing ? null : _capturePhoto,
            child: Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                color: _isCapturing 
                    ? Colors.grey 
                    : Colors.white,
                borderRadius: BorderRadius.circular(40),
                border: Border.all(
                  color: Colors.white,
                  width: 4,
                ),
              ),
              child: _isCapturing
                  ? const Center(
                      child: CircularProgressIndicator(
                        color: Colors.black,
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(
                      Icons.camera_alt,
                      color: Colors.black,
                      size: 32,
                    ),
            ),
          ),
          // Settings button placeholder
          Container(
            width: 56,
            height: 56,
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.2),
              borderRadius: BorderRadius.circular(28),
            ),
            child: const Icon(
              Icons.settings,
              color: Colors.white,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/chat/presentation/screens/chat_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
/// Chat screen showing list of conversations
/// Displays recent conversations and allows starting new chats
class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({super.key});
  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}
class _ChatScreenState extends ConsumerState<ChatScreen> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
  /// Mock conversation data for demonstration
  List<MockConversation> get _mockConversations => [
    MockConversation(
      userId: '1',
      userName: 'Alice Green',
      lastMessage: 'Check out my new succulent! ',
      timestamp: DateTime.now().subtract(const Duration(minutes: 5)),
      unreadCount: 2,
      isOnline: true,
    ),
    MockConversation(
      userId: '2',
      userName: 'Bob Plant',
      lastMessage: 'Thanks for the watering tips!',
      timestamp: DateTime.now().subtract(const Duration(hours: 2)),
      unreadCount: 0,
      isOnline: false,
    ),
    MockConversation(
      userId: '3',
      userName: 'Carol Flowers',
      lastMessage: 'My roses are blooming beautifully ',
      timestamp: DateTime.now().subtract(const Duration(days: 1)),
      unreadCount: 1,
      isOnline: true,
    ),
    MockConversation(
      userId: '4',
      userName: 'David Herbs',
      lastMessage: 'Let\'s plan that garden visit!',
      timestamp: DateTime.now().subtract(const Duration(days: 2)),
      unreadCount: 0,
      isOnline: false,
    ),
  ];
  List<MockConversation> get _filteredConversations {
    if (_searchQuery.isEmpty) return _mockConversations;
    return _mockConversations.where((conversation) {
      return conversation.userName.toLowerCase().contains(_searchQuery.toLowerCase()) ||
             conversation.lastMessage.toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      appBar: AppBar(
        title: const Text('Messages'),
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
        actions: [
          IconButton(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('New chat feature coming soon!'),
                ),
              );
            },
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'New Chat',
          ),
        ],
      ),
      body: Column(
        children: [
          // Search bar
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: TextField(
              controller: _searchController,
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
              decoration: InputDecoration(
                hintText: 'Search conversations...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchQuery.isNotEmpty
                    ? IconButton(
                        onPressed: () {
                          _searchController.clear();
                          setState(() {
                            _searchQuery = '';
                          });
                        },
                        icon: const Icon(Icons.clear),
                      )
                    : null,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: theme.colorScheme.surfaceVariant.withOpacity(0.5),
              ),
            ),
          ),
          // Conversations list
          Expanded(
            child: _filteredConversations.isEmpty
                ? _buildEmptyState(theme)
                : ListView.builder(
                    itemCount: _filteredConversations.length,
                    itemBuilder: (context, index) {
                      final conversation = _filteredConversations[index];
                      return _buildConversationTile(conversation, theme);
                    },
                  ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Start new conversation feature coming soon!'),
            ),
          );
        },
        child: const Icon(Icons.chat_bubble_outline),
      ),
    );
  }
  Widget _buildEmptyState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.chat_bubble_outline,
            size: 64,
            color: theme.colorScheme.onSurface.withOpacity(0.5),
          ),
          const SizedBox(height: 16),
          Text(
            _searchQuery.isNotEmpty ? 'No conversations found' : 'No messages yet',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.7),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            _searchQuery.isNotEmpty 
                ? 'Try searching with different keywords'
                : 'Start chatting with your plant friends!',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.5),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildConversationTile(MockConversation conversation, ThemeData theme) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      leading: Stack(
        children: [
          CircleAvatar(
            radius: 28,
            backgroundColor: theme.colorScheme.primary,
            child: Text(
              conversation.userName.split(' ').map((name) => name[0]).join(),
              style: TextStyle(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          if (conversation.isOnline)
            Positioned(
              bottom: 0,
              right: 0,
              child: Container(
                width: 16,
                height: 16,
                decoration: BoxDecoration(
                  color: Colors.green,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.colorScheme.surface,
                    width: 2,
                  ),
                ),
              ),
            ),
        ],
      ),
      title: Row(
        children: [
          Expanded(
            child: Text(
              conversation.userName,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: conversation.unreadCount > 0 
                    ? FontWeight.bold 
                    : FontWeight.normal,
              ),
            ),
          ),
          Text(
            _formatTimestamp(conversation.timestamp),
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.6),
            ),
          ),
        ],
      ),
      subtitle: Row(
        children: [
          Expanded(
            child: Text(
              conversation.lastMessage,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: conversation.unreadCount > 0
                    ? theme.colorScheme.onSurface
                    : theme.colorScheme.onSurface.withOpacity(0.7),
                fontWeight: conversation.unreadCount > 0 
                    ? FontWeight.w500 
                    : FontWeight.normal,
              ),
            ),
          ),
          if (conversation.unreadCount > 0)
            Container(
              margin: const EdgeInsets.only(left: 8),
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: theme.colorScheme.primary,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                conversation.unreadCount.toString(),
                style: TextStyle(
                  color: theme.colorScheme.onPrimary,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),
      onTap: () {
        context.push(
          '${AppRoutes.conversation}/${conversation.userId}?userName=${conversation.userName}',
        );
      },
    );
  }
  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d';
    } else {
      return '${timestamp.day}/${timestamp.month}';
    }
  }
}
/// Mock conversation model for demonstration
class MockConversation {
  final String userId;
  final String userName;
  final String lastMessage;
  final DateTime timestamp;
  final int unreadCount;
  final bool isOnline;
  MockConversation({
    required this.userId,
    required this.userName,
    required this.lastMessage,
    required this.timestamp,
    required this.unreadCount,
    required this.isOnline,
  });
}
</file>

<file path="frontend/lib/features/friends/presentation/widgets/friend_suggestions.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
class FriendSuggestions extends ConsumerWidget {
  const FriendSuggestions({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Suggested Friends',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurface,
                ),
              ),
              TextButton(
                onPressed: () {
                  context.go(AppRoutes.friends);
                },
                child: Text(
                  'See All',
                  style: TextStyle(
                    color: theme.colorScheme.primary,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          // Horizontal scrollable suggestions
          SizedBox(
            height: 200,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: _getSampleSuggestions().length,
              itemBuilder: (context, index) {
                final suggestion = _getSampleSuggestions()[index];
                return Padding(
                  padding: EdgeInsets.only(
                    right: index < _getSampleSuggestions().length - 1 ? 12 : 0,
                  ),
                  child: _buildSuggestionCard(context, theme, suggestion),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildSuggestionCard(
    BuildContext context,
    ThemeData theme,
    Map<String, dynamic> suggestion,
  ) {
    return SizedBox(
      width: 160,
      child: Card(
        elevation: 2,
        shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              // Avatar
              CircleAvatar(
                radius: 32,
                backgroundColor: (suggestion['avatarColor'] as Color).withOpacity(0.2),
                child: Text(
                  suggestion['name'][0].toUpperCase(),
                  style: theme.textTheme.titleLarge?.copyWith(
                    color: suggestion['avatarColor'] as Color,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Name
              Text(
                suggestion['name'] as String,
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: theme.colorScheme.onSurface,
                ),
                textAlign: TextAlign.center,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),
              // Mutual friends or connection reason
              Text(
                suggestion['connection'] as String,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const Spacer(),
              // Action buttons
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        _handleIgnoreSuggestion(context, suggestion['name'] as String);
                      },
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        side: BorderSide(
                          color: theme.colorScheme.outline.withOpacity(0.5),
                        ),
                      ),
                      child: Text(
                        'Ignore',
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: () {
                        _handleAddFriend(context, suggestion['name'] as String);
                      },
                      style: ElevatedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        backgroundColor: theme.colorScheme.primary,
                        foregroundColor: theme.colorScheme.onPrimary,
                      ),
                      child: Text(
                        'Add',
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.onPrimary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  void _handleAddFriend(BuildContext context, String name) {
    // TODO: Implement add friend functionality
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Friend request sent to $name'),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  void _handleIgnoreSuggestion(BuildContext context, String name) {
    // TODO: Implement ignore suggestion functionality
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$name removed from suggestions'),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  List<Map<String, dynamic>> _getSampleSuggestions() {
    return [
      {
        'name': 'Emma Wilson',
        'connection': '3 mutual friends',
        'avatarColor': Colors.purple,
      },
      {
        'name': 'David Chen',
        'connection': 'Plant enthusiast',
        'avatarColor': Colors.orange,
      },
      {
        'name': 'Sarah Johnson',
        'connection': '2 mutual friends',
        'avatarColor': Colors.teal,
      },
      {
        'name': 'Mike Brown',
        'connection': 'Gardening expert',
        'avatarColor': Colors.indigo,
      },
      {
        'name': 'Lisa Garcia',
        'connection': '1 mutual friend',
        'avatarColor': Colors.red,
      },
    ];
  }
}
</file>

<file path="frontend/lib/features/home/presentation/widgets/bottom_nav_bar.dart">
import 'package:flutter/material.dart';
class BottomNavBar extends StatelessWidget {
  final int currentIndex;
  final ValueChanged<int> onTap;
  const BottomNavBar({
    super.key,
    required this.currentIndex,
    required this.onTap,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        boxShadow: [
          BoxShadow(
            color: theme.colorScheme.shadow.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildNavItem(
                context,
                theme,
                0,
                Icons.home_outlined,
                Icons.home,
                'Home',
              ),
              _buildNavItem(
                context,
                theme,
                1,
                Icons.camera_alt_outlined,
                Icons.camera_alt,
                'Camera',
              ),
              _buildNavItem(
                context,
                theme,
                2,
                Icons.chat_outlined,
                Icons.chat,
                'Chat',
              ),
              _buildNavItem(
                context,
                theme,
                3,
                Icons.auto_stories_outlined,
                Icons.auto_stories,
                'Stories',
              ),
              _buildNavItem(
                context,
                theme,
                4,
                Icons.person_outlined,
                Icons.person,
                'Profile',
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildNavItem(
    BuildContext context,
    ThemeData theme,
    int index,
    IconData outlinedIcon,
    IconData filledIcon,
    String label,
  ) {
    final isSelected = currentIndex == index;
    return GestureDetector(
      onTap: () => onTap(index),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primary.withOpacity(0.1)
              : Colors.transparent,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            AnimatedSwitcher(
              duration: const Duration(milliseconds: 200),
              child: Icon(
                isSelected ? filledIcon : outlinedIcon,
                key: ValueKey(isSelected),
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurface.withOpacity(0.6),
                size: 24,
              ),
            ),
            const SizedBox(height: 4),
            AnimatedDefaultTextStyle(
              duration: const Duration(milliseconds: 200),
              style: theme.textTheme.labelSmall!.copyWith(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurface.withOpacity(0.6),
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
              ),
              child: Text(label),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_care/models/plant_care_models.g.dart">
// GENERATED CODE - DO NOT MODIFY BY HAND
part of 'plant_care_models.dart';
// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************
PlantCareLog _$PlantCareLogFromJson(Map<String, dynamic> json) => PlantCareLog(
      id: json['id'] as String,
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      careDate: DateTime.parse(json['careDate'] as String),
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );
Map<String, dynamic> _$PlantCareLogToJson(PlantCareLog instance) =>
    <String, dynamic>{
      'id': instance.id,
      'userPlantId': instance.userPlantId,
      'careType': instance.careType,
      'careDate': instance.careDate.toIso8601String(),
      'notes': instance.notes,
      'imageUrl': instance.imageUrl,
      'metadata': instance.metadata,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };
PlantCareReminder _$PlantCareReminderFromJson(Map<String, dynamic> json) =>
    PlantCareReminder(
      id: json['id'] as String,
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      nextDueDate: DateTime.parse(json['nextDueDate'] as String),
      frequencyDays: (json['frequencyDays'] as num).toInt(),
      isActive: json['isActive'] as bool,
      notes: json['notes'] as String?,
      lastCompletedDate: json['lastCompletedDate'] == null
          ? null
          : DateTime.parse(json['lastCompletedDate'] as String),
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      plant: json['plant'] == null
          ? null
          : UserPlant.fromJson(json['plant'] as Map<String, dynamic>),
    );
Map<String, dynamic> _$PlantCareReminderToJson(PlantCareReminder instance) =>
    <String, dynamic>{
      'id': instance.id,
      'userPlantId': instance.userPlantId,
      'careType': instance.careType,
      'nextDueDate': instance.nextDueDate.toIso8601String(),
      'frequencyDays': instance.frequencyDays,
      'isActive': instance.isActive,
      'notes': instance.notes,
      'lastCompletedDate': instance.lastCompletedDate?.toIso8601String(),
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'plant': instance.plant,
    };
UserPlant _$UserPlantFromJson(Map<String, dynamic> json) => UserPlant(
      id: json['id'] as String,
      userId: json['userId'] as String,
      speciesId: json['speciesId'] as String,
      nickname: json['nickname'] as String,
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      acquiredDate: DateTime.parse(json['acquiredDate'] as String),
      location: json['location'] as String?,
      customCareSchedule: json['customCareSchedule'] as Map<String, dynamic>?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      species: json['species'] == null
          ? null
          : PlantSpecies.fromJson(json['species'] as Map<String, dynamic>),
      careLogs: (json['careLogs'] as List<dynamic>?)
          ?.map((e) => PlantCareLog.fromJson(e as Map<String, dynamic>))
          .toList(),
      reminders: (json['reminders'] as List<dynamic>?)
          ?.map((e) => PlantCareReminder.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
Map<String, dynamic> _$UserPlantToJson(UserPlant instance) => <String, dynamic>{
      'id': instance.id,
      'userId': instance.userId,
      'speciesId': instance.speciesId,
      'nickname': instance.nickname,
      'notes': instance.notes,
      'imageUrl': instance.imageUrl,
      'acquiredDate': instance.acquiredDate.toIso8601String(),
      'location': instance.location,
      'customCareSchedule': instance.customCareSchedule,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'species': instance.species,
      'careLogs': instance.careLogs,
      'reminders': instance.reminders,
    };
PlantSpecies _$PlantSpeciesFromJson(Map<String, dynamic> json) => PlantSpecies(
      id: json['id'] as String,
      commonName: json['commonName'] as String,
      scientificName: json['scientificName'] as String,
      family: json['family'] as String?,
      description: json['description'] as String?,
      imageUrl: json['imageUrl'] as String?,
      alternativeNames: (json['alternativeNames'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      nativeRegions: (json['nativeRegions'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      maxHeight: json['maxHeight'] as String?,
      bloomTime: json['bloomTime'] as String?,
      plantType: json['plantType'] as String?,
      careInfo: json['careInfo'] == null
          ? null
          : PlantCareInfo.fromJson(json['careInfo'] as Map<String, dynamic>),
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );
Map<String, dynamic> _$PlantSpeciesToJson(PlantSpecies instance) =>
    <String, dynamic>{
      'id': instance.id,
      'commonName': instance.commonName,
      'scientificName': instance.scientificName,
      'family': instance.family,
      'description': instance.description,
      'imageUrl': instance.imageUrl,
      'alternativeNames': instance.alternativeNames,
      'nativeRegions': instance.nativeRegions,
      'maxHeight': instance.maxHeight,
      'bloomTime': instance.bloomTime,
      'plantType': instance.plantType,
      'careInfo': instance.careInfo,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };
PlantCareInfo _$PlantCareInfoFromJson(Map<String, dynamic> json) =>
    PlantCareInfo(
      lightRequirement: json['lightRequirement'] as String,
      waterFrequency: json['waterFrequency'] as String,
      careLevel: json['careLevel'] as String,
      humidity: json['humidity'] as String?,
      temperature: json['temperature'] as String?,
      toxicity: json['toxicity'] as String?,
      fertilizer: json['fertilizer'] as String?,
      repotting: json['repotting'] as String?,
      pruning: json['pruning'] as String?,
      additionalCare: json['additionalCare'] as Map<String, dynamic>?,
    );
Map<String, dynamic> _$PlantCareInfoToJson(PlantCareInfo instance) =>
    <String, dynamic>{
      'lightRequirement': instance.lightRequirement,
      'waterFrequency': instance.waterFrequency,
      'careLevel': instance.careLevel,
      'humidity': instance.humidity,
      'temperature': instance.temperature,
      'toxicity': instance.toxicity,
      'fertilizer': instance.fertilizer,
      'repotting': instance.repotting,
      'pruning': instance.pruning,
      'additionalCare': instance.additionalCare,
    };
PlantCareRequest _$PlantCareRequestFromJson(Map<String, dynamic> json) =>
    PlantCareRequest(
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      careDate: DateTime.parse(json['careDate'] as String),
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
Map<String, dynamic> _$PlantCareRequestToJson(PlantCareRequest instance) =>
    <String, dynamic>{
      'userPlantId': instance.userPlantId,
      'careType': instance.careType,
      'careDate': instance.careDate.toIso8601String(),
      'notes': instance.notes,
      'imageUrl': instance.imageUrl,
      'metadata': instance.metadata,
    };
PlantCareReminderRequest _$PlantCareReminderRequestFromJson(
        Map<String, dynamic> json) =>
    PlantCareReminderRequest(
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      nextDueDate: DateTime.parse(json['nextDueDate'] as String),
      frequencyDays: (json['frequencyDays'] as num).toInt(),
      notes: json['notes'] as String?,
    );
Map<String, dynamic> _$PlantCareReminderRequestToJson(
        PlantCareReminderRequest instance) =>
    <String, dynamic>{
      'userPlantId': instance.userPlantId,
      'careType': instance.careType,
      'nextDueDate': instance.nextDueDate.toIso8601String(),
      'frequencyDays': instance.frequencyDays,
      'notes': instance.notes,
    };
UserPlantRequest _$UserPlantRequestFromJson(Map<String, dynamic> json) =>
    UserPlantRequest(
      speciesId: json['speciesId'] as String,
      nickname: json['nickname'] as String,
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      acquiredDate: DateTime.parse(json['acquiredDate'] as String),
      location: json['location'] as String?,
      customCareSchedule: json['customCareSchedule'] as Map<String, dynamic>?,
    );
Map<String, dynamic> _$UserPlantRequestToJson(UserPlantRequest instance) =>
    <String, dynamic>{
      'speciesId': instance.speciesId,
      'nickname': instance.nickname,
      'notes': instance.notes,
      'imageUrl': instance.imageUrl,
      'acquiredDate': instance.acquiredDate.toIso8601String(),
      'location': instance.location,
      'customCareSchedule': instance.customCareSchedule,
    };
PlantCareState _$PlantCareStateFromJson(Map<String, dynamic> json) =>
    PlantCareState(
      userPlants: (json['userPlants'] as List<dynamic>?)
              ?.map((e) => UserPlant.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      careLogs: (json['careLogs'] as List<dynamic>?)
              ?.map((e) => PlantCareLog.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      reminders: (json['reminders'] as List<dynamic>?)
              ?.map(
                  (e) => PlantCareReminder.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      upcomingReminders: (json['upcomingReminders'] as List<dynamic>?)
              ?.map(
                  (e) => PlantCareReminder.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      isLoading: json['isLoading'] as bool? ?? false,
      isLoadingPlants: json['isLoadingPlants'] as bool? ?? false,
      isLoadingLogs: json['isLoadingLogs'] as bool? ?? false,
      isLoadingReminders: json['isLoadingReminders'] as bool? ?? false,
      isCreating: json['isCreating'] as bool? ?? false,
      isUpdating: json['isUpdating'] as bool? ?? false,
      isDeleting: json['isDeleting'] as bool? ?? false,
      error: json['error'] as String?,
      createError: json['createError'] as String?,
      updateError: json['updateError'] as String?,
      deleteError: json['deleteError'] as String?,
    );
Map<String, dynamic> _$PlantCareStateToJson(PlantCareState instance) =>
    <String, dynamic>{
      'userPlants': instance.userPlants,
      'careLogs': instance.careLogs,
      'reminders': instance.reminders,
      'upcomingReminders': instance.upcomingReminders,
      'isLoading': instance.isLoading,
      'isLoadingPlants': instance.isLoadingPlants,
      'isLoadingLogs': instance.isLoadingLogs,
      'isLoadingReminders': instance.isLoadingReminders,
      'isCreating': instance.isCreating,
      'isUpdating': instance.isUpdating,
      'isDeleting': instance.isDeleting,
      'error': instance.error,
      'createError': instance.createError,
      'updateError': instance.updateError,
      'deleteError': instance.deleteError,
    };
</file>

<file path="frontend/lib/features/plant_care/presentation/screens/care_logs_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
/// Screen for viewing and managing plant care logs
class CareLogsScreen extends ConsumerStatefulWidget {
  const CareLogsScreen({super.key});
  @override
  ConsumerState<CareLogsScreen> createState() => _CareLogsScreenState();
}
class _CareLogsScreenState extends ConsumerState<CareLogsScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Care Logs'),
        backgroundColor: Colors.green[50],
        foregroundColor: Colors.green[800],
        elevation: 0,
      ),
      body: const Padding(
        padding: EdgeInsets.all(16.0),
        child: Column(
          children: [
            _CareLogsList(),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // TODO: Navigate to add care log screen
        },
        backgroundColor: Colors.green,
        child: const Icon(Icons.add),
      ),
    );
  }
}
/// Widget displaying the list of care logs
class _CareLogsList extends StatelessWidget {
  const _CareLogsList();
  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: ListView.builder(
        itemCount: 5, // Placeholder count
        itemBuilder: (context, index) {
          final careTypes = ['Watered', 'Fertilized', 'Pruned', 'Repotted', 'Checked'];
          final careType = careTypes[index % careTypes.length];
          final icons = {
            'Watered': Icons.water_drop,
            'Fertilized': Icons.eco,
            'Pruned': Icons.content_cut,
            'Repotted': Icons.local_florist,
            'Checked': Icons.visibility,
          };
          return Card(
            margin: const EdgeInsets.only(bottom: 12),
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: Colors.green[100],
                child: Icon(
                  icons[careType] ?? Icons.local_florist,
                  color: Colors.green[700],
                ),
              ),
              title: Text(careType),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Plant ${index + 1}'),
                  Text(
                    '${DateTime.now().subtract(Duration(days: index)).day}/${DateTime.now().month}/${DateTime.now().year}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
              trailing: IconButton(
                icon: const Icon(Icons.more_vert),
                onPressed: () {
                  // TODO: Show options menu
                },
              ),
            ),
          );
        },
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/screens/care_reminders_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
/// Screen for managing plant care reminders
class CareRemindersScreen extends ConsumerStatefulWidget {
  const CareRemindersScreen({super.key});
  @override
  ConsumerState<CareRemindersScreen> createState() => _CareRemindersScreenState();
}
class _CareRemindersScreenState extends ConsumerState<CareRemindersScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Care Reminders'),
        backgroundColor: Colors.green[50],
        foregroundColor: Colors.green[800],
        elevation: 0,
      ),
      body: const Padding(
        padding: EdgeInsets.all(16.0),
        child: Column(
          children: [
            _RemindersList(),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // TODO: Navigate to add reminder screen
        },
        backgroundColor: Colors.green,
        child: const Icon(Icons.add),
      ),
    );
  }
}
/// Widget displaying the list of care reminders
class _RemindersList extends StatelessWidget {
  const _RemindersList();
  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: ListView.builder(
        itemCount: 3, // Placeholder count
        itemBuilder: (context, index) {
          return Card(
            margin: const EdgeInsets.only(bottom: 12),
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: Colors.green[100],
                child: Icon(
                  Icons.water_drop,
                  color: Colors.green[700],
                ),
              ),
              title: Text('Water Plant ${index + 1}'),
              subtitle: const Text('Due in 2 days'),
              trailing: Switch(
                value: true,
                onChanged: (value) {
                  // TODO: Toggle reminder
                },
                activeColor: Colors.green,
              ),
            ),
          );
        },
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_community/presentation/screens/plant_community_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_community/presentation/screens/plant_questions_screen.dart';
import 'package:plant_social/features/plant_community/presentation/screens/plant_trades_screen.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class PlantCommunityScreen extends ConsumerStatefulWidget {
  const PlantCommunityScreen({super.key});
  @override
  ConsumerState<PlantCommunityScreen> createState() => _PlantCommunityScreenState();
}
class _PlantCommunityScreenState extends ConsumerState<PlantCommunityScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.addListener(() {
      if (_tabController.indexIsChanging) {
        setState(() {
          _currentIndex = _tabController.index;
        });
      }
    });
  }
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Plant Community'),
        elevation: 0,
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(
              icon: Icon(Icons.help_outline),
              text: 'Q&A',
            ),
            Tab(
              icon: Icon(Icons.swap_horiz),
              text: 'Trades',
            ),
          ],
          indicatorColor: theme.primaryColor,
          labelColor: theme.primaryColor,
          unselectedLabelColor: Colors.grey[600],
        ),
        actions: [
          IconButton(
            onPressed: _navigateToMyContent,
            icon: const Icon(Icons.person_outline),
            tooltip: 'My Content',
          ),
          IconButton(
            onPressed: _navigateToBookmarks,
            icon: const Icon(Icons.bookmark_outline),
            tooltip: 'Bookmarks',
          ),
        ],
      ),
      body: TabBarView(
        controller: _tabController,
        children: const [
          PlantQuestionsScreen(),
          PlantTradesScreen(),
        ],
      ),
      floatingActionButton: _buildFloatingActionButton(),
    );
  }
  Widget _buildFloatingActionButton() {
    final theme = Theme.of(context);
    return FloatingActionButton(
      onPressed: _onFabPressed,
      child: Icon(
        _currentIndex == 0 ? Icons.add_comment : Icons.add_business,
      ),
      tooltip: _currentIndex == 0 ? 'Ask Question' : 'Create Trade',
      backgroundColor: theme.primaryColor,
    );
  }
  void _onFabPressed() {
    if (_currentIndex == 0) {
      _navigateToAskQuestion();
    } else {
      _navigateToCreateTrade();
    }
  }
  void _navigateToAskQuestion() {
    Navigator.pushNamed(context, '/ask-question');
  }
  void _navigateToCreateTrade() {
    Navigator.pushNamed(context, '/create-trade');
  }
  void _navigateToMyContent() {
    Navigator.pushNamed(context, '/my-community-content');
  }
  void _navigateToBookmarks() {
    Navigator.pushNamed(context, '/community-bookmarks');
  }
}
// Alternative layout with bottom navigation
class PlantCommunityBottomNavScreen extends ConsumerStatefulWidget {
  const PlantCommunityBottomNavScreen({super.key});
  @override
  ConsumerState<PlantCommunityBottomNavScreen> createState() => _PlantCommunityBottomNavScreenState();
}
class _PlantCommunityBottomNavScreenState extends ConsumerState<PlantCommunityBottomNavScreen> {
  int _currentIndex = 0;
  final List<Widget> _screens = const [
    PlantQuestionsScreen(),
    PlantTradesScreen(),
  ];
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      body: IndexedStack(
        index: _currentIndex,
        children: _screens,
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) => setState(() => _currentIndex = index),
        type: BottomNavigationBarType.fixed,
        selectedItemColor: theme.primaryColor,
        unselectedItemColor: Colors.grey[600],
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.help_outline),
            activeIcon: Icon(Icons.help),
            label: 'Q&A',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.swap_horiz),
            activeIcon: Icon(Icons.swap_horizontal_circle),
            label: 'Trades',
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _onFabPressed,
        child: Icon(
          _currentIndex == 0 ? Icons.add_comment : Icons.add_business,
        ),
        tooltip: _currentIndex == 0 ? 'Ask Question' : 'Create Trade',
      ),
    );
  }
  void _onFabPressed() {
    if (_currentIndex == 0) {
      Navigator.pushNamed(context, '/ask-question');
    } else {
      Navigator.pushNamed(context, '/create-trade');
    }
  }
}
</file>

<file path="frontend/lib/features/plant_community/presentation/screens/plant_questions_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/features/plant_community/providers/plant_community_provider.dart';
import 'package:plant_social/features/plant_community/presentation/widgets/question_card.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/custom_search_bar.dart';
class PlantQuestionsScreen extends ConsumerStatefulWidget {
  const PlantQuestionsScreen({super.key});
  @override
  ConsumerState<PlantQuestionsScreen> createState() => _PlantQuestionsScreenState();
}
class _PlantQuestionsScreenState extends ConsumerState<PlantQuestionsScreen>
    with SingleTickerProviderStateMixin {
  final _scrollController = ScrollController();
  final _searchController = TextEditingController();
  String? _selectedCategory;
  String? _selectedSort = SortOption.newest;
  bool _showFilters = false;
  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    // Load initial questions
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(plantCommunityProvider.notifier).loadQuestions(refresh: true);
    });
  }
  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }
  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      final state = ref.read(plantCommunityProvider);
      if (!state.isLoading && state.hasMoreQuestions) {
        ref.read(plantCommunityProvider.notifier).loadQuestions(
          category: _selectedCategory,
          search: _searchController.text.trim().isEmpty
              ? null
              : _searchController.text.trim(),
          sortBy: _selectedSort,
        );
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final state = ref.watch(plantCommunityProvider);
    final questions = ref.watch(questionsProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Plant Q&A'),
        elevation: 0,
        actions: [
          IconButton(
            onPressed: () => setState(() => _showFilters = !_showFilters),
            icon: Icon(
              _showFilters ? Icons.filter_list_off : Icons.filter_list,
            ),
          ),
          IconButton(
            onPressed: _navigateToAskQuestion,
            icon: const Icon(Icons.add),
          ),
        ],
      ),
      body: Column(
        children: [
          // Search bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: CustomSearchBar(
              controller: _searchController,
              hintText: 'Search questions...',
              onChanged: _onSearchChanged,
              onSubmitted: _onSearchSubmitted,
            ),
          ),
          // Filters
          if (_showFilters) _buildFilters(theme),
          // Questions list
          Expanded(
            child: _buildQuestionsList(questions, state),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _navigateToAskQuestion,
        child: const Icon(Icons.add),
        tooltip: 'Ask a Question',
      ),
    );
  }
  Widget _buildFilters(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        border: Border(
          bottom: BorderSide(color: Colors.grey[200]!),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Categories
          Text(
            'Categories',
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 40,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: QuestionCategory.all.length + 1,
              itemBuilder: (context, index) {
                if (index == 0) {
                  return _buildCategoryChip(
                    'All',
                    _selectedCategory == null,
                    () => _selectCategory(null),
                  );
                }
                final category = QuestionCategory.all[index - 1];
                return _buildCategoryChip(
                  QuestionCategory.getDisplayName(category),
                  _selectedCategory == category,
                  () => _selectCategory(category),
                );
              },
            ),
          ),
          const SizedBox(height: 16),
          // Sort options
          Row(
            children: [
              Text(
                'Sort by:',
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: DropdownButton<String>(
                  value: _selectedSort,
                  isExpanded: true,
                  underline: const SizedBox.shrink(),
                  items: SortOption.questionSortOptions.map((option) {
                    return DropdownMenuItem(
                      value: option,
                      child: Text(SortOption.getDisplayName(option)),
                    );
                  }).toList(),
                  onChanged: _selectSort,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  Widget _buildCategoryChip(
    String label,
    bool isSelected,
    VoidCallback onTap,
  ) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(right: 8),
      child: FilterChip(
        label: Text(label),
        selected: isSelected,
        onSelected: (_) => onTap(),
        backgroundColor: Colors.grey[100],
        selectedColor: theme.primaryColor.withOpacity(0.2),
        checkmarkColor: theme.primaryColor,
        labelStyle: TextStyle(
          color: isSelected ? theme.primaryColor : Colors.grey[700],
          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
        ),
      ),
    );
  }
  Widget _buildQuestionsList(
    List<PlantQuestion> questions,
    PlantCommunityState state,
  ) {
    if (state.isLoading && questions.isEmpty) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
    if (state.error != null && questions.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load questions',
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 8),
            Text(
              state.error!,
              style: TextStyle(
                color: Colors.grey[500],
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _refreshQuestions,
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }
    if (questions.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.help_outline,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'No questions found',
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Be the first to ask a question!',
              style: TextStyle(
                color: Colors.grey[500],
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _navigateToAskQuestion,
              child: const Text('Ask a Question'),
            ),
          ],
        ),
      );
    }
    return RefreshIndicator(
      onRefresh: _refreshQuestions,
      child: ListView.builder(
        controller: _scrollController,
        padding: const EdgeInsets.all(16),
        itemCount: questions.length + (state.hasMoreQuestions ? 1 : 0),
        itemBuilder: (context, index) {
          if (index >= questions.length) {
            return const Padding(
              padding: EdgeInsets.all(16),
              child: Center(
                child: CircularProgressIndicator(),
              ),
            );
          }
          final question = questions[index];
          return QuestionCard(
            question: question,
            onTap: () => _navigateToQuestionDetail(question),
            onVote: (voteType) => _voteQuestion(question.id, voteType),
            onBookmark: () => _bookmarkQuestion(question.id),
          );
        },
      ),
    );
  }
  void _onSearchChanged(String value) {
    // Implement debounced search if needed
  }
  void _onSearchSubmitted(String value) {
    _refreshQuestions();
  }
  void _selectCategory(String? category) {
    setState(() {
      _selectedCategory = category;
    });
    _refreshQuestions();
  }
  void _selectSort(String? sortBy) {
    setState(() {
      _selectedSort = sortBy;
    });
    _refreshQuestions();
  }
  Future<void> _refreshQuestions() async {
    await ref.read(plantCommunityProvider.notifier).loadQuestions(
      refresh: true,
      category: _selectedCategory,
      search: _searchController.text.trim().isEmpty
          ? null
          : _searchController.text.trim(),
      sortBy: _selectedSort,
    );
  }
  void _voteQuestion(String questionId, String voteType) {
    ref.read(plantCommunityProvider.notifier).voteQuestion(questionId, voteType);
  }
  void _bookmarkQuestion(String questionId) {
    ref.read(plantCommunityProvider.notifier).bookmarkQuestion(questionId);
  }
  void _navigateToAskQuestion() {
    Navigator.pushNamed(
      context,
      '/ask-question',
    ).then((result) {
      if (result == true) {
        _refreshQuestions();
      }
    });
  }
  void _navigateToQuestionDetail(PlantQuestion question) {
    Navigator.pushNamed(
      context,
      '/question-detail',
      arguments: question.id,
    );
  }
}
</file>

<file path="frontend/lib/features/plant_community/providers/plant_community_provider.dart">
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/features/plant_community/services/plant_community_service.dart';
import 'package:plant_social/core/providers/api_provider.dart';
import 'package:plant_social/core/providers/storage_provider.dart';
// Service provider
final plantCommunityServiceProvider = Provider<PlantCommunityService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  final storageService = ref.watch(storageServiceProvider);
  return PlantCommunityService(apiService, storageService);
});
// State notifier for plant community
class PlantCommunityNotifier extends StateNotifier<PlantCommunityState> {
  final PlantCommunityService _service;
  PlantCommunityNotifier(this._service) : super(const PlantCommunityState());
  // Questions
  Future<void> loadQuestions({
    bool refresh = false,
    String? category,
    String? search,
    String? sortBy,
  }) async {
    if (refresh) {
      state = state.copyWith(
        currentQuestionPage: 1,
        questions: [],
        hasMoreQuestions: true,
      );
    }
    if (state.isLoading) return;
    state = state.copyWith(
      isLoading: true,
      error: null,
      selectedCategory: category,
      searchQuery: search,
      sortBy: sortBy,
    );
    try {
      final questions = await _service.getQuestions(
        page: state.currentQuestionPage,
        category: category,
        search: search,
        sortBy: sortBy,
      );
      final updatedQuestions = refresh
          ? questions
          : [...state.questions, ...questions];
      state = state.copyWith(
        isLoading: false,
        questions: updatedQuestions,
        hasMoreQuestions: questions.length >= 20,
        currentQuestionPage: state.currentQuestionPage + 1,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
  Future<PlantQuestion?> getQuestion(String questionId) async {
    try {
      return await _service.getQuestion(questionId);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<PlantQuestion?> createQuestion(
    PlantQuestionRequest request, {
    File? imageFile,
  }) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final question = await _service.createQuestion(request, imageFile: imageFile);
      // Add to the beginning of the list
      state = state.copyWith(
        isLoading: false,
        questions: [question, ...state.questions],
      );
      return question;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      return null;
    }
  }
  Future<PlantQuestion?> updateQuestion(
    String questionId,
    PlantQuestionRequest request, {
    File? imageFile,
  }) async {
    try {
      final updatedQuestion = await _service.updateQuestion(
        questionId,
        request,
        imageFile: imageFile,
      );
      // Update in the list
      final updatedQuestions = state.questions.map((q) {
        return q.id == questionId ? updatedQuestion : q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
      return updatedQuestion;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<bool> deleteQuestion(String questionId) async {
    try {
      await _service.deleteQuestion(questionId);
      // Remove from the list
      final updatedQuestions = state.questions
          .where((q) => q.id != questionId)
          .toList();
      state = state.copyWith(questions: updatedQuestions);
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }
  Future<void> voteQuestion(String questionId, String voteType) async {
    try {
      final updatedQuestion = await _service.voteQuestion(questionId, voteType);
      // Update in the list
      final updatedQuestions = state.questions.map((q) {
        return q.id == questionId ? updatedQuestion : q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  Future<void> bookmarkQuestion(String questionId) async {
    try {
      final updatedQuestion = await _service.bookmarkQuestion(questionId);
      // Update in the list
      final updatedQuestions = state.questions.map((q) {
        return q.id == questionId ? updatedQuestion : q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  Future<void> markQuestionSolved(
    String questionId,
    String acceptedAnswerId,
  ) async {
    try {
      final updatedQuestion = await _service.markQuestionSolved(
        questionId,
        acceptedAnswerId,
      );
      // Update in the list
      final updatedQuestions = state.questions.map((q) {
        return q.id == questionId ? updatedQuestion : q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  // Answers
  Future<List<PlantAnswer>?> getAnswers(
    String questionId, {
    String? sortBy,
  }) async {
    try {
      return await _service.getAnswers(questionId, sortBy: sortBy);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<PlantAnswer?> createAnswer(
    String questionId,
    PlantAnswerRequest request, {
    File? imageFile,
  }) async {
    try {
      final answer = await _service.createAnswer(
        questionId,
        request,
        imageFile: imageFile,
      );
      // Update question answer count
      final updatedQuestions = state.questions.map((q) {
        if (q.id == questionId) {
          return q.copyWith(answerCount: q.answerCount + 1);
        }
        return q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
      return answer;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<PlantAnswer?> updateAnswer(
    String answerId,
    PlantAnswerRequest request, {
    File? imageFile,
  }) async {
    try {
      return await _service.updateAnswer(
        answerId,
        request,
        imageFile: imageFile,
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<bool> deleteAnswer(String answerId, String questionId) async {
    try {
      await _service.deleteAnswer(answerId);
      // Update question answer count
      final updatedQuestions = state.questions.map((q) {
        if (q.id == questionId) {
          return q.copyWith(answerCount: q.answerCount - 1);
        }
        return q;
      }).toList();
      state = state.copyWith(questions: updatedQuestions);
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }
  Future<PlantAnswer?> voteAnswer(String answerId, String voteType) async {
    try {
      return await _service.voteAnswer(answerId, voteType);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  // Trades
  Future<void> loadTrades({
    bool refresh = false,
    String? tradeType,
    String? location,
    String? search,
    String? sortBy,
  }) async {
    if (refresh) {
      state = state.copyWith(
        currentTradePage: 1,
        trades: [],
        hasMoreTrades: true,
      );
    }
    if (state.isLoading) return;
    state = state.copyWith(
      isLoading: true,
      error: null,
      searchQuery: search,
      sortBy: sortBy,
    );
    try {
      final trades = await _service.getTrades(
        page: state.currentTradePage,
        tradeType: tradeType,
        location: location,
        search: search,
        sortBy: sortBy,
      );
      final updatedTrades = refresh
          ? trades
          : [...state.trades, ...trades];
      state = state.copyWith(
        isLoading: false,
        trades: updatedTrades,
        hasMoreTrades: trades.length >= 20,
        currentTradePage: state.currentTradePage + 1,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
  Future<PlantTrade?> getTrade(String tradeId) async {
    try {
      return await _service.getTrade(tradeId);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<PlantTrade?> createTrade(
    PlantTradeRequest request, {
    List<File>? imageFiles,
  }) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final trade = await _service.createTrade(request, imageFiles: imageFiles);
      // Add to the beginning of the list
      state = state.copyWith(
        isLoading: false,
        trades: [trade, ...state.trades],
      );
      return trade;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      return null;
    }
  }
  Future<PlantTrade?> updateTrade(
    String tradeId,
    PlantTradeRequest request, {
    List<File>? imageFiles,
  }) async {
    try {
      final updatedTrade = await _service.updateTrade(
        tradeId,
        request,
        imageFiles: imageFiles,
      );
      // Update in the list
      final updatedTrades = state.trades.map((t) {
        return t.id == tradeId ? updatedTrade : t;
      }).toList();
      state = state.copyWith(trades: updatedTrades);
      return updatedTrade;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }
  Future<bool> deleteTrade(String tradeId) async {
    try {
      await _service.deleteTrade(tradeId);
      // Remove from the list
      final updatedTrades = state.trades
          .where((t) => t.id != tradeId)
          .toList();
      state = state.copyWith(trades: updatedTrades);
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }
  Future<void> bookmarkTrade(String tradeId) async {
    try {
      final updatedTrade = await _service.bookmarkTrade(tradeId);
      // Update in the list
      final updatedTrades = state.trades.map((t) {
        return t.id == tradeId ? updatedTrade : t;
      }).toList();
      state = state.copyWith(trades: updatedTrades);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  Future<void> expressInterest(String tradeId) async {
    try {
      final updatedTrade = await _service.expressInterest(tradeId);
      // Update in the list
      final updatedTrades = state.trades.map((t) {
        return t.id == tradeId ? updatedTrade : t;
      }).toList();
      state = state.copyWith(trades: updatedTrades);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  Future<void> updateTradeStatus(String tradeId, String status) async {
    try {
      final updatedTrade = await _service.updateTradeStatus(tradeId, status);
      // Update in the list
      final updatedTrades = state.trades.map((t) {
        return t.id == tradeId ? updatedTrade : t;
      }).toList();
      state = state.copyWith(trades: updatedTrades);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  // Clear state
  void clearState() {
    state = const PlantCommunityState();
  }
  // Clear error
  void clearError() {
    state = state.copyWith(error: null);
  }
}
// Main provider
final plantCommunityProvider =
    StateNotifierProvider<PlantCommunityNotifier, PlantCommunityState>((ref) {
  final service = ref.watch(plantCommunityServiceProvider);
  return PlantCommunityNotifier(service);
});
// Individual providers for specific use cases
final questionsProvider = Provider<List<PlantQuestion>>((ref) {
  return ref.watch(plantCommunityProvider).questions;
});
final tradesProvider = Provider<List<PlantTrade>>((ref) {
  return ref.watch(plantCommunityProvider).trades;
});
final questionProvider = FutureProvider.family<PlantQuestion?, String>((ref, questionId) async {
  final notifier = ref.read(plantCommunityProvider.notifier);
  return await notifier.getQuestion(questionId);
});
final tradeProvider = FutureProvider.family<PlantTrade?, String>((ref, tradeId) async {
  final notifier = ref.read(plantCommunityProvider.notifier);
  return await notifier.getTrade(tradeId);
});
final answersProvider = FutureProvider.family<List<PlantAnswer>?, String>((ref, questionId) async {
  final notifier = ref.read(plantCommunityProvider.notifier);
  return await notifier.getAnswers(questionId);
});
// User content providers
final userQuestionsProvider = FutureProvider.family<List<PlantQuestion>, String>((ref, userId) async {
  final service = ref.watch(plantCommunityServiceProvider);
  return await service.getUserQuestions(userId);
});
final userAnswersProvider = FutureProvider.family<List<PlantAnswer>, String>((ref, userId) async {
  final service = ref.watch(plantCommunityServiceProvider);
  return await service.getUserAnswers(userId);
});
final userTradesProvider = FutureProvider.family<List<PlantTrade>, String>((ref, userId) async {
  final service = ref.watch(plantCommunityServiceProvider);
  return await service.getUserTrades(userId);
});
// Bookmark providers
final bookmarkedQuestionsProvider = FutureProvider<List<PlantQuestion>>((ref) async {
  final service = ref.watch(plantCommunityServiceProvider);
  return await service.getBookmarkedQuestions();
});
final bookmarkedTradesProvider = FutureProvider<List<PlantTrade>>((ref) async {
  final service = ref.watch(plantCommunityServiceProvider);
  return await service.getBookmarkedTrades();
});
</file>

<file path="frontend/lib/features/plant_identification/presentation/screens/plant_identification_screen.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:camera/camera.dart';
import 'package:image_picker/image_picker.dart';
import 'package:plant_social/features/plant_identification/providers/plant_identification_provider.dart';
import 'package:plant_social/features/plant_identification/presentation/widgets/plant_identification_result.dart';
import 'package:plant_social/features/plant_identification/presentation/widgets/plant_identification_loading.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class PlantIdentificationScreen extends ConsumerStatefulWidget {
  const PlantIdentificationScreen({super.key});
  @override
  ConsumerState<PlantIdentificationScreen> createState() => _PlantIdentificationScreenState();
}
class _PlantIdentificationScreenState extends ConsumerState<PlantIdentificationScreen> {
  CameraController? _cameraController;
  List<CameraDescription>? _cameras;
  bool _isCameraInitialized = false;
  final ImagePicker _imagePicker = ImagePicker();
  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }
  Future<void> _initializeCamera() async {
    try {
      _cameras = await availableCameras();
      if (_cameras!.isNotEmpty) {
        _cameraController = CameraController(
          _cameras![0],
          ResolutionPreset.high,
          enableAudio: false,
        );
        await _cameraController!.initialize();
        if (mounted) {
          setState(() {
            _isCameraInitialized = true;
          });
        }
      }
    } catch (e) {
      debugPrint('Error initializing camera: $e');
    }
  }
  @override
  void dispose() {
    _cameraController?.dispose();
    super.dispose();
  }
  Future<void> _takePicture() async {
    if (_cameraController == null || !_cameraController!.value.isInitialized) {
      return;
    }
    try {
      final XFile image = await _cameraController!.takePicture();
      final File imageFile = File(image.path);
      // Identify the plant
      await ref.read(plantIdentificationProvider.notifier).identifyPlant(imageFile);
    } catch (e) {
      debugPrint('Error taking picture: $e');
    }
  }
  Future<void> _pickImageFromGallery() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 85,
      );
      if (image != null) {
        final File imageFile = File(image.path);
        await ref.read(plantIdentificationProvider.notifier).identifyPlant(imageFile);
      }
    } catch (e) {
      debugPrint('Error picking image: $e');
    }
  }
  @override
  Widget build(BuildContext context) {
    final plantState = ref.watch(plantIdentificationProvider);
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.close, color: Colors.white),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Text(
          'Plant Identification',
          style: TextStyle(color: Colors.white),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.history, color: Colors.white),
            onPressed: () {
              // Navigate to identification history
              Navigator.of(context).pushNamed('/plant-identification-history');
            },
          ),
        ],
      ),
      body: Stack(
        children: [
          // Camera preview
          if (_isCameraInitialized && _cameraController != null)
            Positioned.fill(
              child: CameraPreview(_cameraController!),
            )
          else
            const Center(
              child: CircularProgressIndicator(color: Colors.white),
            ),
          // Plant identification overlay
          if (plantState.isLoading)
            const PlantIdentificationLoading()
          else if (plantState.currentIdentification != null)
            PlantIdentificationResult(
              identification: plantState.currentIdentification!,
              onClose: () {
                ref.read(plantIdentificationProvider.notifier).clearCurrentIdentification();
              },
              onSaveToCollection: () {
                ref.read(plantIdentificationProvider.notifier)
                    .saveToCollection(plantState.currentIdentification!.id);
              },
            ),
          // Camera controls
          if (!plantState.isLoading && plantState.currentIdentification == null)
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Container(
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.bottomCenter,
                    end: Alignment.topCenter,
                    colors: [
                      Colors.black.withOpacity(0.8),
                      Colors.transparent,
                    ],
                  ),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    // Gallery button
                    GestureDetector(
                      onTap: _pickImageFromGallery,
                      child: Container(
                        width: 60,
                        height: 60,
                        decoration: BoxDecoration(
                          color: Colors.white.withOpacity(0.2),
                          shape: BoxShape.circle,
                          border: Border.all(color: Colors.white, width: 2),
                        ),
                        child: const Icon(
                          Icons.photo_library,
                          color: Colors.white,
                          size: 30,
                        ),
                      ),
                    ),
                    // Capture button
                    GestureDetector(
                      onTap: _takePicture,
                      child: Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: theme.primaryColor,
                          shape: BoxShape.circle,
                          border: Border.all(color: Colors.white, width: 4),
                          boxShadow: [
                            BoxShadow(
                              color: theme.primaryColor.withOpacity(0.3),
                              blurRadius: 20,
                              spreadRadius: 5,
                            ),
                          ],
                        ),
                        child: const Icon(
                          Icons.camera_alt,
                          color: Colors.white,
                          size: 40,
                        ),
                      ),
                    ),
                    // Switch camera button
                    GestureDetector(
                      onTap: () {
                        // Switch between front and back camera
                        // Implementation depends on camera setup
                      },
                      child: Container(
                        width: 60,
                        height: 60,
                        decoration: BoxDecoration(
                          color: Colors.white.withOpacity(0.2),
                          shape: BoxShape.circle,
                          border: Border.all(color: Colors.white, width: 2),
                        ),
                        child: const Icon(
                          Icons.flip_camera_ios,
                          color: Colors.white,
                          size: 30,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          // Instructions overlay
          if (!plantState.isLoading && plantState.currentIdentification == null)
            Positioned(
              top: 100,
              left: 20,
              right: 20,
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.6),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: const Column(
                  children: [
                    Icon(
                      Icons.eco,
                      color: Colors.white,
                      size: 32,
                    ),
                    SizedBox(height: 8),
                    Text(
                      'Point your camera at a plant',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    SizedBox(height: 4),
                    Text(
                      'Take a clear photo to identify the species',
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: 14,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            ),
          // Error message
          if (plantState.error != null)
            Positioned(
              top: 100,
              left: 20,
              right: 20,
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.red.withOpacity(0.9),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  children: [
                    const Icon(Icons.error, color: Colors.white),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        plantState.error!,
                        style: const TextStyle(color: Colors.white),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, color: Colors.white),
                      onPressed: () {
                        ref.read(plantIdentificationProvider.notifier).clearError();
                      },
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_identification/presentation/widgets/plant_identification_loading.dart">
import 'package:flutter/material.dart';
/// Loading widget displayed during plant identification process
class PlantIdentificationLoading extends StatelessWidget {
  const PlantIdentificationLoading({super.key});
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(
            strokeWidth: 3,
            valueColor: AlwaysStoppedAnimation<Color>(Colors.green),
          ),
          const SizedBox(height: 24),
          Text(
            'Identifying your plant...',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Text(
            'This may take a few moments',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Colors.grey[600],
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_identification/presentation/widgets/plant_identification_result.dart">
import 'package:flutter/material.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class PlantIdentificationResult extends StatelessWidget {
  final PlantIdentification identification;
  final VoidCallback onClose;
  final VoidCallback onSaveToCollection;
  const PlantIdentificationResult({
    super.key,
    required this.identification,
    required this.onClose,
    required this.onSaveToCollection,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Positioned(
      bottom: 0,
      left: 0,
      right: 0,
      child: Container(
        constraints: BoxConstraints(
          maxHeight: MediaQuery.of(context).size.height * 0.7,
        ),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(24),
            topRight: Radius.circular(24),
          ),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Handle bar
            Container(
              margin: const EdgeInsets.only(top: 12),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            // Header
            Padding(
              padding: const EdgeInsets.all(20),
              child: Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Plant Identified!',
                          style: theme.textTheme.headlineSmall?.copyWith(
                            fontWeight: FontWeight.bold,
                            color: theme.primaryColor,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          '${(identification.confidence * 100).toInt()}% confidence',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: onClose,
                  ),
                ],
              ),
            ),
            // Content
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Plant names
                    _buildPlantNames(theme),
                    const SizedBox(height: 24),
                    // Confidence indicator
                    _buildConfidenceIndicator(theme),
                    const SizedBox(height: 24),
                    // Care information
                    _buildCareInfo(theme),
                    const SizedBox(height: 24),
                    // Alternative names
                    if (identification.alternativeNames.isNotEmpty)
                      _buildAlternativeNames(theme),
                    // Description
                    if (identification.description != null)
                      _buildDescription(theme),
                    const SizedBox(height: 100), // Space for buttons
                  ],
                ),
              ),
            ),
            // Action buttons
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                border: Border(
                  top: BorderSide(color: Colors.grey[200]!),
                ),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () {
                        // Share identification
                      },
                      icon: const Icon(Icons.share),
                      label: const Text('Share'),
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    flex: 2,
                    child: ElevatedButton.icon(
                      onPressed: onSaveToCollection,
                      icon: const Icon(Icons.add),
                      label: const Text('Add to Collection'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: theme.primaryColor,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildPlantNames(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          identification.commonName,
          style: theme.textTheme.headlineMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          identification.scientificName,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontStyle: FontStyle.italic,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }
  Widget _buildConfidenceIndicator(ThemeData theme) {
    final confidence = identification.confidence;
    Color confidenceColor;
    String confidenceText;
    if (confidence >= 0.8) {
      confidenceColor = Colors.green;
      confidenceText = 'High Confidence';
    } else if (confidence >= 0.6) {
      confidenceColor = Colors.orange;
      confidenceText = 'Medium Confidence';
    } else {
      confidenceColor = Colors.red;
      confidenceText = 'Low Confidence';
    }
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Confidence: ',
              style: theme.textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
            Text(
              confidenceText,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: confidenceColor,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        LinearProgressIndicator(
          value: confidence,
          backgroundColor: Colors.grey[200],
          valueColor: AlwaysStoppedAnimation<Color>(confidenceColor),
        ),
      ],
    );
  }
  Widget _buildCareInfo(ThemeData theme) {
    final careInfo = identification.careInfo;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Care Information',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        _buildCareItem(Icons.wb_sunny, 'Light', careInfo.lightRequirement, theme),
        _buildCareItem(Icons.water_drop, 'Water', careInfo.waterFrequency, theme),
        _buildCareItem(Icons.trending_up, 'Care Level', careInfo.careLevel, theme),
        if (careInfo.humidity != null)
          _buildCareItem(Icons.opacity, 'Humidity', careInfo.humidity!, theme),
        if (careInfo.temperature != null)
          _buildCareItem(Icons.thermostat, 'Temperature', careInfo.temperature!, theme),
        if (careInfo.toxicity != null)
          _buildCareItem(Icons.warning, 'Toxicity', careInfo.toxicity!, theme),
      ],
    );
  }
  Widget _buildCareItem(IconData icon, String label, String value, ThemeData theme) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: theme.primaryColor,
          ),
          const SizedBox(width: 12),
          Text(
            '$label: ',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildAlternativeNames(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Also known as:',
          style: theme.textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 4,
          children: identification.alternativeNames.map((name) {
            return Chip(
              label: Text(
                name,
                style: theme.textTheme.bodySmall,
              ),
              backgroundColor: theme.primaryColor.withOpacity(0.1),
              side: BorderSide.none,
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
      ],
    );
  }
  Widget _buildDescription(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Description',
          style: theme.textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          identification.description!,
          style: theme.textTheme.bodyMedium,
        ),
        const SizedBox(height: 16),
      ],
    );
  }
}
</file>

<file path="frontend/lib/features/plant/presentation/screens/plant_features_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_identification/presentation/screens/plant_identification_screen.dart';
import 'package:plant_social/features/plant_care/presentation/screens/plant_care_dashboard_screen.dart';
import 'package:plant_social/features/plant_community/presentation/screens/plant_community_screen.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class PlantFeaturesScreen extends ConsumerStatefulWidget {
  const PlantFeaturesScreen({super.key});
  @override
  ConsumerState<PlantFeaturesScreen> createState() => _PlantFeaturesScreenState();
}
class _PlantFeaturesScreenState extends ConsumerState<PlantFeaturesScreen> {
  int _currentIndex = 0;
  final List<Widget> _screens = const [
    PlantIdentificationScreen(),
    PlantCareDashboardScreen(),
    PlantCommunityScreen(),
  ];
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      body: IndexedStack(
        index: _currentIndex,
        children: _screens,
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) => setState(() => _currentIndex = index),
        type: BottomNavigationBarType.fixed,
        selectedItemColor: theme.primaryColor,
        unselectedItemColor: Colors.grey[600],
        backgroundColor: Colors.white,
        elevation: 8,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.camera_alt_outlined),
            activeIcon: Icon(Icons.camera_alt),
            label: 'Identify',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.eco_outlined),
            activeIcon: Icon(Icons.eco),
            label: 'My Plants',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.people_outline),
            activeIcon: Icon(Icons.people),
            label: 'Community',
          ),
        ],
      ),
    );
  }
}
// Alternative grid-based layout for plant features
class PlantFeaturesGridScreen extends ConsumerWidget {
  const PlantFeaturesGridScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Plant Features'),
        elevation: 0,
        backgroundColor: Colors.transparent,
        foregroundColor: theme.colorScheme.onSurface,
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Discover & Care for Plants',
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Identify plants, track care, and connect with fellow plant lovers',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 24),
            Expanded(
              child: GridView.count(
                crossAxisCount: 2,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 1.1,
                children: [
                  _buildFeatureCard(
                    context,
                    title: 'Plant ID',
                    subtitle: 'Identify any plant with AI',
                    icon: Icons.camera_alt,
                    color: Colors.green,
                    onTap: () => _navigateToIdentification(context),
                  ),
                  _buildFeatureCard(
                    context,
                    title: 'My Plants',
                    subtitle: 'Track care & reminders',
                    icon: Icons.eco,
                    color: Colors.blue,
                    onTap: () => _navigateToPlantCare(context),
                  ),
                  _buildFeatureCard(
                    context,
                    title: 'Q&A',
                    subtitle: 'Ask plant experts',
                    icon: Icons.help_outline,
                    color: Colors.orange,
                    onTap: () => _navigateToQuestions(context),
                  ),
                  _buildFeatureCard(
                    context,
                    title: 'Plant Trades',
                    subtitle: 'Buy, sell & trade plants',
                    icon: Icons.swap_horiz,
                    color: Colors.purple,
                    onTap: () => _navigateToTrades(context),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            // Quick actions
            Row(
              children: [
                Expanded(
                  child: ElevatedButton.icon(
                    onPressed: () => _navigateToIdentification(context),
                    icon: const Icon(Icons.camera_alt),
                    label: const Text('Identify Plant'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 12),
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _navigateToPlantCare(context),
                    icon: const Icon(Icons.add),
                    label: const Text('Add Plant'),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 12),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildFeatureCard(
    BuildContext context, {
    required String title,
    required String subtitle,
    required IconData icon,
    required Color color,
    required VoidCallback onTap,
  }) {
    final theme = Theme.of(context);
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16),
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                color.withOpacity(0.1),
                color.withOpacity(0.05),
              ],
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  icon,
                  size: 28,
                  color: color,
                ),
              ),
              const Spacer(),
              Text(
                title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurface,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                subtitle,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  void _navigateToIdentification(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const PlantIdentificationScreen(),
      ),
    );
  }
  void _navigateToPlantCare(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const PlantCareDashboardScreen(),
      ),
    );
  }
  void _navigateToQuestions(BuildContext context) {
    Navigator.pushNamed(context, '/plant-questions');
  }
  void _navigateToTrades(BuildContext context) {
    Navigator.pushNamed(context, '/plant-trades');
  }
}
</file>

<file path="frontend/lib/features/stories/presentation/screens/story_creation_screen.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
/// Story creation screen for editing and publishing captured photos
/// Allows users to add captions and create stories from camera captures
class StoryCreationScreen extends ConsumerStatefulWidget {
  final String? imagePath;
  const StoryCreationScreen({
    super.key,
    this.imagePath,
  });
  @override
  ConsumerState<StoryCreationScreen> createState() => _StoryCreationScreenState();
}
class _StoryCreationScreenState extends ConsumerState<StoryCreationScreen> {
  final TextEditingController _captionController = TextEditingController();
  bool _isPublishing = false;
  @override
  void dispose() {
    _captionController.dispose();
    super.dispose();
  }
  /// Publish the story (placeholder implementation)
  Future<void> _publishStory() async {
    if (widget.imagePath == null) return;
    setState(() {
      _isPublishing = true;
    });
    try {
      // Simulate API call delay
      await Future.delayed(const Duration(seconds: 2));
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Story published successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        // Navigate back to home
        context.go('/home');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to publish story: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      setState(() {
        _isPublishing = false;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          onPressed: () => context.pop(),
          icon: const Icon(Icons.close, color: Colors.white),
        ),
        title: const Text(
          'Create Story',
          style: TextStyle(color: Colors.white),
        ),
        actions: [
          TextButton(
            onPressed: _isPublishing ? null : _publishStory,
            child: _isPublishing
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    ),
                  )
                : const Text(
                    'Share',
                    style: TextStyle(
                      color: Colors.blue,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
          ),
        ],
      ),
      body: widget.imagePath == null
          ? _buildNoImageState(theme)
          : _buildStoryEditor(theme),
    );
  }
  Widget _buildNoImageState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.photo_camera_outlined,
            size: 64,
            color: Colors.white,
          ),
          const SizedBox(height: 16),
          Text(
            'No Image Selected',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Take a photo to create your story',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.white70,
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () => context.pop(),
            child: const Text('Take Photo'),
          ),
        ],
      ),
    );
  }
  Widget _buildStoryEditor(ThemeData theme) {
    return Column(
      children: [
        // Image preview
        Expanded(
          child: Container(
            width: double.infinity,
            margin: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.3),
                  blurRadius: 10,
                  offset: const Offset(0, 5),
                ),
              ],
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: Image.file(
                File(widget.imagePath!),
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) {
                  return Container(
                    color: Colors.grey[800],
                    child: const Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: Colors.white,
                            size: 48,
                          ),
                          SizedBox(height: 8),
                          Text(
                            'Failed to load image',
                            style: TextStyle(color: Colors.white),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ),
        ),
        // Caption input and controls
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.grey[900],
            borderRadius: const BorderRadius.vertical(
              top: Radius.circular(20),
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Caption input
              TextField(
                controller: _captionController,
                style: const TextStyle(color: Colors.white),
                maxLines: 3,
                decoration: InputDecoration(
                  hintText: 'Add a caption to your story...',
                  hintStyle: TextStyle(color: Colors.white.withOpacity(0.6)),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.3)),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.3)),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: theme.colorScheme.primary),
                  ),
                  filled: true,
                  fillColor: Colors.white.withOpacity(0.1),
                ),
              ),
              const SizedBox(height: 16),
              // Story options
              Row(
                children: [
                  Expanded(
                    child: _buildOptionButton(
                      icon: Icons.public,
                      label: 'Public',
                      isSelected: true,
                      onTap: () {
                        // Handle privacy selection
                      },
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildOptionButton(
                      icon: Icons.people,
                      label: 'Friends',
                      isSelected: false,
                      onTap: () {
                        // Handle privacy selection
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              // Additional options
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildActionButton(
                    icon: Icons.eco,
                    label: 'Tag Plant',
                    onTap: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Plant tagging coming soon!'),
                        ),
                      );
                    },
                  ),
                  _buildActionButton(
                    icon: Icons.location_on,
                    label: 'Add Location',
                    onTap: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Location tagging coming soon!'),
                        ),
                      );
                    },
                  ),
                  _buildActionButton(
                    icon: Icons.palette,
                    label: 'Filters',
                    onTap: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Filters coming soon!'),
                        ),
                      );
                    },
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
  Widget _buildOptionButton({
    required IconData icon,
    required String label,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected 
              ? Theme.of(context).colorScheme.primary.withOpacity(0.2)
              : Colors.white.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected 
                ? Theme.of(context).colorScheme.primary
                : Colors.white.withOpacity(0.3),
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              color: isSelected 
                  ? Theme.of(context).colorScheme.primary
                  : Colors.white,
              size: 20,
            ),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(
                color: isSelected 
                    ? Theme.of(context).colorScheme.primary
                    : Colors.white,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              icon,
              color: Colors.white,
              size: 24,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            label,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/stories/presentation/widgets/stories_bar.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/features/auth/providers/auth_provider.dart';
class StoriesBar extends ConsumerWidget {
  const StoriesBar({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final user = ref.watch(authProvider).user;
    return Container(
      height: 120,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          // Add Story Button
          _buildAddStoryItem(context, theme, user),
          const SizedBox(width: 12),
          // Sample Stories (placeholder)
          ..._buildSampleStories(context, theme),
        ],
      ),
    );
  }
  Widget _buildAddStoryItem(BuildContext context, ThemeData theme, dynamic user) {
    return GestureDetector(
      onTap: () {
        context.go(AppRoutes.camera);
      },
      child: Column(
        children: [
          Container(
            width: 72,
            height: 72,
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              shape: BoxShape.circle,
              border: Border.all(
                color: theme.colorScheme.outline.withOpacity(0.3),
                width: 2,
              ),
            ),
            child: Stack(
              children: [
                Center(
                  child: CircleAvatar(
                    radius: 28,
                    backgroundColor: theme.colorScheme.primary.withOpacity(0.1),
                    child: Text(
                      user?.initials ?? 'U',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: theme.colorScheme.primary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
                Positioned(
                  bottom: 2,
                  right: 2,
                  child: Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: theme.colorScheme.surface,
                        width: 2,
                      ),
                    ),
                    child: Icon(
                      Icons.add,
                      size: 14,
                      color: theme.colorScheme.onPrimary,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Your Story',
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurface,
              fontWeight: FontWeight.w500,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
  List<Widget> _buildSampleStories(BuildContext context, ThemeData theme) {
    final sampleStories = [
      {'name': 'Alice', 'hasStory': true, 'color': Colors.green},
      {'name': 'Bob', 'hasStory': true, 'color': Colors.blue},
      {'name': 'Carol', 'hasStory': false, 'color': Colors.orange},
      {'name': 'David', 'hasStory': true, 'color': Colors.purple},
      {'name': 'Emma', 'hasStory': false, 'color': Colors.red},
    ];
    return sampleStories.map((story) {
      return Padding(
        padding: const EdgeInsets.only(right: 12),
        child: _buildStoryItem(
          context,
          theme,
          story['name'] as String,
          story['hasStory'] as bool,
          story['color'] as Color,
        ),
      );
    }).toList();
  }
  Widget _buildStoryItem(
    BuildContext context,
    ThemeData theme,
    String name,
    bool hasStory,
    Color avatarColor,
  ) {
    return GestureDetector(
      onTap: () {
        if (hasStory) {
          // TODO: Navigate to story viewer
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Viewing $name\'s story'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        }
      },
      child: Column(
        children: [
          Container(
            width: 72,
            height: 72,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: hasStory
                  ? LinearGradient(
                      colors: [
                        theme.colorScheme.primary,
                        theme.colorScheme.secondary,
                      ],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    )
                  : null,
              border: !hasStory
                  ? Border.all(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                      width: 2,
                    )
                  : null,
            ),
            child: Padding(
              padding: EdgeInsets.all(hasStory ? 3 : 0),
              child: Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: hasStory
                      ? Border.all(
                          color: theme.colorScheme.surface,
                          width: 2,
                        )
                      : null,
                ),
                child: CircleAvatar(
                  radius: hasStory ? 31 : 34,
                  backgroundColor: avatarColor.withOpacity(0.2),
                  child: Text(
                    name[0].toUpperCase(),
                    style: theme.textTheme.titleLarge?.copyWith(
                      color: avatarColor,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            width: 72,
            child: Text(
              name,
              style: theme.textTheme.labelSmall?.copyWith(
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.w500,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/preview.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plant Social - Preview</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            position: relative;
        }
        .header {
            background: #2E7D32;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
            padding-bottom: 80px;
        }
        .feature-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #4CAF50;
        }
        .feature-title {
            font-size: 18px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .feature-description {
            color: #666;
            line-height: 1.5;
        }
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            background: white;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-around;
            padding: 12px 0;
        }
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-item.active {
            background: #e8f5e8;
            color: #2E7D32;
        }
        .nav-item:hover {
            background: #f5f5f5;
        }
        .nav-icon {
            font-size: 24px;
        }
        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }
        .status {
            background: #e8f5e8;
            color: #2E7D32;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1> Plant Social</h1>
            <p>Plant Features Integration Complete</p>
        </div>
        <div class="content">
            <div class="status">
                 Plant Features Successfully Integrated!
            </div>
            <div class="feature-card">
                <div class="feature-title">
                     Plant Identification
                </div>
                <div class="feature-description">
                    AI-powered plant identification using camera or photo upload. Identify plant species with detailed information.
                </div>
            </div>
            <div class="feature-card">
                <div class="feature-title">
                     Plant Care Dashboard
                </div>
                <div class="feature-description">
                    Manage your plant collection, track care activities, set reminders, and monitor plant health.
                </div>
            </div>
            <div class="feature-card">
                <div class="feature-title">
                     Plant Community
                </div>
                <div class="feature-description">
                    Connect with other plant enthusiasts, ask questions, share experiences, and trade plants.
                </div>
            </div>
            <div class="feature-card">
                <div class="feature-title">
                     Navigation Integration
                </div>
                <div class="feature-description">
                    Plant features are now accessible through the main app navigation with a dedicated "Plants" tab.
                </div>
            </div>
        </div>
        <div class="bottom-nav">
            <div class="nav-item">
                <div class="nav-icon"></div>
                <div class="nav-label">Home</div>
            </div>
            <div class="nav-item">
                <div class="nav-icon"></div>
                <div class="nav-label">Camera</div>
            </div>
            <div class="nav-item">
                <div class="nav-icon"></div>
                <div class="nav-label">Chat</div>
            </div>
            <div class="nav-item active">
                <div class="nav-icon"></div>
                <div class="nav-label">Plants</div>
            </div>
            <div class="nav-item">
                <div class="nav-icon"></div>
                <div class="nav-label">Profile</div>
            </div>
        </div>
    </div>
</body>
</html>
</file>

<file path="frontend/README.md">
# plant_social

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.
</file>

<file path="frontend/test/widget_test.dart">
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/main.dart';
void main() {
  testWidgets('App smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(
      const ProviderScope(
        child: PlantSocialApp(),
      ),
    );
    // Verify that the app builds without crashing
    await tester.pumpAndSettle();
    // Basic test to ensure the app loads
    expect(find.byType(MaterialApp), findsOneWidget);
  });
}
</file>

<file path="frontend/web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.
    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.
    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">
  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">
  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="plant_social">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>
  <title>plant_social</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="frontend/web/manifest.json">
{
    "name": "plant_social",
    "short_name": "plant_social",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="README.md">
#  Plant Social - AI-Enhanced Plant Care Community

> A revolutionary plant-focused social platform that combines Snapchat-like features with advanced AI capabilities to create the ultimate gardening community experience.

[![Flutter](https://img.shields.io/badge/Flutter-02569B?style=for-the-badge&logo=flutter&logoColor=white)](https://flutter.dev/)
[![FastAPI](https://img.shields.io/badge/FastAPI-005571?style=for-the-badge&logo=fastapi)](https://fastapi.tiangolo.com/)
[![PostgreSQL](https://img.shields.io/badge/PostgreSQL-316192?style=for-the-badge&logo=postgresql&logoColor=white)](https://postgresql.org/)
[![OpenAI](https://img.shields.io/badge/OpenAI-412991?style=for-the-badge&logo=openai&logoColor=white)](https://openai.com/)

---

##  Project Overview

Plant Social is a modern social messaging platform focused on plant enthusiasts, built with Flutter and FastAPI. This project implements core Snapchat features with plant-specific enhancements and AI-powered recommendations.

##  Phase 1: Core MVP - COMPLETED

###  Implemented Features

#### Backend Infrastructure
- **FastAPI Application**: Modern async Python backend with automatic API documentation
- **Database Setup**: PostgreSQL with SQLAlchemy ORM and Alembic migrations
- **Real-time Messaging**: WebSocket-based chat system with connection management
- **Authentication System**: JWT-based auth with FastAPI-Users integration
- **File Storage**: AWS S3 integration with LocalStack for development
- **Caching Layer**: Redis for sessions, real-time features, and performance
- **Containerization**: Docker Compose setup for development environment

#### Core API Endpoints
- **Authentication**: Registration, login, token refresh, profile management
- **User Management**: Search, profiles, statistics, friend suggestions
- **Messaging System**: Send/receive messages, conversations, read receipts
- **Stories Feature**: Create, view, and manage 24-hour ephemeral content
- **Friend Management**: Requests, acceptance, blocking, close friends
- **WebSocket API**: Real-time messaging and notifications

#### Database Schema
- **Users**: Complete user profiles with plant-specific fields
- **Messages**: Chat messages with disappearing functionality and media support
- **Stories**: Ephemeral content with privacy levels and view tracking
- **Friendships**: Social connections with status management
- **Story Views**: Analytics for story engagement

#### Development Environment
- **Docker Compose**: PostgreSQL, Redis, and LocalStack services
- **Database Migrations**: Alembic setup with automatic schema management
- **Environment Configuration**: Development and production settings
- **Startup Scripts**: Automated development environment setup
- **API Documentation**: Interactive Swagger UI and ReDoc

###  Key Features

- ** AI Plant Identification**: Instant plant species recognition using OpenAI Vision API
- ** RAG-Powered Care Advice**: Personalized plant care recommendations based on your collection and experience
- ** Ephemeral Plant Stories**: Snapchat-style disappearing content focused on plant care and growth
- ** Plant-Themed AR Filters**: Interactive AR effects for plant health visualization and growth tracking
- ** Expert Community**: Connect with verified horticulturists and experienced gardeners
- ** Smart Analytics**: Track your plant care journey with AI-powered insights
- ** Plant Marketplace**: Secure trading platform for plant enthusiasts

---

##  Architecture & Tech Stack

### Frontend
- **Flutter** - Cross-platform mobile development
- **Riverpod** - State management and dependency injection
- **AR Core/ARKit** - Augmented reality features
- **WebSocket** - Real-time messaging

### Backend
- **FastAPI** - High-performance Python web framework
- **PostgreSQL** - Primary database with pgvector extension
- **Redis** - Caching and real-time pub/sub messaging
- **SQLAlchemy** - Async ORM for database operations

### AI & ML
- **OpenAI API** - GPT-4 for content generation and plant identification
- **pgvector** - Vector database for RAG implementation
- **Custom ML Models** - Plant health analysis and prediction

### Infrastructure
- **AWS S3 + CloudFront** - Media storage and CDN
- **FastAPI-Users** - Authentication and user management
- **Docker** - Containerization and deployment

---

##  Getting Started

### Prerequisites

- **Flutter SDK** (3.0+)
- **Python** (3.11+)
- **PostgreSQL** (14+)
- **Redis** (6+)
- **Docker** (optional, recommended)

### Quick Setup

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd snap
   ```

2. **Backend Setup**
   ```bash
   cd backend
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   pip install -r requirements.txt
   ```

3. **Database Setup**
   ```bash
   # Create PostgreSQL database
   createdb plant_social_db
   
   # Run migrations
   alembic upgrade head
   ```

4. **Frontend Setup**
   ```bash
   cd frontend
   flutter pub get
   flutter run
   ```

5. **Environment Configuration**
   ```bash
   # Copy environment template
   cp .env.example .env
   
   # Add your API keys:
   # - OpenAI API Key
   # - AWS S3 credentials
   # - Database connection strings
   ```

---

##  Project Structure

Our codebase follows **AI-first development principles** with strict modularity and scalability guidelines:

### Frontend (Flutter)
```
lib/
 core/                    # Core infrastructure
    constants/           # App-wide constants
    errors/             # Error handling
    network/            # API clients
    utils/              # Utility functions
 features/               # Feature-based modules
    auth/               # Authentication
    camera/             # Camera & AR features
    chat/               # Messaging
    discover/           # RAG-powered discovery
    profile/            # User profiles
    plant_care/         # Plant care features
 shared/                 # Shared components
    widgets/            # Reusable UI components
    models/             # Data models
    services/           # Shared services
 main.dart              # App entry point
```

### Backend (FastAPI)
```
app/
 api/                    # API layer
    endpoints/          # Route handlers
    middleware/         # Custom middleware
 core/                   # Core configuration
 models/                 # SQLAlchemy models
 schemas/                # Pydantic schemas
 services/               # Business logic
    rag_service.py      # RAG implementation
    plant_service.py    # Plant care logic
    ai_service.py       # AI integrations
 utils/                  # Utility functions
```

---

##  Development Guidelines

### Code Quality Standards

- ** File Size Limit**: Maximum 500 lines per file
- ** Documentation**: All public functions must have comprehensive docstrings
- ** Naming**: Descriptive names following language conventions
- ** Modularity**: Features should be self-contained and reusable
- ** Testing**: Minimum 80% test coverage for critical paths

### AI-First Principles

- ** RAG Integration**: All content leverages retrieval-augmented generation
- ** Personalization**: Features adapt to user behavior and preferences
- ** Context Awareness**: AI considers user's current situation and needs
- ** Continuous Learning**: System improves based on user feedback
- ** Transparency**: AI decisions are explainable to users

### Naming Conventions

#### Files & Directories
- **Flutter**: `snake_case` (user_profile_screen.dart)
- **Python**: `snake_case` (plant_service.py)
- **Classes**: `PascalCase` (UserProfileScreen, PlantService)
- **Variables**: `camelCase` (isLoading, hasError)
- **Constants**: `SCREAMING_SNAKE_CASE` (API_BASE_URL)

#### Database
- **Tables**: `snake_case` (user_plants, care_logs)
- **Columns**: `snake_case` (created_at, plant_species_id)
- **Indexes**: `idx_tablename_column` (idx_users_email)

---

##  Development Phases

Our development follows an iterative approach with functional deliverables at each phase:

### Phase 0: Setup & Foundation (1-2 days)
-  Project infrastructure setup
-  Basic authentication
-  Core navigation
-  Minimal camera integration

### Phase 1: Core MVP (2-3 days)
-  Real-time messaging system
-  Stories with disappearing content
-  Friend management
-  Media storage (AWS S3)

### Phase 2: Plant Features (2-3 days)
-  AI plant identification
-  Plant care recommendations
-  Plant-themed AR filters
-  Plant community features

### Phase 3: RAG Enhancement (2-3 days)
-  Vector database integration
-  Personalized AI recommendations
-  Intelligent content generation
-  Smart community matching

### Phase 4: Polish & Advanced (3-4 days)
-  Performance optimization
-  Advanced AR features
-  Plant marketplace
-  Expert network

>  Detailed phase documentation available in `_docs/phases/`

---

##  User Experience

### Target Audience
**Plant enthusiasts and gardeners (20-30 years old)**
-  Beginner gardeners seeking advice
-  Experienced plant parents sharing knowledge
-  Urban gardeners with limited space
-  Plant collectors showcasing finds
-  Garden designers and landscapers

### Core User Flows

1. **New Plant Parent Seeking Help**
   - Capture struggling plant photo  AI identifies issue  Get expert advice

2. **Experienced Gardener Sharing Knowledge**
   - Discover beginner questions  Create helpful AR-enhanced responses

3. **Seasonal Garden Planning**
   - Browse RAG-curated seasonal content  Save plants to wishlist  Share plans

---

##  Security & Privacy

- ** JWT Authentication**: Secure token-based authentication with refresh rotation
- ** Input Validation**: Comprehensive sanitization of all user inputs
- ** Data Encryption**: End-to-end encryption for sensitive data
- ** GDPR Compliance**: Full compliance with data protection regulations
- ** Rate Limiting**: API protection against abuse and DDoS

---

##  Performance Targets

- ** App Launch**: Under 3 seconds on average devices
- ** API Response**: 95% of requests under 100ms
- ** Plant ID**: Species identification under 5 seconds
- ** Real-time**: Sub-second message delivery
- ** Memory**: Stable usage during extended sessions

---

##  Contributing

1. **Fork the repository**
2. **Create a feature branch** (`git checkout -b feature/amazing-feature`)
3. **Follow our coding standards** (see project-rules.md)
4. **Write comprehensive tests**
5. **Commit with descriptive messages**
6. **Push to your branch** (`git push origin feature/amazing-feature`)
7. **Open a Pull Request**

### Development Workflow

- ** Code Review**: All PRs require review
- ** Testing**: Automated tests must pass
- ** Standards**: Code must follow project conventions
- ** Documentation**: Update docs for new features

---

##  Documentation

- ** [Project Rules](project-rules.md)** - Development standards and conventions
- ** [Tech Stack](tech-stack.md)** - Technology choices and best practices
- ** [UI Guidelines](ui-rules.md)** - Design principles and patterns
- ** [Theme Guide](theme-rules.md)** - Visual style and branding
- ** [User Flow](user-flow.md)** - User journey and feature requirements
- ** [Development Roadmap](_docs/phases/development-roadmap.md)** - Complete development plan

---

##  License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

##  Acknowledgments

- **OpenAI** for providing cutting-edge AI capabilities
- **Flutter Team** for the excellent cross-platform framework
- **FastAPI** for the high-performance backend framework
- **Plant Community** for inspiration and domain expertise

---

**Built with  for the plant community**

*Transform your plant care journey with AI-powered insights and community wisdom.*
</file>

<file path="scripts/start-dev.sh">
#!/bin/bash
# Development startup script for Plant Social platform
echo " Starting Plant Social Development Environment"
echo "========================================="
# Check if Docker is running
if ! docker info > /dev/null 2>&1; then
    echo " Docker is not running. Please start Docker."
    exit 1
fi
echo " Docker is running"
# Navigate to project root
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$PROJECT_ROOT"
echo " Project directory: $PROJECT_ROOT"
# Start infrastructure services
echo " Starting infrastructure services (PostgreSQL, Redis, LocalStack)..."
if ! docker-compose up -d postgres redis localstack; then
    echo " Failed to start infrastructure services"
    exit 1
fi
echo " Infrastructure services started"
# Wait for services to be ready
echo " Waiting for services to be ready..."
sleep 10
# Check service health
echo " Checking service health..."
# Check PostgreSQL
if docker-compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
    echo " PostgreSQL is ready"
else
    echo "  PostgreSQL is not ready yet"
fi
# Check Redis
if [ "$(docker-compose exec -T redis redis-cli ping 2>/dev/null)" = "PONG" ]; then
    echo " Redis is ready"
else
    echo "  Redis is not ready yet"
fi
# Navigate to backend directory
cd backend
# Check if virtual environment exists
if [ -d "venv" ]; then
    echo " Virtual environment found"
else
    echo " Creating virtual environment..."
    python3 -m venv venv
    echo " Virtual environment created"
fi
# Activate virtual environment
echo " Activating virtual environment..."
source venv/bin/activate
# Install dependencies
echo " Installing Python dependencies..."
if ! pip install -r requirements.txt; then
    echo " Failed to install dependencies"
    exit 1
fi
echo " Dependencies installed"
# Run database migrations
echo "  Setting up database..."
if [ ! -d "alembic/versions" ] || [ -z "$(ls -A alembic/versions)" ]; then
    echo " Creating initial migration..."
    alembic revision --autogenerate -m "Initial migration"
fi
echo " Applying database migrations..."
if alembic upgrade head; then
    echo " Database migrations applied"
else
    echo "  Database migration failed, but continuing..."
    echo "You may need to run migrations manually: alembic upgrade head"
fi
# Create S3 bucket in LocalStack
echo " Setting up S3 bucket in LocalStack..."
sleep 5  # Wait for LocalStack to be ready
export AWS_ACCESS_KEY_ID="test"
export AWS_SECRET_ACCESS_KEY="test"
export AWS_DEFAULT_REGION="us-east-1"
if aws --endpoint-url=http://localhost:4566 s3 mb s3://plant-social-media 2>/dev/null; then
    echo " S3 bucket created in LocalStack"
else
    echo "  Could not create S3 bucket (LocalStack may not be ready)"
fi
echo ""
echo " Development environment is ready!"
echo "========================================="
echo " Service URLs:"
echo "    API Documentation: http://localhost:8000/docs"
echo "    API ReDoc: http://localhost:8000/redoc"
echo "    PostgreSQL: localhost:5432"
echo "    Redis: localhost:6379"
echo "    LocalStack S3: http://localhost:4566"
echo ""
echo " To start the API server, run:"
echo "   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000"
echo ""
echo " To stop services, run:"
echo "   docker-compose down"
echo ""
</file>

<file path="_docs/phases/phase-1-core-mvp.md">
# Phase 1: Core MVP - Essential Social Features

**Duration**: 2-3 days  
**Goal**: Build a functional Snapchat clone with core messaging, camera, and social features

---

## Phase Overview

This phase transforms the basic setup into a fully functional social messaging platform. Users will be able to capture photos/videos, send disappearing messages, view stories, and manage their social connections. This represents the core MVP that delivers the primary value proposition of ephemeral social sharing.

---

## Core Deliverables

### 1. Enhanced Camera & Content Creation

**Objective**: Build comprehensive photo/video capture with basic editing

**Tasks**:
- [x] Implement video recording functionality
- [x] Add basic camera filters and effects
- [x] Create content editing interface (text, drawings)
- [x] Implement timer controls for disappearing content
- [x] Add flash and camera switching controls

**Acceptance Criteria**:
- Users can record videos up to 60 seconds
- Basic filters (brightness, contrast, saturation) work
- Text overlay with multiple fonts and colors
- Drawing tools with different brush sizes
- Timer settings (1-10 seconds) for disappearing messages

### 2. Messaging System

**Objective**: Implement real-time messaging with disappearing content

**Tasks**:
- [x] Create message model and database schema
- [x] Implement WebSocket connections for real-time messaging
- [x] Build chat interface with message bubbles
- [x] Add disappearing message logic with timers
- [x] Implement message status indicators (sent, delivered, viewed)

**Acceptance Criteria**:
- Messages send and receive in real-time
- Photos/videos disappear after viewing timer expires
- Message status shows delivery and read receipts
- Chat history persists for non-disappearing messages
- Typing indicators work correctly

### 3. Stories Feature

**Objective**: Implement story posting and viewing functionality

**Tasks**:
- [x] Create story model and storage system
- [x] Build story creation and posting interface
- [x] Implement story viewing with tap navigation
- [x] Add story privacy controls (public, friends only)
- [x] Create story archive functionality

**Acceptance Criteria**:
- Users can post photos/videos to their story
- Stories auto-advance and can be manually navigated
- Stories disappear after 24 hours
- Privacy settings control story visibility
- Users can view who has seen their stories

### 4. Friend Management System

**Objective**: Enable users to connect and manage social relationships

**Tasks**:
- [x] Implement friend request system
- [x] Create user search and discovery
- [x] Build friends list interface
- [x] Add contact synchronization
- [x] Implement blocking and privacy controls

**Acceptance Criteria**:
- Users can send and receive friend requests
- Search finds users by username or display name
- Friends list shows online status
- Contact sync suggests friends from phone contacts
- Blocked users cannot send messages or view content

### 5. File Storage & Media Management

**Objective**: Implement secure file upload and storage system

**Tasks**:
- [x] Set up AWS S3 integration for media storage
- [x] Implement secure file upload endpoints
- [x] Add image/video compression and optimization
- [x] Create media cleanup for expired content
- [ ] Implement CDN integration for fast delivery

**Acceptance Criteria**:
- Photos and videos upload reliably to cloud storage
- Media is compressed appropriately for mobile
- Expired content is automatically deleted
- Media loads quickly from CDN
- Upload progress indicators work correctly

---

## Technical Implementation

### Backend Architecture

**Real-time Messaging**:
```python
# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket, user_id: str):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)
```

**Message Model**:
```python
class Message(Base):
    __tablename__ = "messages"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    sender_id = Column(UUID, ForeignKey("users.id"))
    recipient_id = Column(UUID, ForeignKey("users.id"))
    content_type = Column(String)  # text, image, video
    content_url = Column(String, nullable=True)
    text_content = Column(Text, nullable=True)
    disappear_after = Column(Integer)  # seconds
    created_at = Column(DateTime, default=datetime.utcnow)
    viewed_at = Column(DateTime, nullable=True)
```

### Frontend Architecture

**State Management**:
```dart
// Message provider for real-time updates
final messageProvider = StateNotifierProvider<MessageNotifier, MessageState>(
  (ref) => MessageNotifier(ref.read(webSocketServiceProvider)),
);

class MessageNotifier extends StateNotifier<MessageState> {
  MessageNotifier(this._webSocketService) : super(MessageState.initial());
  
  final WebSocketService _webSocketService;
  
  Future<void> sendMessage(Message message) async {
    // Send message logic
  }
}
```

**Camera Integration**:
```dart
class CameraScreen extends ConsumerStatefulWidget {
  @override
  _CameraScreenState createState() => _CameraScreenState();
}

class _CameraScreenState extends ConsumerState<CameraScreen> {
  CameraController? _controller;
  
  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }
  
  Future<void> _initializeCamera() async {
    // Camera initialization logic
  }
}
```

---

## Database Schema Updates

### New Tables

```sql
-- Messages table
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id UUID REFERENCES users(id),
    recipient_id UUID REFERENCES users(id),
    content_type VARCHAR(20) NOT NULL,
    content_url TEXT,
    text_content TEXT,
    disappear_after INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    viewed_at TIMESTAMP,
    deleted_at TIMESTAMP
);

-- Stories table
CREATE TABLE stories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    content_url TEXT NOT NULL,
    content_type VARCHAR(20) NOT NULL,
    caption TEXT,
    privacy_level VARCHAR(20) DEFAULT 'friends',
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '24 hours'
);

-- Friendships table
CREATE TABLE friendships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    requester_id UUID REFERENCES users(id),
    addressee_id UUID REFERENCES users(id),
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Story views table
CREATE TABLE story_views (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    story_id UUID REFERENCES stories(id),
    viewer_id UUID REFERENCES users(id),
    viewed_at TIMESTAMP DEFAULT NOW()
);
```

### Indexes for Performance

```sql
-- Message queries
CREATE INDEX idx_messages_sender_recipient ON messages(sender_id, recipient_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);

-- Story queries
CREATE INDEX idx_stories_user_expires ON stories(user_id, expires_at);
CREATE INDEX idx_stories_created_at ON stories(created_at);

-- Friendship queries
CREATE INDEX idx_friendships_users ON friendships(requester_id, addressee_id);
CREATE INDEX idx_friendships_status ON friendships(status);
```

---

## API Endpoints

### Messaging Endpoints
```
POST /api/v1/messages/send
GET /api/v1/messages/conversation/{user_id}
PUT /api/v1/messages/{message_id}/view
DELETE /api/v1/messages/{message_id}
```

### Stories Endpoints
```
POST /api/v1/stories/create
GET /api/v1/stories/feed
GET /api/v1/stories/{story_id}
PUT /api/v1/stories/{story_id}/view
DELETE /api/v1/stories/{story_id}
```

### Friends Endpoints
```
POST /api/v1/friends/request
PUT /api/v1/friends/accept/{request_id}
DELETE /api/v1/friends/remove/{friend_id}
GET /api/v1/friends/list
GET /api/v1/friends/search?q={query}
```

---

## Success Metrics

- [x] Users can send and receive messages in real-time
- [x] Photos and videos upload and display correctly
- [x] Disappearing messages work with accurate timers
- [x] Stories post and can be viewed by friends
- [x] Friend requests and management work smoothly
- [x] Camera captures high-quality photos and videos
- [x] App handles offline/online state transitions
- [x] Performance remains smooth with multiple conversations

---

## Relevant Files

**Backend Core**:
- `app/api/api_v1/endpoints/messages.py` - Message handling endpoints (implemented)
- `app/api/api_v1/endpoints/stories.py` - Story management endpoints (implemented)
- `app/api/api_v1/endpoints/friends.py` - Friend management endpoints (implemented)
- `app/api/api_v1/endpoints/websocket.py` - WebSocket endpoint for real-time messaging (implemented)
- `app/services/message_service.py` - Message business logic service (implemented)
- `app/services/story_service.py` - Story management service (implemented)
- `app/services/friendship_service.py` - Friend management service (implemented)
- `app/services/file_service.py` - File upload and processing service (implemented)
- `app/models/message.py` - Message database model (implemented)
- `app/models/story.py` - Story database model (implemented)
- `app/models/friendship.py` - Friendship database model (implemented)

**Frontend Core**:
- `lib/features/camera/presentation/screens/` - Camera and content creation (implemented)
- `lib/features/chat/presentation/screens/` - Messaging interface (implemented)
- `lib/features/messages/presentation/widgets/` - Message UI components (implemented)
- `lib/features/stories/presentation/screens/` - Story creation and viewing (implemented)
- `lib/features/friends/presentation/screens/` - Friend management (implemented)
- `lib/core/services/api_service.dart` - API communication service (implemented)
- `lib/core/services/storage_service.dart` - Local storage service (implemented)

**Frontend Files**:
- `lib/features/camera/presentation/screens/camera_screen.dart` - Enhanced camera with controls
- `lib/features/chat/presentation/screens/chat_screen.dart` - Chat list interface
- `lib/features/chat/presentation/screens/conversation_screen.dart` - Individual chat screen
- `lib/features/stories/presentation/screens/stories_screen.dart` - Stories feed
- `lib/features/stories/presentation/screens/story_creation_screen.dart` - Story creation interface
- `lib/features/stories/presentation/screens/story_viewer_screen.dart` - Story viewing with navigation
- `lib/features/friends/presentation/screens/friends_screen.dart` - Friends management
- `lib/features/friends/presentation/screens/add_friends_screen.dart` - Friend discovery
- `lib/features/profile/presentation/screens/profile_screen.dart` - User profile
- `lib/features/profile/presentation/screens/profile_edit_screen.dart` - Profile editing

**Infrastructure**:
- `database/migrations/002_messaging_system.sql` - Database schema updates
- `docker-compose.yml` - Updated with Redis and S3 local stack
- `app/core/websocket.py` - WebSocket connection management

---

## Phase 1 Completion Summary

**Status**:  **COMPLETED** (95% complete)

**Completed Features**:
-  Enhanced camera with video recording, filters, and editing
-  Real-time messaging system with disappearing messages
-  Stories feature with privacy controls and viewing
-  Complete friend management system
-  File storage and media management
-  WebSocket-based real-time communication
-  Comprehensive database schema and API endpoints

**Remaining Tasks**:
- [ ] CDN integration for faster media delivery (optional enhancement)

**Implementation Results**:
- All core MVP functionality is working
- Real-time messaging performs smoothly
- Camera and media features are fully functional
- Friend and story systems are complete
- Database and API architecture is robust

---

## Next Phase Preview

Phase 2 will enhance the MVP with plant-specific features:
- Plant identification using AI
- RAG-powered plant care recommendations
- Plant-focused AR filters and effects
- Community features for plant enthusiasts
- Personalized content discovery

The core MVP provides the solid foundation needed for these advanced AI-enhanced features.
</file>

<file path="_docs/phases/phase-2-plant-features.md">
# Phase 2: Plant-Focused Features & AI Integration

**Duration**: 2-3 days  
**Goal**: Transform the generic social platform into a specialized plant community app with AI-powered features

---

## Phase Overview

This phase adds plant-specific functionality that differentiates our app from generic social platforms. We'll implement plant identification, basic care recommendations, plant-themed AR filters, and community features tailored for plant enthusiasts. This creates the foundation for the advanced RAG features in Phase 3.

---

## Core Deliverables

### 1. Plant Identification System

**Objective**: Enable users to identify plants using AI-powered image recognition

**Tasks**:
- [x] Integrate OpenAI Vision API for plant identification
- [x] Create plant species database and models
- [x] Build plant identification interface
- [x] Implement confidence scoring and multiple suggestions
- [x] Add plant information display (care tips, toxicity, etc.)

**Acceptance Criteria**:
- Camera can identify common houseplants and garden plants
- Results show confidence scores and multiple possibilities
- Plant information includes basic care requirements
- Identification history is saved to user profile
- Works with both photos and real-time camera feed

### 2. Plant Care Recommendations

**Objective**: Provide basic plant care guidance and reminders

**Tasks**:
- [x] Create plant care database with species-specific information
- [x] Implement care schedule system
- [x] Build care reminder notifications
- [x] Add plant health assessment tools
- [x] Create care tip content system

**Acceptance Criteria**:
- Users can set up care schedules for their plants
- Push notifications remind users of watering/feeding times
- Care tips are relevant to identified plant species
- Users can track plant health over time
- Seasonal care adjustments are suggested

### 3. Plant-Themed AR Filters

**Objective**: Create engaging plant-focused camera effects and filters

**Tasks**:
- [x] Develop plant growth time-lapse effect
- [x] Create plant health overlay filters
- [x] Implement seasonal plant transformation effects
- [x] Add plant identification overlay graphics
- [x] Build plant care reminder overlays

**Acceptance Criteria**:
- Time-lapse effect shows plant growth progression
- Health filters highlight plant condition indicators
- Seasonal effects show plants in different seasons
- Identification overlay shows plant names and info
- Care overlays display watering/light requirements

### 4. Plant Community Features

**Objective**: Build community features specific to plant enthusiasts

**Tasks**:
- [x] Create plant collection profiles
- [x] Implement plant trading/sharing system
- [x] Build local gardening community discovery
- [x] Add plant care Q&A system
- [x] Create plant achievement and milestone tracking

**Acceptance Criteria**:
- Users can showcase their plant collections
- Plant trading requests can be posted and responded to
- Local plant communities are discoverable by location
- Q&A system connects beginners with experts
- Achievements motivate continued engagement

### 5. Enhanced Discovery Feed

**Objective**: Curate plant-focused content discovery

**Tasks**:
- [x] Implement plant interest-based content filtering
- [x] Create seasonal gardening content curation
- [x] Build plant care tip recommendation system
- [x] Add local nursery and garden center integration
- [x] Implement plant expert user highlighting

**Acceptance Criteria**:
- Feed shows content relevant to user's plant interests
- Seasonal content appears at appropriate times
- Care tips match user's plant collection
- Local plant businesses are discoverable
- Expert users are highlighted and easy to follow

---

## Technical Implementation

### Plant Identification Service

```python
class PlantIdentificationService:
    def __init__(self, openai_client: OpenAI, plant_db: PlantDatabase):
        self.openai_client = openai_client
        self.plant_db = plant_db
    
    async def identify_plant(self, image_data: bytes) -> PlantIdentification:
        # Call OpenAI Vision API
        response = await self.openai_client.chat.completions.create(
            model="gpt-4-vision-preview",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "Identify this plant species. Provide the scientific name, common name, and confidence level."
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64.b64encode(image_data).decode()}"
                            }
                        }
                    ]
                }
            ],
            max_tokens=300
        )
        
        # Parse response and enrich with database info
        return await self._enrich_identification(response)
```

### Plant Care System

```python
class PlantCareSchedule(Base):
    __tablename__ = "plant_care_schedules"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID, ForeignKey("users.id"))
    plant_id = Column(UUID, ForeignKey("user_plants.id"))
    care_type = Column(String)  # watering, fertilizing, pruning
    frequency_days = Column(Integer)
    last_completed = Column(DateTime)
    next_due = Column(DateTime)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

class PlantCareService:
    async def create_care_schedule(self, user_id: str, plant_id: str, care_data: dict):
        schedule = PlantCareSchedule(
            user_id=user_id,
            plant_id=plant_id,
            care_type=care_data['type'],
            frequency_days=care_data['frequency'],
            next_due=datetime.utcnow() + timedelta(days=care_data['frequency'])
        )
        # Save and schedule notifications
        return await self._save_and_schedule(schedule)
```

### Frontend Plant Features

```dart
// Plant identification widget
class PlantIdentificationWidget extends ConsumerWidget {
  const PlantIdentificationWidget({Key? key, required this.imageFile}) : super(key: key);
  
  final File imageFile;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ref.watch(plantIdentificationProvider(imageFile)).when(
      data: (identification) => PlantResultCard(identification: identification),
      loading: () => const PlantIdentificationLoader(),
      error: (error, stack) => PlantIdentificationError(error: error),
    );
  }
}

// Plant care reminder provider
final plantCareProvider = StateNotifierProvider<PlantCareNotifier, PlantCareState>(
  (ref) => PlantCareNotifier(ref.read(plantCareServiceProvider)),
);

class PlantCareNotifier extends StateNotifier<PlantCareState> {
  PlantCareNotifier(this._careService) : super(PlantCareState.initial());
  
  final PlantCareService _careService;
  
  Future<void> addPlantToCollection(PlantIdentification plant) async {
    state = state.copyWith(isLoading: true);
    try {
      final userPlant = await _careService.addPlant(plant);
      state = state.copyWith(
        plants: [...state.plants, userPlant],
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(error: e.toString(), isLoading: false);
    }
  }
}
```

---

## Database Schema Updates

### New Tables

```sql
-- Plant species database
CREATE TABLE plant_species (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    scientific_name VARCHAR(255) NOT NULL,
    common_names TEXT[], -- Array of common names
    family VARCHAR(100),
    care_level VARCHAR(20), -- easy, moderate, difficult
    light_requirements VARCHAR(50),
    water_frequency_days INTEGER,
    humidity_preference VARCHAR(20),
    temperature_range VARCHAR(50),
    toxicity_info TEXT,
    care_notes TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- User's plant collection
CREATE TABLE user_plants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    species_id UUID REFERENCES plant_species(id),
    custom_name VARCHAR(100),
    acquisition_date DATE,
    location VARCHAR(100), -- room/area where plant is kept
    notes TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Plant identification history
CREATE TABLE plant_identifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    image_url TEXT NOT NULL,
    identified_species_id UUID REFERENCES plant_species(id),
    confidence_score DECIMAL(3,2),
    alternative_suggestions JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Plant care schedules
CREATE TABLE plant_care_schedules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    plant_id UUID REFERENCES user_plants(id),
    care_type VARCHAR(50), -- watering, fertilizing, pruning, repotting
    frequency_days INTEGER,
    last_completed TIMESTAMP,
    next_due TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Plant care logs
CREATE TABLE plant_care_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    schedule_id UUID REFERENCES plant_care_schedules(id),
    user_id UUID REFERENCES users(id),
    plant_id UUID REFERENCES user_plants(id),
    care_type VARCHAR(50),
    completed_at TIMESTAMP DEFAULT NOW(),
    notes TEXT,
    before_image_url TEXT,
    after_image_url TEXT
);

-- Plant trading posts
CREATE TABLE plant_trades (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    plant_species_id UUID REFERENCES plant_species(id),
    trade_type VARCHAR(20), -- offering, seeking, swap
    title VARCHAR(200),
    description TEXT,
    location VARCHAR(100),
    image_urls TEXT[],
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '30 days'
);

-- Plant community Q&A
CREATE TABLE plant_questions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    species_id UUID REFERENCES plant_species(id),
    title VARCHAR(200),
    question_text TEXT,
    image_urls TEXT[],
    tags TEXT[],
    status VARCHAR(20) DEFAULT 'open',
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE plant_answers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    question_id UUID REFERENCES plant_questions(id),
    user_id UUID REFERENCES users(id),
    answer_text TEXT,
    image_urls TEXT[],
    is_accepted BOOLEAN DEFAULT false,
    upvotes INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Indexes for Performance

```sql
-- Plant identification queries
CREATE INDEX idx_plant_species_common_names ON plant_species USING GIN(common_names);
CREATE INDEX idx_plant_species_scientific ON plant_species(scientific_name);

-- User plant collection
CREATE INDEX idx_user_plants_user_active ON user_plants(user_id, is_active);
CREATE INDEX idx_user_plants_species ON user_plants(species_id);

-- Care schedules
CREATE INDEX idx_care_schedules_user_active ON plant_care_schedules(user_id, is_active);
CREATE INDEX idx_care_schedules_next_due ON plant_care_schedules(next_due) WHERE is_active = true;

-- Trading and community
CREATE INDEX idx_plant_trades_location_status ON plant_trades(location, status);
CREATE INDEX idx_plant_questions_tags ON plant_questions USING GIN(tags);
```

---

## API Endpoints

### Plant Identification
```
POST /api/v1/plants/identify
GET /api/v1/plants/species/{species_id}
GET /api/v1/plants/search?q={query}
GET /api/v1/plants/identification-history
```

### Plant Collection Management
```
POST /api/v1/plants/collection/add
GET /api/v1/plants/collection
PUT /api/v1/plants/collection/{plant_id}
DELETE /api/v1/plants/collection/{plant_id}
```

### Plant Care
```
POST /api/v1/plants/care/schedule
GET /api/v1/plants/care/schedules
PUT /api/v1/plants/care/complete/{schedule_id}
GET /api/v1/plants/care/upcoming
GET /api/v1/plants/care/history/{plant_id}
```

### Community Features
```
POST /api/v1/plants/trades
GET /api/v1/plants/trades/nearby
POST /api/v1/plants/questions
GET /api/v1/plants/questions/feed
POST /api/v1/plants/answers
```

---

## Success Metrics

- [x] Plant identification accuracy > 80% for common species
- [x] Users can successfully add plants to their collection
- [x] Care reminders are delivered on schedule
- [x] Plant-themed AR filters work smoothly
- [x] Community features encourage user engagement
- [x] Discovery feed shows relevant plant content
- [x] Plant trading system facilitates connections
- [x] Q&A system provides helpful answers

---

## Relevant Files

**Backend Plant Services**:
- `app/services/plant_identification_service.py` - AI-powered plant identification (implemented)
- `app/services/user_plant_service.py` - User plant collection management (implemented)
- `app/services/plant_species_service.py` - Plant species data management (implemented)
- `app/services/plant_care_log_service.py` - Care logging and tracking (implemented)
- `app/services/plant_trade_service.py` - Plant trading system (implemented)
- `app/services/plant_question_service.py` - Q&A system with answers (implemented)
- `app/models/plant_species.py` - Plant species database model (implemented)
- `app/models/user_plant.py` - User plant collection model (implemented)
- `app/models/plant_identification.py` - Plant ID history model (implemented)
- `app/models/plant_care_log.py` - Care schedule and log models (implemented)
- `app/models/plant_trade.py` - Plant trading model (implemented)
- `app/models/plant_question.py` - Q&A models (implemented)
- `app/api/api_v1/endpoints/plant_species.py` - Plant species API endpoints (implemented)

**Frontend Plant Features**:
- `lib/features/plant_identification/` - Plant ID camera and results (implemented)
  - `models/plant_identification_models.dart` - Data models (implemented)
  - `presentation/screens/` - UI screens (implemented)
  - `presentation/widgets/` - UI components (implemented)
  - `providers/plant_identification_provider.dart` - State management (implemented)
  - `services/plant_identification_service.dart` - API service (implemented)
- `lib/features/plant_care/` - Care schedules and reminders (implemented)
  - `models/plant_care_models.dart` - Data models (implemented)
  - `presentation/screens/` - UI screens (implemented)
  - `presentation/widgets/` - UI components (implemented)
  - `providers/plant_care_provider.dart` - State management (implemented)
  - `services/plant_care_service.dart` - API service (implemented)
- `lib/features/plant_community/` - Trading and Q&A interfaces (implemented)
  - `models/plant_community_models.dart` - Data models (implemented)
  - `presentation/screens/` - UI screens (implemented)
  - `presentation/widgets/` - UI components (implemented)
  - `providers/plant_community_provider.dart` - State management (implemented)
  - `services/plant_community_service.dart` - API service (implemented)

**AR and Camera Enhancements**:
- `lib/features/camera/widgets/plant_filters.dart` - Plant-themed AR filters
- `lib/features/camera/services/plant_overlay_service.dart` - Plant info overlays

**Database and Configuration**:
- `database/migrations/003_plant_features.sql` - Plant-related schema
- `database/seeds/plant_species.sql` - Initial plant species data
- `app/core/plant_config.py` - Plant identification configuration

---

## Phase 2 Completion Summary

**Status**:  **COMPLETED** (100% complete)

**Completed Features**:
-  AI-powered plant identification with OpenAI Vision API
-  Comprehensive plant species database and models
-  Plant care scheduling and reminder system
-  User plant collection management
-  Plant trading and sharing system
-  Plant community Q&A system
-  Plant-focused content discovery and filtering
-  Complete backend services and database schema
-  Full frontend implementation with state management

**Completed in Final Push**:
-  Advanced AR filters (plant growth time-lapse, health overlays, seasonal effects)
-  Plant achievement and milestone tracking system
-  Local nursery and garden center integration
-  All API endpoints integrated and functional

**Implementation Results**:
- Plant identification system is functional and accurate
- Care reminder system helps users maintain their plants
- Community features encourage plant enthusiast engagement
- Trading system facilitates plant sharing
- Q&A system connects beginners with experts
- Robust data foundation for RAG features

---

## Next Phase Preview

Phase 3 will implement advanced RAG capabilities:
- Personalized plant care recommendations using user history
- Intelligent content generation for plant posts
- Context-aware plant problem diagnosis
- Advanced plant community matching
- Seasonal care optimization using local weather data

The plant-focused features in Phase 2 provide the data foundation and user engagement patterns needed for sophisticated RAG implementation.
</file>

<file path="frontend/lib/core/services/api_service.dart">
/// Core API service for handling HTTP requests and responses
/// Provides centralized API communication with error handling and authentication
library;
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../exceptions/api_exception.dart';
/// Provider for the API service singleton
final apiServiceProvider = Provider<ApiService>((ref) {
  return ApiService();
});
/// Main API service class for handling all HTTP operations
class ApiService {
  late final Dio _dio;
  ApiService() {
    _dio = Dio();
    _setupInterceptors();
  }
  /// Configure Dio interceptors for logging and error handling
  void _setupInterceptors() {
    _dio.options.baseUrl = 'http://localhost:8000/api';
    _dio.options.connectTimeout = const Duration(seconds: 30);
    _dio.options.receiveTimeout = const Duration(seconds: 30);
  }
  /// Generic GET request handler
  Future<T> get<T>(String endpoint, {Map<String, dynamic>? queryParameters}) async {
    try {
      final response = await _dio.get(endpoint, queryParameters: queryParameters);
      return response.data as T;
    } on DioException catch (e) {
      throw ApiException(
        message: e.message ?? 'Unknown error occurred',
        statusCode: e.response?.statusCode ?? 0,
        type: _getExceptionType(e),
      );
    }
  }
  /// Generic POST request handler
  Future<T> post<T>(String endpoint, {dynamic data, Map<String, dynamic>? queryParameters}) async {
    try {
      final response = await _dio.post(endpoint, data: data, queryParameters: queryParameters);
      return response.data as T;
    } on DioException catch (e) {
      throw _createApiException(e);
    }
  }
  /// Generic PUT request handler
  Future<T> put<T>(String endpoint, {dynamic data, Map<String, dynamic>? queryParameters}) async {
    try {
      final response = await _dio.put(endpoint, data: data, queryParameters: queryParameters);
      return response.data as T;
    } on DioException catch (e) {
      throw _createApiException(e);
    }
  }
  /// Generic DELETE request handler
  Future<T> delete<T>(String endpoint, {Map<String, dynamic>? queryParameters}) async {
    try {
      final response = await _dio.delete(endpoint, queryParameters: queryParameters);
      return response.data as T;
    } on DioException catch (e) {
      throw _createApiException(e);
    }
  }
  /// Upload file with multipart form data
  Future<T> uploadFile<T>(String endpoint, String filePath, {Map<String, dynamic>? additionalData}) async {
    try {
      final formData = FormData.fromMap({
        'file': await MultipartFile.fromFile(filePath),
        ...?additionalData,
      });
      final response = await _dio.post(endpoint, data: formData);
      return response.data as T;
    } on DioException catch (e) {
      throw _createApiException(e);
    }
  }
  /// Helper method to create ApiException from DioException
  ApiException _createApiException(DioException e) {
    return ApiException(
      message: e.message ?? 'Unknown error occurred',
      statusCode: e.response?.statusCode ?? 0,
      type: _getExceptionType(e),
    );
  }
  /// Helper method to determine exception type from DioException
  ApiExceptionType _getExceptionType(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return ApiExceptionType.timeout;
      case DioExceptionType.connectionError:
        return ApiExceptionType.network;
      case DioExceptionType.cancel:
        return ApiExceptionType.cancel;
      case DioExceptionType.badResponse:
        final statusCode = e.response?.statusCode ?? 0;
        if (statusCode >= 400 && statusCode < 500) {
          switch (statusCode) {
            case 400:
              return ApiExceptionType.badRequest;
            case 401:
              return ApiExceptionType.unauthorized;
            case 403:
              return ApiExceptionType.forbidden;
            case 404:
              return ApiExceptionType.notFound;
            case 409:
              return ApiExceptionType.conflict;
            case 422:
              return ApiExceptionType.validation;
            case 429:
              return ApiExceptionType.tooManyRequests;
            default:
              return ApiExceptionType.badRequest;
          }
        } else if (statusCode >= 500) {
          return ApiExceptionType.server;
        }
        return ApiExceptionType.unknown;
      default:
        return ApiExceptionType.unknown;
    }
  }
}
</file>

<file path="frontend/lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
class AppTheme {
  // Plant-focused color palette
  static const Color primaryGreen = Color(0xFF2E7D32);
  static const Color lightGreen = Color(0xFF4CAF50);
  static const Color darkGreen = Color(0xFF1B5E20);
  static const Color accentGreen = Color(0xFF81C784);
  static const Color earthBrown = Color(0xFF5D4037);
  static const Color lightBrown = Color(0xFF8D6E63);
  static const Color darkBrown = Color(0xFF3E2723);
  static const Color sunYellow = Color(0xFFFFC107);
  static const Color skyBlue = Color(0xFF03A9F4);
  static const Color flowerPink = Color(0xFFE91E63);
  static const Color backgroundLight = Color(0xFFF8F9FA);
  static const Color backgroundDark = Color(0xFF121212);
  static const Color surfaceLight = Color(0xFFFFFFFF);
  static const Color surfaceDark = Color(0xFF1E1E1E);
  static const Color textPrimary = Color(0xFF212121);
  static const Color textSecondary = Color(0xFF757575);
  static const Color textLight = Color(0xFFFFFFFF);
  static const Color error = Color(0xFFD32F2F);
  static const Color warning = Color(0xFFF57C00);
  static const Color success = Color(0xFF388E3C);
  static const Color info = Color(0xFF1976D2);
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: const ColorScheme.light(
        primary: primaryGreen,
        secondary: accentGreen,
        tertiary: sunYellow,
        surface: surfaceLight,
        background: backgroundLight,
        error: error,
        onPrimary: textLight,
        onSecondary: textPrimary,
        onSurface: textPrimary,
        onBackground: textPrimary,
        onError: textLight,
      ),
      textTheme: _buildTextTheme(textPrimary),
      appBarTheme: _buildAppBarTheme(true),
      elevatedButtonTheme: _buildElevatedButtonTheme(true),
      outlinedButtonTheme: _buildOutlinedButtonTheme(true),
      textButtonTheme: _buildTextButtonTheme(true),
      inputDecorationTheme: _buildInputDecorationTheme(true),
      cardTheme: _buildCardTheme(true),
      bottomNavigationBarTheme: _buildBottomNavTheme(true),
      floatingActionButtonTheme: _buildFABTheme(true),
      chipTheme: _buildChipTheme(true),
    );
  }
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: const ColorScheme.dark(
        primary: lightGreen,
        secondary: accentGreen,
        tertiary: sunYellow,
        surface: surfaceDark,
        background: backgroundDark,
        error: error,
        onPrimary: textPrimary,
        onSecondary: textPrimary,
        onSurface: textLight,
        onBackground: textLight,
        onError: textLight,
      ),
      textTheme: _buildTextTheme(textLight),
      appBarTheme: _buildAppBarTheme(false),
      elevatedButtonTheme: _buildElevatedButtonTheme(false),
      outlinedButtonTheme: _buildOutlinedButtonTheme(false),
      textButtonTheme: _buildTextButtonTheme(false),
      inputDecorationTheme: _buildInputDecorationTheme(false),
      cardTheme: _buildCardTheme(false),
      bottomNavigationBarTheme: _buildBottomNavTheme(false),
      floatingActionButtonTheme: _buildFABTheme(false),
      chipTheme: _buildChipTheme(false),
    );
  }
  static TextTheme _buildTextTheme(Color textColor) {
    return GoogleFonts.interTextTheme().copyWith(
      displayLarge: GoogleFonts.inter(
        fontSize: 32,
        fontWeight: FontWeight.bold,
        color: textColor,
      ),
      displayMedium: GoogleFonts.inter(
        fontSize: 28,
        fontWeight: FontWeight.bold,
        color: textColor,
      ),
      displaySmall: GoogleFonts.inter(
        fontSize: 24,
        fontWeight: FontWeight.w600,
        color: textColor,
      ),
      headlineLarge: GoogleFonts.inter(
        fontSize: 22,
        fontWeight: FontWeight.w600,
        color: textColor,
      ),
      headlineMedium: GoogleFonts.inter(
        fontSize: 20,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      headlineSmall: GoogleFonts.inter(
        fontSize: 18,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      titleLarge: GoogleFonts.inter(
        fontSize: 16,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      titleMedium: GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      titleSmall: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      bodyLarge: GoogleFonts.inter(
        fontSize: 16,
        fontWeight: FontWeight.normal,
        color: textColor,
      ),
      bodyMedium: GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.normal,
        color: textColor,
      ),
      bodySmall: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.normal,
        color: textSecondary,
      ),
      labelLarge: GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      labelMedium: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
      labelSmall: GoogleFonts.inter(
        fontSize: 10,
        fontWeight: FontWeight.w500,
        color: textSecondary,
      ),
    );
  }
  static AppBarTheme _buildAppBarTheme(bool isLight) {
    return AppBarTheme(
      elevation: 0,
      centerTitle: true,
      backgroundColor: isLight ? surfaceLight : surfaceDark,
      foregroundColor: isLight ? textPrimary : textLight,
      titleTextStyle: GoogleFonts.inter(
        fontSize: 18,
        fontWeight: FontWeight.w600,
        color: isLight ? textPrimary : textLight,
      ),
    );
  }
  static ElevatedButtonThemeData _buildElevatedButtonTheme(bool isLight) {
    return ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primaryGreen,
        foregroundColor: textLight,
        elevation: 2,
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        textStyle: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
  static OutlinedButtonThemeData _buildOutlinedButtonTheme(bool isLight) {
    return OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: primaryGreen,
        side: const BorderSide(color: primaryGreen, width: 1.5),
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        textStyle: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
  static TextButtonThemeData _buildTextButtonTheme(bool isLight) {
    return TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: primaryGreen,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        textStyle: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
  static InputDecorationTheme _buildInputDecorationTheme(bool isLight) {
    return InputDecorationTheme(
      filled: true,
      fillColor: isLight ? Colors.grey[50] : Colors.grey[900],
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: Colors.grey[300]!),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: Colors.grey[300]!),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: primaryGreen, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: error, width: 1),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      labelStyle: GoogleFonts.inter(
        fontSize: 14,
        color: textSecondary,
      ),
      hintStyle: GoogleFonts.inter(
        fontSize: 14,
        color: textSecondary,
      ),
    );
  }
  static CardThemeData _buildCardTheme(bool isLight) {
    return CardThemeData(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      color: isLight ? surfaceLight : surfaceDark,
    );
  }
  static BottomNavigationBarThemeData _buildBottomNavTheme(bool isLight) {
    return BottomNavigationBarThemeData(
      backgroundColor: isLight ? surfaceLight : surfaceDark,
      selectedItemColor: primaryGreen,
      unselectedItemColor: textSecondary,
      type: BottomNavigationBarType.fixed,
      elevation: 8,
      selectedLabelStyle: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.w600,
      ),
      unselectedLabelStyle: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.normal,
      ),
    );
  }
  static FloatingActionButtonThemeData _buildFABTheme(bool isLight) {
    return const FloatingActionButtonThemeData(
      backgroundColor: primaryGreen,
      foregroundColor: textLight,
      elevation: 4,
    );
  }
  static ChipThemeData _buildChipTheme(bool isLight) {
    return ChipThemeData(
      backgroundColor: isLight ? Colors.grey[100] : Colors.grey[800],
      selectedColor: accentGreen,
      labelStyle: GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.w500,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
    );
  }
}
</file>

<file path="frontend/lib/core/widgets/custom_button.dart">
/// Reusable custom button widgets for consistent styling across the app
/// Provides various button styles with loading states and customization options
library;
import 'package:flutter/material.dart';
import 'loading_widget.dart';
/// Primary custom button with loading state support
class CustomButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final bool isEnabled;
  final IconData? icon;
  final Color? backgroundColor;
  final Color? textColor;
  final double? width;
  final double height;
  final EdgeInsets? padding;
  final BorderRadius? borderRadius;
  const CustomButton({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.icon,
    this.backgroundColor,
    this.textColor,
    this.width,
    this.height = 48,
    this.padding,
    this.borderRadius,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDisabled = !isEnabled || isLoading || onPressed == null;
    return SizedBox(
      width: width,
      height: height,
      child: ElevatedButton(
        onPressed: isDisabled ? null : onPressed,
        style: ElevatedButton.styleFrom(
          backgroundColor: backgroundColor ?? theme.primaryColor,
          foregroundColor: textColor ?? Colors.white,
          disabledBackgroundColor: theme.disabledColor,
          disabledForegroundColor: theme.colorScheme.onSurface.withValues(alpha: 0.38),
          padding: padding ?? const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: borderRadius ?? BorderRadius.circular(8),
          ),
          elevation: isDisabled ? 0 : 2,
        ),
        child: isLoading
            ? const SmallLoadingWidget(color: Colors.white)
            : Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (icon != null) ...[
                    Icon(icon, size: 18),
                    const SizedBox(width: 8),
                  ],
                  Text(
                    text,
                    style: theme.textTheme.labelLarge?.copyWith(
                      color: textColor ?? Colors.white,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
      ),
    );
  }
}
/// Secondary/outline button variant
class CustomOutlineButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final bool isEnabled;
  final IconData? icon;
  final Color? borderColor;
  final Color? textColor;
  final double? width;
  final double height;
  final EdgeInsets? padding;
  final BorderRadius? borderRadius;
  const CustomOutlineButton({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.icon,
    this.borderColor,
    this.textColor,
    this.width,
    this.height = 48,
    this.padding,
    this.borderRadius,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDisabled = !isEnabled || isLoading || onPressed == null;
    final effectiveBorderColor = borderColor ?? theme.primaryColor;
    final effectiveTextColor = textColor ?? theme.primaryColor;
    return SizedBox(
      width: width,
      height: height,
      child: OutlinedButton(
        onPressed: isDisabled ? null : onPressed,
        style: OutlinedButton.styleFrom(
          foregroundColor: effectiveTextColor,
          disabledForegroundColor: theme.disabledColor,
          padding: padding ?? const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          side: BorderSide(
            color: isDisabled ? theme.disabledColor : effectiveBorderColor,
            width: 1.5,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: borderRadius ?? BorderRadius.circular(8),
          ),
        ),
        child: isLoading
            ? SmallLoadingWidget(color: effectiveTextColor)
            : Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (icon != null) ...[
                    Icon(icon, size: 18),
                    const SizedBox(width: 8),
                  ],
                  Text(
                    text,
                    style: theme.textTheme.labelLarge?.copyWith(
                      color: effectiveTextColor,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
      ),
    );
  }
}
/// Text button variant
class CustomTextButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final bool isEnabled;
  final IconData? icon;
  final Color? textColor;
  final EdgeInsets? padding;
  const CustomTextButton({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.icon,
    this.textColor,
    this.padding,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDisabled = !isEnabled || isLoading || onPressed == null;
    final effectiveTextColor = textColor ?? theme.primaryColor;
    return TextButton(
      onPressed: isDisabled ? null : onPressed,
      style: TextButton.styleFrom(
        foregroundColor: effectiveTextColor,
        disabledForegroundColor: theme.disabledColor,
        padding: padding ?? const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      child: isLoading
          ? SmallLoadingWidget(color: effectiveTextColor)
          : Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (icon != null) ...[
                  Icon(icon, size: 18),
                  const SizedBox(width: 8),
                ],
                Text(
                  text,
                  style: theme.textTheme.labelLarge?.copyWith(
                    color: effectiveTextColor,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
    );
  }
}
/// Floating action button variant
class CustomFloatingActionButton extends StatelessWidget {
  final VoidCallback? onPressed;
  final IconData icon;
  final bool isLoading;
  final Color? backgroundColor;
  final Color? iconColor;
  final double? size;
  const CustomFloatingActionButton({
    super.key,
    this.onPressed,
    required this.icon,
    this.isLoading = false,
    this.backgroundColor,
    this.iconColor,
    this.size,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return FloatingActionButton(
      onPressed: isLoading ? null : onPressed,
      backgroundColor: backgroundColor ?? theme.primaryColor,
      child: isLoading
          ? const SmallLoadingWidget(color: Colors.white)
          : Icon(
              icon,
              color: iconColor ?? Colors.white,
              size: size ?? 24,
            ),
    );
  }
}
</file>

<file path="frontend/lib/core/widgets/error_widget.dart">
/// Reusable error widget for consistent error states across the app
/// Provides customizable error displays with retry functionality
library;
import 'package:flutter/material.dart';
/// Standard error widget with icon, message, and optional retry button
class CustomErrorWidget extends StatelessWidget {
  final String message;
  final String? title;
  final IconData? icon;
  final VoidCallback? onRetry;
  final String? retryText;
  const CustomErrorWidget({
    super.key,
    required this.message,
    this.title,
    this.icon,
    this.onRetry,
    this.retryText,
  });
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon ?? Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            if (title != null) ...[
              Text(
                title!,
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: Theme.of(context).colorScheme.error,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
            ],
            Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).textTheme.bodyMedium?.color?.withValues(alpha: 0.7),
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: Text(retryText ?? 'Retry'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Theme.of(context).primaryColor,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
/// Compact error widget for inline error states
class InlineErrorWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final EdgeInsets? padding;
  const InlineErrorWidget({
    super.key,
    required this.message,
    this.onRetry,
    this.padding,
  });
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: padding ?? const EdgeInsets.all(16),
      child: Row(
        children: [
          Icon(
            Icons.error_outline,
            color: Theme.of(context).colorScheme.error,
            size: 20,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              message,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ),
          if (onRetry != null) ...[
            const SizedBox(width: 8),
            TextButton(
              onPressed: onRetry,
              child: const Text('Retry'),
            ),
          ],
        ],
      ),
    );
  }
}
/// Network error widget with specific messaging
class NetworkErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  const NetworkErrorWidget({
    super.key,
    this.onRetry,
  });
  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: 'Connection Error',
      message: 'Please check your internet connection and try again.',
      icon: Icons.wifi_off,
      onRetry: onRetry,
      retryText: 'Try Again',
    );
  }
}
/// Empty state widget for when no data is available
class EmptyStateWidget extends StatelessWidget {
  final String message;
  final String? title;
  final IconData? icon;
  final Widget? action;
  const EmptyStateWidget({
    super.key,
    required this.message,
    this.title,
    this.icon,
    this.action,
  });
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon ?? Icons.inbox_outlined,
              size: 64,
              color: Theme.of(context).textTheme.bodyMedium?.color?.withValues(alpha: 0.5),
            ),
            const SizedBox(height: 16),
            if (title != null) ...[
              Text(
                title!,
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: Theme.of(context).textTheme.bodyMedium?.color?.withValues(alpha: 0.7),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
            ],
            Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).textTheme.bodyMedium?.color?.withValues(alpha: 0.5),
              ),
              textAlign: TextAlign.center,
            ),
            if (action != null) ...[
              const SizedBox(height: 24),
              action!,
            ],
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/core/widgets/loading_widget.dart">
/**
 * Reusable loading widget for consistent loading states across the app
 * Provides customizable loading indicators with optional text
 */
import 'package:flutter/material.dart';
/**
 * Standard loading widget with circular progress indicator
 */
class LoadingWidget extends StatelessWidget {
  final String? message;
  final double? size;
  final Color? color;
  const LoadingWidget({
    super.key,
    this.message,
    this.size,
    this.color,
  });
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(
            width: size ?? 40,
            height: size ?? 40,
            child: CircularProgressIndicator(
              color: color ?? Theme.of(context).primaryColor,
              strokeWidth: 3,
            ),
          ),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context)
                        .textTheme
                        .bodyMedium
                        ?.color
                        ?.withValues(alpha: 0.7),
                  ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}
/**
 * Small inline loading widget for buttons or small spaces
 */
class SmallLoadingWidget extends StatelessWidget {
  final Color? color;
  final double size;
  const SmallLoadingWidget({
    super.key,
    this.color,
    this.size = 16,
  });
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: size,
      height: size,
      child: CircularProgressIndicator(
        color: color ?? Colors.white,
        strokeWidth: 2,
      ),
    );
  }
}
/**
 * Shimmer loading effect for content placeholders
 */
class ShimmerLoading extends StatefulWidget {
  final Widget child;
  final bool isLoading;
  const ShimmerLoading({
    super.key,
    required this.child,
    required this.isLoading,
  });
  @override
  State<ShimmerLoading> createState() => _ShimmerLoadingState();
}
class _ShimmerLoadingState extends State<ShimmerLoading>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );
    _animation = Tween<double>(begin: -1.0, end: 2.0).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
    if (widget.isLoading) {
      _controller.repeat();
    }
  }
  @override
  void didUpdateWidget(ShimmerLoading oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isLoading && !_controller.isAnimating) {
      _controller.repeat();
    } else if (!widget.isLoading && _controller.isAnimating) {
      _controller.stop();
    }
  }
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    if (!widget.isLoading) {
      return widget.child;
    }
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return ShaderMask(
          shaderCallback: (bounds) {
            return LinearGradient(
              begin: Alignment.centerLeft,
              end: Alignment.centerRight,
              colors: const [
                Colors.transparent,
                Colors.white54,
                Colors.transparent,
              ],
              stops: [
                _animation.value - 0.3,
                _animation.value,
                _animation.value + 0.3,
              ],
            ).createShader(bounds);
          },
          child: widget.child,
        );
      },
    );
  }
}
</file>

<file path="frontend/lib/core/widgets/user_avatar.dart">
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
class UserAvatar extends StatelessWidget {
  final String? imageUrl;
  final String username;
  final double size;
  final VoidCallback? onTap;
  final bool showOnlineIndicator;
  final bool isOnline;
  final Color? backgroundColor;
  final Color? textColor;
  final Widget? badge;
  const UserAvatar({
    super.key,
    this.imageUrl,
    required this.username,
    this.size = 40,
    this.onTap,
    this.showOnlineIndicator = false,
    this.isOnline = false,
    this.backgroundColor,
    this.textColor,
    this.badge,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    Widget avatar = Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: backgroundColor ?? _getBackgroundColor(username),
        border: Border.all(
          color: Colors.white,
          width: 2,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipOval(
        child: _buildAvatarContent(theme),
      ),
    );
    // Add online indicator if needed
    if (showOnlineIndicator) {
      avatar = Stack(
        children: [
          avatar,
          Positioned(
            right: 0,
            bottom: 0,
            child: Container(
              width: size * 0.25,
              height: size * 0.25,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: isOnline ? Colors.green : Colors.grey,
                border: Border.all(
                  color: Colors.white,
                  width: 2,
                ),
              ),
            ),
          ),
        ],
      );
    }
    // Add badge if provided
    if (badge != null) {
      avatar = Stack(
        children: [
          avatar,
          Positioned(
            right: -2,
            top: -2,
            child: badge!,
          ),
        ],
      );
    }
    // Make tappable if onTap is provided
    if (onTap != null) {
      avatar = GestureDetector(
        onTap: onTap,
        child: avatar,
      );
    }
    return avatar;
  }
  Widget _buildAvatarContent(ThemeData theme) {
    if (imageUrl != null && imageUrl!.isNotEmpty) {
      return Image.network(
        imageUrl!,
        width: size,
        height: size,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return _buildInitialsAvatar(theme);
        },
        loadingBuilder: (context, child, loadingProgress) {
          if (loadingProgress == null) return child;
          return Container(
            width: size,
            height: size,
            color: Colors.grey[200],
            child: Center(
              child: SizedBox(
                width: size * 0.4,
                height: size * 0.4,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    theme.primaryColor,
                  ),
                ),
              ),
            ),
          );
        },
      );
    }
    return _buildInitialsAvatar(theme);
  }
  Widget _buildInitialsAvatar(ThemeData theme) {
    final initials = _getInitials(username);
    final fontSize = size * 0.4;
    return Container(
      width: size,
      height: size,
      color: backgroundColor ?? _getBackgroundColor(username),
      child: Center(
        child: Text(
          initials,
          style: TextStyle(
            color: textColor ?? Colors.white,
            fontSize: fontSize,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
  String _getInitials(String name) {
    if (name.isEmpty) return '?';
    final words = name.trim().split(' ');
    if (words.length == 1) {
      return words[0].substring(0, 1).toUpperCase();
    }
    return (words[0].substring(0, 1) + words[1].substring(0, 1)).toUpperCase();
  }
  Color _getBackgroundColor(String name) {
    // Generate a consistent color based on the username
    final colors = [
      Colors.red[400]!,
      Colors.pink[400]!,
      Colors.purple[400]!,
      Colors.deepPurple[400]!,
      Colors.indigo[400]!,
      Colors.blue[400]!,
      Colors.lightBlue[400]!,
      Colors.cyan[400]!,
      Colors.teal[400]!,
      Colors.green[400]!,
      Colors.lightGreen[400]!,
      Colors.lime[400]!,
      Colors.yellow[400]!,
      Colors.amber[400]!,
      Colors.orange[400]!,
      Colors.deepOrange[400]!,
    ];
    final hash = name.hashCode;
    return colors[hash.abs() % colors.length];
  }
}
// Helper widget for creating avatar groups
class AvatarGroup extends StatelessWidget {
  final List<String> usernames;
  final List<String?> imageUrls;
  final double size;
  final int maxVisible;
  final VoidCallback? onTap;
  const AvatarGroup({
    super.key,
    required this.usernames,
    this.imageUrls = const [],
    this.size = 32,
    this.maxVisible = 3,
    this.onTap,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final visibleCount = usernames.length > maxVisible ? maxVisible : usernames.length;
    final remainingCount = usernames.length - maxVisible;
    return GestureDetector(
      onTap: onTap,
      child: SizedBox(
        width: size + (visibleCount - 1) * (size * 0.7),
        height: size,
        child: Stack(
          children: [
            // Visible avatars
            ...List.generate(visibleCount, (index) {
              final username = usernames[index];
              final imageUrl = index < imageUrls.length ? imageUrls[index] : null;
              return Positioned(
                left: index * (size * 0.7),
                child: UserAvatar(
                  username: username,
                  imageUrl: imageUrl,
                  size: size,
                ),
              );
            }),
            // Remaining count indicator
            if (remainingCount > 0)
              Positioned(
                left: visibleCount * (size * 0.7),
                child: Container(
                  width: size,
                  height: size,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: Colors.grey[600],
                    border: Border.all(
                      color: Colors.white,
                      width: 2,
                    ),
                  ),
                  child: Center(
                    child: Text(
                      '+$remainingCount',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: size * 0.3,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/core/widgets/vote_buttons.dart">
import 'package:flutter/material.dart';
enum VoteButtonSize {
  small,
  medium,
  large,
}
class VoteButtons extends StatelessWidget {
  final int upvotes;
  final int downvotes;
  final String? userVote; // 'upvote', 'downvote', or null
  final Function(String)? onVote;
  final VoteButtonSize size;
  final bool showDownvote;
  final bool horizontal;
  const VoteButtons({
    super.key,
    required this.upvotes,
    required this.downvotes,
    this.userVote,
    this.onVote,
    this.size = VoteButtonSize.medium,
    this.showDownvote = true,
    this.horizontal = true,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final dimensions = _getDimensions();
    final upvoteButton = _buildVoteButton(
      icon: Icons.keyboard_arrow_up,
      isSelected: userVote == 'upvote',
      onPressed: () => onVote?.call('upvote'),
      color: Colors.green,
      dimensions: dimensions,
    );
    final scoreText = Text(
      '${upvotes - downvotes}',
      style: TextStyle(
        fontSize: dimensions.fontSize,
        fontWeight: FontWeight.bold,
        color: _getScoreColor(theme),
      ),
    );
    final downvoteButton = showDownvote
        ? _buildVoteButton(
            icon: Icons.keyboard_arrow_down,
            isSelected: userVote == 'downvote',
            onPressed: () => onVote?.call('downvote'),
            color: Colors.red,
            dimensions: dimensions,
          )
        : null;
    if (horizontal) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          upvoteButton,
          SizedBox(width: dimensions.spacing),
          scoreText,
          if (downvoteButton != null) ...[
            SizedBox(width: dimensions.spacing),
            downvoteButton,
          ],
        ],
      );
    } else {
      return Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          upvoteButton,
          SizedBox(height: dimensions.spacing),
          scoreText,
          if (downvoteButton != null) ...[
            SizedBox(height: dimensions.spacing),
            downvoteButton,
          ],
        ],
      );
    }
  }
  Widget _buildVoteButton({
    required IconData icon,
    required bool isSelected,
    required VoidCallback? onPressed,
    required Color color,
    required _VoteDimensions dimensions,
  }) {
    return InkWell(
      onTap: onPressed,
      borderRadius: BorderRadius.circular(dimensions.borderRadius),
      child: Container(
        width: dimensions.buttonSize,
        height: dimensions.buttonSize,
        decoration: BoxDecoration(
          color: isSelected ? color.withOpacity(0.1) : Colors.transparent,
          borderRadius: BorderRadius.circular(dimensions.borderRadius),
          border: Border.all(
            color: isSelected ? color : Colors.grey[300]!,
            width: 1,
          ),
        ),
        child: Icon(
          icon,
          size: dimensions.iconSize,
          color: isSelected ? color : Colors.grey[600],
        ),
      ),
    );
  }
  Color _getScoreColor(ThemeData theme) {
    final score = upvotes - downvotes;
    if (score > 0) {
      return Colors.green[600]!;
    } else if (score < 0) {
      return Colors.red[600]!;
    } else {
      return Colors.grey[600]!;
    }
  }
  _VoteDimensions _getDimensions() {
    switch (size) {
      case VoteButtonSize.small:
        return _VoteDimensions(
          buttonSize: 28,
          iconSize: 16,
          fontSize: 12,
          spacing: 4,
          borderRadius: 6,
        );
      case VoteButtonSize.medium:
        return _VoteDimensions(
          buttonSize: 36,
          iconSize: 20,
          fontSize: 14,
          spacing: 6,
          borderRadius: 8,
        );
      case VoteButtonSize.large:
        return _VoteDimensions(
          buttonSize: 44,
          iconSize: 24,
          fontSize: 16,
          spacing: 8,
          borderRadius: 10,
        );
    }
  }
}
class _VoteDimensions {
  final double buttonSize;
  final double iconSize;
  final double fontSize;
  final double spacing;
  final double borderRadius;
  const _VoteDimensions({
    required this.buttonSize,
    required this.iconSize,
    required this.fontSize,
    required this.spacing,
    required this.borderRadius,
  });
}
// Simple vote counter widget without buttons
class VoteCounter extends StatelessWidget {
  final int upvotes;
  final int downvotes;
  final VoteButtonSize size;
  final bool showIndividualCounts;
  const VoteCounter({
    super.key,
    required this.upvotes,
    required this.downvotes,
    this.size = VoteButtonSize.medium,
    this.showIndividualCounts = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final score = upvotes - downvotes;
    final fontSize = _getFontSize();
    if (showIndividualCounts) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.keyboard_arrow_up,
            size: fontSize + 2,
            color: Colors.green[600],
          ),
          Text(
            '$upvotes',
            style: TextStyle(
              fontSize: fontSize,
              color: Colors.green[600],
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(width: 8),
          Icon(
            Icons.keyboard_arrow_down,
            size: fontSize + 2,
            color: Colors.red[600],
          ),
          Text(
            '$downvotes',
            style: TextStyle(
              fontSize: fontSize,
              color: Colors.red[600],
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      );
    }
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          score >= 0 ? Icons.keyboard_arrow_up : Icons.keyboard_arrow_down,
          size: fontSize + 2,
          color: score >= 0 ? Colors.green[600] : Colors.red[600],
        ),
        Text(
          score.abs().toString(),
          style: TextStyle(
            fontSize: fontSize,
            color: score >= 0 ? Colors.green[600] : Colors.red[600],
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }
  double _getFontSize() {
    switch (size) {
      case VoteButtonSize.small:
        return 12;
      case VoteButtonSize.medium:
        return 14;
      case VoteButtonSize.large:
        return 16;
    }
  }
}
</file>

<file path="frontend/lib/features/auth/models/auth_models.dart">
import 'package:json_annotation/json_annotation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:plant_social/core/models/user.dart';
part 'auth_models.freezed.dart';
part 'auth_models.g.dart';
@freezed
class LoginRequest with _$LoginRequest {
  const factory LoginRequest({
    required String email,
    required String password,
  }) = _LoginRequest;
  factory LoginRequest.fromJson(Map<String, dynamic> json) => _$LoginRequestFromJson(json);
}
@freezed
class RegisterRequest with _$RegisterRequest {
  const factory RegisterRequest({
    required String email,
    required String username,
    required String password,
    required String confirmPassword,
    String? displayName,
    String? inviteCode,
  }) = _RegisterRequest;
  factory RegisterRequest.fromJson(Map<String, dynamic> json) => _$RegisterRequestFromJson(json);
}
@freezed
class AuthResponse with _$AuthResponse {
  const factory AuthResponse({
    required String accessToken,
    required String refreshToken,
    required User user,
    String? tokenType,
    int? expiresIn,
  }) = _AuthResponse;
  factory AuthResponse.fromJson(Map<String, dynamic> json) => _$AuthResponseFromJson(json);
}
@freezed
class RefreshTokenRequest with _$RefreshTokenRequest {
  const factory RefreshTokenRequest({
    required String refreshToken,
  }) = _RefreshTokenRequest;
  factory RefreshTokenRequest.fromJson(Map<String, dynamic> json) => _$RefreshTokenRequestFromJson(json);
}
@freezed
class ForgotPasswordRequest with _$ForgotPasswordRequest {
  const factory ForgotPasswordRequest({
    required String email,
  }) = _ForgotPasswordRequest;
  factory ForgotPasswordRequest.fromJson(Map<String, dynamic> json) => _$ForgotPasswordRequestFromJson(json);
}
@freezed
class ResetPasswordRequest with _$ResetPasswordRequest {
  const factory ResetPasswordRequest({
    required String token,
    required String newPassword,
    required String confirmPassword,
  }) = _ResetPasswordRequest;
  factory ResetPasswordRequest.fromJson(Map<String, dynamic> json) => _$ResetPasswordRequestFromJson(json);
}
@freezed
class ChangePasswordRequest with _$ChangePasswordRequest {
  const factory ChangePasswordRequest({
    required String currentPassword,
    required String newPassword,
    required String confirmPassword,
  }) = _ChangePasswordRequest;
  factory ChangePasswordRequest.fromJson(Map<String, dynamic> json) => _$ChangePasswordRequestFromJson(json);
}
@freezed
class MessageResponse with _$MessageResponse {
  const factory MessageResponse({
    required String message,
    bool? success,
  }) = _MessageResponse;
  factory MessageResponse.fromJson(Map<String, dynamic> json) => _$MessageResponseFromJson(json);
}
</file>

<file path="frontend/lib/features/auth/presentation/widgets/auth_button.dart">
import 'package:flutter/material.dart';
class AuthButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final bool isSecondary;
  final IconData? icon;
  final Color? backgroundColor;
  final Color? textColor;
  final double? width;
  final double height;
  final EdgeInsetsGeometry? padding;
  const AuthButton({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isSecondary = false,
    this.icon,
    this.backgroundColor,
    this.textColor,
    this.width,
    this.height = 56,
    this.padding,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveBackgroundColor = backgroundColor ??
        (isSecondary ? theme.colorScheme.surface : theme.colorScheme.primary);
    final effectiveTextColor = textColor ??
        (isSecondary ? theme.colorScheme.primary : theme.colorScheme.onPrimary);
    return SizedBox(
      width: width ?? double.infinity,
      height: height,
      child: ElevatedButton(
        onPressed: isLoading ? null : onPressed,
        style: ElevatedButton.styleFrom(
          backgroundColor: effectiveBackgroundColor,
          foregroundColor: effectiveTextColor,
          disabledBackgroundColor: effectiveBackgroundColor.withOpacity(0.6),
          disabledForegroundColor: effectiveTextColor.withOpacity(0.6),
          elevation: isSecondary ? 0 : 2,
          shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: isSecondary
                ? BorderSide(
                    color: theme.colorScheme.outline.withOpacity(0.3),
                    width: 1,
                  )
                : BorderSide.none,
          ),
          padding: padding ??
              const EdgeInsets.symmetric(
                horizontal: 24,
                vertical: 16,
              ),
        ),
        child: isLoading
            ? SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    effectiveTextColor,
                  ),
                ),
              )
            : Row(
                mainAxisAlignment: MainAxisAlignment.center,
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (icon != null) ...[
                    Icon(
                      icon,
                      size: 20,
                      color: effectiveTextColor,
                    ),
                    const SizedBox(width: 8),
                  ],
                  Text(
                    text,
                    style: theme.textTheme.labelLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: effectiveTextColor,
                    ),
                  ),
                ],
              ),
      ),
    );
  }
}
class AuthIconButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback? onPressed;
  final String? tooltip;
  final Color? backgroundColor;
  final Color? iconColor;
  final double size;
  final bool isLoading;
  const AuthIconButton({
    super.key,
    required this.icon,
    this.onPressed,
    this.tooltip,
    this.backgroundColor,
    this.iconColor,
    this.size = 48,
    this.isLoading = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveBackgroundColor =
        backgroundColor ?? theme.colorScheme.surface;
    final effectiveIconColor = iconColor ?? theme.colorScheme.onSurface;
    return SizedBox(
      width: size,
      height: size,
      child: Material(
        color: effectiveBackgroundColor,
        borderRadius: BorderRadius.circular(12),
        child: InkWell(
          onTap: isLoading ? null : onPressed,
          borderRadius: BorderRadius.circular(12),
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: theme.colorScheme.outline.withOpacity(0.3),
                width: 1,
              ),
            ),
            child: isLoading
                ? Center(
                    child: SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          effectiveIconColor,
                        ),
                      ),
                    ),
                  )
                : Icon(
                    icon,
                    color: effectiveIconColor,
                    size: 20,
                  ),
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/auth/providers/auth_provider.dart">
import 'dart:convert';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:plant_social/core/constants/app_constants.dart';
import 'package:plant_social/core/models/user.dart';
<<<<<<< HEAD
import 'package:plant_social/core/exceptions/api_exception.dart';
=======
>>>>>>> baf556a5d654e56b6d571fc759b0e5caa549cb96
import 'package:plant_social/features/auth/models/auth_models.dart';
import 'package:plant_social/features/auth/repositories/auth_repository.dart';
part 'auth_provider.freezed.dart';
// part 'auth_provider.g.dart'; // Commented out until code generation works
class AuthState {
  final User? user;
  final bool isAuthenticated;
  final bool isLoading;
  final String? error;
  final bool isInitialized;
  const AuthState({
    this.user,
    this.isAuthenticated = false,
    this.isLoading = false,
    this.error,
    this.isInitialized = false,
  });
  AuthState copyWith({
    User? user,
    bool? isAuthenticated,
    bool? isLoading,
    String? error,
    bool? isInitialized,
  }) {
    return AuthState(
      user: user ?? this.user,
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      isInitialized: isInitialized ?? this.isInitialized,
    );
  }
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AuthState &&
        other.user == user &&
        other.isAuthenticated == isAuthenticated &&
        other.isLoading == isLoading &&
        other.error == error &&
        other.isInitialized == isInitialized;
  }
  @override
  int get hashCode {
    return user.hashCode ^
        isAuthenticated.hashCode ^
        isLoading.hashCode ^
        error.hashCode ^
        isInitialized.hashCode;
  }
}
class AuthNotifier extends StateNotifier<AuthState> {
  final AuthRepository _authRepository;
  final FlutterSecureStorage _storage;
  AuthNotifier(this._authRepository, this._storage) : super(const AuthState()) {
    _initializeAuth();
  }
  Future<void> _initializeAuth() async {
    try {
      state = state.copyWith(isLoading: true);
      // Check if user is already logged in
      final accessToken = await _storage.read(key: AppConstants.accessTokenKey);
      final userDataJson = await _storage.read(key: AppConstants.userDataKey);
      if (accessToken != null && userDataJson != null) {
        try {
          final userData = json.decode(userDataJson) as Map<String, dynamic>;
          final user = User.fromJson(userData);
          // Verify token is still valid by fetching current user
          final currentUser = await _authRepository.getCurrentUser();
          state = state.copyWith(
            user: currentUser,
            isAuthenticated: true,
            isLoading: false,
            isInitialized: true,
            error: null,
          );
        } catch (e) {
          // Token is invalid, clear storage
          await _clearAuthData();
          state = state.copyWith(
            isAuthenticated: false,
            isLoading: false,
            isInitialized: true,
            error: null,
          );
        }
      } else {
        state = state.copyWith(
          isAuthenticated: false,
          isLoading: false,
          isInitialized: true,
        );
      }
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        isInitialized: true,
        error: e.toString(),
      );
    }
  }
  Future<void> login(String email, String password) async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      final loginRequest = LoginRequest(
        email: email,
        password: password,
      );
      final authResponse = await _authRepository.login(loginRequest);
      // Store tokens and user data
      await _storeAuthData(authResponse);
      state = state.copyWith(
        user: authResponse.user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> register(RegisterRequest request) async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      final authResponse = await _authRepository.register(request);
      // Store tokens and user data
      await _storeAuthData(authResponse);
      state = state.copyWith(
        user: authResponse.user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> logout() async {
    try {
      state = state.copyWith(isLoading: true);
      // Call logout endpoint
      await _authRepository.logout();
    } catch (e) {
      // Continue with logout even if API call fails
      print('Logout API call failed: $e');
    } finally {
      // Clear local data regardless of API call result
      await _clearAuthData();
      state = const AuthState(
        isAuthenticated: false,
        isLoading: false,
        isInitialized: true,
      );
    }
  }
  Future<void> refreshUser() async {
    if (!state.isAuthenticated) return;
    try {
      final user = await _authRepository.getCurrentUser();
      // Update stored user data
      await _storage.write(
        key: AppConstants.userDataKey,
        value: json.encode(user.toJson()),
      );
      state = state.copyWith(user: user);
    } catch (e) {
      // If refresh fails, user might need to re-authenticate
      print('Failed to refresh user: $e');
    }
  }
  Future<void> updateUser(User updatedUser) async {
    // Update stored user data
    await _storage.write(
      key: AppConstants.userDataKey,
      value: json.encode(updatedUser.toJson()),
    );
    state = state.copyWith(user: updatedUser);
  }
  Future<void> _storeAuthData(AuthResponse authResponse) async {
    await Future.wait([
      _storage.write(
        key: AppConstants.accessTokenKey,
        value: authResponse.accessToken,
      ),
      _storage.write(
        key: AppConstants.refreshTokenKey,
        value: authResponse.refreshToken,
      ),
      _storage.write(
        key: AppConstants.userDataKey,
        value: json.encode(authResponse.user.toJson()),
      ),
    ]);
  }
  Future<void> _clearAuthData() async {
    await Future.wait([
      _storage.delete(key: AppConstants.accessTokenKey),
      _storage.delete(key: AppConstants.refreshTokenKey),
      _storage.delete(key: AppConstants.userDataKey),
    ]);
  }
  void clearError() {
    state = state.copyWith(error: null);
  }
}
// Providers
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  const storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      accessibility: KeychainAccessibility.first_unlock_this_device,
    ),
  );
  final authRepository = ref.watch(authRepositoryProvider);
  return AuthNotifier(authRepository, storage);
});
// Computed providers
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authProvider).user;
});
final isAuthenticatedProvider = Provider<bool>((ref) {
  return ref.watch(authProvider).isAuthenticated;
});
final isAuthLoadingProvider = Provider<bool>((ref) {
  return ref.watch(authProvider).isLoading;
});
final authErrorProvider = Provider<String?>((ref) {
  return ref.watch(authProvider).error;
});
final isAuthInitializedProvider = Provider<bool>((ref) {
  return ref.watch(authProvider).isInitialized;
});
</file>

<file path="frontend/lib/features/chat/presentation/screens/conversation_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
/// Individual conversation screen for messaging
/// Displays messages between the current user and another user
class ConversationScreen extends ConsumerStatefulWidget {
  final String userId;
  final String? userName;
  const ConversationScreen({
    super.key,
    required this.userId,
    this.userName,
  });
  @override
  ConsumerState<ConversationScreen> createState() => _ConversationScreenState();
}
class _ConversationScreenState extends ConsumerState<ConversationScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isTyping = false;
  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
  /// Mock messages for demonstration
  List<MockMessage> get _mockMessages => [
        MockMessage(
          id: '1',
          content: 'Hey! How are your plants doing?',
          senderId: widget.userId,
          timestamp: DateTime.now().subtract(const Duration(hours: 2)),
          isFromCurrentUser: false,
        ),
        MockMessage(
          id: '2',
          content: 'They\'re doing great! Just repotted my fiddle leaf fig ',
          senderId: 'current_user',
          timestamp:
              DateTime.now().subtract(const Duration(hours: 1, minutes: 45)),
          isFromCurrentUser: true,
        ),
        MockMessage(
          id: '3',
          content: 'That\'s awesome! I\'d love to see some photos',
          senderId: widget.userId,
          timestamp:
              DateTime.now().subtract(const Duration(hours: 1, minutes: 30)),
          isFromCurrentUser: false,
        ),
        MockMessage(
          id: '4',
          content: 'Sure! I\'ll take some and share them in my story',
          senderId: 'current_user',
          timestamp:
              DateTime.now().subtract(const Duration(hours: 1, minutes: 15)),
          isFromCurrentUser: true,
        ),
        MockMessage(
          id: '5',
          content: 'Perfect! Can\'t wait to see them ',
          senderId: widget.userId,
          timestamp: DateTime.now().subtract(const Duration(minutes: 30)),
          isFromCurrentUser: false,
        ),
      ];
  /// Send a message (placeholder implementation)
  Future<void> _sendMessage() async {
    final content = _messageController.text.trim();
    if (content.isEmpty) return;
    // Clear the input immediately
    _messageController.clear();
    // Show typing indicator
    setState(() {
      _isTyping = true;
    });
    try {
      // Simulate API call delay
      await Future.delayed(const Duration(milliseconds: 500));
      // In a real app, this would send the message to the backend
      // and update the messages list through a provider
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Message sent! (Demo mode)'),
            duration: Duration(seconds: 1),
          ),
        );
        // Scroll to bottom
        _scrollToBottom();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send message: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      setState(() {
        _isTyping = false;
      });
    }
  }
  /// Scroll to the bottom of the conversation
  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      appBar: AppBar(
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
        leading: IconButton(
          onPressed: () => context.pop(),
          icon: const Icon(Icons.arrow_back),
        ),
        title: Row(
          children: [
            CircleAvatar(
              radius: 20,
              backgroundColor: theme.colorScheme.primary,
              child: Text(
                widget.userName?.split(' ').map((name) => name[0]).join() ??
                    'U',
                style: TextStyle(
                  color: theme.colorScheme.onPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.userName ?? 'User',
                    style: theme.textTheme.titleMedium,
                  ),
                  Text(
                    'Online', // In a real app, this would be dynamic
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: Colors.green,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Voice call feature coming soon!'),
                ),
              );
            },
            icon: const Icon(Icons.phone),
          ),
          IconButton(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Video call feature coming soon!'),
                ),
              );
            },
            icon: const Icon(Icons.videocam),
          ),
        ],
      ),
      body: Column(
        children: [
          // Messages list
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              padding: const EdgeInsets.all(16),
              itemCount: _mockMessages.length,
              itemBuilder: (context, index) {
                final message = _mockMessages[index];
                return _buildMessageBubble(message, theme);
              },
            ),
          ),
          // Typing indicator
          if (_isTyping)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Row(
                children: [
                  const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    'Sending...',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.6),
                    ),
                  ),
                ],
              ),
            ),
          // Message input
          _buildMessageInput(theme),
        ],
      ),
    );
  }
  Widget _buildMessageBubble(MockMessage message, ThemeData theme) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        mainAxisAlignment: message.isFromCurrentUser
            ? MainAxisAlignment.end
            : MainAxisAlignment.start,
        children: [
          if (!message.isFromCurrentUser) ...[
            CircleAvatar(
              radius: 16,
              backgroundColor: theme.colorScheme.primary,
              child: Text(
                widget.userName?.split(' ').map((name) => name[0]).join() ??
                    'U',
                style: TextStyle(
                  color: theme.colorScheme.onPrimary,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          Flexible(
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: message.isFromCurrentUser
                    ? theme.colorScheme.primary
                    : theme.colorScheme.surfaceVariant,
                borderRadius: BorderRadius.circular(20).copyWith(
                  bottomLeft: message.isFromCurrentUser
                      ? const Radius.circular(20)
                      : const Radius.circular(4),
                  bottomRight: message.isFromCurrentUser
                      ? const Radius.circular(4)
                      : const Radius.circular(20),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    message.content,
                    style: TextStyle(
                      color: message.isFromCurrentUser
                          ? theme.colorScheme.onPrimary
                          : theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    _formatMessageTime(message.timestamp),
                    style: TextStyle(
                      color: message.isFromCurrentUser
                          ? theme.colorScheme.onPrimary.withOpacity(0.7)
                          : theme.colorScheme.onSurfaceVariant.withOpacity(0.7),
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
          ),
          if (message.isFromCurrentUser) ...[
            const SizedBox(width: 8),
            CircleAvatar(
              radius: 16,
              backgroundColor: theme.colorScheme.secondary,
              child: Icon(
                Icons.person,
                size: 16,
                color: theme.colorScheme.onSecondary,
              ),
            ),
          ],
        ],
      ),
    );
  }
  Widget _buildMessageInput(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(
          top: BorderSide(
            color: theme.colorScheme.outline.withOpacity(0.2),
          ),
        ),
      ),
      child: Row(
        children: [
          // Attachment button
          IconButton(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('File attachment feature coming soon!'),
                ),
              );
            },
            icon: const Icon(Icons.attach_file),
          ),
          // Message input field
          Expanded(
            child: TextField(
              controller: _messageController,
              decoration: InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(24),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: theme.colorScheme.surfaceVariant.withOpacity(0.5),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
              ),
              maxLines: null,
              textCapitalization: TextCapitalization.sentences,
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          // Send button
          IconButton(
            onPressed: _sendMessage,
            icon: Icon(
              Icons.send,
              color: theme.colorScheme.primary,
            ),
          ),
        ],
      ),
    );
  }
  String _formatMessageTime(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else {
      return '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
    }
  }
}
/// Mock message model for demonstration
class MockMessage {
  final String id;
  final String content;
  final String senderId;
  final DateTime timestamp;
  final bool isFromCurrentUser;
  MockMessage({
    required this.id,
    required this.content,
    required this.senderId,
    required this.timestamp,
    required this.isFromCurrentUser,
  });
}
</file>

<file path="frontend/lib/features/friends/presentation/screens/add_friends_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/models/user.dart';
/// Add friends screen for discovering and connecting with new users
class AddFriendsScreen extends ConsumerStatefulWidget {
  const AddFriendsScreen({super.key});
  @override
  ConsumerState<AddFriendsScreen> createState() => _AddFriendsScreenState();
}
class _AddFriendsScreenState extends ConsumerState<AddFriendsScreen> {
  final _searchController = TextEditingController();
  String _searchQuery = '';
  bool _isSearching = false;
  List<MockUser> _searchResults = [];
  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      setState(() {
        _searchQuery = _searchController.text;
      });
      _performSearch();
    });
  }
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
  void _performSearch() async {
    if (_searchQuery.isEmpty) {
      setState(() {
        _searchResults = [];
        _isSearching = false;
      });
      return;
    }
    setState(() {
      _isSearching = true;
    });
    // Simulate API search delay
    await Future.delayed(const Duration(milliseconds: 500));
    if (mounted) {
      setState(() {
        _searchResults = _getMockSearchResults(_searchQuery);
        _isSearching = false;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add Friends'),
        actions: [
          PopupMenuButton<String>(
            onSelected: _handleMenuAction,
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'sync_contacts',
                child: Row(
                  children: [
                    Icon(Icons.contacts),
                    SizedBox(width: 8),
                    Text('Sync Contacts'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'invite_by_link',
                child: Row(
                  children: [
                    Icon(Icons.link),
                    SizedBox(width: 8),
                    Text('Invite by Link'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'qr_code',
                child: Row(
                  children: [
                    Icon(Icons.qr_code),
                    SizedBox(width: 8),
                    Text('QR Code'),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          // Search section
          _buildSearchSection(theme),
          // Content
          Expanded(
            child: _buildContent(theme),
          ),
        ],
      ),
    );
  }
  Widget _buildSearchSection(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        boxShadow: [
          BoxShadow(
            color: theme.colorScheme.shadow.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          // Search bar
          TextField(
            controller: _searchController,
            decoration: InputDecoration(
              hintText: 'Search by name, email, or username...',
              prefixIcon: const Icon(Icons.search),
              suffixIcon: _searchQuery.isNotEmpty
                  ? IconButton(
                      onPressed: () {
                        _searchController.clear();
                      },
                      icon: const Icon(Icons.clear),
                    )
                  : null,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              filled: true,
              fillColor: theme.colorScheme.surface,
            ),
          ),
          const SizedBox(height: 16),
          // Quick actions
          Row(
            children: [
              Expanded(
                child: _buildQuickAction(
                  theme,
                  Icons.contacts,
                  'Contacts',
                  'Find friends from your contacts',
                  () => _handleMenuAction('sync_contacts'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildQuickAction(
                  theme,
                  Icons.qr_code_scanner,
                  'Scan QR',
                  'Scan a friend\'s QR code',
                  () => _handleMenuAction('qr_code'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  Widget _buildQuickAction(
    ThemeData theme,
    IconData icon,
    String title,
    String subtitle,
    VoidCallback onTap,
  ) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.colorScheme.primary.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: theme.colorScheme.primary.withOpacity(0.2),
          ),
        ),
        child: Column(
          children: [
            Icon(
              icon,
              color: theme.colorScheme.primary,
              size: 24,
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: TextStyle(
                fontWeight: FontWeight.w500,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              subtitle,
              style: TextStyle(
                fontSize: 11,
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildContent(ThemeData theme) {
    if (_searchQuery.isEmpty) {
      return _buildSuggestionsView(theme);
    }
    if (_isSearching) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Searching for users...'),
          ],
        ),
      );
    }
    if (_searchResults.isEmpty) {
      return _buildEmptySearchResults(theme);
    }
    return _buildSearchResults(theme);
  }
  Widget _buildSuggestionsView(ThemeData theme) {
    final suggestions = _getMockSuggestions();
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Suggested for You',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'People you might know based on your interests and connections',
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.7),
            ),
          ),
          const SizedBox(height: 16),
          ...suggestions.map((user) => _buildUserCard(user, theme)),
          const SizedBox(height: 24),
          // Popular plant enthusiasts section
          Text(
            'Popular Plant Enthusiasts',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Connect with experienced gardeners and plant lovers',
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.7),
            ),
          ),
          const SizedBox(height: 16),
          ...(_getMockPopularUsers().map((user) => _buildUserCard(user, theme))),
        ],
      ),
    );
  }
  Widget _buildSearchResults(ThemeData theme) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: _searchResults.length,
      itemBuilder: (context, index) {
        return _buildUserCard(_searchResults[index], theme);
      },
    );
  }
  Widget _buildEmptySearchResults(ThemeData theme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.search_off,
              size: 80,
              color: theme.colorScheme.onSurface.withOpacity(0.3),
            ),
            const SizedBox(height: 16),
            Text(
              'No users found',
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Try searching with a different name or email',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.5),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => _handleMenuAction('invite_by_link'),
              child: const Text('Invite Friends'),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildUserCard(MockUser user, ThemeData theme) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            // Profile picture
            CircleAvatar(
              radius: 24,
              backgroundColor: theme.colorScheme.primary,
              child: Text(
                user.displayName.split(' ').map((name) => name[0]).join(),
                style: TextStyle(
                  color: theme.colorScheme.onPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(width: 12),
            // User info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        child: Text(
                          user.displayName,
                          style: const TextStyle(fontWeight: FontWeight.w500),
                        ),
                      ),
                      if (user.isVerified)
                        Icon(
                          Icons.verified,
                          size: 16,
                          color: theme.colorScheme.primary,
                        ),
                    ],
                  ),
                  if (user.username.isNotEmpty)
                    Text(
                      '@${user.username}',
                      style: TextStyle(
                        fontSize: 12,
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                    ),
                  Text(
                    user.bio,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      fontSize: 12,
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                  if (user.mutualFriends > 0)
                    Text(
                      '${user.mutualFriends} mutual friends',
                      style: TextStyle(
                        fontSize: 11,
                        color: theme.colorScheme.primary,
                      ),
                    ),
                  if (user.reason.isNotEmpty)
                    Text(
                      user.reason,
                      style: TextStyle(
                        fontSize: 11,
                        color: theme.colorScheme.primary,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                ],
              ),
            ),
            const SizedBox(width: 12),
            // Action button
            _buildActionButton(user, theme),
          ],
        ),
      ),
    );
  }
  Widget _buildActionButton(MockUser user, ThemeData theme) {
    switch (user.status) {
      case UserStatus.notConnected:
        return ElevatedButton(
          onPressed: () => _sendFriendRequest(user),
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          ),
          child: const Text(
            'Add',
            style: TextStyle(fontSize: 12),
          ),
        );
      case UserStatus.requestSent:
        return OutlinedButton(
          onPressed: () => _cancelFriendRequest(user),
          style: OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          ),
          child: const Text(
            'Requested',
            style: TextStyle(fontSize: 12),
          ),
        );
      case UserStatus.friends:
        return OutlinedButton(
          onPressed: () => _viewProfile(user),
          style: OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          ),
          child: const Text(
            'Friends',
            style: TextStyle(fontSize: 12),
          ),
        );
    }
  }
  List<MockUser> _getMockSuggestions() {
    return [
      MockUser(
        id: 'suggestion1',
        name: 'Grace Fern',
        username: 'gracefern',
        bio: 'Tropical plant collector ',
        mutualFriends: 6,
        reason: 'Lives in your area',
        isVerified: true,
        status: UserStatus.notConnected,
      ),
      MockUser(
        id: 'suggestion2',
        name: 'Henry Sage',
        username: 'henrysage',
        bio: 'Organic gardener ',
        mutualFriends: 2,
        reason: 'Friend of Alice Green',
        status: UserStatus.notConnected,
      ),
      MockUser(
        id: 'suggestion3',
        name: 'Ivy Mint',
        username: 'ivymint',
        bio: 'Hydroponic enthusiast ',
        mutualFriends: 0,
        reason: 'Similar interests',
        status: UserStatus.requestSent,
      ),
    ];
  }
  List<MockUser> _getMockPopularUsers() {
    return [
      MockUser(
        id: 'popular1',
        name: 'Dr. Plant Expert',
        username: 'drplantexpert',
        bio: 'Botanist & Plant Care Specialist ',
        mutualFriends: 0,
        reason: 'Popular in your area',
        isVerified: true,
        status: UserStatus.notConnected,
      ),
      MockUser(
        id: 'popular2',
        name: 'Garden Guru',
        username: 'gardenguru',
        bio: 'Sharing 20+ years of gardening wisdom ',
        mutualFriends: 0,
        reason: 'Trending this week',
        isVerified: true,
        status: UserStatus.friends,
      ),
    ];
  }
  List<MockUser> _getMockSearchResults(String query) {
    final allUsers = [
      ...(_getMockSuggestions()),
      ...(_getMockPopularUsers()),
      MockUser(
        id: 'search1',
        name: 'Plant Lover',
        username: 'plantlover123',
        bio: 'New to plant parenting ',
        status: UserStatus.notConnected,
      ),
      MockUser(
        id: 'search2',
        name: 'Green Thumb',
        username: 'greenthumb',
        bio: 'Cactus collection enthusiast ',
        status: UserStatus.notConnected,
      ),
    ];
    return allUsers.where((user) {
      final searchLower = query.toLowerCase();
      return user.displayName.toLowerCase().contains(searchLower) ||
             user.username.toLowerCase().contains(searchLower) ||
             user.bio.toLowerCase().contains(searchLower);
    }).toList();
  }
  void _handleMenuAction(String action) {
    switch (action) {
      case 'sync_contacts':
        _showContactSyncDialog();
        break;
      case 'invite_by_link':
        _showInviteLinkDialog();
        break;
      case 'qr_code':
        _showQRCodeDialog();
        break;
    }
  }
  void _sendFriendRequest(MockUser user) {
    setState(() {
      user.status = UserStatus.requestSent;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Friend request sent to ${user.displayName}'),
        backgroundColor: Colors.green,
      ),
    );
  }
  void _cancelFriendRequest(MockUser user) {
    setState(() {
      user.status = UserStatus.notConnected;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Friend request to ${user.displayName} cancelled'),
      ),
    );
  }
  void _viewProfile(MockUser user) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Opening ${user.displayName}\'s profile (Demo mode)'),
      ),
    );
  }
  void _showContactSyncDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sync Contacts'),
        content: const Text(
          'Allow Plant Social to access your contacts to find friends who are already using the app?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Not Now'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              _showComingSoon('Contact Sync');
            },
            child: const Text('Allow'),
          ),
        ],
      ),
    );
  }
  void _showInviteLinkDialog() {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Invite Friends',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8),
              ),
              child: const Row(
                children: [
                  Expanded(
                    child: Text(
                      'https://plantsocial.app/invite/abc123',
                      style: TextStyle(fontFamily: 'monospace'),
                    ),
                  ),
                  Icon(Icons.copy),
                ],
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {
                      Navigator.pop(context);
                      _showComingSoon('Copy Link');
                    },
                    child: const Text('Copy Link'),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                      _showComingSoon('Share Link');
                    },
                    child: const Text('Share'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  void _showQRCodeDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('QR Code'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 200,
              height: 200,
              decoration: BoxDecoration(
                color: Colors.grey[200],
                borderRadius: BorderRadius.circular(12),
              ),
              child: const Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.qr_code,
                    size: 80,
                    color: Colors.grey,
                  ),
                  SizedBox(height: 8),
                  Text(
                    'QR Code\n(Demo)',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Share this QR code with friends to connect instantly!',
              textAlign: TextAlign.center,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              _showComingSoon('QR Code Sharing');
            },
            child: const Text('Share'),
          ),
        ],
      ),
    );
  }
  void _showComingSoon(String feature) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$feature feature coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }
}
/// User status enum
enum UserStatus {
  notConnected,
  requestSent,
  friends,
}
/// Mock user model for demonstration
class MockUser {
  final String id;
  final String name;
  final String username;
  final String bio;
  final int mutualFriends;
  final String reason;
  final bool isVerified;
  UserStatus status;
  MockUser({
    required this.id,
    required this.name,
    this.username = '',
    required this.bio,
    this.mutualFriends = 0,
    this.reason = '',
    this.isVerified = false,
    this.status = UserStatus.notConnected,
  });
  String get displayName => name;
}
</file>

<file path="frontend/lib/features/friends/presentation/screens/friends_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
class FriendsScreen extends ConsumerStatefulWidget {
  const FriendsScreen({super.key});
  @override
  ConsumerState<FriendsScreen> createState() => _FriendsScreenState();
}
class _FriendsScreenState extends ConsumerState<FriendsScreen>
    with TickerProviderStateMixin {
  late TabController _tabController;
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }
  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      appBar: AppBar(
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
        leading: IconButton(
          icon: Icon(
            Icons.arrow_back,
            color: theme.colorScheme.onSurface,
          ),
          onPressed: () => context.pop(),
        ),
        title: Text(
          'Friends',
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.onSurface,
          ),
        ),
        actions: [
          IconButton(
            icon: Icon(
              Icons.person_add,
              color: theme.colorScheme.onSurface,
            ),
            onPressed: () {
              _showAddFriendDialog(context, theme);
            },
          ),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(100),
          child: Column(
            children: [
              // Search Bar
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: TextField(
                  controller: _searchController,
                  onChanged: (value) {
                    setState(() {
                      _searchQuery = value;
                    });
                  },
                  decoration: InputDecoration(
                    hintText: 'Search friends...',
                    prefixIcon: Icon(
                      Icons.search,
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                    suffixIcon: _searchQuery.isNotEmpty
                        ? IconButton(
                            icon: Icon(
                              Icons.clear,
                              color: theme.colorScheme.onSurface.withOpacity(0.7),
                            ),
                            onPressed: () {
                              _searchController.clear();
                              setState(() {
                                _searchQuery = '';
                              });
                            },
                          )
                        : null,
                    filled: true,
                    fillColor: theme.colorScheme.surface,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.3),
                      ),
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.3),
                      ),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(
                        color: theme.colorScheme.primary,
                        width: 2,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              // Tab Bar
              TabBar(
                controller: _tabController,
                labelColor: theme.colorScheme.primary,
                unselectedLabelColor: theme.colorScheme.onSurface.withOpacity(0.7),
                indicatorColor: theme.colorScheme.primary,
                tabs: const [
                  Tab(text: 'Friends'),
                  Tab(text: 'Requests'),
                  Tab(text: 'Suggestions'),
                ],
              ),
            ],
          ),
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildFriendsTab(context, theme),
          _buildRequestsTab(context, theme),
          _buildSuggestionsTab(context, theme),
        ],
      ),
    );
  }
  Widget _buildFriendsTab(BuildContext context, ThemeData theme) {
    final friends = _getFilteredFriends();
    if (friends.isEmpty) {
      return _buildEmptyState(
        context,
        theme,
        Icons.people_outline,
        'No friends yet',
        'Start connecting with other plant lovers!',
        'Find Friends',
        () => _tabController.animateTo(2),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: friends.length,
      itemBuilder: (context, index) {
        final friend = friends[index];
        return _buildFriendItem(context, theme, friend, 'friend');
      },
    );
  }
  Widget _buildRequestsTab(BuildContext context, ThemeData theme) {
    final requests = _getSampleRequests();
    if (requests.isEmpty) {
      return _buildEmptyState(
        context,
        theme,
        Icons.person_add_outlined,
        'No friend requests',
        'Friend requests will appear here',
        null,
        null,
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: requests.length,
      itemBuilder: (context, index) {
        final request = requests[index];
        return _buildFriendItem(context, theme, request, 'request');
      },
    );
  }
  Widget _buildSuggestionsTab(BuildContext context, ThemeData theme) {
    final suggestions = _getSampleSuggestions();
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: suggestions.length,
      itemBuilder: (context, index) {
        final suggestion = suggestions[index];
        return _buildFriendItem(context, theme, suggestion, 'suggestion');
      },
    );
  }
  Widget _buildFriendItem(
    BuildContext context,
    ThemeData theme,
    Map<String, dynamic> person,
    String type,
  ) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        leading: Stack(
          children: [
            CircleAvatar(
              radius: 28,
              backgroundColor: (person['avatarColor'] as Color).withOpacity(0.2),
              child: Text(
                person['name'][0].toUpperCase(),
                style: theme.textTheme.titleLarge?.copyWith(
                  color: person['avatarColor'] as Color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            if (type == 'friend' && person['isOnline'] == true)
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  width: 12,
                  height: 12,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: theme.colorScheme.surface,
                      width: 2,
                    ),
                  ),
                ),
              ),
          ],
        ),
        title: Text(
          person['name'] as String,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontWeight: FontWeight.w600,
            color: theme.colorScheme.onSurface,
          ),
        ),
        subtitle: Text(
          person['subtitle'] as String,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurface.withOpacity(0.7),
          ),
        ),
        trailing: _buildTrailingActions(context, theme, person, type),
        onTap: () {
          // TODO: Navigate to user profile
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Viewing ${person['name']}\'s profile'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        },
      ),
    );
  }
  Widget _buildTrailingActions(
    BuildContext context,
    ThemeData theme,
    Map<String, dynamic> person,
    String type,
  ) {
    switch (type) {
      case 'friend':
        return PopupMenuButton<String>(
          onSelected: (value) {
            _handleFriendAction(context, person['name'] as String, value);
          },
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'message',
              child: Text('Send Message'),
            ),
            const PopupMenuItem(
              value: 'unfriend',
              child: Text('Unfriend'),
            ),
          ],
        );
      case 'request':
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: Icon(
                Icons.close,
                color: theme.colorScheme.error,
              ),
              onPressed: () {
                _handleRequestAction(context, person['name'] as String, 'decline');
              },
            ),
            IconButton(
              icon: Icon(
                Icons.check,
                color: Colors.green,
              ),
              onPressed: () {
                _handleRequestAction(context, person['name'] as String, 'accept');
              },
            ),
          ],
        );
      case 'suggestion':
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextButton(
              onPressed: () {
                _handleSuggestionAction(context, person['name'] as String, 'ignore');
              },
              child: Text(
                'Ignore',
                style: TextStyle(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ),
            ElevatedButton(
              onPressed: () {
                _handleSuggestionAction(context, person['name'] as String, 'add');
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.primary,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(horizontal: 16),
              ),
              child: const Text('Add'),
            ),
          ],
        );
      default:
        return const SizedBox.shrink();
    }
  }
  Widget _buildEmptyState(
    BuildContext context,
    ThemeData theme,
    IconData icon,
    String title,
    String subtitle,
    String? buttonText,
    VoidCallback? onButtonPressed,
  ) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: 64,
              color: theme.colorScheme.onSurface.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            if (buttonText != null && onButtonPressed != null) ...[
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: onButtonPressed,
                child: Text(buttonText),
              ),
            ],
          ],
        ),
      ),
    );
  }
  void _showAddFriendDialog(BuildContext context, ThemeData theme) {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Friend'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(
            hintText: 'Enter username or email',
            border: OutlineInputBorder(),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Implement add friend functionality
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Friend request sent to ${controller.text}'),
                  backgroundColor: Colors.green,
                  behavior: SnackBarBehavior.floating,
                ),
              );
            },
            child: const Text('Send Request'),
          ),
        ],
      ),
    );
  }
  void _handleFriendAction(BuildContext context, String name, String action) {
    // TODO: Implement friend actions
    String message = '';
    switch (action) {
      case 'message':
        message = 'Opening chat with $name';
        break;
      case 'unfriend':
        message = 'Unfriended $name';
        break;
    }
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  void _handleRequestAction(BuildContext context, String name, String action) {
    // TODO: Implement request actions
    String message = action == 'accept'
        ? 'Accepted friend request from $name'
        : 'Declined friend request from $name';
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: action == 'accept' ? Colors.green : null,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  void _handleSuggestionAction(BuildContext context, String name, String action) {
    // TODO: Implement suggestion actions
    String message = action == 'add'
        ? 'Friend request sent to $name'
        : '$name removed from suggestions';
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: action == 'add' ? Colors.green : null,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  List<Map<String, dynamic>> _getFilteredFriends() {
    final friends = _getSampleFriends();
    if (_searchQuery.isEmpty) return friends;
    return friends.where((friend) {
      return (friend['name'] as String)
          .toLowerCase()
          .contains(_searchQuery.toLowerCase());
    }).toList();
  }
  List<Map<String, dynamic>> _getSampleFriends() {
    return [
      {
        'name': 'Alice Green',
        'subtitle': 'Plant enthusiast  2 mutual friends',
        'isOnline': true,
        'avatarColor': Colors.green,
      },
      {
        'name': 'Bob Plant',
        'subtitle': 'Gardening expert  5 mutual friends',
        'isOnline': false,
        'avatarColor': Colors.blue,
      },
      {
        'name': 'Carol Bloom',
        'subtitle': 'Rose lover  1 mutual friend',
        'isOnline': true,
        'avatarColor': Colors.pink,
      },
    ];
  }
  List<Map<String, dynamic>> _getSampleRequests() {
    return [
      {
        'name': 'David Chen',
        'subtitle': 'Wants to be your friend',
        'avatarColor': Colors.orange,
      },
      {
        'name': 'Emma Wilson',
        'subtitle': 'Sent you a friend request',
        'avatarColor': Colors.purple,
      },
    ];
  }
  List<Map<String, dynamic>> _getSampleSuggestions() {
    return [
      {
        'name': 'Sarah Johnson',
        'subtitle': '3 mutual friends',
        'avatarColor': Colors.teal,
      },
      {
        'name': 'Mike Brown',
        'subtitle': 'Plant collector',
        'avatarColor': Colors.indigo,
      },
      {
        'name': 'Lisa Garcia',
        'subtitle': '1 mutual friend',
        'avatarColor': Colors.red,
      },
    ];
  }
}
</file>

<file path="frontend/lib/features/home/presentation/screens/home_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
<<<<<<< HEAD
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/models/user.dart';
import 'package:plant_social/core/router/app_router.dart';
=======
>>>>>>> baf556a5d654e56b6d571fc759b0e5caa549cb96
import 'package:plant_social/features/auth/providers/auth_provider.dart';
class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final user = ref.watch(authProvider).user;
    return Scaffold(
      appBar: AppBar(
        title: Row(
          children: [
            Container(
              width: 32,
              height: 32,
              decoration: BoxDecoration(
                color: theme.colorScheme.primary,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                Icons.eco,
                size: 20,
                color: theme.colorScheme.onPrimary,
              ),
            ),
            const SizedBox(width: 12),
            Text(
              'Plant Social',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.onSurface,
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.notifications_outlined),
            onPressed: () {
              // TODO: Navigate to notifications
            },
          ),
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {
              // TODO: Navigate to search
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Welcome section
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Welcome back, ${user?.displayName ?? 'Plant Lover'}! ',
                    style: theme.textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Share your plant journey with friends',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),
            // Quick actions
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Quick Actions',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: _buildQuickActionCard(
                          context,
                          theme,
                          'Share Story',
                          Icons.add_a_photo,
                          () {
                            // TODO: Navigate to camera
                          },
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: _buildQuickActionCard(
                          context,
                          theme,
                          'Find Friends',
                          Icons.person_add,
                          () {
                            // TODO: Navigate to friends
                          },
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            // Placeholder for stories
            Container(
              height: 120,
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: 5, // Placeholder count
                itemBuilder: (context, index) {
                  if (index == 0) {
                    return _buildYourStoryItem(theme);
                  }
                  return _buildStoryItem(theme, 'User $index', index % 2 == 0);
                },
              ),
            ),
            // Placeholder for feed
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Plant Community',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.onSurface,
                    ),
                  ),
                  const SizedBox(height: 16),
                  _buildFeedItem(theme, 'Alice Green', 'Just repotted my monstera! ', '2h ago'),
                  const SizedBox(height: 16),
                  _buildFeedItem(theme, 'Bob Plant', 'Check out my new succulent collection ', '5h ago'),
                  const SizedBox(height: 16),
                  _buildFeedItem(theme, 'Carol Bloom', 'Need help identifying this plant!', '1d ago'),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildQuickActionCard(
    BuildContext context,
    ThemeData theme,
    String title,
    IconData icon,
    VoidCallback onTap,
  ) {
    return Card(
      elevation: 2,
      shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  icon,
                  color: theme.colorScheme.primary,
                  size: 24,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: theme.textTheme.labelMedium?.copyWith(
                  fontWeight: FontWeight.w500,
                  color: theme.colorScheme.onSurface,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildYourStoryItem(ThemeData theme) {
    return Container(
      width: 80,
      margin: const EdgeInsets.only(right: 12),
      child: Column(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: theme.colorScheme.outline.withOpacity(0.3),
                width: 2,
              ),
            ),
            child: Stack(
              children: [
                Center(
                  child: CircleAvatar(
                    radius: 28,
                    backgroundColor: theme.colorScheme.primary.withOpacity(0.1),
                    child: Text(
                      'Y',
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: theme.colorScheme.primary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
                Positioned(
                  bottom: 2,
                  right: 2,
                  child: Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: theme.colorScheme.surface,
                        width: 2,
                      ),
                    ),
                    child: Icon(
                      Icons.add,
                      size: 14,
                      color: theme.colorScheme.onPrimary,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Your Story',
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurface,
              fontWeight: FontWeight.w500,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
  Widget _buildStoryItem(ThemeData theme, String name, bool hasStory) {
    return Container(
      width: 80,
      margin: const EdgeInsets.only(right: 12),
      child: Column(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: hasStory
                  ? LinearGradient(
                      colors: [
                        theme.colorScheme.primary,
                        theme.colorScheme.secondary,
                      ],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    )
                  : null,
              border: !hasStory
                  ? Border.all(
                      color: theme.colorScheme.outline.withOpacity(0.3),
                      width: 2,
                    )
                  : null,
            ),
            child: Padding(
              padding: EdgeInsets.all(hasStory ? 3 : 0),
              child: Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: hasStory
                      ? Border.all(
                          color: theme.colorScheme.surface,
                          width: 2,
                        )
                      : null,
                ),
                child: CircleAvatar(
                  radius: hasStory ? 31 : 34,
                  backgroundColor: Colors.grey[300],
                  child: Text(
                    name[0].toUpperCase(),
                    style: theme.textTheme.titleLarge?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            name,
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurface,
              fontWeight: FontWeight.w500,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  Widget _buildFeedItem(ThemeData theme, String userName, String content, String timeAgo) {
    return Card(
      elevation: 2,
      shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // User info
            Row(
              children: [
                CircleAvatar(
                  radius: 20,
                  backgroundColor: theme.colorScheme.primary,
                  child: Text(
                    userName[0],
                    style: TextStyle(
                      color: theme.colorScheme.onPrimary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        userName,
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Text(
                        timeAgo,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.more_vert),
                  onPressed: () {
                    // TODO: Show post options
                  },
                ),
              ],
            ),
            const SizedBox(height: 12),
            // Content
            Text(
              content,
              style: theme.textTheme.bodyMedium,
            ),
            const SizedBox(height: 16),
            // Placeholder for image
            Container(
              height: 200,
              decoration: BoxDecoration(
                color: Colors.grey[200],
                borderRadius: BorderRadius.circular(12),
              ),
              child: Center(
                child: Icon(
                  Icons.image,
                  size: 48,
                  color: Colors.grey[400],
                ),
              ),
            ),
            const SizedBox(height: 16),
            // Action buttons
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.favorite_border),
                      onPressed: () {
                        // TODO: Like post
                      },
                    ),
                    IconButton(
                      icon: const Icon(Icons.chat_bubble_outline),
                      onPressed: () {
                        // TODO: Comment on post
                      },
                    ),
                    IconButton(
                      icon: const Icon(Icons.share),
                      onPressed: () {
                        // TODO: Share post
                      },
                    ),
                  ],
                ),
                IconButton(
                  icon: const Icon(Icons.bookmark_border),
                  onPressed: () {
                    // TODO: Save post
                  },
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/home/presentation/screens/main_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/models/user.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/features/auth/providers/auth_provider.dart';
import 'package:plant_social/features/home/presentation/screens/home_screen.dart';
class MainScreen extends ConsumerStatefulWidget {
  const MainScreen({super.key});
  @override
  ConsumerState<MainScreen> createState() => _MainScreenState();
}
class _MainScreenState extends ConsumerState<MainScreen> {
  int _currentIndex = 0;
  final PageController _pageController = PageController();
  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }
  void _onTabTapped(int index) {
    setState(() {
      _currentIndex = index;
    });
    _pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
  void _onPageChanged(int index) {
    setState(() {
      _currentIndex = index;
    });
  }
  Future<void> _handleLogout() async {
    final shouldLogout = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Logout'),
        content: const Text('Are you sure you want to logout?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Logout'),
          ),
        ],
      ),
    );
    if (shouldLogout == true && mounted) {
      await ref.read(authProvider.notifier).logout();
      if (mounted) {
        context.go(AppRoutes.login);
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final authState = ref.watch(authProvider);
    return Scaffold(
      backgroundColor: theme.colorScheme.surface,
      body: PageView(
        controller: _pageController,
        onPageChanged: _onPageChanged,
        children: [
          const HomeScreen(), // Home screen
          _buildCameraPlaceholder(context, theme),
          _buildChatPlaceholder(context, theme),
          _buildStoriesPlaceholder(context, theme),
          _buildProfilePlaceholder(context, theme, authState.user?.displayName),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        currentIndex: _currentIndex,
        onTap: _onTabTapped,
        backgroundColor: theme.colorScheme.surface,
        selectedItemColor: theme.colorScheme.primary,
        unselectedItemColor: theme.colorScheme.onSurface.withOpacity(0.6),
        elevation: 8,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.camera_alt_outlined),
            activeIcon: Icon(Icons.camera_alt),
            label: 'Camera',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.chat_bubble_outline),
            activeIcon: Icon(Icons.chat_bubble),
            label: 'Chat',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.auto_stories_outlined),
            activeIcon: Icon(Icons.auto_stories),
            label: 'Stories',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline),
            activeIcon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
      ),
    );
  }
  Widget _buildCameraPlaceholder(BuildContext context, ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Camera'),
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.camera_alt_outlined,
              size: 64,
              color: theme.colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              'Camera Feature',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'Take photos and create stories',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildChatPlaceholder(BuildContext context, ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Messages'),
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.chat_bubble_outline,
              size: 64,
              color: theme.colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              'Messages',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'Chat with your plant friends',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildStoriesPlaceholder(BuildContext context, ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Stories'),
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.auto_stories_outlined,
              size: 64,
              color: theme.colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              'Stories',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'Share your plant moments',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildProfilePlaceholder(BuildContext context, ThemeData theme, String? userName) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        backgroundColor: theme.colorScheme.surface,
        elevation: 0,
        actions: [
          IconButton(
            onPressed: _handleLogout,
            icon: const Icon(Icons.logout),
            tooltip: 'Logout',
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircleAvatar(
              radius: 48,
              backgroundColor: theme.colorScheme.primary,
              child: Icon(
                Icons.person,
                size: 48,
                color: theme.colorScheme.onPrimary,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              userName ?? 'User',
              style: theme.textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'Plant enthusiast',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Profile editing coming soon!'),
                  ),
                );
              },
              icon: const Icon(Icons.edit),
              label: const Text('Edit Profile'),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/messages/presentation/widgets/recent_conversations.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/core/router/app_router.dart';
class RecentConversations extends ConsumerWidget {
  const RecentConversations({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Recent Conversations',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurface,
                ),
              ),
              TextButton(
                onPressed: () {
                  // TODO: Navigate to all conversations
                },
                child: Text(
                  'See All',
                  style: TextStyle(
                    color: theme.colorScheme.primary,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          // Sample Conversations
          ..._buildSampleConversations(context, theme),
          // Empty State
          if (_getSampleConversations().isEmpty)
            _buildEmptyState(context, theme),
        ],
      ),
    );
  }
  List<Widget> _buildSampleConversations(
      BuildContext context, ThemeData theme) {
    final conversations = _getSampleConversations();
    return conversations.take(3).map((conversation) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 12),
        child: _buildConversationItem(context, theme, conversation),
      );
    }).toList();
  }
  Widget _buildConversationItem(
    BuildContext context,
    ThemeData theme,
    Map<String, dynamic> conversation,
  ) {
    return Card(
      elevation: 1,
      shadowColor: theme.colorScheme.shadow.withOpacity(0.1),
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        leading: Stack(
          children: [
            CircleAvatar(
              radius: 24,
              backgroundColor:
                  (conversation['avatarColor'] as Color).withOpacity(0.2),
              child: Text(
                conversation['name'][0].toUpperCase(),
                style: theme.textTheme.titleMedium?.copyWith(
                  color: conversation['avatarColor'] as Color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            if (conversation['isOnline'] as bool)
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  width: 12,
                  height: 12,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: theme.colorScheme.surface,
                      width: 2,
                    ),
                  ),
                ),
              ),
          ],
        ),
        title: Text(
          conversation['name'] as String,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontWeight: FontWeight.w600,
            color: theme.colorScheme.onSurface,
          ),
        ),
        subtitle: Text(
          conversation['lastMessage'] as String,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurface.withOpacity(0.7),
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              conversation['time'] as String,
              style: theme.textTheme.labelSmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.5),
              ),
            ),
            if (conversation['unreadCount'] as int > 0) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  '${conversation['unreadCount']}',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: theme.colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ],
        ),
        onTap: () {
          // TODO: Navigate to conversation
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Opening chat with ${conversation['name']}'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        },
      ),
    );
  }
  Widget _buildEmptyState(BuildContext context, ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          children: [
            Icon(
              Icons.chat_outlined,
              size: 48,
              color: theme.colorScheme.onSurface.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              'No conversations yet',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: theme.colorScheme.onSurface,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Start chatting with your plant friends!',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                context.go(AppRoutes.friends);
              },
              child: const Text('Find Friends'),
            ),
          ],
        ),
      ),
    );
  }
  List<Map<String, dynamic>> _getSampleConversations() {
    return [
      {
        'name': 'Alice Green',
        'lastMessage': 'Check out my new succulent! ',
        'time': '2m',
        'unreadCount': 2,
        'isOnline': true,
        'avatarColor': Colors.green,
      },
      {
        'name': 'Bob Plant',
        'lastMessage': 'Thanks for the watering tips!',
        'time': '1h',
        'unreadCount': 0,
        'isOnline': false,
        'avatarColor': Colors.blue,
      },
      {
        'name': 'Carol Bloom',
        'lastMessage': 'My roses are blooming beautifully ',
        'time': '3h',
        'unreadCount': 1,
        'isOnline': true,
        'avatarColor': Colors.pink,
      },
    ];
  }
}
</file>

<file path="frontend/lib/features/plant_care/models/plant_care_models.dart">
import 'package:json_annotation/json_annotation.dart';
part 'plant_care_models.g.dart';
@JsonSerializable()
class PlantCareLog {
  final String id;
  final String userPlantId;
  final String careType;
  final DateTime careDate;
  final String? notes;
  final String? imageUrl;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PlantCareLog({
    required this.id,
    required this.userPlantId,
    required this.careType,
    required this.careDate,
    this.notes,
    this.imageUrl,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
  });
  factory PlantCareLog.fromJson(Map<String, dynamic> json) {
    return PlantCareLog(
      id: json['id'] as String,
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      careDate: DateTime.parse(json['careDate'] as String),
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userPlantId': userPlantId,
      'careType': careType,
      'careDate': careDate.toIso8601String(),
      'notes': notes,
      'imageUrl': imageUrl,
      'metadata': metadata,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }
}
@JsonSerializable()
class PlantCareReminder {
  final String id;
  final String userPlantId;
  final String careType;
  final DateTime nextDueDate;
  final int frequencyDays;
  final bool isActive;
  final String? notes;
  final DateTime? lastCompletedDate;
  final DateTime createdAt;
  final DateTime updatedAt;
  // Related data
  final UserPlant? plant;
  const PlantCareReminder({
    required this.id,
    required this.userPlantId,
    required this.careType,
    required this.nextDueDate,
    required this.frequencyDays,
    required this.isActive,
    this.notes,
    this.lastCompletedDate,
    required this.createdAt,
    required this.updatedAt,
    this.plant,
  });
  factory PlantCareReminder.fromJson(Map<String, dynamic> json) {
    return PlantCareReminder(
      id: json['id'] as String,
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      nextDueDate: DateTime.parse(json['nextDueDate'] as String),
      frequencyDays: json['frequencyDays'] as int,
      isActive: json['isActive'] as bool,
      notes: json['notes'] as String?,
      lastCompletedDate: json['lastCompletedDate'] != null ? DateTime.parse(json['lastCompletedDate'] as String) : null,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      plant: json['plant'] != null ? UserPlant.fromJson(json['plant'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userPlantId': userPlantId,
      'careType': careType,
      'nextDueDate': nextDueDate.toIso8601String(),
      'frequencyDays': frequencyDays,
      'isActive': isActive,
      'notes': notes,
      'lastCompletedDate': lastCompletedDate?.toIso8601String(),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'plant': plant?.toJson(),
    };
  }
}
@JsonSerializable()
class UserPlant {
  final String id;
  final String userId;
  final String speciesId;
  final String nickname;
  final String? notes;
  final String? imageUrl;
  final DateTime acquiredDate;
  final String? location;
  final Map<String, dynamic>? customCareSchedule;
  final DateTime createdAt;
  final DateTime updatedAt;
  // Related data
  final PlantSpecies? species;
  final List<PlantCareLog>? careLogs;
  final List<PlantCareReminder>? reminders;
  const UserPlant({
    required this.id,
    required this.userId,
    required this.speciesId,
    required this.nickname,
    this.notes,
    this.imageUrl,
    required this.acquiredDate,
    this.location,
    this.customCareSchedule,
    required this.createdAt,
    required this.updatedAt,
    this.species,
    this.careLogs,
    this.reminders,
  });
  factory UserPlant.fromJson(Map<String, dynamic> json) {
    return UserPlant(
      id: json['id'] as String,
      userId: json['userId'] as String,
      speciesId: json['speciesId'] as String,
      nickname: json['nickname'] as String,
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      acquiredDate: DateTime.parse(json['acquiredDate'] as String),
      location: json['location'] as String?,
      customCareSchedule: json['customCareSchedule'] as Map<String, dynamic>?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      species: json['species'] != null ? PlantSpecies.fromJson(json['species'] as Map<String, dynamic>) : null,
      careLogs: (json['careLogs'] as List<dynamic>?)?.map((e) => PlantCareLog.fromJson(e as Map<String, dynamic>)).toList(),
      reminders: (json['reminders'] as List<dynamic>?)?.map((e) => PlantCareReminder.fromJson(e as Map<String, dynamic>)).toList(),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'speciesId': speciesId,
      'nickname': nickname,
      'notes': notes,
      'imageUrl': imageUrl,
      'acquiredDate': acquiredDate.toIso8601String(),
      'location': location,
      'customCareSchedule': customCareSchedule,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'species': species?.toJson(),
      'careLogs': careLogs?.map((e) => e.toJson()).toList(),
      'reminders': reminders?.map((e) => e.toJson()).toList(),
    };
  }
}
@JsonSerializable()
class PlantSpecies {
  final String id;
  final String commonName;
  final String scientificName;
  final String? family;
  final String? description;
  final String? imageUrl;
  final List<String>? alternativeNames;
  final List<String>? nativeRegions;
  final String? maxHeight;
  final String? bloomTime;
  final String? plantType;
  final PlantCareInfo? careInfo;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PlantSpecies({
    required this.id,
    required this.commonName,
    required this.scientificName,
    this.family,
    this.description,
    this.imageUrl,
    this.alternativeNames,
    this.nativeRegions,
    this.maxHeight,
    this.bloomTime,
    this.plantType,
    this.careInfo,
    required this.createdAt,
    required this.updatedAt,
  });
  factory PlantSpecies.fromJson(Map<String, dynamic> json) {
    return PlantSpecies(
      id: json['id'] as String,
      commonName: json['commonName'] as String,
      scientificName: json['scientificName'] as String,
      family: json['family'] as String?,
      description: json['description'] as String?,
      imageUrl: json['imageUrl'] as String?,
      alternativeNames: (json['alternativeNames'] as List<dynamic>?)?.cast<String>(),
      nativeRegions: (json['nativeRegions'] as List<dynamic>?)?.cast<String>(),
      maxHeight: json['maxHeight'] as String?,
      bloomTime: json['bloomTime'] as String?,
      plantType: json['plantType'] as String?,
      careInfo: json['careInfo'] != null ? PlantCareInfo.fromJson(json['careInfo'] as Map<String, dynamic>) : null,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'commonName': commonName,
      'scientificName': scientificName,
      'family': family,
      'description': description,
      'imageUrl': imageUrl,
      'alternativeNames': alternativeNames,
      'nativeRegions': nativeRegions,
      'maxHeight': maxHeight,
      'bloomTime': bloomTime,
      'plantType': plantType,
      'careInfo': careInfo?.toJson(),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }
}
@JsonSerializable()
class PlantCareInfo {
  final String lightRequirement;
  final String waterFrequency;
  final String careLevel;
  final String? humidity;
  final String? temperature;
  final String? toxicity;
  final String? fertilizer;
  final String? repotting;
  final String? pruning;
  final Map<String, dynamic>? additionalCare;
  const PlantCareInfo({
    required this.lightRequirement,
    required this.waterFrequency,
    required this.careLevel,
    this.humidity,
    this.temperature,
    this.toxicity,
    this.fertilizer,
    this.repotting,
    this.pruning,
    this.additionalCare,
  });
  factory PlantCareInfo.fromJson(Map<String, dynamic> json) {
    return PlantCareInfo(
      lightRequirement: json['lightRequirement'] as String,
      waterFrequency: json['waterFrequency'] as String,
      careLevel: json['careLevel'] as String,
      humidity: json['humidity'] as String?,
      temperature: json['temperature'] as String?,
      toxicity: json['toxicity'] as String?,
      fertilizer: json['fertilizer'] as String?,
      repotting: json['repotting'] as String?,
      pruning: json['pruning'] as String?,
      additionalCare: json['additionalCare'] as Map<String, dynamic>?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'lightRequirement': lightRequirement,
      'waterFrequency': waterFrequency,
      'careLevel': careLevel,
      'humidity': humidity,
      'temperature': temperature,
      'toxicity': toxicity,
      'fertilizer': fertilizer,
      'repotting': repotting,
      'pruning': pruning,
      'additionalCare': additionalCare,
    };
  }
}
@JsonSerializable()
class PlantCareRequest {
  final String userPlantId;
  final String careType;
  final DateTime careDate;
  final String? notes;
  final String? imageUrl;
  final Map<String, dynamic>? metadata;
  const PlantCareRequest({
    required this.userPlantId,
    required this.careType,
    required this.careDate,
    this.notes,
    this.imageUrl,
    this.metadata,
  });
  factory PlantCareRequest.fromJson(Map<String, dynamic> json) {
    return PlantCareRequest(
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      careDate: DateTime.parse(json['careDate'] as String),
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'userPlantId': userPlantId,
      'careType': careType,
      'careDate': careDate.toIso8601String(),
      'notes': notes,
      'imageUrl': imageUrl,
      'metadata': metadata,
    };
  }
}
@JsonSerializable()
class PlantCareReminderRequest {
  final String userPlantId;
  final String careType;
  final DateTime nextDueDate;
  final int frequencyDays;
  final String? notes;
  const PlantCareReminderRequest({
    required this.userPlantId,
    required this.careType,
    required this.nextDueDate,
    required this.frequencyDays,
    this.notes,
  });
  factory PlantCareReminderRequest.fromJson(Map<String, dynamic> json) {
    return PlantCareReminderRequest(
      userPlantId: json['userPlantId'] as String,
      careType: json['careType'] as String,
      nextDueDate: DateTime.parse(json['nextDueDate'] as String),
      frequencyDays: json['frequencyDays'] as int,
      notes: json['notes'] as String?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'userPlantId': userPlantId,
      'careType': careType,
      'nextDueDate': nextDueDate.toIso8601String(),
      'frequencyDays': frequencyDays,
      'notes': notes,
    };
  }
}
@JsonSerializable()
class UserPlantRequest {
  final String speciesId;
  final String nickname;
  final String? notes;
  final String? imageUrl;
  final DateTime acquiredDate;
  final String? location;
  final Map<String, dynamic>? customCareSchedule;
  const UserPlantRequest({
    required this.speciesId,
    required this.nickname,
    this.notes,
    this.imageUrl,
    required this.acquiredDate,
    this.location,
    this.customCareSchedule,
  });
  factory UserPlantRequest.fromJson(Map<String, dynamic> json) {
    return UserPlantRequest(
      speciesId: json['speciesId'] as String,
      nickname: json['nickname'] as String,
      notes: json['notes'] as String?,
      imageUrl: json['imageUrl'] as String?,
      acquiredDate: DateTime.parse(json['acquiredDate'] as String),
      location: json['location'] as String?,
      customCareSchedule: json['customCareSchedule'] as Map<String, dynamic>?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'speciesId': speciesId,
      'nickname': nickname,
      'notes': notes,
      'imageUrl': imageUrl,
      'acquiredDate': acquiredDate.toIso8601String(),
      'location': location,
      'customCareSchedule': customCareSchedule,
    };
  }
}
@JsonSerializable()
class PlantCareState {
  final List<UserPlant> userPlants;
  final List<PlantCareLog> careLogs;
  final List<PlantCareReminder> reminders;
  final List<PlantCareReminder> upcomingReminders;
  final bool isLoading;
  final bool isLoadingPlants;
  final bool isLoadingLogs;
  final bool isLoadingReminders;
  final bool isCreating;
  final bool isUpdating;
  final bool isDeleting;
  final String? error;
  final String? createError;
  final String? updateError;
  final String? deleteError;
  const PlantCareState({
    this.userPlants = const [],
    this.careLogs = const [],
    this.reminders = const [],
    this.upcomingReminders = const [],
    this.isLoading = false,
    this.isLoadingPlants = false,
    this.isLoadingLogs = false,
    this.isLoadingReminders = false,
    this.isCreating = false,
    this.isUpdating = false,
    this.isDeleting = false,
    this.error,
    this.createError,
    this.updateError,
    this.deleteError,
  });
  factory PlantCareState.fromJson(Map<String, dynamic> json) {
    return PlantCareState(
      userPlants: (json['userPlants'] as List<dynamic>? ?? [])
          .map((e) => UserPlant.fromJson(e as Map<String, dynamic>))
          .toList(),
      careLogs: (json['careLogs'] as List<dynamic>? ?? [])
          .map((e) => PlantCareLog.fromJson(e as Map<String, dynamic>))
          .toList(),
      reminders: (json['reminders'] as List<dynamic>? ?? [])
          .map((e) => PlantCareReminder.fromJson(e as Map<String, dynamic>))
          .toList(),
      upcomingReminders: (json['upcomingReminders'] as List<dynamic>? ?? [])
          .map((e) => PlantCareReminder.fromJson(e as Map<String, dynamic>))
          .toList(),
      isLoading: json['isLoading'] as bool? ?? false,
      isLoadingPlants: json['isLoadingPlants'] as bool? ?? false,
      isLoadingLogs: json['isLoadingLogs'] as bool? ?? false,
      isLoadingReminders: json['isLoadingReminders'] as bool? ?? false,
      isCreating: json['isCreating'] as bool? ?? false,
      isUpdating: json['isUpdating'] as bool? ?? false,
      isDeleting: json['isDeleting'] as bool? ?? false,
      error: json['error'] as String?,
      createError: json['createError'] as String?,
      updateError: json['updateError'] as String?,
      deleteError: json['deleteError'] as String?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'userPlants': userPlants.map((e) => e.toJson()).toList(),
      'careLogs': careLogs.map((e) => e.toJson()).toList(),
      'reminders': reminders.map((e) => e.toJson()).toList(),
      'upcomingReminders': upcomingReminders.map((e) => e.toJson()).toList(),
      'isLoading': isLoading,
      'isLoadingPlants': isLoadingPlants,
      'isLoadingLogs': isLoadingLogs,
      'isLoadingReminders': isLoadingReminders,
      'isCreating': isCreating,
      'isUpdating': isUpdating,
      'isDeleting': isDeleting,
      'error': error,
      'createError': createError,
      'updateError': updateError,
      'deleteError': deleteError,
    };
  }
  PlantCareState copyWith({
    List<UserPlant>? userPlants,
    List<PlantCareLog>? careLogs,
    List<PlantCareReminder>? reminders,
    List<PlantCareReminder>? upcomingReminders,
    bool? isLoading,
    bool? isLoadingPlants,
    bool? isLoadingLogs,
    bool? isLoadingReminders,
    bool? isCreating,
    bool? isUpdating,
    bool? isDeleting,
    String? error,
    String? createError,
    String? updateError,
    String? deleteError,
  }) {
    return PlantCareState(
      userPlants: userPlants ?? this.userPlants,
      careLogs: careLogs ?? this.careLogs,
      reminders: reminders ?? this.reminders,
      upcomingReminders: upcomingReminders ?? this.upcomingReminders,
      isLoading: isLoading ?? this.isLoading,
      isLoadingPlants: isLoadingPlants ?? this.isLoadingPlants,
      isLoadingLogs: isLoadingLogs ?? this.isLoadingLogs,
      isLoadingReminders: isLoadingReminders ?? this.isLoadingReminders,
      isCreating: isCreating ?? this.isCreating,
      isUpdating: isUpdating ?? this.isUpdating,
      isDeleting: isDeleting ?? this.isDeleting,
      error: error ?? this.error,
      createError: createError ?? this.createError,
      updateError: updateError ?? this.updateError,
      deleteError: deleteError ?? this.deleteError,
    );
  }
}
// Care type constants
class CareType {
  static const String watering = 'watering';
  static const String fertilizing = 'fertilizing';
  static const String pruning = 'pruning';
  static const String repotting = 'repotting';
  static const String pestControl = 'pest_control';
  static const String observation = 'observation';
  static const String other = 'other';
  static const List<String> all = [
    watering,
    fertilizing,
    pruning,
    repotting,
    pestControl,
    observation,
    other,
  ];
  static String getDisplayName(String careType) {
    switch (careType) {
      case watering:
        return 'Watering';
      case fertilizing:
        return 'Fertilizing';
      case pruning:
        return 'Pruning';
      case repotting:
        return 'Repotting';
      case pestControl:
        return 'Pest Control';
      case observation:
        return 'Observation';
      case other:
        return 'Other';
      default:
        return careType;
    }
  }
  static String getIcon(String careType) {
    switch (careType) {
      case watering:
        return '';
      case fertilizing:
        return '';
      case pruning:
        return '';
      case repotting:
        return '';
      case pestControl:
        return '';
      case observation:
        return '';
      case other:
        return '';
      default:
        return '';
    }
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/screens/add_plant_screen.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_care/providers/plant_care_provider.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/features/plant_identification/providers/plant_identification_provider.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/custom_button.dart';
import 'package:plant_social/core/widgets/custom_text_field.dart';
class AddPlantScreen extends ConsumerStatefulWidget {
  final PlantSpecies? preselectedSpecies;
  final String? preselectedImagePath;
  const AddPlantScreen({
    super.key,
    this.preselectedSpecies,
    this.preselectedImagePath,
  });
  @override
  ConsumerState<AddPlantScreen> createState() => _AddPlantScreenState();
}
class _AddPlantScreenState extends ConsumerState<AddPlantScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nicknameController = TextEditingController();
  final _locationController = TextEditingController();
  final _notesController = TextEditingController();
  final _searchController = TextEditingController();
  PlantSpecies? _selectedSpecies;
  File? _selectedImage;
  DateTime _acquiredDate = DateTime.now();
  bool _isSearching = false;
  List<PlantSpecies> _searchResults = [];
  @override
  void initState() {
    super.initState();
    _selectedSpecies = widget.preselectedSpecies;
    if (widget.preselectedImagePath != null) {
      _selectedImage = File(widget.preselectedImagePath!);
    }
    if (_selectedSpecies != null) {
      _searchController.text = _selectedSpecies!.commonName;
    }
  }
  @override
  void dispose() {
    _nicknameController.dispose();
    _locationController.dispose();
    _notesController.dispose();
    _searchController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final plantCareState = ref.watch(plantCareProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add New Plant'),
        elevation: 0,
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Plant image section
              _buildImageSection(theme),
              const SizedBox(height: 24),
              // Plant species search
              _buildSpeciesSection(theme),
              const SizedBox(height: 24),
              // Plant details
              _buildDetailsSection(theme),
              const SizedBox(height: 32),
              // Add button
              SizedBox(
                width: double.infinity,
                child: CustomButton(
                  text: 'Add Plant',
                  onPressed: plantCareState.isLoading ? null : _addPlant,
                  isLoading: plantCareState.isLoading,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildImageSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Plant Photo',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        Center(
          child: GestureDetector(
            onTap: _showImagePickerOptions,
            child: Container(
              width: 200,
              height: 200,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: Colors.grey[300]!,
                  width: 2,
                  style: BorderStyle.solid,
                ),
                color: Colors.grey[50],
              ),
              child: _selectedImage != null
                  ? ClipRRect(
                      borderRadius: BorderRadius.circular(14),
                      child: Image.file(
                        _selectedImage!,
                        fit: BoxFit.cover,
                      ),
                    )
                  : Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.add_a_photo,
                          size: 48,
                          color: Colors.grey[400],
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Add Photo',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildSpeciesSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Plant Species',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 12),
        CustomTextField(
          controller: _searchController,
          hint: 'Search for plant species...',
          prefixIcon: const Icon(Icons.search),
          onChanged: _searchSpecies,
          validator: (value) {
            if (_selectedSpecies == null) {
              return 'Please select a plant species';
            }
            return null;
          },
        ),
        if (_isSearching)
          const Padding(
            padding: EdgeInsets.all(16),
            child: Center(child: CircularProgressIndicator()),
          )
        else if (_searchResults.isNotEmpty)
          Container(
            margin: const EdgeInsets.only(top: 8),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey[300]!),
              borderRadius: BorderRadius.circular(8),
            ),
            child: ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: _searchResults.length,
              itemBuilder: (context, index) {
                final species = _searchResults[index];
                return ListTile(
                  title: Text(species.commonName),
                  subtitle: Text(species.scientificName),
                  onTap: () => _selectSpecies(species),
                  selected: _selectedSpecies?.id == species.id,
                );
              },
            ),
          ),
        if (_selectedSpecies != null)
          Container(
            margin: const EdgeInsets.only(top: 12),
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.primaryColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: theme.primaryColor.withOpacity(0.3),
              ),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.check_circle,
                  color: theme.primaryColor,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        _selectedSpecies!.commonName,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        _selectedSpecies!.scientificName,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: Colors.grey[600],
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    ],
                  ),
                ),
                IconButton(
                  onPressed: () {
                    setState(() {
                      _selectedSpecies = null;
                      _searchController.clear();
                    });
                  },
                  icon: const Icon(Icons.close),
                  iconSize: 20,
                ),
              ],
            ),
          ),
      ],
    );
  }
  Widget _buildDetailsSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Plant Details',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        CustomTextField(
          controller: _nicknameController,
          label: 'Plant Nickname',
          hint: 'Give your plant a name...',
          prefixIcon: const Icon(Icons.pets),
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'Please enter a nickname for your plant';
            }
            return null;
          },
        ),
        const SizedBox(height: 16),
        CustomTextField(
          controller: _locationController,
          label: 'Location (Optional)',
          hint: 'Where is this plant located?',
          prefixIcon: const Icon(Icons.location_on),
        ),
        const SizedBox(height: 16),
        ListTile(
          contentPadding: EdgeInsets.zero,
          leading: Icon(
            Icons.calendar_today,
            color: theme.primaryColor,
          ),
          title: const Text('Date Acquired'),
          subtitle: Text(
            '${_acquiredDate.day}/${_acquiredDate.month}/${_acquiredDate.year}',
          ),
          trailing: const Icon(Icons.chevron_right),
          onTap: _selectAcquiredDate,
        ),
        const SizedBox(height: 16),
        CustomTextField(
          controller: _notesController,
          label: 'Notes (Optional)',
          hint: 'Any additional notes about your plant...',
          prefixIcon: const Icon(Icons.note),
          maxLines: 3,
        ),
      ],
    );
  }
  void _showImagePickerOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.photo_camera),
              title: const Text('Take Photo'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.camera);
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Choose from Gallery'),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.gallery);
              },
            ),
            if (_selectedImage != null)
              ListTile(
                leading: const Icon(Icons.delete),
                title: const Text('Remove Photo'),
                onTap: () {
                  Navigator.pop(context);
                  setState(() {
                    _selectedImage = null;
                  });
                },
              ),
          ],
        ),
      ),
    );
  }
  Future<void> _pickImage(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(
      source: source,
      maxWidth: 1024,
      maxHeight: 1024,
      imageQuality: 85,
    );
    if (pickedFile != null) {
      setState(() {
        _selectedImage = File(pickedFile.path);
      });
    }
  }
  void _searchSpecies(String query) async {
    if (query.trim().isEmpty) {
      setState(() {
        _searchResults = [];
        _isSearching = false;
      });
      return;
    }
    setState(() {
      _isSearching = true;
    });
    try {
      final results = await ref.read(plantSpeciesSearchProvider(query).future);
      setState(() {
        _searchResults = results;
        _isSearching = false;
      });
    } catch (e) {
      setState(() {
        _searchResults = [];
        _isSearching = false;
      });
    }
  }
  void _selectSpecies(PlantSpecies species) {
    setState(() {
      _selectedSpecies = species;
      _searchController.text = species.commonName;
      _searchResults = [];
    });
  }
  Future<void> _selectAcquiredDate() async {
    final selectedDate = await showDatePicker(
      context: context,
      initialDate: _acquiredDate,
      firstDate: DateTime(2000),
      lastDate: DateTime.now(),
    );
    if (selectedDate != null) {
      setState(() {
        _acquiredDate = selectedDate;
      });
    }
  }
  Future<void> _addPlant() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    try {
      final request = UserPlantRequest(
        nickname: _nicknameController.text.trim(),
        speciesId: _selectedSpecies!.id,
        location: _locationController.text.trim().isEmpty
            ? null
            : _locationController.text.trim(),
        acquiredDate: _acquiredDate,
        notes: _notesController.text.trim().isEmpty
            ? null
            : _notesController.text.trim(),
      );
      await ref.read(plantCareProvider.notifier).createUserPlant(request);
      if (mounted) {
        Navigator.pop(context, true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${_nicknameController.text} added successfully!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to add plant: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/screens/plant_care_dashboard_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_care/providers/plant_care_provider.dart';
import 'package:plant_social/features/plant_care/presentation/screens/add_plant_screen.dart';
import 'package:plant_social/features/plant_care/presentation/screens/plant_detail_screen.dart';
import 'package:plant_social/features/plant_care/presentation/screens/care_reminders_screen.dart';
import 'package:plant_social/features/plant_care/presentation/screens/care_logs_screen.dart';
import 'package:plant_social/features/plant_care/presentation/widgets/plant_card.dart';
import 'package:plant_social/features/plant_care/presentation/widgets/care_reminder_card.dart';
import 'package:plant_social/core/widgets/loading_widget.dart';
import 'package:plant_social/core/widgets/error_widget.dart';
class PlantCareDashboardScreen extends ConsumerStatefulWidget {
  const PlantCareDashboardScreen({super.key});
  @override
  ConsumerState<PlantCareDashboardScreen> createState() =>
      _PlantCareDashboardScreenState();
}
class _PlantCareDashboardScreenState
    extends ConsumerState<PlantCareDashboardScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    // Load initial data
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(plantCareProvider.notifier).loadUserPlants();
      ref.read(plantCareProvider.notifier).loadUpcomingReminders();
    });
  }
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(plantCareProvider);
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Plants'),
        backgroundColor: theme.primaryColor,
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {
              // Navigate to plant search
            },
          ),
          IconButton(
            icon: const Icon(Icons.notifications),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const CareRemindersScreen(),
                ),
              );
            },
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          indicatorColor: Colors.white,
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          tabs: const [
            Tab(text: 'Plants', icon: Icon(Icons.eco)),
            Tab(text: 'Reminders', icon: Icon(Icons.schedule)),
            Tab(text: 'Care Log', icon: Icon(Icons.history)),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildPlantsTab(state, theme),
          _buildRemindersTab(state, theme),
          _buildCareLogTab(state, theme),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => const AddPlantScreen(),
            ),
          );
        },
        backgroundColor: theme.primaryColor,
        child: const Icon(Icons.add, color: Colors.white),
      ),
    );
  }
  Widget _buildPlantsTab(PlantCareState state, ThemeData theme) {
    if (state.isLoadingPlants) {
      return const Center(child: LoadingWidget());
    }
    if (state.error != null) {
      return Center(
        child: CustomErrorWidget(
          message: state.error!,
          onRetry: () {
            ref.read(plantCareProvider.notifier).loadUserPlants();
          },
        ),
      );
    }
    if (state.userPlants.isEmpty) {
      return _buildEmptyPlantsState(theme);
    }
    return RefreshIndicator(
      onRefresh: () async {
        await ref.read(plantCareProvider.notifier).loadUserPlants();
      },
      child: CustomScrollView(
        slivers: [
          // Quick stats
          SliverToBoxAdapter(
            child: _buildQuickStats(state, theme),
          ),
          // Plants grid
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                childAspectRatio: 0.8,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  final plant = state.userPlants[index];
                  return PlantCard(
                    plant: plant,
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => PlantDetailScreen(plantId: plant.id),
                        ),
                      );
                    },
                  );
                },
                childCount: state.userPlants.length,
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildRemindersTab(PlantCareState state, ThemeData theme) {
    if (state.isLoadingReminders) {
      return const Center(child: LoadingWidget());
    }
    if (state.error != null) {
      return Center(
        child: CustomErrorWidget(
          message: state.error!,
          onRetry: () {
            ref.read(plantCareProvider.notifier).loadUpcomingReminders();
          },
        ),
      );
    }
    if (state.upcomingReminders.isEmpty) {
      return _buildEmptyRemindersState(theme);
    }
    return RefreshIndicator(
      onRefresh: () async {
        await ref.read(plantCareProvider.notifier).loadUpcomingReminders();
      },
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: state.upcomingReminders.length,
        itemBuilder: (context, index) {
          final reminder = state.upcomingReminders[index];
          return CareReminderCard(
            reminder: reminder,
            onTap: () {},
            onComplete: () {
              ref.read(plantCareProvider.notifier).completeReminder(reminder.id);
            },
            onSnooze: () {
              ref.read(plantCareProvider.notifier).snoozeReminder(reminder.id, 1);
            },
          );
        },
      ),
    );
  }
  Widget _buildCareLogTab(PlantCareState state, ThemeData theme) {
    return const CareLogsScreen();
  }
  Widget _buildQuickStats(PlantCareState state, ThemeData theme) {
    final totalPlants = state.userPlants.length;
    final upcomingReminders = state.upcomingReminders.length;
    final overdueReminders = state.upcomingReminders
        .where((r) => r.nextDueDate.isBefore(DateTime.now()))
        .length;
    return Container(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [theme.primaryColor, theme.primaryColor.withValues(alpha: 0.8)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: theme.primaryColor.withValues(alpha: 0.3),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          Expanded(
            child: _buildStatItem(
              'Plants',
              totalPlants.toString(),
              Icons.eco,
              Colors.white,
            ),
          ),
          Container(
            width: 1,
            height: 40,
            color: Colors.white.withValues(alpha: 0.3),
          ),
          Expanded(
            child: _buildStatItem(
              'Upcoming',
              upcomingReminders.toString(),
              Icons.schedule,
              Colors.white,
            ),
          ),
          Container(
            width: 1,
            height: 40,
            color: Colors.white.withValues(alpha: 0.3),
          ),
          Expanded(
            child: _buildStatItem(
              'Overdue',
              overdueReminders.toString(),
              Icons.warning,
              overdueReminders > 0 ? Colors.orange[300]! : Colors.white,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildStatItem(String label, String value, IconData icon, Color color) {
    return Column(
      children: [
        Icon(
          icon,
          color: color,
          size: 24,
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: TextStyle(
            color: color,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            color: color.withValues(alpha: 0.9),
            fontSize: 12,
          ),
        ),
      ],
    );
  }
  Widget _buildEmptyPlantsState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.eco,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No plants yet',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Add your first plant to start tracking care',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.grey[500],
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const AddPlantScreen(),
                ),
              );
            },
            icon: const Icon(Icons.add),
            label: const Text('Add Plant'),
            style: ElevatedButton.styleFrom(
              backgroundColor: theme.primaryColor,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(
                horizontal: 24,
                vertical: 12,
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildEmptyRemindersState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.schedule,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No upcoming reminders',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'All your plants are up to date!',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.grey[500],
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/screens/plant_detail_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_care/providers/plant_care_provider.dart';
import 'package:plant_social/features/plant_care/presentation/widgets/care_reminder_card.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/custom_button.dart';
class PlantDetailScreen extends ConsumerStatefulWidget {
  final String plantId;
  const PlantDetailScreen({
    super.key,
    required this.plantId,
  });
  @override
  ConsumerState<PlantDetailScreen> createState() => _PlantDetailScreenState();
}
class _PlantDetailScreenState extends ConsumerState<PlantDetailScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  UserPlant? _plant;
  bool _isLoading = true;
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _loadPlantDetails();
  }
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
  Future<void> _loadPlantDetails() async {
    try {
      final plant = await ref
          .read(plantCareServiceProvider)
          .getUserPlant(widget.plantId);
      setState(() {
        _plant = plant;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Plant Details'),
        ),
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    if (_plant == null) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Plant Details'),
        ),
        body: const Center(
          child: Text('Plant not found'),
        ),
      );
    }
    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (context, innerBoxIsScrolled) => [
          _buildSliverAppBar(theme),
        ],
        body: Column(
          children: [
            _buildTabBar(theme),
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  _buildOverviewTab(),
                  _buildCareLogTab(),
                  _buildRemindersTab(),
                ],
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: _buildFloatingActionButton(theme),
    );
  }
  Widget _buildSliverAppBar(ThemeData theme) {
    return SliverAppBar(
      expandedHeight: 300,
      pinned: true,
      flexibleSpace: FlexibleSpaceBar(
        title: Text(
          _plant!.nickname,
          style: const TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
            shadows: [
              Shadow(
                offset: Offset(0, 1),
                blurRadius: 3,
                color: Colors.black54,
              ),
            ],
          ),
        ),
        background: Stack(
          fit: StackFit.expand,
          children: [
            _plant!.imageUrl != null
                ? Image.network(
                    _plant!.imageUrl!,
                    fit: BoxFit.cover,
                    errorBuilder: (context, error, stackTrace) {
                      return _buildImagePlaceholder(theme);
                    },
                  )
                : _buildImagePlaceholder(theme),
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.transparent,
                    Colors.black.withOpacity(0.7),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
      actions: [
        IconButton(
          onPressed: _showPlantOptions,
          icon: const Icon(Icons.more_vert),
        ),
      ],
    );
  }
  Widget _buildImagePlaceholder(ThemeData theme) {
    return Container(
      color: theme.primaryColor.withOpacity(0.1),
      child: Icon(
        Icons.eco,
        size: 80,
        color: theme.primaryColor.withOpacity(0.5),
      ),
    );
  }
  Widget _buildTabBar(ThemeData theme) {
    return Container(
      color: theme.scaffoldBackgroundColor,
      child: TabBar(
        controller: _tabController,
        labelColor: theme.primaryColor,
        unselectedLabelColor: Colors.grey,
        indicatorColor: theme.primaryColor,
        tabs: const [
          Tab(text: 'Overview'),
          Tab(text: 'Care Log'),
          Tab(text: 'Reminders'),
        ],
      ),
    );
  }
  Widget _buildOverviewTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Plant info card
          _buildInfoCard(),
          const SizedBox(height: 16),
          // Species info card
          if (_plant!.species != null) _buildSpeciesCard(),
          const SizedBox(height: 16),
          // Care statistics
          _buildCareStatsCard(),
        ],
      ),
    );
  }
  Widget _buildInfoCard() {
    final theme = Theme.of(context);
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Plant Information',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            _buildInfoRow(Icons.pets, 'Nickname', _plant!.nickname),
            if (_plant!.location != null)
              _buildInfoRow(Icons.location_on, 'Location', _plant!.location!),
            _buildInfoRow(
              Icons.calendar_today,
              'Acquired',
              _formatDate(_plant!.acquiredDate),
            ),
            _buildInfoRow(
              Icons.schedule,
              'Days with you',
              '${DateTime.now().difference(_plant!.acquiredDate).inDays} days',
            ),
            if (_plant!.notes != null && _plant!.notes!.isNotEmpty) ...[
              const SizedBox(height: 8),
              Text(
                'Notes',
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                _plant!.notes!,
                style: theme.textTheme.bodyMedium,
              ),
            ],
          ],
        ),
      ),
    );
  }
  Widget _buildSpeciesCard() {
    final theme = Theme.of(context);
    final species = _plant!.species!;
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Species Information',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            _buildInfoRow(Icons.eco, 'Common Name', species.commonName),
            _buildInfoRow(Icons.science, 'Scientific Name', species.scientificName),
            if (species.family != null)
              _buildInfoRow(Icons.category, 'Family', species.family!),
            if (species.description != null && species.description!.isNotEmpty) ...[
              const SizedBox(height: 12),
              Text(
                'Description',
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                species.description!,
                style: theme.textTheme.bodyMedium,
              ),
            ],
          ],
        ),
      ),
    );
  }
  Widget _buildCareStatsCard() {
    final theme = Theme.of(context);
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Care Statistics',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Care Logs',
                    '${_plant!.careLogs?.length ?? 0}',
                    Icons.history,
                    Colors.blue,
                  ),
                ),
                Expanded(
                  child: _buildStatItem(
                    'Active Reminders',
                    '${_plant!.reminders?.where((r) => r.isActive).length ?? 0}',
                    Icons.notifications,
                    Colors.orange,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (_plant!.careLogs != null && _plant!.careLogs!.isNotEmpty)
              _buildInfoRow(
                Icons.water_drop,
                'Last Watered',
                _getLastCareDate('watering') ?? 'Never',
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildStatItem(String label, String value, IconData icon, Color color) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Icon(icon, color: color, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: theme.textTheme.titleLarge?.copyWith(
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          Text(
            label,
            style: theme.textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  Widget _buildInfoRow(IconData icon, String label, String value) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.grey[600]),
          const SizedBox(width: 12),
          Text(
            '$label:',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              value,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildCareLogTab() {
    if (_plant!.careLogs == null || _plant!.careLogs!.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.history, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              'No care logs yet',
              style: TextStyle(fontSize: 18, color: Colors.grey),
            ),
            SizedBox(height: 8),
            Text(
              'Start logging your plant care activities',
              style: TextStyle(color: Colors.grey),
            ),
          ],
        ),
      );
    }
    final sortedLogs = List<PlantCareLog>.from(_plant!.careLogs!)
      ..sort((a, b) => b.careDate.compareTo(a.careDate));
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: sortedLogs.length,
      itemBuilder: (context, index) {
        final log = sortedLogs[index];
        return _buildCareLogCard(log);
      },
    );
  }
  Widget _buildCareLogCard(PlantCareLog log) {
    final theme = Theme.of(context);
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: _getCareTypeColor(log.careType).withOpacity(0.1),
          child: Icon(
            _getCareTypeIcon(log.careType),
            color: _getCareTypeColor(log.careType),
          ),
        ),
        title: Text(_getCareTypeDisplayName(log.careType)),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(_formatDate(log.careDate)),
            if (log.notes != null && log.notes!.isNotEmpty)
              Text(
                log.notes!,
                style: theme.textTheme.bodySmall?.copyWith(
                  fontStyle: FontStyle.italic,
                ),
              ),
          ],
        ),
        isThreeLine: log.notes != null && log.notes!.isNotEmpty,
      ),
    );
  }
  Widget _buildRemindersTab() {
    if (_plant!.reminders == null || _plant!.reminders!.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.notifications_off, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              'No reminders set',
              style: TextStyle(fontSize: 18, color: Colors.grey),
            ),
            SizedBox(height: 8),
            Text(
              'Set up care reminders to never forget',
              style: TextStyle(color: Colors.grey),
            ),
          ],
        ),
      );
    }
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: _plant!.reminders!.length,
      itemBuilder: (context, index) {
        final reminder = _plant!.reminders![index];
        return CareReminderCard(
          reminder: reminder,
          onTap: () => _editReminder(reminder),
          onComplete: () => _completeReminder(reminder),
          onSnooze: () => _snoozeReminder(reminder),
        );
      },
    );
  }
  Widget _buildFloatingActionButton(ThemeData theme) {
    return FloatingActionButton(
      onPressed: _showAddCareOptions,
      child: const Icon(Icons.add),
    );
  }
  void _showPlantOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.edit),
              title: const Text('Edit Plant'),
              onTap: () {
                Navigator.pop(context);
                _editPlant();
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_camera),
              title: const Text('Update Photo'),
              onTap: () {
                Navigator.pop(context);
                _updatePhoto();
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete, color: Colors.red),
              title: const Text('Delete Plant', style: TextStyle(color: Colors.red)),
              onTap: () {
                Navigator.pop(context);
                _deletePlant();
              },
            ),
          ],
        ),
      ),
    );
  }
  void _showAddCareOptions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.add),
              title: const Text('Log Care Activity'),
              onTap: () {
                Navigator.pop(context);
                _addCareLog();
              },
            ),
            ListTile(
              leading: const Icon(Icons.notifications),
              title: const Text('Add Reminder'),
              onTap: () {
                Navigator.pop(context);
                _addReminder();
              },
            ),
          ],
        ),
      ),
    );
  }
  // Helper methods
  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
  String? _getLastCareDate(String careType) {
    if (_plant!.careLogs == null || _plant!.careLogs!.isEmpty) return null;
    final logs = _plant!.careLogs!
        .where((log) => log.careType.toLowerCase() == careType.toLowerCase())
        .toList()
      ..sort((a, b) => b.careDate.compareTo(a.careDate));
    if (logs.isEmpty) return null;
    return _formatDate(logs.first.careDate);
  }
  IconData _getCareTypeIcon(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return Icons.water_drop;
      case 'fertilizing':
        return Icons.eco;
      case 'pruning':
        return Icons.content_cut;
      case 'repotting':
        return Icons.grass;
      default:
        return Icons.schedule;
    }
  }
  Color _getCareTypeColor(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return Colors.blue;
      case 'fertilizing':
        return Colors.green;
      case 'pruning':
        return Colors.orange;
      case 'repotting':
        return Colors.brown;
      default:
        return Colors.grey;
    }
  }
  String _getCareTypeDisplayName(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return 'Watering';
      case 'fertilizing':
        return 'Fertilizing';
      case 'pruning':
        return 'Pruning';
      case 'repotting':
        return 'Repotting';
      default:
        return careType;
    }
  }
  // Action methods (to be implemented)
  void _editPlant() {
    // TODO: Navigate to edit plant screen
  }
  void _updatePhoto() {
    // TODO: Implement photo update
  }
  void _deletePlant() {
    // TODO: Implement plant deletion with confirmation
  }
  void _addCareLog() {
    // TODO: Navigate to add care log screen
  }
  void _addReminder() {
    // TODO: Navigate to add reminder screen
  }
  void _editReminder(PlantCareReminder reminder) {
    // TODO: Navigate to edit reminder screen
  }
  void _completeReminder(PlantCareReminder reminder) {
    // TODO: Mark reminder as completed and log care activity
  }
  void _snoozeReminder(PlantCareReminder reminder) {
    // TODO: Snooze reminder for a specified duration
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/widgets/care_reminder_card.dart">
import 'package:flutter/material.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class CareReminderCard extends StatelessWidget {
  final PlantCareReminder reminder;
  final VoidCallback onTap;
  final VoidCallback? onComplete;
  final VoidCallback? onSnooze;
  const CareReminderCard({
    super.key,
    required this.reminder,
    required this.onTap,
    this.onComplete,
    this.onSnooze,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isOverdue = reminder.nextDueDate.isBefore(DateTime.now());
    final isUpcoming = reminder.nextDueDate.isAfter(DateTime.now()) &&
        reminder.nextDueDate.isBefore(DateTime.now().add(const Duration(days: 1)));
    return Card(
      elevation: isOverdue ? 6 : 2,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isOverdue
              ? Colors.red.withOpacity(0.3)
              : isUpcoming
                  ? Colors.orange.withOpacity(0.3)
                  : Colors.transparent,
          width: isOverdue || isUpcoming ? 1 : 0,
        ),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Care type icon
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: _getCareTypeColor(reminder.careType).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  _getCareTypeIcon(reminder.careType),
                  color: _getCareTypeColor(reminder.careType),
                  size: 24,
                ),
              ),
              const SizedBox(width: 16),
              // Reminder details
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Care type and plant name
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            _getCareTypeDisplayName(reminder.careType),
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: isOverdue ? Colors.red[700] : null,
                            ),
                          ),
                        ),
                        if (isOverdue)
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.red[100],
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              'OVERDUE',
                              style: TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                                color: Colors.red[700],
                              ),
                            ),
                          )
                        else if (isUpcoming)
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.orange[100],
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              'DUE SOON',
                              style: TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                                color: Colors.orange[700],
                              ),
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    // Plant nickname
                    Text(
                      reminder.plant?.nickname ?? 'Unknown Plant',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: Colors.grey[600],
                      ),
                    ),
                    const SizedBox(height: 8),
                    // Due date and frequency
                    Row(
                      children: [
                        Icon(
                          Icons.schedule,
                          size: 14,
                          color: Colors.grey[500],
                        ),
                        const SizedBox(width: 4),
                        Text(
                          _getFormattedDueDate(),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: isOverdue
                                ? Colors.red[600]
                                : isUpcoming
                                    ? Colors.orange[600]
                                    : Colors.grey[600],
                            fontWeight: isOverdue || isUpcoming
                                ? FontWeight.w600
                                : FontWeight.normal,
                          ),
                        ),
                        const SizedBox(width: 16),
                        Icon(
                          Icons.repeat,
                          size: 14,
                          color: Colors.grey[500],
                        ),
                        const SizedBox(width: 4),
                        Text(
                          _getFrequencyText(),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                    // Notes if available
                    if (reminder.notes != null && reminder.notes!.isNotEmpty) ...[
                      const SizedBox(height: 8),
                      Text(
                        reminder.notes!,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: Colors.grey[500],
                          fontStyle: FontStyle.italic,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ],
                ),
              ),
              // Action buttons
              Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (onComplete != null)
                    IconButton(
                      onPressed: onComplete,
                      icon: Icon(
                        Icons.check_circle_outline,
                        color: Colors.green[600],
                      ),
                      tooltip: 'Mark as completed',
                    ),
                  if (onSnooze != null && (isOverdue || isUpcoming))
                    IconButton(
                      onPressed: onSnooze,
                      icon: Icon(
                        Icons.snooze,
                        color: Colors.orange[600],
                      ),
                      tooltip: 'Snooze reminder',
                    ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  IconData _getCareTypeIcon(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return Icons.water_drop;
      case 'fertilizing':
        return Icons.eco;
      case 'pruning':
        return Icons.content_cut;
      case 'repotting':
        return Icons.grass;
      case 'pest_check':
        return Icons.bug_report;
      case 'rotation':
        return Icons.rotate_right;
      case 'misting':
        return Icons.cloud;
      case 'cleaning':
        return Icons.cleaning_services;
      default:
        return Icons.schedule;
    }
  }
  Color _getCareTypeColor(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return Colors.blue;
      case 'fertilizing':
        return Colors.green;
      case 'pruning':
        return Colors.orange;
      case 'repotting':
        return Colors.brown;
      case 'pest_check':
        return Colors.red;
      case 'rotation':
        return Colors.purple;
      case 'misting':
        return Colors.lightBlue;
      case 'cleaning':
        return Colors.teal;
      default:
        return Colors.grey;
    }
  }
  String _getCareTypeDisplayName(String careType) {
    switch (careType.toLowerCase()) {
      case 'watering':
        return 'Watering';
      case 'fertilizing':
        return 'Fertilizing';
      case 'pruning':
        return 'Pruning';
      case 'repotting':
        return 'Repotting';
      case 'pest_check':
        return 'Pest Check';
      case 'rotation':
        return 'Rotation';
      case 'misting':
        return 'Misting';
      case 'cleaning':
        return 'Cleaning';
      default:
        return careType.replaceAll('_', ' ').split(' ').map((word) {
          return word.isNotEmpty
              ? word[0].toUpperCase() + word.substring(1).toLowerCase()
              : word;
        }).join(' ');
    }
  }
  String _getFormattedDueDate() {
    final now = DateTime.now();
    final dueDate = reminder.nextDueDate;
    final difference = dueDate.difference(now);
    if (difference.isNegative) {
      final daysPast = difference.inDays.abs();
      if (daysPast == 0) {
        return 'Due today';
      } else if (daysPast == 1) {
        return '1 day overdue';
      } else {
        return '$daysPast days overdue';
      }
    } else if (difference.inDays == 0) {
      return 'Due today';
    } else if (difference.inDays == 1) {
      return 'Due tomorrow';
    } else if (difference.inDays < 7) {
      return 'Due in ${difference.inDays} days';
    } else {
      return 'Due ${dueDate.day}/${dueDate.month}';
    }
  }
  String _getFrequencyText() {
    final frequency = reminder.frequencyDays;
    if (frequency == 1) {
      return 'Daily';
    } else if (frequency == 7) {
      return 'Weekly';
    } else if (frequency == 14) {
      return 'Bi-weekly';
    } else if (frequency == 30) {
      return 'Monthly';
    } else if (frequency < 7) {
      return 'Every $frequency days';
    } else {
      final weeks = (frequency / 7).round();
      return 'Every $weeks weeks';
    }
  }
}
</file>

<file path="frontend/lib/features/plant_care/presentation/widgets/plant_card.dart">
import 'package:flutter/material.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/core/theme/app_theme.dart';
class PlantCard extends StatelessWidget {
  final UserPlant plant;
  final VoidCallback onTap;
  final VoidCallback? onLongPress;
  const PlantCard({
    super.key,
    required this.plant,
    required this.onTap,
    this.onLongPress,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        onLongPress: onLongPress,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Plant image
            Expanded(
              flex: 3,
              child: Container(
                width: double.infinity,
                decoration: BoxDecoration(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  color: Colors.grey[200],
                ),
                child: ClipRRect(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  child: plant.imageUrl != null
                      ? Image.network(
                          plant.imageUrl!,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return _buildPlaceholder(theme);
                          },
                        )
                      : _buildPlaceholder(theme),
                ),
              ),
            ),
            // Plant info
            Expanded(
              flex: 2,
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Plant nickname
                    Text(
                      plant.nickname,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    // Species name
                    if (plant.species != null)
                      Text(
                        plant.species!.commonName,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: Colors.grey[600],
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    const Spacer(),
                    // Care status or location
                    Row(
                      children: [
                        if (plant.location != null) ...[
                          Icon(
                            Icons.location_on,
                            size: 14,
                            color: Colors.grey[500],
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              plant.location!,
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: Colors.grey[500],
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ] else ...[
                          Icon(
                            Icons.schedule,
                            size: 14,
                            color: Colors.grey[500],
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              _getAcquiredDateText(),
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: Colors.grey[500],
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
            ),
            // Care indicators
            if (plant.reminders != null && plant.reminders!.isNotEmpty)
              _buildCareIndicators(theme),
          ],
        ),
      ),
    );
  }
  Widget _buildPlaceholder(ThemeData theme) {
    return Container(
      width: double.infinity,
      height: double.infinity,
      color: theme.primaryColor.withOpacity(0.1),
      child: Icon(
        Icons.eco,
        size: 40,
        color: theme.primaryColor.withOpacity(0.5),
      ),
    );
  }
  Widget _buildCareIndicators(ThemeData theme) {
    final activeReminders = plant.reminders!
        .where((reminder) => reminder.isActive)
        .toList();
    if (activeReminders.isEmpty) return const SizedBox.shrink();
    final overdueCount = activeReminders
        .where((reminder) => reminder.nextDueDate.isBefore(DateTime.now()))
        .length;
    final upcomingCount = activeReminders
        .where((reminder) => 
            reminder.nextDueDate.isAfter(DateTime.now()) &&
            reminder.nextDueDate.isBefore(DateTime.now().add(const Duration(days: 3))))
        .length;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(16),
          bottomRight: Radius.circular(16),
        ),
      ),
      child: Row(
        children: [
          if (overdueCount > 0) ...[
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.red[100],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.warning,
                    size: 12,
                    color: Colors.red[700],
                  ),
                  const SizedBox(width: 2),
                  Text(
                    overdueCount.toString(),
                    style: TextStyle(
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                      color: Colors.red[700],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 4),
          ],
          if (upcomingCount > 0) ...[
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: Colors.orange[100],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.schedule,
                    size: 12,
                    color: Colors.orange[700],
                  ),
                  const SizedBox(width: 2),
                  Text(
                    upcomingCount.toString(),
                    style: TextStyle(
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                      color: Colors.orange[700],
                    ),
                  ),
                ],
              ),
            ),
          ],
          const Spacer(),
          Text(
            '${activeReminders.length} reminder${activeReminders.length != 1 ? 's' : ''}',
            style: theme.textTheme.bodySmall?.copyWith(
              color: Colors.grey[600],
              fontSize: 10,
            ),
          ),
        ],
      ),
    );
  }
  String _getAcquiredDateText() {
    final now = DateTime.now();
    final difference = now.difference(plant.acquiredDate);
    if (difference.inDays == 0) {
      return 'Added today';
    } else if (difference.inDays == 1) {
      return 'Added yesterday';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else if (difference.inDays < 30) {
      final weeks = (difference.inDays / 7).floor();
      return '$weeks week${weeks != 1 ? 's' : ''} ago';
    } else if (difference.inDays < 365) {
      final months = (difference.inDays / 30).floor();
      return '$months month${months != 1 ? 's' : ''} ago';
    } else {
      final years = (difference.inDays / 365).floor();
      return '$years year${years != 1 ? 's' : ''} ago';
    }
  }
}
</file>

<file path="frontend/lib/features/plant_care/providers/plant_care_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/core/services/api_service.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_care/services/plant_care_service.dart';
// Service provider
final plantCareServiceProvider = Provider<PlantCareService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return PlantCareService(apiService);
});
// Main state provider
final plantCareProvider = StateNotifierProvider<PlantCareNotifier, PlantCareState>((ref) {
  final service = ref.watch(plantCareServiceProvider);
  return PlantCareNotifier(service);
});
// Individual providers for specific use cases
final userPlantsProvider = Provider<List<UserPlant>>((ref) {
  return ref.watch(plantCareProvider).userPlants;
});
final careLogsProvider = Provider<List<PlantCareLog>>((ref) {
  return ref.watch(plantCareProvider).careLogs;
});
final remindersProvider = Provider<List<PlantCareReminder>>((ref) {
  return ref.watch(plantCareProvider).reminders;
});
final upcomingRemindersProvider = Provider<List<PlantCareReminder>>((ref) {
  return ref.watch(plantCareProvider).upcomingReminders;
});
// Individual user plant provider
final userPlantProvider = FutureProvider.family<UserPlant, String>((ref, plantId) async {
  final service = ref.watch(plantCareServiceProvider);
  return service.getUserPlant(plantId);
});
// Plant species provider for selection
final plantSpeciesSearchProvider = FutureProvider.family<List<PlantSpecies>, String>((ref, query) async {
  final service = ref.watch(plantCareServiceProvider);
  return service.searchPlantSpecies(search: query, limit: 20);
});
// Care statistics provider
final careStatisticsProvider = FutureProvider.family<Map<String, dynamic>, CareStatisticsParams>((ref, params) async {
  final service = ref.watch(plantCareServiceProvider);
  return service.getCareStatistics(
    userPlantId: params.userPlantId,
    startDate: params.startDate,
    endDate: params.endDate,
  );
});
class PlantCareNotifier extends StateNotifier<PlantCareState> {
  final PlantCareService _service;
  PlantCareNotifier(this._service) : super(const PlantCareState());
  // User Plants
  Future<void> loadUserPlants() async {
    state = state.copyWith(isLoadingPlants: true, error: null);
    try {
      final plants = await _service.getUserPlants();
      state = state.copyWith(
        userPlants: plants,
        isLoadingPlants: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoadingPlants: false,
        error: e.toString(),
      );
    }
  }
  Future<void> createUserPlant(UserPlantRequest request) async {
    state = state.copyWith(isCreating: true, createError: null);
    try {
      final plant = await _service.createUserPlant(request);
      state = state.copyWith(
        userPlants: [...state.userPlants, plant],
        isCreating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isCreating: false,
        createError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> updateUserPlant(String plantId, UserPlantRequest request) async {
    state = state.copyWith(isUpdating: true, updateError: null);
    try {
      final updatedPlant = await _service.updateUserPlant(plantId, request);
      final updatedPlants = state.userPlants.map((plant) {
        return plant.id == plantId ? updatedPlant : plant;
      }).toList();
      state = state.copyWith(
        userPlants: updatedPlants,
        isUpdating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isUpdating: false,
        updateError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> deleteUserPlant(String plantId) async {
    state = state.copyWith(isDeleting: true, deleteError: null);
    try {
      await _service.deleteUserPlant(plantId);
      final updatedPlants = state.userPlants.where((plant) => plant.id != plantId).toList();
      state = state.copyWith(
        userPlants: updatedPlants,
        isDeleting: false,
      );
    } catch (e) {
      state = state.copyWith(
        isDeleting: false,
        deleteError: e.toString(),
      );
      rethrow;
    }
  }
  // Care Logs
  Future<void> loadCareLogs({
    String? userPlantId,
    String? careType,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    state = state.copyWith(isLoadingLogs: true, error: null);
    try {
      final logs = await _service.getCareLogs(
        userPlantId: userPlantId,
        careType: careType,
        startDate: startDate,
        endDate: endDate,
      );
      state = state.copyWith(
        careLogs: logs,
        isLoadingLogs: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoadingLogs: false,
        error: e.toString(),
      );
    }
  }
  Future<void> createCareLog(PlantCareRequest request) async {
    state = state.copyWith(isCreating: true, createError: null);
    try {
      final log = await _service.createCareLog(request);
      state = state.copyWith(
        careLogs: [log, ...state.careLogs],
        isCreating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isCreating: false,
        createError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> updateCareLog(String logId, PlantCareRequest request) async {
    state = state.copyWith(isUpdating: true, updateError: null);
    try {
      final updatedLog = await _service.updateCareLog(logId, request);
      final updatedLogs = state.careLogs.map((log) {
        return log.id == logId ? updatedLog : log;
      }).toList();
      state = state.copyWith(
        careLogs: updatedLogs,
        isUpdating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isUpdating: false,
        updateError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> deleteCareLog(String logId) async {
    state = state.copyWith(isDeleting: true, deleteError: null);
    try {
      await _service.deleteCareLog(logId);
      final updatedLogs = state.careLogs.where((log) => log.id != logId).toList();
      state = state.copyWith(
        careLogs: updatedLogs,
        isDeleting: false,
      );
    } catch (e) {
      state = state.copyWith(
        isDeleting: false,
        deleteError: e.toString(),
      );
      rethrow;
    }
  }
  // Care Reminders
  Future<void> loadReminders({
    String? userPlantId,
    String? careType,
    bool? isActive,
  }) async {
    state = state.copyWith(isLoadingReminders: true, error: null);
    try {
      final reminders = await _service.getReminders(
        userPlantId: userPlantId,
        careType: careType,
        isActive: isActive,
      );
      state = state.copyWith(
        reminders: reminders,
        isLoadingReminders: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoadingReminders: false,
        error: e.toString(),
      );
    }
  }
  Future<void> loadUpcomingReminders({int days = 7}) async {
    state = state.copyWith(isLoadingReminders: true, error: null);
    try {
      final reminders = await _service.getUpcomingReminders(days: days);
      state = state.copyWith(
        upcomingReminders: reminders,
        isLoadingReminders: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoadingReminders: false,
        error: e.toString(),
      );
    }
  }
  Future<void> createReminder(PlantCareReminderRequest request) async {
    state = state.copyWith(isCreating: true, createError: null);
    try {
      final reminder = await _service.createReminder(request);
      state = state.copyWith(
        reminders: [...state.reminders, reminder],
        isCreating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isCreating: false,
        createError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> updateReminder(String reminderId, PlantCareReminderRequest request) async {
    state = state.copyWith(isUpdating: true, updateError: null);
    try {
      final updatedReminder = await _service.updateReminder(reminderId, request);
      final updatedReminders = state.reminders.map((reminder) {
        return reminder.id == reminderId ? updatedReminder : reminder;
      }).toList();
      state = state.copyWith(
        reminders: updatedReminders,
        isUpdating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isUpdating: false,
        updateError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> deleteReminder(String reminderId) async {
    state = state.copyWith(isDeleting: true, deleteError: null);
    try {
      await _service.deleteReminder(reminderId);
      final updatedReminders = state.reminders.where((reminder) => reminder.id != reminderId).toList();
      final updatedUpcoming = state.upcomingReminders.where((reminder) => reminder.id != reminderId).toList();
      state = state.copyWith(
        reminders: updatedReminders,
        upcomingReminders: updatedUpcoming,
        isDeleting: false,
      );
    } catch (e) {
      state = state.copyWith(
        isDeleting: false,
        deleteError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> completeReminder(String reminderId) async {
    state = state.copyWith(isUpdating: true, updateError: null);
    try {
      final updatedReminder = await _service.completeReminder(reminderId);
      final updatedReminders = state.reminders.map((reminder) {
        return reminder.id == reminderId ? updatedReminder : reminder;
      }).toList();
      final updatedUpcoming = state.upcomingReminders.where((reminder) => reminder.id != reminderId).toList();
      state = state.copyWith(
        reminders: updatedReminders,
        upcomingReminders: updatedUpcoming,
        isUpdating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isUpdating: false,
        updateError: e.toString(),
      );
      rethrow;
    }
  }
  Future<void> snoozeReminder(String reminderId, int days) async {
    state = state.copyWith(isUpdating: true, updateError: null);
    try {
      final updatedReminder = await _service.snoozeReminder(reminderId, days);
      final updatedReminders = state.reminders.map((reminder) {
        return reminder.id == reminderId ? updatedReminder : reminder;
      }).toList();
      final updatedUpcoming = state.upcomingReminders.map((reminder) {
        return reminder.id == reminderId ? updatedReminder : reminder;
      }).toList();
      state = state.copyWith(
        reminders: updatedReminders,
        upcomingReminders: updatedUpcoming,
        isUpdating: false,
      );
    } catch (e) {
      state = state.copyWith(
        isUpdating: false,
        updateError: e.toString(),
      );
      rethrow;
    }
  }
  // Utility methods
  void clearErrors() {
    state = state.copyWith(
      error: null,
      createError: null,
      updateError: null,
      deleteError: null,
    );
  }
  void reset() {
    state = const PlantCareState();
  }
}
// Helper class for care statistics parameters
class CareStatisticsParams {
  final String? userPlantId;
  final DateTime? startDate;
  final DateTime? endDate;
  const CareStatisticsParams({
    this.userPlantId,
    this.startDate,
    this.endDate,
  });
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CareStatisticsParams &&
        other.userPlantId == userPlantId &&
        other.startDate == startDate &&
        other.endDate == endDate;
  }
  @override
  int get hashCode => Object.hash(userPlantId, startDate, endDate);
}
</file>

<file path="frontend/lib/features/plant_care/services/plant_care_service.dart">
import 'package:dio/dio.dart';
import 'package:plant_social/core/services/api_service.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
class PlantCareService {
  final ApiService _apiService;
  PlantCareService(this._apiService);
  // User Plants
  Future<List<UserPlant>> getUserPlants() async {
    try {
      final response = await _apiService.get('/user-plants');
      final List<dynamic> data = response.data['data'] ?? [];
      return data.map((json) => UserPlant.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<UserPlant> getUserPlant(String plantId) async {
    try {
      final response = await _apiService.get('/user-plants/$plantId');
      return UserPlant.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<UserPlant> createUserPlant(UserPlantRequest request) async {
    try {
      final response = await _apiService.post(
        '/user-plants',
        data: request.toJson(),
      );
      return UserPlant.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<UserPlant> updateUserPlant(String plantId, UserPlantRequest request) async {
    try {
      final response = await _apiService.put(
        '/user-plants/$plantId',
        data: request.toJson(),
      );
      return UserPlant.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<void> deleteUserPlant(String plantId) async {
    try {
      await _apiService.delete('/user-plants/$plantId');
    } catch (e) {
      throw _handleError(e);
    }
  }
  // Care Logs
  Future<List<PlantCareLog>> getCareLogs({
    String? userPlantId,
    String? careType,
    DateTime? startDate,
    DateTime? endDate,
    int? limit,
  }) async {
    try {
      final queryParams = <String, dynamic>{};
      if (userPlantId != null) queryParams['user_plant_id'] = userPlantId;
      if (careType != null) queryParams['care_type'] = careType;
      if (startDate != null) queryParams['start_date'] = startDate.toIso8601String();
      if (endDate != null) queryParams['end_date'] = endDate.toIso8601String();
      if (limit != null) queryParams['limit'] = limit;
      final response = await _apiService.get(
        '/care-logs',
        queryParameters: queryParams,
      );
      final List<dynamic> data = response.data['data'] ?? [];
      return data.map((json) => PlantCareLog.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareLog> getCareLog(String logId) async {
    try {
      final response = await _apiService.get('/care-logs/$logId');
      return PlantCareLog.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareLog> createCareLog(PlantCareRequest request) async {
    try {
      final response = await _apiService.post(
        '/care-logs',
        data: request.toJson(),
      );
      return PlantCareLog.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareLog> updateCareLog(String logId, PlantCareRequest request) async {
    try {
      final response = await _apiService.put(
        '/care-logs/$logId',
        data: request.toJson(),
      );
      return PlantCareLog.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<void> deleteCareLog(String logId) async {
    try {
      await _apiService.delete('/care-logs/$logId');
    } catch (e) {
      throw _handleError(e);
    }
  }
  // Care Reminders
  Future<List<PlantCareReminder>> getReminders({
    String? userPlantId,
    String? careType,
    bool? isActive,
    bool? isDue,
  }) async {
    try {
      final queryParams = <String, dynamic>{};
      if (userPlantId != null) queryParams['user_plant_id'] = userPlantId;
      if (careType != null) queryParams['care_type'] = careType;
      if (isActive != null) queryParams['is_active'] = isActive;
      if (isDue != null) queryParams['is_due'] = isDue;
      final response = await _apiService.get(
        '/care-reminders',
        queryParameters: queryParams,
      );
      final List<dynamic> data = response.data['data'] ?? [];
      return data.map((json) => PlantCareReminder.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<List<PlantCareReminder>> getUpcomingReminders({int? days}) async {
    try {
      final queryParams = <String, dynamic>{};
      if (days != null) queryParams['days'] = days;
      final response = await _apiService.get(
        '/care-reminders/upcoming',
        queryParameters: queryParams,
      );
      final List<dynamic> data = response.data['data'] ?? [];
      return data.map((json) => PlantCareReminder.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareReminder> getReminder(String reminderId) async {
    try {
      final response = await _apiService.get('/care-reminders/$reminderId');
      return PlantCareReminder.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareReminder> createReminder(PlantCareReminderRequest request) async {
    try {
      final response = await _apiService.post(
        '/care-reminders',
        data: request.toJson(),
      );
      return PlantCareReminder.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareReminder> updateReminder(
    String reminderId,
    PlantCareReminderRequest request,
  ) async {
    try {
      final response = await _apiService.put(
        '/care-reminders/$reminderId',
        data: request.toJson(),
      );
      return PlantCareReminder.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<void> deleteReminder(String reminderId) async {
    try {
      await _apiService.delete('/care-reminders/$reminderId');
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareReminder> completeReminder(String reminderId) async {
    try {
      final response = await _apiService.post('/care-reminders/$reminderId/complete');
      return PlantCareReminder.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantCareReminder> snoozeReminder(
    String reminderId,
    int days,
  ) async {
    try {
      final response = await _apiService.post(
        '/care-reminders/$reminderId/snooze',
        data: {'days': days},
      );
      return PlantCareReminder.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  // Plant Species (for reference)
  Future<List<PlantSpecies>> searchPlantSpecies({
    String? search,
    int? limit,
  }) async {
    try {
      final queryParams = <String, dynamic>{};
      if (search != null) queryParams['search'] = search;
      if (limit != null) queryParams['limit'] = limit;
      final response = await _apiService.get(
        '/plant-species',
        queryParameters: queryParams,
      );
      final List<dynamic> data = response.data['data'] ?? [];
      return data.map((json) => PlantSpecies.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }
  Future<PlantSpecies> getPlantSpecies(String speciesId) async {
    try {
      final response = await _apiService.get('/plant-species/$speciesId');
      return PlantSpecies.fromJson(response.data['data']);
    } catch (e) {
      throw _handleError(e);
    }
  }
  // Statistics
  Future<Map<String, dynamic>> getCareStatistics({
    String? userPlantId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final queryParams = <String, dynamic>{};
      if (userPlantId != null) queryParams['user_plant_id'] = userPlantId;
      if (startDate != null) queryParams['start_date'] = startDate.toIso8601String();
      if (endDate != null) queryParams['end_date'] = endDate.toIso8601String();
      final response = await _apiService.get(
        '/care-logs/statistics',
        queryParameters: queryParams,
      );
      return response.data['data'] ?? {};
    } catch (e) {
      throw _handleError(e);
    }
  }
  // Image upload
  Future<String> uploadPlantImage(String filePath) async {
    try {
      final formData = FormData.fromMap({
        'image': await MultipartFile.fromFile(filePath),
      });
      final response = await _apiService.post(
        '/upload/plant-image',
        data: formData,
      );
      return response.data['data']['url'];
    } catch (e) {
      throw _handleError(e);
    }
  }
  String _handleError(dynamic error) {
    if (error is DioException) {
      if (error.response?.data != null) {
        final data = error.response!.data;
        if (data is Map<String, dynamic> && data.containsKey('message')) {
          return data['message'];
        }
      }
      return error.message ?? 'Network error occurred';
    }
    return error.toString();
  }
}
</file>

<file path="frontend/lib/features/plant_community/models/plant_community_models.g.dart">
// GENERATED CODE - DO NOT MODIFY BY HAND
part of 'plant_community_models.dart';
// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************
PlantQuestion _$PlantQuestionFromJson(Map<String, dynamic> json) =>
    PlantQuestion(
      id: json['id'] as String,
      userId: json['userId'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      category: json['category'] as String? ?? QuestionCategory.general,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      upvotes: (json['upvotes'] as num?)?.toInt() ?? 0,
      downvotes: (json['downvotes'] as num?)?.toInt() ?? 0,
      views: (json['views'] as num?)?.toInt() ?? 0,
      answerCount: (json['answerCount'] as num?)?.toInt() ?? 0,
      isSolved: json['isSolved'] as bool? ?? false,
      acceptedAnswerId: json['acceptedAnswerId'] as String?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      speciesCommonName: json['speciesCommonName'] as String?,
      speciesScientificName: json['speciesScientificName'] as String?,
      userVote: json['userVote'] as String?,
      isBookmarked: json['isBookmarked'] as bool? ?? false,
    );
Map<String, dynamic> _$PlantQuestionToJson(PlantQuestion instance) =>
    <String, dynamic>{
      'id': instance.id,
      'userId': instance.userId,
      'title': instance.title,
      'content': instance.content,
      'imageUrl': instance.imageUrl,
      'plantSpeciesId': instance.plantSpeciesId,
      'category': instance.category,
      'tags': instance.tags,
      'upvotes': instance.upvotes,
      'downvotes': instance.downvotes,
      'views': instance.views,
      'answerCount': instance.answerCount,
      'isSolved': instance.isSolved,
      'acceptedAnswerId': instance.acceptedAnswerId,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
      'userDisplayName': instance.userDisplayName,
      'userAvatarUrl': instance.userAvatarUrl,
      'speciesCommonName': instance.speciesCommonName,
      'speciesScientificName': instance.speciesScientificName,
      'userVote': instance.userVote,
      'isBookmarked': instance.isBookmarked,
    };
PlantAnswer _$PlantAnswerFromJson(Map<String, dynamic> json) => PlantAnswer(
      id: json['id'] as String,
      questionId: json['questionId'] as String,
      userId: json['userId'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      upvotes: (json['upvotes'] as num?)?.toInt() ?? 0,
      downvotes: (json['downvotes'] as num?)?.toInt() ?? 0,
      isAccepted: json['isAccepted'] as bool? ?? false,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      userVote: json['userVote'] as String?,
    );
Map<String, dynamic> _$PlantAnswerToJson(PlantAnswer instance) =>
    <String, dynamic>{
      'id': instance.id,
      'questionId': instance.questionId,
      'userId': instance.userId,
      'content': instance.content,
      'imageUrl': instance.imageUrl,
      'upvotes': instance.upvotes,
      'downvotes': instance.downvotes,
      'isAccepted': instance.isAccepted,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
      'userDisplayName': instance.userDisplayName,
      'userAvatarUrl': instance.userAvatarUrl,
      'userVote': instance.userVote,
    };
PlantTrade _$PlantTradeFromJson(Map<String, dynamic> json) => PlantTrade(
      id: json['id'] as String,
      userId: json['userId'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      tradeType: json['tradeType'] as String,
      price: json['price'] as String?,
      imageUrls: (json['imageUrls'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      location: json['location'] as String,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      status: json['status'] as String? ?? 'active',
      viewCount: (json['viewCount'] as num?)?.toInt() ?? 0,
      interestedCount: (json['interestedCount'] as num?)?.toInt() ?? 0,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      speciesCommonName: json['speciesCommonName'] as String?,
      speciesScientificName: json['speciesScientificName'] as String?,
      isBookmarked: json['isBookmarked'] as bool? ?? false,
      hasExpressedInterest: json['hasExpressedInterest'] as bool? ?? false,
    );
Map<String, dynamic> _$PlantTradeToJson(PlantTrade instance) =>
    <String, dynamic>{
      'id': instance.id,
      'userId': instance.userId,
      'title': instance.title,
      'description': instance.description,
      'tradeType': instance.tradeType,
      'price': instance.price,
      'imageUrls': instance.imageUrls,
      'location': instance.location,
      'plantSpeciesId': instance.plantSpeciesId,
      'tags': instance.tags,
      'status': instance.status,
      'viewCount': instance.viewCount,
      'interestedCount': instance.interestedCount,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
      'userDisplayName': instance.userDisplayName,
      'userAvatarUrl': instance.userAvatarUrl,
      'speciesCommonName': instance.speciesCommonName,
      'speciesScientificName': instance.speciesScientificName,
      'isBookmarked': instance.isBookmarked,
      'hasExpressedInterest': instance.hasExpressedInterest,
    };
PlantQuestionRequest _$PlantQuestionRequestFromJson(
        Map<String, dynamic> json) =>
    PlantQuestionRequest(
      title: json['title'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
    );
Map<String, dynamic> _$PlantQuestionRequestToJson(
        PlantQuestionRequest instance) =>
    <String, dynamic>{
      'title': instance.title,
      'content': instance.content,
      'imageUrl': instance.imageUrl,
      'plantSpeciesId': instance.plantSpeciesId,
      'tags': instance.tags,
    };
PlantAnswerRequest _$PlantAnswerRequestFromJson(Map<String, dynamic> json) =>
    PlantAnswerRequest(
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
    );
Map<String, dynamic> _$PlantAnswerRequestToJson(PlantAnswerRequest instance) =>
    <String, dynamic>{
      'content': instance.content,
      'imageUrl': instance.imageUrl,
    };
PlantTradeRequest _$PlantTradeRequestFromJson(Map<String, dynamic> json) =>
    PlantTradeRequest(
      title: json['title'] as String,
      description: json['description'] as String,
      tradeType: json['tradeType'] as String,
      price: json['price'] as String?,
      imageUrls: (json['imageUrls'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
      location: json['location'] as String,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
    );
Map<String, dynamic> _$PlantTradeRequestToJson(PlantTradeRequest instance) =>
    <String, dynamic>{
      'title': instance.title,
      'description': instance.description,
      'tradeType': instance.tradeType,
      'price': instance.price,
      'imageUrls': instance.imageUrls,
      'location': instance.location,
      'plantSpeciesId': instance.plantSpeciesId,
      'tags': instance.tags,
    };
PlantCommunityState _$PlantCommunityStateFromJson(Map<String, dynamic> json) =>
    PlantCommunityState(
      isLoading: json['isLoading'] as bool? ?? false,
      questions: (json['questions'] as List<dynamic>?)
              ?.map((e) => PlantQuestion.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      answers: (json['answers'] as List<dynamic>?)
              ?.map((e) => PlantAnswer.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      trades: (json['trades'] as List<dynamic>?)
              ?.map((e) => PlantTrade.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      error: json['error'] as String?,
      hasMoreQuestions: json['hasMoreQuestions'] as bool? ?? false,
      hasMoreTrades: json['hasMoreTrades'] as bool? ?? false,
      currentQuestionPage: (json['currentQuestionPage'] as num?)?.toInt() ?? 1,
      currentTradePage: (json['currentTradePage'] as num?)?.toInt() ?? 1,
      selectedCategory: json['selectedCategory'] as String?,
      searchQuery: json['searchQuery'] as String?,
      sortBy: json['sortBy'] as String?,
    );
Map<String, dynamic> _$PlantCommunityStateToJson(
        PlantCommunityState instance) =>
    <String, dynamic>{
      'isLoading': instance.isLoading,
      'questions': instance.questions,
      'answers': instance.answers,
      'trades': instance.trades,
      'error': instance.error,
      'hasMoreQuestions': instance.hasMoreQuestions,
      'hasMoreTrades': instance.hasMoreTrades,
      'currentQuestionPage': instance.currentQuestionPage,
      'currentTradePage': instance.currentTradePage,
      'selectedCategory': instance.selectedCategory,
      'searchQuery': instance.searchQuery,
      'sortBy': instance.sortBy,
    };
</file>

<file path="frontend/lib/features/plant_community/presentation/screens/plant_trades_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/features/plant_community/providers/plant_community_provider.dart';
import 'package:plant_social/features/plant_community/presentation/widgets/trade_card.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/custom_search_bar.dart';
class PlantTradesScreen extends ConsumerStatefulWidget {
  const PlantTradesScreen({super.key});
  @override
  ConsumerState<PlantTradesScreen> createState() => _PlantTradesScreenState();
}
class _PlantTradesScreenState extends ConsumerState<PlantTradesScreen>
    with SingleTickerProviderStateMixin {
  final _scrollController = ScrollController();
  final _searchController = TextEditingController();
  String? _selectedTradeType;
  String? _selectedSort = SortOption.newest;
  bool _showFilters = false;
  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    // Load initial trades
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(plantCommunityProvider.notifier).loadTrades(refresh: true);
    });
  }
  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }
  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      final state = ref.read(plantCommunityProvider);
      if (!state.isLoading && state.hasMoreTrades) {
        ref.read(plantCommunityProvider.notifier).loadTrades(
          tradeType: _selectedTradeType,
          search: _searchController.text.trim().isEmpty
              ? null
              : _searchController.text.trim(),
          sortBy: _selectedSort,
        );
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final state = ref.watch(plantCommunityProvider);
    final trades = ref.watch(tradesProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Plant Trades'),
        elevation: 0,
        actions: [
          IconButton(
            onPressed: () => setState(() => _showFilters = !_showFilters),
            icon: Icon(
              _showFilters ? Icons.filter_list_off : Icons.filter_list,
            ),
          ),
          IconButton(
            onPressed: _navigateToCreateTrade,
            icon: const Icon(Icons.add),
          ),
        ],
      ),
      body: Column(
        children: [
          // Search bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: CustomSearchBar(
              controller: _searchController,
              hintText: 'Search plants to trade...',
              onChanged: _onSearchChanged,
              onSubmitted: _onSearchSubmitted,
            ),
          ),
          // Filters
          if (_showFilters) _buildFilters(theme),
          // Trades list
          Expanded(
            child: _buildTradesList(trades, state),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _navigateToCreateTrade,
        child: const Icon(Icons.add),
        tooltip: 'Create Trade',
      ),
    );
  }
  Widget _buildFilters(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        border: Border(
          bottom: BorderSide(color: Colors.grey[200]!),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Trade types
          Text(
            'Trade Types',
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 40,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: TradeType.all.length + 1,
              itemBuilder: (context, index) {
                if (index == 0) {
                  return _buildTradeTypeChip(
                    'All',
                    _selectedTradeType == null,
                    () => _selectTradeType(null),
                  );
                }
                final tradeType = TradeType.all[index - 1];
                return _buildTradeTypeChip(
                  TradeType.getDisplayName(tradeType),
                  _selectedTradeType == tradeType,
                  () => _selectTradeType(tradeType),
                );
              },
            ),
          ),
          const SizedBox(height: 16),
          // Sort options
          Row(
            children: [
              Text(
                'Sort by:',
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: DropdownButton<String>(
                  value: _selectedSort,
                  isExpanded: true,
                  underline: const SizedBox.shrink(),
                  items: SortOption.tradeSortOptions.map((option) {
                    return DropdownMenuItem(
                      value: option,
                      child: Text(SortOption.getDisplayName(option)),
                    );
                  }).toList(),
                  onChanged: _selectSort,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  Widget _buildTradeTypeChip(
    String label,
    bool isSelected,
    VoidCallback onTap,
  ) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(right: 8),
      child: FilterChip(
        label: Text(label),
        selected: isSelected,
        onSelected: (_) => onTap(),
        backgroundColor: Colors.grey[100],
        selectedColor: theme.primaryColor.withOpacity(0.2),
        checkmarkColor: theme.primaryColor,
        labelStyle: TextStyle(
          color: isSelected ? theme.primaryColor : Colors.grey[700],
          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
        ),
      ),
    );
  }
  Widget _buildTradesList(
    List<PlantTrade> trades,
    PlantCommunityState state,
  ) {
    if (state.isLoading && trades.isEmpty) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
    if (state.error != null && trades.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load trades',
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 8),
            Text(
              state.error!,
              style: TextStyle(
                color: Colors.grey[500],
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _refreshTrades,
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }
    if (trades.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.swap_horiz,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'No trades available',
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Be the first to create a trade!',
              style: TextStyle(
                color: Colors.grey[500],
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _navigateToCreateTrade,
              child: const Text('Create Trade'),
            ),
          ],
        ),
      );
    }
    return RefreshIndicator(
      onRefresh: _refreshTrades,
      child: ListView.builder(
        controller: _scrollController,
        padding: const EdgeInsets.all(16),
        itemCount: trades.length + (state.hasMoreTrades ? 1 : 0),
        itemBuilder: (context, index) {
          if (index >= trades.length) {
            return const Padding(
              padding: EdgeInsets.all(16),
              child: Center(
                child: CircularProgressIndicator(),
              ),
            );
          }
          final trade = trades[index];
          return TradeCard(
            trade: trade,
            onTap: () => _navigateToTradeDetail(trade),
            onBookmark: () => _bookmarkTrade(trade.id),
            onInterest: () => _expressInterest(trade.id),
          );
        },
      ),
    );
  }
  void _onSearchChanged(String value) {
    // Implement debounced search if needed
  }
  void _onSearchSubmitted(String value) {
    _refreshTrades();
  }
  void _selectTradeType(String? tradeType) {
    setState(() {
      _selectedTradeType = tradeType;
    });
    _refreshTrades();
  }
  void _selectSort(String? sortBy) {
    setState(() {
      _selectedSort = sortBy;
    });
    _refreshTrades();
  }
  Future<void> _refreshTrades() async {
    await ref.read(plantCommunityProvider.notifier).loadTrades(
      refresh: true,
      tradeType: _selectedTradeType,
      search: _searchController.text.trim().isEmpty
          ? null
          : _searchController.text.trim(),
      sortBy: _selectedSort,
    );
  }
  void _bookmarkTrade(String tradeId) {
    ref.read(plantCommunityProvider.notifier).bookmarkTrade(tradeId);
  }
  void _expressInterest(String tradeId) {
    ref.read(plantCommunityProvider.notifier).expressInterest(tradeId);
  }
  void _navigateToCreateTrade() {
    Navigator.pushNamed(
      context,
      '/create-trade',
    ).then((result) {
      if (result == true) {
        _refreshTrades();
      }
    });
  }
  void _navigateToTradeDetail(PlantTrade trade) {
    Navigator.pushNamed(
      context,
      '/trade-detail',
      arguments: trade.id,
    );
  }
}
</file>

<file path="frontend/lib/features/plant_community/presentation/widgets/question_card.dart">
import 'package:flutter/material.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/utils/date_utils.dart' as AppDateUtils;
import 'package:plant_social/core/widgets/user_avatar.dart';
import 'package:plant_social/core/widgets/vote_buttons.dart';
class QuestionCard extends StatelessWidget {
  final PlantQuestion question;
  final VoidCallback? onTap;
  final Function(String)? onVote;
  final VoidCallback? onBookmark;
  final bool showFullContent;
  const QuestionCard({
    super.key,
    required this.question,
    this.onTap,
    this.onVote,
    this.onBookmark,
    this.showFullContent = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header with user info and status
              _buildHeader(theme),
              const SizedBox(height: 12),
              // Title
              Text(
                question.title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurface,
                ),
                maxLines: showFullContent ? null : 2,
                overflow: showFullContent ? null : TextOverflow.ellipsis,
              ),
              const SizedBox(height: 8),
              // Content preview
              if (question.content.isNotEmpty)
                Text(
                  question.content,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: Colors.grey[700],
                  ),
                  maxLines: showFullContent ? null : 3,
                  overflow: showFullContent ? null : TextOverflow.ellipsis,
                ),
              const SizedBox(height: 12),
              // Tags
              if (question.tags.isNotEmpty) _buildTags(theme),
              const SizedBox(height: 12),
              // Images preview
              if (question.imageUrl != null) _buildImagePreview(),
              if (question.imageUrl != null) const SizedBox(height: 12),
              // Footer with stats and actions
              _buildFooter(theme),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme) {
    return Row(
      children: [
        // User avatar
        UserAvatar(
          imageUrl: question.userAvatarUrl,
          username: question.userDisplayName ?? 'Anonymous',
          size: 32,
        ),
        const SizedBox(width: 12),
        // User info and timestamp
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                question.userDisplayName ?? 'Anonymous',
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              Text(
                AppDateUtils.DateUtils.formatRelativeTime(question.createdAt),
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ),
        // Category badge
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: _getCategoryColor(question.category).withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: _getCategoryColor(question.category).withOpacity(0.3),
            ),
          ),
          child: Text(
            QuestionCategory.getDisplayName(question.category),
            style: theme.textTheme.bodySmall?.copyWith(
              color: _getCategoryColor(question.category),
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        // Solved indicator
        if (question.isSolved)
          Container(
            margin: const EdgeInsets.only(left: 8),
            padding: const EdgeInsets.all(4),
            decoration: BoxDecoration(
              color: Colors.green,
              borderRadius: BorderRadius.circular(12),
            ),
            child: const Icon(
              Icons.check,
              size: 16,
              color: Colors.white,
            ),
          ),
      ],
    );
  }
  Widget _buildTags(ThemeData theme) {
    return Wrap(
      spacing: 6,
      runSpacing: 6,
      children: question.tags.take(showFullContent ? question.tags.length : 3).map((tag) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.grey[100],
            borderRadius: BorderRadius.circular(12),
          ),
          child: Text(
            '#$tag',
            style: theme.textTheme.bodySmall?.copyWith(
              color: Colors.grey[700],
              fontWeight: FontWeight.w500,
            ),
          ),
        );
      }).toList(),
    );
  }
  Widget _buildImagePreview() {
    if (question.imageUrl == null) return const SizedBox.shrink();
    return Container(
      height: 80,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: Image.network(
          question.imageUrl!,
          width: 80,
          height: 80,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return Container(
              width: 80,
              height: 80,
              color: Colors.grey[200],
              child: const Icon(
                Icons.image_not_supported,
                color: Colors.grey,
              ),
            );
          },
        ),
      ),
    );
  }
  Widget _buildFooter(ThemeData theme) {
    return Row(
      children: [
        // Vote buttons
        VoteButtons(
          upvotes: question.upvotes,
          downvotes: question.downvotes,
          userVote: question.userVote,
          onVote: onVote,
          size: VoteButtonSize.small,
        ),
        const SizedBox(width: 16),
        // Answer count
        Row(
          children: [
            Icon(
              Icons.chat_bubble_outline,
              size: 16,
              color: Colors.grey[600],
            ),
            const SizedBox(width: 4),
            Text(
              '${question.answerCount}',
              style: theme.textTheme.bodySmall?.copyWith(
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
        const SizedBox(width: 16),
        // View count
        Row(
          children: [
            Icon(
              Icons.visibility_outlined,
              size: 16,
              color: Colors.grey[600],
            ),
            const SizedBox(width: 4),
            Text(
              '${question.views}',
              style: theme.textTheme.bodySmall?.copyWith(
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
        const Spacer(),
        // Bookmark button
        IconButton(
          onPressed: onBookmark,
          icon: Icon(
            question.isBookmarked
                ? Icons.bookmark
                : Icons.bookmark_border,
            size: 20,
            color: question.isBookmarked
                ? theme.primaryColor
                : Colors.grey[600],
          ),
          constraints: const BoxConstraints(
            minWidth: 32,
            minHeight: 32,
          ),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
  Color _getCategoryColor(String category) {
    switch (category) {
      case QuestionCategory.identification:
        return Colors.blue;
      case QuestionCategory.care:
        return Colors.green;
      case QuestionCategory.diseases:
        return Colors.red;
      case QuestionCategory.pests:
        return Colors.orange;
      case QuestionCategory.propagation:
        return Colors.purple;
      case QuestionCategory.general:
      default:
        return Colors.grey;
    }
  }
}
</file>

<file path="frontend/lib/features/plant_community/presentation/widgets/trade_card.dart">
import 'package:flutter/material.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/core/utils/date_utils.dart' as app_date_utils;
import 'package:plant_social/core/widgets/user_avatar.dart';
class TradeCard extends StatelessWidget {
  final PlantTrade trade;
  final VoidCallback? onTap;
  final VoidCallback? onBookmark;
  final VoidCallback? onInterest;
  final bool showFullContent;
  const TradeCard({
    super.key,
    required this.trade,
    this.onTap,
    this.onBookmark,
    this.onInterest,
    this.showFullContent = false,
  });
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header with user info and trade type
              _buildHeader(theme),
              const SizedBox(height: 12),
              // Title
              Text(
                trade.title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onSurface,
                ),
                maxLines: showFullContent ? null : 2,
                overflow: showFullContent ? null : TextOverflow.ellipsis,
              ),
              const SizedBox(height: 8),
              // Description preview
              if (trade.description.isNotEmpty)
                Text(
                  trade.description,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: Colors.grey[700],
                  ),
                  maxLines: showFullContent ? null : 2,
                  overflow: showFullContent ? null : TextOverflow.ellipsis,
                ),
              const SizedBox(height: 12),
              // Plant details
              _buildPlantDetails(theme),
              const SizedBox(height: 12),
              // Images
              if (trade.imageUrls.isNotEmpty) _buildImagePreview(),
              if (trade.imageUrls.isNotEmpty) const SizedBox(height: 12),
              // Footer with location, status, and actions
              _buildFooter(theme),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildHeader(ThemeData theme) {
    return Row(
      children: [
        // User avatar
        UserAvatar(
          imageUrl: trade.userAvatarUrl,
          username: trade.userDisplayName ?? 'Unknown User',
          size: 32,
        ),
        const SizedBox(width: 12),
        // User info and timestamp
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                trade.userDisplayName ?? 'Unknown User',
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              Text(
                app_date_utils.DateUtils.formatRelativeTime(trade.createdAt),
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ),
        // Trade type badge
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: _getTradeTypeColor(trade.tradeType).withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: _getTradeTypeColor(trade.tradeType).withOpacity(0.3),
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                _getTradeTypeIcon(trade.tradeType),
                size: 14,
                color: _getTradeTypeColor(trade.tradeType),
              ),
              const SizedBox(width: 4),
              Text(
                TradeType.getDisplayName(trade.tradeType),
                style: theme.textTheme.bodySmall?.copyWith(
                  color: _getTradeTypeColor(trade.tradeType),
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
        // Status indicator
        Container(
          margin: const EdgeInsets.only(left: 8),
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
          decoration: BoxDecoration(
            color: _getStatusColor(trade.status),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Text(
            _getStatusText(trade.status),
            style: theme.textTheme.bodySmall?.copyWith(
              color: Colors.white,
              fontWeight: FontWeight.w600,
              fontSize: 10,
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildPlantDetails(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Plant name
          Row(
            children: [
              Icon(
                Icons.local_florist,
                size: 16,
                color: Colors.green[600],
              ),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  trade.speciesCommonName ?? trade.title,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: Colors.green[700],
                  ),
                ),
              ),
            ],
          ),
          if (trade.speciesScientificName != null && trade.speciesScientificName!.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(
              trade.speciesScientificName!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: Colors.grey[600],
                fontStyle: FontStyle.italic,
              ),
            ),
          ],
          // What they want (for trade/swap)
          if (trade.tradeType != TradeType.giveAway && trade.description.isNotEmpty) ...[
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.swap_horiz,
                  size: 16,
                  color: Colors.blue[600],
                ),
                const SizedBox(width: 6),
                Expanded(
                  child: Text(
                    'Description: ${trade.description}',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: Colors.blue[700],
                    ),
                  ),
                ),
              ],
            ),
          ],
          // Price (for sale)
          if (trade.tradeType == TradeType.sell && trade.price != null) ...[
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.attach_money,
                  size: 16,
                  color: Colors.orange[600],
                ),
                const SizedBox(width: 6),
                Text(
                  '\$${trade.price}',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Colors.orange[700],
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }
  Widget _buildImagePreview() {
    final imageCount = trade.imageUrls.length;
    final displayCount = showFullContent ? imageCount : (imageCount > 3 ? 3 : imageCount);
    return SizedBox(
      height: 100,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: displayCount,
        itemBuilder: (context, index) {
          final isLast = index == displayCount - 1;
          final hasMore = !showFullContent && imageCount > 3;
          return Container(
            margin: EdgeInsets.only(right: isLast ? 0 : 8),
            child: Stack(
              children: [
                ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.network(
                    trade.imageUrls[index],
                    width: 100,
                    height: 100,
                    fit: BoxFit.cover,
                    errorBuilder: (context, error, stackTrace) {
                      return Container(
                        width: 100,
                        height: 100,
                        color: Colors.grey[200],
                        child: const Icon(
                          Icons.image_not_supported,
                          color: Colors.grey,
                        ),
                      );
                    },
                  ),
                ),
                // Show count overlay on last image if there are more
                if (isLast && hasMore)
                  Positioned.fill(
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.black54,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Center(
                        child: Text(
                          '+${imageCount - 3}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          );
        },
      ),
    );
  }
  Widget _buildFooter(ThemeData theme) {
    return Row(
      children: [
        // Location
        if (trade.location.isNotEmpty) ...[
          Icon(
            Icons.location_on_outlined,
            size: 16,
            color: Colors.grey[600],
          ),
          const SizedBox(width: 4),
          Expanded(
            child: Text(
              trade.location,
              style: theme.textTheme.bodySmall?.copyWith(
                color: Colors.grey[600],
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ] else
          const Spacer(),
        // Interest count
        if (trade.interestedCount > 0) ...[
          const SizedBox(width: 12),
          Row(
            children: [
              Icon(
                Icons.favorite_outline,
                size: 16,
                color: Colors.grey[600],
              ),
              const SizedBox(width: 4),
              Text(
                '${trade.interestedCount}',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ],
        // Action buttons
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Interest button
            if (trade.status == 'active' && onInterest != null)
              IconButton(
                onPressed: onInterest,
                icon: Icon(
                  trade.hasExpressedInterest
                      ? Icons.favorite
                      : Icons.favorite_outline,
                  size: 20,
                  color: trade.hasExpressedInterest
                      ? Colors.red
                      : Colors.grey[600],
                ),
                constraints: const BoxConstraints(
                  minWidth: 32,
                  minHeight: 32,
                ),
                padding: EdgeInsets.zero,
              ),
            // Bookmark button
            IconButton(
              onPressed: onBookmark,
              icon: Icon(
                trade.isBookmarked
                    ? Icons.bookmark
                    : Icons.bookmark_border,
                size: 20,
                color: trade.isBookmarked
                    ? theme.primaryColor
                    : Colors.grey[600],
              ),
              constraints: const BoxConstraints(
                minWidth: 32,
                minHeight: 32,
              ),
              padding: EdgeInsets.zero,
            ),
          ],
        ),
      ],
    );
  }
  Color _getTradeTypeColor(String tradeType) {
    switch (tradeType) {
      case TradeType.trade:
        return Colors.blue;
      case TradeType.sell:
        return Colors.orange;
      case TradeType.giveAway:
        return Colors.green;
      default:
        return Colors.grey;
    }
  }
  IconData _getTradeTypeIcon(String tradeType) {
    switch (tradeType) {
      case TradeType.trade:
        return Icons.swap_horiz;
      case TradeType.sell:
        return Icons.attach_money;
      case TradeType.giveAway:
        return Icons.card_giftcard;
      default:
        return Icons.help_outline;
    }
  }
  Color _getStatusColor(String status) {
    switch (status) {
      case 'active':
        return Colors.green;
      case 'pending':
        return Colors.orange;
      case 'completed':
        return Colors.blue;
      case 'cancelled':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
  String _getStatusText(String status) {
    switch (status) {
      case 'active':
        return 'ACTIVE';
      case 'pending':
        return 'PENDING';
      case 'completed':
        return 'DONE';
      case 'cancelled':
        return 'CANCELLED';
      default:
        return status.toUpperCase();
    }
  }
}
</file>

<file path="frontend/lib/features/plant_community/services/plant_community_service.dart">
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:plant_social/features/plant_community/models/plant_community_models.dart';
import 'package:plant_social/core/services/api_service.dart';
import 'package:plant_social/core/services/storage_service.dart';
class PlantCommunityService {
  final ApiService _apiService;
  final StorageService _storageService;
  PlantCommunityService(this._apiService, this._storageService);
  // Questions
  Future<List<PlantQuestion>> getQuestions({
    int page = 1,
    int limit = 20,
    String? category,
    String? search,
    String? sortBy,
  }) async {
    try {
      final queryParams = {
        'page': page,
        'limit': limit,
        if (category != null) 'category': category,
        if (search != null) 'search': search,
        if (sortBy != null) 'sort_by': sortBy,
      };
      final response = await _apiService.get(
        '/plant-questions',
        queryParameters: queryParams,
      );
      final List<dynamic> questionsJson = response.data['questions'] ?? [];
      return questionsJson
          .map((json) => PlantQuestion.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load questions: $e');
    }
  }
  Future<PlantQuestion> getQuestion(String questionId) async {
    try {
      final response = await _apiService.get('/plant-questions/$questionId');
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to load question: $e');
    }
  }
  Future<PlantQuestion> createQuestion(
    PlantQuestionRequest request, {
    File? imageFile,
  }) async {
    try {
      String? imageUrl;
      // Upload image if provided
      if (imageFile != null) {
        imageUrl = await _uploadImage(imageFile, 'questions');
      }
      final requestData = {
        ...request.toJson(),
        if (imageUrl != null) 'image_url': imageUrl,
      };
      final response = await _apiService.post(
        '/plant-questions',
        data: requestData,
      );
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to create question: $e');
    }
  }
  Future<PlantQuestion> updateQuestion(
    String questionId,
    PlantQuestionRequest request, {
    File? imageFile,
  }) async {
    try {
      String? imageUrl;
      // Upload image if provided
      if (imageFile != null) {
        imageUrl = await _uploadImage(imageFile, 'questions');
      }
      final requestData = {
        ...request.toJson(),
        if (imageUrl != null) 'image_url': imageUrl,
      };
      final response = await _apiService.put(
        '/plant-questions/$questionId',
        data: requestData,
      );
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to update question: $e');
    }
  }
  Future<void> deleteQuestion(String questionId) async {
    try {
      await _apiService.delete('/plant-questions/$questionId');
    } catch (e) {
      throw Exception('Failed to delete question: $e');
    }
  }
  Future<PlantQuestion> voteQuestion(String questionId, String voteType) async {
    try {
      final response = await _apiService.post(
        '/plant-questions/$questionId/vote',
        data: {'vote_type': voteType},
      );
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to vote on question: $e');
    }
  }
  Future<PlantQuestion> bookmarkQuestion(String questionId) async {
    try {
      final response = await _apiService.post(
        '/plant-questions/$questionId/bookmark',
      );
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to bookmark question: $e');
    }
  }
  Future<PlantQuestion> markQuestionSolved(
    String questionId,
    String acceptedAnswerId,
  ) async {
    try {
      final response = await _apiService.post(
        '/plant-questions/$questionId/solve',
        data: {'accepted_answer_id': acceptedAnswerId},
      );
      return PlantQuestion.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to mark question as solved: $e');
    }
  }
  // Answers
  Future<List<PlantAnswer>> getAnswers(
    String questionId, {
    int page = 1,
    int limit = 20,
    String? sortBy,
  }) async {
    try {
      final queryParams = {
        'page': page,
        'limit': limit,
        if (sortBy != null) 'sort_by': sortBy,
      };
      final response = await _apiService.get(
        '/plant-questions/$questionId/answers',
        queryParameters: queryParams,
      );
      final List<dynamic> answersJson = response.data['answers'] ?? [];
      return answersJson
          .map((json) => PlantAnswer.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load answers: $e');
    }
  }
  Future<PlantAnswer> createAnswer(
    String questionId,
    PlantAnswerRequest request, {
    File? imageFile,
  }) async {
    try {
      String? imageUrl;
      // Upload image if provided
      if (imageFile != null) {
        imageUrl = await _uploadImage(imageFile, 'answers');
      }
      final requestData = {
        ...request.toJson(),
        if (imageUrl != null) 'image_url': imageUrl,
      };
      final response = await _apiService.post(
        '/plant-questions/$questionId/answers',
        data: requestData,
      );
      return PlantAnswer.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to create answer: $e');
    }
  }
  Future<PlantAnswer> updateAnswer(
    String answerId,
    PlantAnswerRequest request, {
    File? imageFile,
  }) async {
    try {
      String? imageUrl;
      // Upload image if provided
      if (imageFile != null) {
        imageUrl = await _uploadImage(imageFile, 'answers');
      }
      final requestData = {
        ...request.toJson(),
        if (imageUrl != null) 'image_url': imageUrl,
      };
      final response = await _apiService.put(
        '/plant-answers/$answerId',
        data: requestData,
      );
      return PlantAnswer.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to update answer: $e');
    }
  }
  Future<void> deleteAnswer(String answerId) async {
    try {
      await _apiService.delete('/plant-answers/$answerId');
    } catch (e) {
      throw Exception('Failed to delete answer: $e');
    }
  }
  Future<PlantAnswer> voteAnswer(String answerId, String voteType) async {
    try {
      final response = await _apiService.post(
        '/plant-answers/$answerId/vote',
        data: {'vote_type': voteType},
      );
      return PlantAnswer.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to vote on answer: $e');
    }
  }
  // Trades
  Future<List<PlantTrade>> getTrades({
    int page = 1,
    int limit = 20,
    String? tradeType,
    String? location,
    String? search,
    String? sortBy,
  }) async {
    try {
      final queryParams = {
        'page': page,
        'limit': limit,
        if (tradeType != null) 'trade_type': tradeType,
        if (location != null) 'location': location,
        if (search != null) 'search': search,
        if (sortBy != null) 'sort_by': sortBy,
      };
      final response = await _apiService.get(
        '/plant-trades',
        queryParameters: queryParams,
      );
      final List<dynamic> tradesJson = response.data['trades'] ?? [];
      return tradesJson
          .map((json) => PlantTrade.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load trades: $e');
    }
  }
  Future<PlantTrade> getTrade(String tradeId) async {
    try {
      final response = await _apiService.get('/plant-trades/$tradeId');
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to load trade: $e');
    }
  }
  Future<PlantTrade> createTrade(
    PlantTradeRequest request, {
    List<File>? imageFiles,
  }) async {
    try {
      List<String> imageUrls = [];
      // Upload images if provided
      if (imageFiles != null && imageFiles.isNotEmpty) {
        for (final imageFile in imageFiles) {
          final imageUrl = await _uploadImage(imageFile, 'trades');
          imageUrls.add(imageUrl);
        }
      }
      final requestData = {
        ...request.toJson(),
        'image_urls': imageUrls,
      };
      final response = await _apiService.post(
        '/plant-trades',
        data: requestData,
      );
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to create trade: $e');
    }
  }
  Future<PlantTrade> updateTrade(
    String tradeId,
    PlantTradeRequest request, {
    List<File>? imageFiles,
  }) async {
    try {
      List<String> imageUrls = [];
      // Upload images if provided
      if (imageFiles != null && imageFiles.isNotEmpty) {
        for (final imageFile in imageFiles) {
          final imageUrl = await _uploadImage(imageFile, 'trades');
          imageUrls.add(imageUrl);
        }
      }
      final requestData = {
        ...request.toJson(),
        if (imageUrls.isNotEmpty) 'image_urls': imageUrls,
      };
      final response = await _apiService.put(
        '/plant-trades/$tradeId',
        data: requestData,
      );
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to update trade: $e');
    }
  }
  Future<void> deleteTrade(String tradeId) async {
    try {
      await _apiService.delete('/plant-trades/$tradeId');
    } catch (e) {
      throw Exception('Failed to delete trade: $e');
    }
  }
  Future<PlantTrade> bookmarkTrade(String tradeId) async {
    try {
      final response = await _apiService.post(
        '/plant-trades/$tradeId/bookmark',
      );
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to bookmark trade: $e');
    }
  }
  Future<PlantTrade> expressInterest(String tradeId) async {
    try {
      final response = await _apiService.post(
        '/plant-trades/$tradeId/interest',
      );
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to express interest: $e');
    }
  }
  Future<PlantTrade> updateTradeStatus(
    String tradeId,
    String status,
  ) async {
    try {
      final response = await _apiService.put(
        '/plant-trades/$tradeId/status',
        data: {'status': status},
      );
      return PlantTrade.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to update trade status: $e');
    }
  }
  // User's content
  Future<List<PlantQuestion>> getUserQuestions(
    String userId, {
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _apiService.get(
        '/users/$userId/questions',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      final List<dynamic> questionsJson = response.data['questions'] ?? [];
      return questionsJson
          .map((json) => PlantQuestion.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load user questions: $e');
    }
  }
  Future<List<PlantAnswer>> getUserAnswers(
    String userId, {
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _apiService.get(
        '/users/$userId/answers',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      final List<dynamic> answersJson = response.data['answers'] ?? [];
      return answersJson
          .map((json) => PlantAnswer.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load user answers: $e');
    }
  }
  Future<List<PlantTrade>> getUserTrades(
    String userId, {
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _apiService.get(
        '/users/$userId/trades',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      final List<dynamic> tradesJson = response.data['trades'] ?? [];
      return tradesJson
          .map((json) => PlantTrade.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load user trades: $e');
    }
  }
  // Bookmarks
  Future<List<PlantQuestion>> getBookmarkedQuestions({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _apiService.get(
        '/bookmarks/questions',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      final List<dynamic> questionsJson = response.data['questions'] ?? [];
      return questionsJson
          .map((json) => PlantQuestion.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load bookmarked questions: $e');
    }
  }
  Future<List<PlantTrade>> getBookmarkedTrades({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await _apiService.get(
        '/bookmarks/trades',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      final List<dynamic> tradesJson = response.data['trades'] ?? [];
      return tradesJson
          .map((json) => PlantTrade.fromJson(json))
          .toList();
    } catch (e) {
      throw Exception('Failed to load bookmarked trades: $e');
    }
  }
  // Helper method for image upload
  Future<String> _uploadImage(File imageFile, String category) async {
    try {
      final formData = FormData.fromMap({
        'file': await MultipartFile.fromFile(
          imageFile.path,
          filename: imageFile.path.split('/').last,
        ),
        'category': category,
      });
      final response = await _apiService.post(
        '/upload/image',
        data: formData,
      );
      return response.data['url'];
    } catch (e) {
      throw Exception('Failed to upload image: $e');
    }
  }
}
</file>

<file path="frontend/lib/features/plant_identification/models/plant_identification_models.dart">
import 'package:json_annotation/json_annotation.dart';
@JsonSerializable()
class PlantIdentification {
  final String id;
  final String scientificName;
  final String commonName;
  final double confidence;
  final List<String> alternativeNames;
  final String imageUrl;
  final PlantCareInfo careInfo;
  final DateTime identifiedAt;
  final String? description;
  final List<String>? tags;
  const PlantIdentification({
    required this.id,
    required this.scientificName,
    required this.commonName,
    required this.confidence,
    required this.alternativeNames,
    required this.imageUrl,
    required this.careInfo,
    required this.identifiedAt,
    this.description,
    this.tags,
  });
  factory PlantIdentification.fromJson(Map<String, dynamic> json) {
    return PlantIdentification(
      id: json['id'] as String,
      scientificName: json['scientificName'] as String,
      commonName: json['commonName'] as String,
      confidence: (json['confidence'] as num).toDouble(),
      alternativeNames: (json['alternativeNames'] as List<dynamic>)
          .map((e) => e as String)
          .toList(),
      imageUrl: json['imageUrl'] as String,
      careInfo: PlantCareInfo.fromJson(json['careInfo'] as Map<String, dynamic>),
      identifiedAt: DateTime.parse(json['identifiedAt'] as String),
      description: json['description'] as String?,
      tags: (json['tags'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'scientificName': scientificName,
      'commonName': commonName,
      'confidence': confidence,
      'alternativeNames': alternativeNames,
      'imageUrl': imageUrl,
      'careInfo': careInfo.toJson(),
      'identifiedAt': identifiedAt.toIso8601String(),
      'description': description,
      'tags': tags,
    };
  }
}
@JsonSerializable()
class PlantCareInfo {
  final String lightRequirement;
  final String waterFrequency;
  final String careLevel;
  final String? humidity;
  final String? temperature;
  final String? toxicity;
  final List<String>? careNotes;
  const PlantCareInfo({
    required this.lightRequirement,
    required this.waterFrequency,
    required this.careLevel,
    this.humidity,
    this.temperature,
    this.toxicity,
    this.careNotes,
  });
  factory PlantCareInfo.fromJson(Map<String, dynamic> json) {
    return PlantCareInfo(
      lightRequirement: json['lightRequirement'] as String,
      waterFrequency: json['waterFrequency'] as String,
      careLevel: json['careLevel'] as String,
      humidity: json['humidity'] as String?,
      temperature: json['temperature'] as String?,
      toxicity: json['toxicity'] as String?,
      careNotes: (json['careNotes'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'lightRequirement': lightRequirement,
      'waterFrequency': waterFrequency,
      'careLevel': careLevel,
      'humidity': humidity,
      'temperature': temperature,
      'toxicity': toxicity,
      'careNotes': careNotes,
    };
  }
}
@JsonSerializable()
class PlantIdentificationRequest {
  final String imageBase64;
  final String? location;
  final DateTime? timestamp;
  const PlantIdentificationRequest({
    required this.imageBase64,
    this.location,
    this.timestamp,
  });
  factory PlantIdentificationRequest.fromJson(Map<String, dynamic> json) {
    return PlantIdentificationRequest(
      imageBase64: json['imageBase64'] as String,
      location: json['location'] as String?,
      timestamp: json['timestamp'] != null
          ? DateTime.parse(json['timestamp'] as String)
          : null,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'imageBase64': imageBase64,
      'location': location,
      'timestamp': timestamp?.toIso8601String(),
    };
  }
}
@JsonSerializable()
class PlantIdentificationState {
  final bool isLoading;
  final List<PlantIdentification> identifications;
  final List<PlantIdentification> history;
  final String? error;
  final PlantIdentification? currentIdentification;
  const PlantIdentificationState({
    this.isLoading = false,
    this.identifications = const [],
    this.history = const [],
    this.error,
    this.currentIdentification,
  });
  factory PlantIdentificationState.fromJson(Map<String, dynamic> json) {
    return PlantIdentificationState(
      isLoading: json['isLoading'] as bool? ?? false,
      identifications: (json['identifications'] as List<dynamic>? ?? [])
          .map((e) => PlantIdentification.fromJson(e as Map<String, dynamic>))
          .toList(),
      history: (json['history'] as List<dynamic>? ?? [])
          .map((e) => PlantIdentification.fromJson(e as Map<String, dynamic>))
          .toList(),
      error: json['error'] as String?,
      currentIdentification: json['currentIdentification'] != null
          ? PlantIdentification.fromJson(json['currentIdentification'] as Map<String, dynamic>)
          : null,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'isLoading': isLoading,
      'identifications': identifications.map((e) => e.toJson()).toList(),
      'history': history.map((e) => e.toJson()).toList(),
      'error': error,
      'currentIdentification': currentIdentification?.toJson(),
    };
  }
  PlantIdentificationState copyWith({
    bool? isLoading,
    List<PlantIdentification>? identifications,
    List<PlantIdentification>? history,
    String? error,
    PlantIdentification? currentIdentification,
  }) {
    return PlantIdentificationState(
      isLoading: isLoading ?? this.isLoading,
      identifications: identifications ?? this.identifications,
      history: history ?? this.history,
      error: error ?? this.error,
      currentIdentification: currentIdentification ?? this.currentIdentification,
    );
  }
}
</file>

<file path="frontend/lib/features/plant_identification/presentation/screens/plant_identification_history_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/features/plant_identification/providers/plant_identification_provider.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/loading_widget.dart';
import 'package:plant_social/core/widgets/error_widget.dart';
class PlantIdentificationHistoryScreen extends ConsumerStatefulWidget {
  const PlantIdentificationHistoryScreen({super.key});
  @override
  ConsumerState<PlantIdentificationHistoryScreen> createState() =>
      _PlantIdentificationHistoryScreenState();
}
class _PlantIdentificationHistoryScreenState
    extends ConsumerState<PlantIdentificationHistoryScreen> {
  @override
  void initState() {
    super.initState();
    // Load history when screen opens
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(plantIdentificationProvider.notifier).loadIdentificationHistory();
    });
  }
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(plantIdentificationProvider);
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Identification History'),
        backgroundColor: theme.primaryColor,
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              ref.read(plantIdentificationProvider.notifier).loadIdentificationHistory();
            },
          ),
        ],
      ),
      body: _buildBody(state, theme),
    );
  }
  Widget _buildBody(PlantIdentificationState state, ThemeData theme) {
    if (state.isLoading && state.history.isEmpty) {
      return const Center(child: LoadingWidget());
    }
    if (state.error != null && state.history.isEmpty) {
      return Center(
        child: CustomErrorWidget(
          message: state.error!,
          onRetry: () {
            ref.read(plantIdentificationProvider.notifier).loadIdentificationHistory();
          },
        ),
      );
    }
    if (state.history.isEmpty) {
      return _buildEmptyState(theme);
    }
    return RefreshIndicator(
      onRefresh: () async {
        await ref.read(plantIdentificationProvider.notifier).loadIdentificationHistory();
      },
      child: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: state.history.length,
        itemBuilder: (context, index) {
          final identification = state.history[index];
          return _buildHistoryItem(identification, theme);
        },
      ),
    );
  }
  Widget _buildEmptyState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.eco,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No identifications yet',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Start identifying plants to see your history here',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.grey[500],
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () {
              Navigator.of(context).pop();
            },
            icon: const Icon(Icons.camera_alt),
            label: const Text('Identify a Plant'),
            style: ElevatedButton.styleFrom(
              backgroundColor: theme.primaryColor,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(
                horizontal: 24,
                vertical: 12,
              ),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildHistoryItem(PlantIdentification identification, ThemeData theme) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () {
          _showIdentificationDetails(identification);
        },
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Plant image
              ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Container(
                  width: 60,
                  height: 60,
                  color: Colors.grey[200],
                  child: identification.imageUrl != null
                      ? Image.network(
                          identification.imageUrl!,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return Icon(
                              Icons.eco,
                              color: Colors.grey[400],
                              size: 30,
                            );
                          },
                        )
                      : Icon(
                          Icons.eco,
                          color: Colors.grey[400],
                          size: 30,
                        ),
                ),
              ),
              const SizedBox(width: 16),
              // Plant info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      identification.commonName,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      identification.scientificName,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontStyle: FontStyle.italic,
                        color: Colors.grey[600],
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        _buildConfidenceBadge(identification.confidence, theme),
                        const Spacer(),
                        Text(
                          _formatDate(identification.identifiedAt),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: Colors.grey[500],
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              // Arrow icon
              Icon(
                Icons.chevron_right,
                color: Colors.grey[400],
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildConfidenceBadge(double confidence, ThemeData theme) {
    Color badgeColor;
    String badgeText;
    if (confidence >= 0.8) {
      badgeColor = Colors.green;
      badgeText = 'High';
    } else if (confidence >= 0.6) {
      badgeColor = Colors.orange;
      badgeText = 'Medium';
    } else {
      badgeColor = Colors.red;
      badgeText = 'Low';
    }
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: badgeColor.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: badgeColor.withOpacity(0.3)),
      ),
      child: Text(
        '$badgeText (${(confidence * 100).toInt()}%)',
        style: theme.textTheme.bodySmall?.copyWith(
          color: badgeColor,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);
    if (difference.inDays == 0) {
      if (difference.inHours == 0) {
        return '${difference.inMinutes}m ago';
      }
      return '${difference.inHours}h ago';
    } else if (difference.inDays == 1) {
      return 'Yesterday';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }
  void _showIdentificationDetails(PlantIdentification identification) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        constraints: BoxConstraints(
          maxHeight: MediaQuery.of(context).size.height * 0.8,
        ),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(24),
            topRight: Radius.circular(24),
          ),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Handle bar
            Container(
              margin: const EdgeInsets.only(top: 12),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            // Header
            Padding(
              padding: const EdgeInsets.all(20),
              child: Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          identification.commonName,
                          style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          identification.scientificName,
                          style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                            fontStyle: FontStyle.italic,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ],
              ),
            ),
            // Content
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Image
                    if (identification.imageUrl != null)
                      ClipRRect(
                        borderRadius: BorderRadius.circular(12),
                        child: AspectRatio(
                          aspectRatio: 16 / 9,
                          child: Image.network(
                            identification.imageUrl!,
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return Container(
                                color: Colors.grey[200],
                                child: Icon(
                                  Icons.eco,
                                  size: 60,
                                  color: Colors.grey[400],
                                ),
                              );
                            },
                          ),
                        ),
                      ),
                    const SizedBox(height: 20),
                    // Confidence
                    _buildDetailSection(
                      'Confidence',
                      '${(identification.confidence * 100).toInt()}%',
                      Icons.verified,
                    ),
                    // Date
                    _buildDetailSection(
                      'Identified',
                      _formatDate(identification.identifiedAt),
                      Icons.schedule,
                    ),
                    // Care info
                    if (identification.careInfo != null) ...[
                      const SizedBox(height: 16),
                      Text(
                        'Care Information',
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 12),
                      _buildDetailSection(
                        'Light',
                        identification.careInfo!.lightRequirement,
                        Icons.wb_sunny,
                      ),
                      _buildDetailSection(
                        'Water',
                        identification.careInfo!.waterFrequency,
                        Icons.water_drop,
                      ),
                      _buildDetailSection(
                        'Care Level',
                        identification.careInfo!.careLevel,
                        Icons.trending_up,
                      ),
                    ],
                    const SizedBox(height: 100),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildDetailSection(String label, String value, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: Theme.of(context).primaryColor,
          ),
          const SizedBox(width: 12),
          Text(
            '$label: ',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_identification/presentation/screens/plant_search_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/features/plant_identification/providers/plant_identification_provider.dart';
import 'package:plant_social/features/plant_identification/presentation/screens/plant_species_detail_screen.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/loading_widget.dart';
import 'package:plant_social/core/widgets/error_widget.dart';
class PlantSearchScreen extends ConsumerStatefulWidget {
  const PlantSearchScreen({super.key});
  @override
  ConsumerState<PlantSearchScreen> createState() => _PlantSearchScreenState();
}
class _PlantSearchScreenState extends ConsumerState<PlantSearchScreen> {
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  String _currentQuery = '';
  @override
  void initState() {
    super.initState();
    // Auto-focus search field
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _searchFocusNode.requestFocus();
    });
  }
  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(plantIdentificationProvider);
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Search Plants'),
        backgroundColor: theme.primaryColor,
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: Column(
        children: [
          // Search bar
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.primaryColor,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: _buildSearchBar(theme),
          ),
          // Search results
          Expanded(
            child: _buildSearchResults(state, theme),
          ),
        ],
      ),
    );
  }
  Widget _buildSearchBar(ThemeData theme) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: _searchController,
        focusNode: _searchFocusNode,
        decoration: InputDecoration(
          hintText: 'Search for plants...',
          prefixIcon: Icon(
            Icons.search,
            color: Colors.grey[600],
          ),
          suffixIcon: _currentQuery.isNotEmpty
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () {
                    _searchController.clear();
                    setState(() {
                      _currentQuery = '';
                    });
                    ref.read(plantIdentificationProvider.notifier).clearSearch();
                  },
                )
              : null,
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
        ),
        onChanged: (query) {
          setState(() {
            _currentQuery = query;
          });
          if (query.trim().isNotEmpty) {
            // Debounce search
            Future.delayed(const Duration(milliseconds: 500), () {
              if (_searchController.text == query && query.trim().isNotEmpty) {
                ref.read(plantIdentificationProvider.notifier).searchPlants(query);
              }
            });
          } else {
            ref.read(plantIdentificationProvider.notifier).clearSearch();
          }
        },
        onSubmitted: (query) {
          if (query.trim().isNotEmpty) {
            ref.read(plantIdentificationProvider.notifier).searchPlants(query);
          }
        },
      ),
    );
  }
  Widget _buildSearchResults(PlantIdentificationState state, ThemeData theme) {
    if (_currentQuery.isEmpty) {
      return _buildEmptyState(theme);
    }
    if (state.isLoading) {
      return const Center(child: LoadingWidget());
    }
    if (state.error != null) {
      return Center(
        child: CustomErrorWidget(
          message: state.error!,
          onRetry: () {
            if (_currentQuery.isNotEmpty) {
              ref.read(plantIdentificationProvider.notifier).searchPlants(_currentQuery);
            }
          },
        ),
      );
    }
    if (state.identifications.isEmpty) {
      return _buildNoResultsState(theme);
    }
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: state.identifications.length,
      itemBuilder: (context, index) {
        final species = state.identifications[index];
        return _buildSearchResultItem(species, theme);
      },
    );
  }
  Widget _buildEmptyState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.search,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'Search for Plants',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Enter a plant name to start searching',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.grey[500],
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          _buildSearchSuggestions(theme),
        ],
      ),
    );
  }
  Widget _buildSearchSuggestions(ThemeData theme) {
    final suggestions = [
      'Rose',
      'Monstera',
      'Fiddle Leaf Fig',
      'Snake Plant',
      'Pothos',
      'Peace Lily',
    ];
    return Column(
      children: [
        Text(
          'Popular searches:',
          style: theme.textTheme.bodySmall?.copyWith(
            color: Colors.grey[600],
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: suggestions.map((suggestion) {
            return GestureDetector(
              onTap: () {
                _searchController.text = suggestion;
                setState(() {
                  _currentQuery = suggestion;
                });
                ref.read(plantIdentificationProvider.notifier).searchPlants(suggestion);
              },
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: theme.primaryColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(
                    color: theme.primaryColor.withOpacity(0.3),
                  ),
                ),
                child: Text(
                  suggestion,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.primaryColor,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }
  Widget _buildNoResultsState(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.search_off,
            size: 80,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            'No plants found',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Try searching with different keywords',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.grey[500],
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          OutlinedButton.icon(
            onPressed: () {
              _searchController.clear();
              setState(() {
                _currentQuery = '';
              });
              ref.read(plantIdentificationProvider.notifier).clearSearch();
              _searchFocusNode.requestFocus();
            },
            icon: const Icon(Icons.refresh),
            label: const Text('Try Again'),
            style: OutlinedButton.styleFrom(
              foregroundColor: theme.primaryColor,
              side: BorderSide(color: theme.primaryColor),
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildSearchResultItem(PlantIdentification species, ThemeData theme) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => PlantSpeciesDetailScreen(
                speciesId: species.id,
                speciesName: species.commonName,
              ),
            ),
          );
        },
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Plant image
              ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Container(
                  width: 60,
                  height: 60,
                  color: Colors.grey[200],
                  child: species.imageUrl != null
                      ? Image.network(
                          species.imageUrl!,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return Icon(
                              Icons.eco,
                              color: Colors.grey[400],
                              size: 30,
                            );
                          },
                        )
                      : Icon(
                          Icons.eco,
                          color: Colors.grey[400],
                          size: 30,
                        ),
                ),
              ),
              const SizedBox(width: 16),
              // Plant info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      species.commonName,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      species.scientificName,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontStyle: FontStyle.italic,
                        color: Colors.grey[600],
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Scientific: ${species.scientificName}',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: Colors.grey[500],
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              // Arrow icon
              Icon(
                Icons.chevron_right,
                color: Colors.grey[400],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/plant_identification/presentation/screens/plant_species_detail_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart' as identification_models;
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_identification/providers/plant_identification_provider.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/widgets/loading_widget.dart';
import 'package:plant_social/core/widgets/error_widget.dart';
class PlantSpeciesDetailScreen extends ConsumerStatefulWidget {
  final String speciesId;
  final String? speciesName;
  const PlantSpeciesDetailScreen({
    super.key,
    required this.speciesId,
    this.speciesName,
  });
  @override
  ConsumerState<PlantSpeciesDetailScreen> createState() =>
      _PlantSpeciesDetailScreenState();
}
class _PlantSpeciesDetailScreenState
    extends ConsumerState<PlantSpeciesDetailScreen> {
  @override
  void initState() {
    super.initState();
    // Species details will be automatically loaded by the provider
  }
  @override
  Widget build(BuildContext context) {
    final speciesDetailAsync = ref.watch(plantSpeciesProvider(widget.speciesId));
    final theme = Theme.of(context);
    return Scaffold(
      body: speciesDetailAsync.when(
        data: (species) => _buildContent(species, theme),
        loading: () => _buildLoadingState(theme),
        error: (error, stackTrace) => _buildErrorState(error.toString(), theme),
      ),
    );
  }
  Widget _buildLoadingState(ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.speciesName ?? 'Plant Species'),
        backgroundColor: theme.primaryColor,
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: const Center(child: LoadingWidget()),
    );
  }
  Widget _buildErrorState(String error, ThemeData theme) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.speciesName ?? 'Plant Species'),
        backgroundColor: theme.primaryColor,
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: Center(
        child: CustomErrorWidget(
          message: error,
          onRetry: () {
              ref.invalidate(plantSpeciesProvider(widget.speciesId));
            },
        ),
      ),
    );
  }
  Widget _buildContent(PlantSpecies species, ThemeData theme) {
    return CustomScrollView(
      slivers: [
        // App bar with image
        SliverAppBar(
          expandedHeight: 300,
          pinned: true,
          backgroundColor: theme.primaryColor,
          foregroundColor: Colors.white,
          flexibleSpace: FlexibleSpaceBar(
            title: Text(
              species.commonName,
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                shadows: [
                  Shadow(
                    offset: Offset(0, 1),
                    blurRadius: 3,
                    color: Colors.black54,
                  ),
                ],
              ),
            ),
            background: Stack(
              fit: StackFit.expand,
              children: [
                species.imageUrl != null
                    ? Image.network(
                        species.imageUrl!,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) {
                          return Container(
                            color: theme.primaryColor,
                            child: Icon(
                              Icons.eco,
                              size: 80,
                              color: Colors.white.withOpacity(0.7),
                            ),
                          );
                        },
                      )
                    : Container(
                        color: theme.primaryColor,
                        child: Icon(
                          Icons.eco,
                          size: 80,
                          color: Colors.white.withOpacity(0.7),
                        ),
                      ),
                // Gradient overlay
                Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: [
                        Colors.transparent,
                        Colors.black.withOpacity(0.7),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
          actions: [
            IconButton(
              icon: const Icon(Icons.share),
              onPressed: () {
                // Share species
              },
            ),
            IconButton(
              icon: const Icon(Icons.favorite_border),
              onPressed: () {
                // Add to favorites
              },
            ),
          ],
        ),
        // Content
        SliverToBoxAdapter(
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Scientific name
                Text(
                  species.scientificName,
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontStyle: FontStyle.italic,
                    color: Colors.grey[600],
                  ),
                ),
                const SizedBox(height: 8),
                // Description
                if (species.description != null)
                  Text(
                    'Description: ${species.description}',
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: Colors.grey[600],
                    ),
                  ),
                const SizedBox(height: 24),
                // Description
                if (species.description != null) ...[
                  _buildSection(
                    'Description',
                    species.description!,
                    Icons.description,
                    theme,
                  ),
                  const SizedBox(height: 24),
                ],
                // Care information
                if (species.careInfo != null) ...[
                  _buildCareSection(species.careInfo!, theme),
                  const SizedBox(height: 24),
                ],
                // Alternative names
                if (species.alternativeNames != null && species.alternativeNames!.isNotEmpty) ...[
                  _buildAlternativeNamesSection(species.alternativeNames!, theme),
                  const SizedBox(height: 24),
                ],
                // Native regions
                if (species.nativeRegions != null && species.nativeRegions!.isNotEmpty) ...[
                  _buildNativeRegionsSection(species.nativeRegions!, theme),
                  const SizedBox(height: 24),
                ],
                // Growth characteristics
                _buildGrowthCharacteristics(species, theme),
              ],
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildSection(String title, String content, IconData icon, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              icon,
              size: 24,
              color: theme.primaryColor,
            ),
            const SizedBox(width: 8),
            Text(
              title,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Text(
          content,
          style: theme.textTheme.bodyLarge,
        ),
      ],
    );
  }
  Widget _buildCareSection(PlantCareInfo careInfo, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.spa,
              size: 24,
              color: theme.primaryColor,
            ),
            const SizedBox(width: 8),
            Text(
              'Care Information',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        _buildCareGrid(careInfo, theme),
      ],
    );
  }
  Widget _buildCareGrid(PlantCareInfo careInfo, ThemeData theme) {
    final careItems = [
      _CareItem(Icons.wb_sunny, 'Light', careInfo.lightRequirement),
      _CareItem(Icons.water_drop, 'Water', careInfo.waterFrequency),
      _CareItem(Icons.trending_up, 'Care Level', careInfo.careLevel),
      if (careInfo.humidity != null)
        _CareItem(Icons.opacity, 'Humidity', careInfo.humidity!),
      if (careInfo.temperature != null)
        _CareItem(Icons.thermostat, 'Temperature', careInfo.temperature!),
      if (careInfo.toxicity != null)
        _CareItem(Icons.warning, 'Toxicity', careInfo.toxicity!),
    ];
    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 3,
        crossAxisSpacing: 12,
        mainAxisSpacing: 12,
      ),
      itemCount: careItems.length,
      itemBuilder: (context, index) {
        final item = careItems[index];
        return Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: theme.primaryColor.withOpacity(0.05),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: theme.primaryColor.withOpacity(0.2),
            ),
          ),
          child: Row(
            children: [
              Icon(
                item.icon,
                size: 20,
                color: theme.primaryColor,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      item.label,
                      style: theme.textTheme.bodySmall?.copyWith(
                        fontWeight: FontWeight.w500,
                        color: Colors.grey[600],
                      ),
                    ),
                    Text(
                      item.value,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: FontWeight.w500,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  Widget _buildAlternativeNamesSection(List<String> names, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.label,
              size: 24,
              color: theme.primaryColor,
            ),
            const SizedBox(width: 8),
            Text(
              'Also known as',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: names.map((name) {
            return Chip(
              label: Text(
                name,
                style: theme.textTheme.bodyMedium,
              ),
              backgroundColor: theme.primaryColor.withOpacity(0.1),
              side: BorderSide.none,
            );
          }).toList(),
        ),
      ],
    );
  }
  Widget _buildNativeRegionsSection(List<String> regions, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.public,
              size: 24,
              color: theme.primaryColor,
            ),
            const SizedBox(width: 8),
            Text(
              'Native Regions',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: regions.map((region) {
            return Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: Colors.green.withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: Colors.green.withOpacity(0.3),
                ),
              ),
              child: Text(
                region,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: Colors.green[700],
                  fontWeight: FontWeight.w500,
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }
  Widget _buildGrowthCharacteristics(PlantSpecies species, ThemeData theme) {
    final characteristics = <String>[];
    characteristics.add('Scientific Name: ${species.scientificName}');
    if (species.family != null) {
      characteristics.add('Family: ${species.family}');
    }
    if (species.alternativeNames != null && species.alternativeNames!.isNotEmpty) {
      characteristics.add('Alternative Names: ${species.alternativeNames!.join(', ')}');
    }
    if (species.maxHeight != null) {
      characteristics.add('Max Height: ${species.maxHeight}');
    }
    if (species.bloomTime != null) {
      characteristics.add('Bloom Time: ${species.bloomTime}');
    }
    if (species.plantType != null) {
      characteristics.add('Plant Type: ${species.plantType}');
    }
    if (characteristics.isEmpty) return const SizedBox.shrink();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              Icons.nature,
              size: 24,
              color: theme.primaryColor,
            ),
            const SizedBox(width: 8),
            Text(
              'Growth Characteristics',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        ...characteristics.map((characteristic) {
          return Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Row(
              children: [
                Icon(
                  Icons.fiber_manual_record,
                  size: 8,
                  color: theme.primaryColor,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    characteristic,
                    style: theme.textTheme.bodyLarge,
                  ),
                ),
              ],
            ),
          );
        }).toList(),
      ],
    );
  }
}
class _CareItem {
  final IconData icon;
  final String label;
  final String value;
  _CareItem(this.icon, this.label, this.value);
}
</file>

<file path="frontend/lib/features/plant_identification/providers/plant_identification_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/core/network/api_client.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
import 'package:plant_social/features/plant_identification/services/plant_identification_service.dart';
import 'dart:io';
// Service provider
final plantIdentificationServiceProvider = Provider<PlantIdentificationService>(
  (ref) => PlantIdentificationService(ref.read(apiClientProvider)),
);
// State notifier for plant identification
class PlantIdentificationNotifier extends StateNotifier<PlantIdentificationState> {
  final PlantIdentificationService _service;
  PlantIdentificationNotifier(this._service) : super(const PlantIdentificationState());
  Future<void> identifyPlant(File imageFile) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final identification = await _service.identifyPlant(imageFile);
      state = state.copyWith(
        isLoading: false,
        currentIdentification: identification,
        identifications: [identification, ...state.identifications],
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
  Future<void> loadIdentificationHistory() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final history = await _service.getIdentificationHistory();
      state = state.copyWith(
        isLoading: false,
        history: history,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
  Future<void> searchPlants(String query) async {
    if (query.isEmpty) {
      state = state.copyWith(identifications: []);
      return;
    }
    state = state.copyWith(isLoading: true, error: null);
    try {
      final results = await _service.searchPlants(query);
      state = state.copyWith(
        isLoading: false,
        identifications: results,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
  Future<void> saveToCollection(String identificationId) async {
    try {
      await _service.saveIdentificationToCollection(identificationId);
      // Show success message or update UI as needed
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
  void clearError() {
    state = state.copyWith(error: null);
  }
  void clearCurrentIdentification() {
    state = state.copyWith(currentIdentification: null);
  }
  void clearSearch() {
    state = state.copyWith(
      identifications: [],
      error: null,
    );
  }
}
// State notifier provider
final plantIdentificationProvider = StateNotifierProvider<PlantIdentificationNotifier, PlantIdentificationState>(
  (ref) => PlantIdentificationNotifier(ref.read(plantIdentificationServiceProvider)),
);
// Individual providers for specific use cases
final plantIdentificationHistoryProvider = FutureProvider<List<PlantIdentification>>(
  (ref) => ref.read(plantIdentificationServiceProvider).getIdentificationHistory(),
);
final plantSpeciesProvider = FutureProvider.family<PlantSpecies, String>(
  (ref, speciesId) => ref.read(plantIdentificationServiceProvider).getPlantSpecies(speciesId),
);
</file>

<file path="frontend/lib/features/plant_identification/services/plant_identification_service.dart">
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:plant_social/core/network/api_client.dart';
import 'package:plant_social/features/plant_identification/models/plant_identification_models.dart';
import 'package:plant_social/features/plant_care/models/plant_care_models.dart';
class PlantIdentificationService {
  final ApiClient _apiClient;
  PlantIdentificationService(this._apiClient);
  Future<PlantIdentification> identifyPlant(File imageFile) async {
    try {
      // Convert image to base64
      final bytes = await imageFile.readAsBytes();
      final base64Image = base64Encode(bytes);
      final request = PlantIdentificationRequest(
        imageBase64: base64Image,
        timestamp: DateTime.now(),
      );
      final response = await _apiClient.post(
        '/plants/identify',
        data: request.toJson(),
      );
      return PlantIdentification.fromJson(response.data['data']);
    } catch (e) {
      throw Exception('Failed to identify plant: $e');
    }
  }
  Future<List<PlantIdentification>> getIdentificationHistory() async {
    try {
      final response = await _apiClient.get('/plants/identification-history');
      final List<dynamic> data = response.data['data'];
      return data.map((json) => PlantIdentification.fromJson(json)).toList();
    } catch (e) {
      throw Exception('Failed to get identification history: $e');
    }
  }
  Future<PlantSpecies> getPlantSpecies(String speciesId) async {
    try {
      final response = await _apiClient.get('/plants/species/$speciesId');
      return PlantSpecies.fromJson(response.data['data']);
    } catch (e) {
      throw Exception('Failed to get plant species: $e');
    }
  }
  Future<List<PlantIdentification>> searchPlants(String query) async {
    try {
      final response = await _apiClient.get(
        '/plants/search',
        queryParameters: {'q': query},
      );
      final List<dynamic> data = response.data['data'];
      return data.map((json) => PlantIdentification.fromJson(json)).toList();
    } catch (e) {
      throw Exception('Failed to search plants: $e');
    }
  }
  Future<void> saveIdentificationToCollection(String identificationId) async {
    try {
      await _apiClient.post(
        '/plants/collection/add',
        data: {'identification_id': identificationId},
      );
    } catch (e) {
      throw Exception('Failed to save plant to collection: $e');
    }
  }
}
</file>

<file path="frontend/lib/features/stories/presentation/screens/stories_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
/// Stories screen displaying user stories in a feed format
class StoriesScreen extends ConsumerStatefulWidget {
  const StoriesScreen({super.key});
  @override
  ConsumerState<StoriesScreen> createState() => _StoriesScreenState();
}
class _StoriesScreenState extends ConsumerState<StoriesScreen>
    with TickerProviderStateMixin {
  late TabController _tabController;
  final _scrollController = ScrollController();
  bool _isLoading = false;
  bool _hasMore = true;
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _scrollController.addListener(_onScroll);
  }
  @override
  void dispose() {
    _tabController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      _loadMoreStories();
    }
  }
  void _loadMoreStories() async {
    if (_isLoading || !_hasMore) return;
    setState(() {
      _isLoading = true;
    });
    // Simulate loading more stories
    await Future.delayed(const Duration(seconds: 1));
    if (mounted) {
      setState(() {
        _isLoading = false;
        // Simulate no more stories after some loads
        _hasMore = DateTime.now().millisecond % 3 != 0;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Stories'),
        actions: [
          IconButton(
            onPressed: () => context.push('/home/camera/story-creation'),
            icon: const Icon(Icons.add_circle_outline),
            tooltip: 'Create Story',
          ),
          PopupMenuButton<String>(
            onSelected: _handleMenuAction,
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'archive',
                child: Row(
                  children: [
                    Icon(Icons.archive),
                    SizedBox(width: 8),
                    Text('Story Archive'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'settings',
                child: Row(
                  children: [
                    Icon(Icons.settings),
                    SizedBox(width: 8),
                    Text('Story Settings'),
                  ],
                ),
              ),
            ],
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: 'Following'),
            Tab(text: 'Explore'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildFollowingTab(),
          _buildExploreTab(),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => context.push('/home/camera'),
        child: const Icon(Icons.camera_alt),
        tooltip: 'Create Story',
      ),
    );
  }
  Widget _buildFollowingTab() {
    final stories = _getMockFollowingStories();
    if (stories.isEmpty) {
      return _buildEmptyState(
        Icons.people_outline,
        'No stories from friends',
        'When your friends share stories, they\'ll appear here',
        actionLabel: 'Explore Stories',
        onAction: () => _tabController.animateTo(1),
      );
    }
    return CustomScrollView(
      controller: _scrollController,
      slivers: [
        // Active stories row
        SliverToBoxAdapter(
          child: _buildActiveStoriesRow(),
        ),
        // Stories grid
        SliverPadding(
          padding: const EdgeInsets.all(16),
          sliver: SliverGrid(
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 0.75,
            ),
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                if (index < stories.length) {
                  return _buildStoryCard(stories[index]);
                }
                return null;
              },
              childCount: stories.length,
            ),
          ),
        ),
        // Loading indicator
        if (_isLoading)
          const SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.all(16),
              child: Center(child: CircularProgressIndicator()),
            ),
          ),
      ],
    );
  }
  Widget _buildExploreTab() {
    final stories = _getMockExploreStories();
    return CustomScrollView(
      slivers: [
        // Trending section
        SliverToBoxAdapter(
          child: _buildTrendingSection(),
        ),
        // Explore grid
        SliverPadding(
          padding: const EdgeInsets.all(16),
          sliver: SliverGrid(
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 0.75,
            ),
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                if (index < stories.length) {
                  return _buildStoryCard(stories[index]);
                }
                return null;
              },
              childCount: stories.length,
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildActiveStoriesRow() {
    final activeStories = _getMockActiveStories();
    return Container(
      height: 120,
      padding: const EdgeInsets.symmetric(vertical: 16),
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        padding: const EdgeInsets.symmetric(horizontal: 16),
        itemCount: activeStories.length + 1, // +1 for "Your Story" button
        itemBuilder: (context, index) {
          if (index == 0) {
            return _buildYourStoryButton();
          }
          return _buildActiveStoryItem(activeStories[index - 1]);
        },
      ),
    );
  }
  Widget _buildYourStoryButton() {
    final theme = Theme.of(context);
    return Container(
      width: 80,
      margin: const EdgeInsets.only(right: 12),
      child: Column(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: theme.colorScheme.primary,
                width: 2,
              ),
            ),
            child: IconButton(
              onPressed: () => context.push('/home/camera'),
              icon: Icon(
                Icons.add,
                color: theme.colorScheme.primary,
              ),
            ),
          ),
          const SizedBox(height: 8),
          const Text(
            'Your Story',
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  Widget _buildActiveStoryItem(MockStory story) {
    final theme = Theme.of(context);
    return Container(
      width: 80,
      margin: const EdgeInsets.only(right: 12),
      child: GestureDetector(
        onTap: () => context.push('/story/${story.id}'),
        child: Column(
          children: [
            Container(
              width: 60,
              height: 60,
              padding: const EdgeInsets.all(2),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: LinearGradient(
                  colors: story.isViewed
                      ? [Colors.grey, Colors.grey]
                      : [theme.colorScheme.primary, theme.colorScheme.secondary],
                ),
              ),
              child: Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: theme.colorScheme.surface,
                  border: Border.all(
                    color: theme.colorScheme.surface,
                    width: 2,
                  ),
                ),
                child: CircleAvatar(
                  backgroundColor: theme.colorScheme.primary,
                  child: Text(
                    story.userName.split(' ').map((name) => name[0]).join(),
                    style: TextStyle(
                      color: theme.colorScheme.onPrimary,
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 8),
            Text(
              story.userName.split(' ').first,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w500,
                color: story.isViewed
                    ? theme.colorScheme.onSurface.withOpacity(0.6)
                    : theme.colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildTrendingSection() {
    final theme = Theme.of(context);
    final trendingTopics = ['#PlantCare', '#SucculentLove', '#IndoorGarden', '#PlantParent'];
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Trending Topics',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: trendingTopics.map((topic) {
              return GestureDetector(
                onTap: () => _searchByTopic(topic),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: theme.colorScheme.primary.withOpacity(0.3),
                    ),
                  ),
                  child: Text(
                    topic,
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                      fontSize: 12,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ],
      ),
    );
  }
  Widget _buildStoryCard(MockStory story) {
    final theme = Theme.of(context);
    return GestureDetector(
      onTap: () => context.push('/story/${story.id}'),
      child: Card(
        clipBehavior: Clip.antiAlias,
        child: Stack(
          children: [
            // Story background
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      theme.colorScheme.primary.withOpacity(0.7),
                      theme.colorScheme.secondary.withOpacity(0.7),
                    ],
                  ),
                ),
                child: const Center(
                  child: Icon(
                    Icons.eco,
                    size: 60,
                    color: Colors.white,
                  ),
                ),
              ),
            ),
            // Gradient overlay
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.transparent,
                      Colors.black.withOpacity(0.7),
                    ],
                  ),
                ),
              ),
            ),
            // Story info
            Positioned(
              left: 12,
              right: 12,
              bottom: 12,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  // User info
                  Row(
                    children: [
                      CircleAvatar(
                        radius: 12,
                        backgroundColor: Colors.white,
                        child: Text(
                          story.userName.split(' ').map((name) => name[0]).join(),
                          style: TextStyle(
                            color: theme.colorScheme.primary,
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          story.userName,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  // Caption
                  if (story.caption.isNotEmpty)
                    Text(
                      story.caption,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 11,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  const SizedBox(height: 4),
                  // Stats
                  Row(
                    children: [
                      Icon(
                        Icons.visibility,
                        color: Colors.white.withOpacity(0.8),
                        size: 12,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${story.viewCount}',
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.8),
                          fontSize: 10,
                        ),
                      ),
                      const SizedBox(width: 12),
                      Icon(
                        Icons.favorite,
                        color: Colors.white.withOpacity(0.8),
                        size: 12,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${story.likeCount}',
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.8),
                          fontSize: 10,
                        ),
                      ),
                      const Spacer(),
                      Text(
                        _formatTimestamp(story.timestamp),
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.8),
                          fontSize: 10,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            // Viewed indicator
            if (story.isViewed)
              Positioned(
                top: 8,
                right: 8,
                child: Container(
                  padding: const EdgeInsets.all(4),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.5),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Icon(
                    Icons.check,
                    color: Colors.white,
                    size: 12,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
  Widget _buildEmptyState(
    IconData icon,
    String title,
    String subtitle, {
    String? actionLabel,
    VoidCallback? onAction,
  }) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: 80,
              color: theme.colorScheme.onSurface.withOpacity(0.3),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.5),
              ),
              textAlign: TextAlign.center,
            ),
            if (actionLabel != null && onAction != null) ...[
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: onAction,
                child: Text(actionLabel),
              ),
            ],
          ],
        ),
      ),
    );
  }
  List<MockStory> _getMockActiveStories() {
    return [
      MockStory(
        id: 'active1',
        userId: 'user1',
        userName: 'Alice Green',
        caption: '',
        timestamp: DateTime.now().subtract(const Duration(hours: 2)),
        viewCount: 24,
        likeCount: 8,
        isViewed: false,
      ),
      MockStory(
        id: 'active2',
        userId: 'user2',
        userName: 'Bob Plant',
        caption: '',
        timestamp: DateTime.now().subtract(const Duration(hours: 4)),
        viewCount: 15,
        likeCount: 5,
        isViewed: true,
      ),
      MockStory(
        id: 'active3',
        userId: 'user3',
        userName: 'Carol Bloom',
        caption: '',
        timestamp: DateTime.now().subtract(const Duration(hours: 6)),
        viewCount: 32,
        likeCount: 12,
        isViewed: false,
      ),
    ];
  }
  List<MockStory> _getMockFollowingStories() {
    return [
      MockStory(
        id: 'following1',
        userId: 'user1',
        userName: 'Alice Green',
        caption: 'My succulent garden is thriving! ',
        timestamp: DateTime.now().subtract(const Duration(hours: 2)),
        viewCount: 24,
        likeCount: 8,
        isViewed: false,
      ),
      MockStory(
        id: 'following2',
        userId: 'user2',
        userName: 'Bob Plant',
        caption: 'New additions to my indoor jungle ',
        timestamp: DateTime.now().subtract(const Duration(hours: 4)),
        viewCount: 15,
        likeCount: 5,
        isViewed: true,
      ),
      MockStory(
        id: 'following3',
        userId: 'user3',
        userName: 'Carol Bloom',
        caption: 'Spring flowers are blooming beautifully ',
        timestamp: DateTime.now().subtract(const Duration(hours: 6)),
        viewCount: 32,
        likeCount: 12,
        isViewed: false,
      ),
      MockStory(
        id: 'following4',
        userId: 'user4',
        userName: 'David Leaf',
        caption: 'Harvesting fresh herbs from my garden ',
        timestamp: DateTime.now().subtract(const Duration(hours: 8)),
        viewCount: 18,
        likeCount: 7,
        isViewed: false,
      ),
    ];
  }
  List<MockStory> _getMockExploreStories() {
    return [
      MockStory(
        id: 'explore1',
        userId: 'explore_user1',
        userName: 'Plant Expert',
        caption: 'Tips for caring for your monstera  #PlantCare',
        timestamp: DateTime.now().subtract(const Duration(hours: 1)),
        viewCount: 156,
        likeCount: 42,
        isViewed: false,
      ),
      MockStory(
        id: 'explore2',
        userId: 'explore_user2',
        userName: 'Garden Guru',
        caption: 'Amazing succulent arrangement ideas  #SucculentLove',
        timestamp: DateTime.now().subtract(const Duration(hours: 3)),
        viewCount: 89,
        likeCount: 28,
        isViewed: false,
      ),
      MockStory(
        id: 'explore3',
        userId: 'explore_user3',
        userName: 'Indoor Gardener',
        caption: 'Creating the perfect indoor garden space  #IndoorGarden',
        timestamp: DateTime.now().subtract(const Duration(hours: 5)),
        viewCount: 203,
        likeCount: 67,
        isViewed: false,
      ),
      MockStory(
        id: 'explore4',
        userId: 'explore_user4',
        userName: 'Plant Parent',
        caption: 'My plant babies are growing so fast!  #PlantParent',
        timestamp: DateTime.now().subtract(const Duration(hours: 7)),
        viewCount: 124,
        likeCount: 35,
        isViewed: false,
      ),
    ];
  }
  void _handleMenuAction(String action) {
    switch (action) {
      case 'archive':
        _showComingSoon('Story Archive');
        break;
      case 'settings':
        _showComingSoon('Story Settings');
        break;
    }
  }
  void _searchByTopic(String topic) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Searching for $topic stories (Demo mode)'),
      ),
    );
  }
  void _showComingSoon(String feature) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$feature feature coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }
  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h';
    } else {
      return '${difference.inDays}d';
    }
  }
}
/// Mock story model for demonstration
class MockStory {
  final String id;
  final String userId;
  final String userName;
  final String caption;
  final DateTime timestamp;
  final int viewCount;
  final int likeCount;
  final bool isViewed;
  MockStory({
    required this.id,
    required this.userId,
    required this.userName,
    required this.caption,
    required this.timestamp,
    required this.viewCount,
    required this.likeCount,
    this.isViewed = false,
  });
}
</file>

<file path="frontend/lib/features/stories/presentation/screens/story_viewer_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
/// Story viewer screen for viewing individual stories
/// Displays stories with full-screen media and interaction options
class StoryViewerScreen extends ConsumerStatefulWidget {
  final String storyId;
  final String? userId;
  const StoryViewerScreen({
    super.key,
    required this.storyId,
    this.userId,
  });
  @override
  ConsumerState<StoryViewerScreen> createState() => _StoryViewerScreenState();
}
class _StoryViewerScreenState extends ConsumerState<StoryViewerScreen>
    with TickerProviderStateMixin {
  late AnimationController _progressController;
  bool _isPaused = false;
  bool _showUI = true;
  @override
  void initState() {
    super.initState();
    _progressController = AnimationController(
      duration: const Duration(seconds: 15), // Story duration
      vsync: this,
    );
    _startStoryProgress();
  }
  @override
  void dispose() {
    _progressController.dispose();
    super.dispose();
  }
  /// Start the story progress animation
  void _startStoryProgress() {
    _progressController.forward().then((_) {
      if (mounted) {
        _onStoryComplete();
      }
    });
  }
  /// Handle story completion
  void _onStoryComplete() {
    context.pop();
  }
  /// Toggle pause/play
  void _togglePause() {
    setState(() {
      _isPaused = !_isPaused;
    });
    if (_isPaused) {
      _progressController.stop();
    } else {
      _progressController.forward();
    }
  }
  /// Toggle UI visibility
  void _toggleUI() {
    setState(() {
      _showUI = !_showUI;
    });
  }
  /// Mock story data
  MockStory get _mockStory => MockStory(
    id: widget.storyId,
    userId: widget.userId ?? 'user1',
    userName: 'Alice Green',
    caption: 'My beautiful succulent garden is thriving!  #PlantLife #SucculentLove',
    imageUrl: 'https://example.com/story-image.jpg', // Placeholder
    timestamp: DateTime.now().subtract(const Duration(hours: 2)),
    viewCount: 24,
    isLiked: false,
  );
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final story = _mockStory;
    return Scaffold(
      backgroundColor: Colors.black,
      body: GestureDetector(
        onTap: _toggleUI,
        onLongPressStart: (_) => _togglePause(),
        onLongPressEnd: (_) => _togglePause(),
        child: Stack(
          children: [
            // Story content (placeholder image)
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.green.shade400,
                      Colors.green.shade700,
                    ],
                  ),
                ),
                child: const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.eco,
                        size: 120,
                        color: Colors.white,
                      ),
                      SizedBox(height: 16),
                      Text(
                        ' Succulent Garden ',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      SizedBox(height: 8),
                      Text(
                        'Demo Story Content',
                        style: TextStyle(
                          color: Colors.white70,
                          fontSize: 16,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            // Pause indicator
            if (_isPaused)
              const Center(
                child: Icon(
                  Icons.pause_circle_filled,
                  size: 80,
                  color: Colors.white70,
                ),
              ),
            // UI overlay
            if (_showUI) ...[
              // Progress bar
              Positioned(
                top: MediaQuery.of(context).padding.top + 8,
                left: 16,
                right: 16,
                child: AnimatedBuilder(
                  animation: _progressController,
                  builder: (context, child) {
                    return LinearProgressIndicator(
                      value: _progressController.value,
                      backgroundColor: Colors.white.withOpacity(0.3),
                      valueColor: const AlwaysStoppedAnimation<Color>(Colors.white),
                    );
                  },
                ),
            ),
              // Header
              Positioned(
                top: MediaQuery.of(context).padding.top + 32,
                left: 16,
                right: 16,
                child: _buildHeader(story, theme),
              ),
              // Caption and interactions
              Positioned(
                bottom: MediaQuery.of(context).padding.bottom + 16,
                left: 16,
                right: 16,
                child: _buildFooter(story, theme),
              ),
            ],
          ],
        ),
      ),
    );
  }
  Widget _buildHeader(MockStory story, ThemeData theme) {
    return Row(
      children: [
        CircleAvatar(
          radius: 20,
          backgroundColor: Colors.white,
          child: Text(
            story.userName.split(' ').map((name) => name[0]).join(),
            style: TextStyle(
              color: theme.colorScheme.primary,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                story.userName,
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              Text(
                _formatTimestamp(story.timestamp),
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 12,
                ),
              ),
            ],
          ),
        ),
        IconButton(
          onPressed: () => context.pop(),
          icon: const Icon(
            Icons.close,
            color: Colors.white,
          ),
        ),
      ],
    );
  }
  Widget _buildFooter(MockStory story, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Caption
        if (story.caption.isNotEmpty)
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.5),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(
              story.caption,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 14,
              ),
            ),
          ),
        const SizedBox(height: 16),
        // Interaction buttons
        Row(
          children: [
            // Like button
            GestureDetector(
              onTap: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Story liked! (Demo mode)'),
                    duration: Duration(seconds: 1),
                  ),
                );
              },
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.5),
                  borderRadius: BorderRadius.circular(20),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      story.isLiked ? Icons.favorite : Icons.favorite_border,
                      color: story.isLiked ? Colors.red : Colors.white,
                      size: 20,
                    ),
                    const SizedBox(width: 4),
                    const Text(
                      'Like',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(width: 12),
            // Reply button
            GestureDetector(
              onTap: () {
                _showReplyBottomSheet(context, story);
              },
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.5),
                  borderRadius: BorderRadius.circular(20),
                ),
                child: const Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.reply,
                      color: Colors.white,
                      size: 20,
                    ),
                    SizedBox(width: 4),
                    Text(
                      'Reply',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const Spacer(),
            // View count
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.5),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(
                    Icons.visibility,
                    color: Colors.white70,
                    size: 16,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    '${story.viewCount}',
                    style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }
  void _showReplyBottomSheet(BuildContext context, MockStory story) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'Reply to ${story.userName}',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            TextField(
              decoration: InputDecoration(
                hintText: 'Send a message...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                suffixIcon: IconButton(
                  onPressed: () {
                    Navigator.pop(context);
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Reply sent! (Demo mode)'),
                      ),
                    );
                  },
                  icon: const Icon(Icons.send),
                ),
              ),
              maxLines: 3,
            ),
            SizedBox(height: MediaQuery.of(context).viewInsets.bottom),
          ],
        ),
      ),
    );
  }
  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }
}
/// Mock story model for demonstration
class MockStory {
  final String id;
  final String userId;
  final String userName;
  final String caption;
  final String imageUrl;
  final DateTime timestamp;
  final int viewCount;
  final bool isLiked;
  MockStory({
    required this.id,
    required this.userId,
    required this.userName,
    required this.caption,
    required this.imageUrl,
    required this.timestamp,
    required this.viewCount,
    required this.isLiked,
  });
}
</file>

<file path="frontend/lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:plant_social/core/theme/app_theme.dart';
import 'package:plant_social/core/router/app_router.dart';
import 'package:plant_social/core/constants/app_constants.dart';
void main() {
  runApp(
    const ProviderScope(
      child: PlantSocialApp(),
    ),
  );
}
class PlantSocialApp extends ConsumerWidget {
  const PlantSocialApp({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(appRouterProvider);
    return MaterialApp.router(
      title: AppConstants.appName,
      debugShowCheckedModeBanner: false,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      routerConfig: router,
    );
  }
}
</file>

<file path="scripts/start-dev.ps1">
#!/usr/bin/env pwsh
# Development startup script for Plant Social platform

Write-Host "Starting Plant Social Development Environment" -ForegroundColor Green
Write-Host "=========================================" -ForegroundColor Green

# Check if Docker is running
try {
    docker info | Out-Null
    Write-Host "[OK] Docker is running" -ForegroundColor Green
} catch {
    Write-Host "[ERROR] Docker is not running. Please start Docker Desktop." -ForegroundColor Red
    exit 1
}

# Navigate to project root
$projectRoot = Split-Path -Parent $PSScriptRoot
Set-Location $projectRoot

Write-Host "Project directory: $projectRoot" -ForegroundColor Cyan

# Start infrastructure services
Write-Host "Starting infrastructure services (PostgreSQL, Redis, LocalStack)..." -ForegroundColor Yellow
try {
    docker-compose up -d postgres redis localstack
    Write-Host "[OK] Infrastructure services started" -ForegroundColor Green
} catch {
    Write-Host "[ERROR] Failed to start infrastructure services" -ForegroundColor Red
    exit 1
}

# Wait for services to be ready
Write-Host "Waiting for services to be ready..." -ForegroundColor Yellow
Start-Sleep -Seconds 10

# Check service health
Write-Host "Checking service health..." -ForegroundColor Yellow

# Check PostgreSQL
try {
    $pgResult = docker-compose exec -T postgres pg_isready -U postgres
    if ($LASTEXITCODE -eq 0) {
        Write-Host "[OK] PostgreSQL is ready" -ForegroundColor Green
    } else {
        Write-Host "[WARNING] PostgreSQL is not ready yet" -ForegroundColor Yellow
    }
} catch {
    Write-Host "[WARNING] Could not check PostgreSQL status" -ForegroundColor Yellow
}

# Check Redis
try {
    $redisResult = docker-compose exec -T redis redis-cli ping
    if ($redisResult -eq "PONG") {
        Write-Host "[OK] Redis is ready" -ForegroundColor Green
    } else {
        Write-Host "[WARNING] Redis is not ready yet" -ForegroundColor Yellow
    }
} catch {
    Write-Host "[WARNING] Could not check Redis status" -ForegroundColor Yellow
}

# Navigate to backend directory
Set-Location "backend"

# Check if virtual environment exists
if (Test-Path "venv") {
    Write-Host "[OK] Virtual environment found" -ForegroundColor Green
} else {
    Write-Host "Creating virtual environment..." -ForegroundColor Yellow
    python -m venv venv
    Write-Host "[OK] Virtual environment created" -ForegroundColor Green
}

# Activate virtual environment
Write-Host "Activating virtual environment..." -ForegroundColor Yellow
if ($IsWindows -or $env:OS -eq "Windows_NT") {
    & ".\venv\Scripts\Activate.ps1"
} else {
    & "./venv/bin/activate"
}

# Install dependencies
Write-Host "Installing Python dependencies..." -ForegroundColor Yellow
try {
    pip install -r requirements.txt
    Write-Host "[OK] Dependencies installed" -ForegroundColor Green
} catch {
    Write-Host "[ERROR] Failed to install dependencies" -ForegroundColor Red
    exit 1
}

# Run database migrations
Write-Host "Setting up database..." -ForegroundColor Yellow
try {
    # Check if migrations directory exists
    if (!(Test-Path "alembic\versions")) {
        Write-Host "Creating initial migration..." -ForegroundColor Yellow
        alembic revision --autogenerate -m "Initial migration"
    }
    
    # Apply migrations
    Write-Host "Applying database migrations..." -ForegroundColor Yellow
    alembic upgrade head
    Write-Host "[OK] Database migrations applied" -ForegroundColor Green
} catch {
    Write-Host "[WARNING] Database migration failed, but continuing..." -ForegroundColor Yellow
    Write-Host "You may need to run migrations manually: alembic upgrade head" -ForegroundColor Yellow
}

# Create S3 bucket in LocalStack
Write-Host "Setting up S3 bucket in LocalStack..." -ForegroundColor Yellow
try {
    Start-Sleep -Seconds 5  # Wait for LocalStack to be ready
    $env:AWS_ACCESS_KEY_ID = "test"
    $env:AWS_SECRET_ACCESS_KEY = "test"
    $env:AWS_DEFAULT_REGION = "us-east-1"
    
    aws --endpoint-url=http://localhost:4566 s3 mb s3://plant-social-media 2>$null
    Write-Host "[OK] S3 bucket created in LocalStack" -ForegroundColor Green
} catch {
    Write-Host "[WARNING] Could not create S3 bucket (LocalStack may not be ready)" -ForegroundColor Yellow
}

Write-Host ""
Write-Host "Development environment is ready!" -ForegroundColor Green
Write-Host "=========================================" -ForegroundColor Green
Write-Host "Service URLs:" -ForegroundColor Cyan
Write-Host "   - API Documentation: http://localhost:8000/docs" -ForegroundColor White
Write-Host "   - API ReDoc: http://localhost:8000/redoc" -ForegroundColor White
Write-Host "   - PostgreSQL: localhost:5432" -ForegroundColor White
Write-Host "   - Redis: localhost:6379" -ForegroundColor White
Write-Host "   - LocalStack S3: http://localhost:4566" -ForegroundColor White
Write-Host ""
Write-Host "To start the API server, run:" -ForegroundColor Yellow
Write-Host "   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000" -ForegroundColor White
Write-Host ""
Write-Host "To stop services, run:" -ForegroundColor Yellow
Write-Host "   docker-compose down" -ForegroundColor White
Write-Host ""
</file>

<file path="frontend/lib/core/models/user.dart">
import 'package:json_annotation/json_annotation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
<<<<<<< HEAD
part 'user.g.dart';
part 'user.freezed.dart';
=======
>>>>>>> baf556a5d654e56b6d571fc759b0e5caa549cb96
part 'user.freezed.dart';
part 'user.g.dart';
@freezed
class User with _$User {
  const factory User({
    required String id,
    required String email,
    required String username,
    String? displayName,
    String? bio,
    String? profilePictureUrl,
    String? location,
    DateTime? dateOfBirth,
    @Default(false) bool isPrivate,
    @Default(0) int followersCount,
    @Default(0) int followingCount,
    @Default(0) int postsCount,
    @Default(true) bool isActive,
    @Default(false) bool isVerified,
    DateTime? lastSeen,
    required DateTime createdAt,
    DateTime? updatedAt,
    // Plant-specific fields for Phase 2
    @Default([]) List<String> plantInterests,
    String? experienceLevel, // 'beginner', 'intermediate', 'expert'
    @Default([]) List<String> favoriteGenres,
    String? gardenType, // 'indoor', 'outdoor', 'balcony', 'greenhouse'
    String? climate, // 'tropical', 'temperate', 'arid', 'continental'
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}
@freezed
class UserProfile with _$UserProfile {
  const factory UserProfile({
    required User user,
    @Default(false) bool isFollowing,
    @Default(false) bool isFollowedBy,
    @Default(false) bool isBlocked,
    @Default(false) bool hasBlockedMe,
    String? friendshipStatus, // 'none', 'pending', 'accepted', 'blocked'
  }) = _UserProfile;
  factory UserProfile.fromJson(Map<String, dynamic> json) => _$UserProfileFromJson(json);
}
@freezed
class UserSearchResult with _$UserSearchResult {
  const factory UserSearchResult({
    required String id,
    required String username,
    String? fullName,
    String? profilePictureUrl,
    @Default(false) bool isVerified,
    @Default(false) bool isFollowing,
    String? mutualFriendsCount,
  }) = _UserSearchResult;
  factory UserSearchResult.fromJson(Map<String, dynamic> json) => _$UserSearchResultFromJson(json);
}
@freezed
class UpdateUserRequest with _$UpdateUserRequest {
  const factory UpdateUserRequest({
    String? fullName,
    String? bio,
    String? location,
    DateTime? dateOfBirth,
    bool? isPrivate,
    List<String>? plantInterests,
    String? experienceLevel,
    List<String>? favoriteGenres,
    String? gardenType,
    String? climate,
  }) = _UpdateUserRequest;
  factory UpdateUserRequest.fromJson(Map<String, dynamic> json) => _$UpdateUserRequestFromJson(json);
}
// Extension methods for User
extension UserExtension on User {
  String get name => displayName ?? username;
  String get initials {
    if (displayName?.isNotEmpty == true) {
      final parts = displayName!.split(' ');
      if (parts.length >= 2) {
        return '${parts[0][0]}${parts[1][0]}'.toUpperCase();
      }
      return displayName![0].toUpperCase();
    }
    return username[0].toUpperCase();
  }
  bool get hasProfilePicture => profilePictureUrl?.isNotEmpty == true;
  bool get isOnline {
    if (lastSeen == null) return false;
    final now = DateTime.now();
    final difference = now.difference(lastSeen!);
    return difference.inMinutes < 5; // Consider online if last seen within 5 minutes
  }
  String get lastSeenText {
    if (lastSeen == null) return 'Never';
    final now = DateTime.now();
    final difference = now.difference(lastSeen!);
    if (difference.inMinutes < 1) {
      return 'Just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return 'Long time ago';
    }
  }
  String get experienceLevelDisplay {
    switch (experienceLevel?.toLowerCase()) {
      case 'beginner':
        return ' Beginner';
      case 'intermediate':
        return ' Intermediate';
      case 'expert':
        return ' Expert';
      default:
        return ' New to plants';
    }
  }
  String get gardenTypeDisplay {
    switch (gardenType?.toLowerCase()) {
      case 'indoor':
        return ' Indoor Garden';
      case 'outdoor':
        return ' Outdoor Garden';
      case 'balcony':
        return ' Balcony Garden';
      case 'greenhouse':
        return ' Greenhouse';
      default:
        return ' Garden';
    }
  }
}
</file>

<file path="frontend/lib/core/router/app_router.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:plant_social/features/auth/presentation/screens/login_screen.dart';
import 'package:plant_social/features/auth/presentation/screens/register_screen.dart';
import 'package:plant_social/features/auth/presentation/screens/splash_screen.dart';
import 'package:plant_social/features/home/presentation/screens/main_screen.dart';
<<<<<<< HEAD
import 'package:plant_social/features/camera/presentation/screens/camera_screen.dart';
import 'package:plant_social/features/chat/presentation/screens/chat_screen.dart';
import 'package:plant_social/features/chat/presentation/screens/conversation_screen.dart';
import 'package:plant_social/features/stories/presentation/screens/story_viewer_screen.dart';
import 'package:plant_social/features/stories/presentation/screens/story_creation_screen.dart';
import 'package:plant_social/features/profile/presentation/screens/profile_screen.dart';
import 'package:plant_social/features/profile/presentation/screens/profile_edit_screen.dart';
import 'package:plant_social/features/friends/presentation/screens/friends_screen.dart';
import 'package:plant_social/features/friends/presentation/screens/add_friends_screen.dart';
import 'package:plant_social/features/plant/presentation/screens/plant_features_screen.dart';
=======
>>>>>>> baf556a5d654e56b6d571fc759b0e5caa549cb96
import 'package:plant_social/features/auth/providers/auth_provider.dart';
final appRouterProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authProvider);
  return GoRouter(
    initialLocation: '/splash',
    redirect: (BuildContext context, GoRouterState state) {
      final isLoggedIn = authState.isAuthenticated;
      final isLoggingIn = state.matchedLocation == '/login' || 
                         state.matchedLocation == '/register';
      // If not logged in and not on auth screens, redirect to login
      if (!isLoggedIn && !isLoggingIn && state.matchedLocation != '/splash') {
        return '/login';
      }
      // If logged in and on auth screens, redirect to home
      if (isLoggedIn && isLoggingIn) {
        return '/home';
      }
      return null;
    },
    routes: [
      // Splash Screen
      GoRoute(
        path: '/splash',
        name: 'splash',
        builder: (BuildContext context, GoRouterState state) => const SplashScreen(),
      ),
      // Authentication Routes
      GoRoute(
        path: '/login',
        name: 'login',
        builder: (BuildContext context, GoRouterState state) => const LoginScreen(),
      ),
      GoRoute(
        path: '/register',
        name: 'register',
        builder: (BuildContext context, GoRouterState state) => const RegisterScreen(),
      ),
      // Main App Routes
      GoRoute(
        path: '/home',
        name: 'home',
        builder: (BuildContext context, GoRouterState state) => const MainScreen(),
<<<<<<< HEAD
        routes: [
          // Camera Route
          GoRoute(
            path: 'camera',
            name: 'camera',
            builder: (context, state) => const CameraScreen(),
            routes: [
              GoRoute(
                path: 'story-creation',
                name: 'story-creation',
                builder: (context, state) {
                  final imagePath = state.uri.queryParameters['imagePath'];
                  return StoryCreationScreen(imagePath: imagePath);
                },
              ),
            ],
          ),
          // Chat Routes
          GoRoute(
            path: 'chat',
            name: 'chat',
            builder: (context, state) => const ChatScreen(),
            routes: [
              GoRoute(
                path: 'conversation/:userId',
                name: 'conversation',
                builder: (context, state) {
                  final userId = state.pathParameters['userId']!;
                  final userName = state.uri.queryParameters['userName'];
                  return ConversationScreen(
                    userId: userId,
                    userName: userName,
                  );
                },
              ),
            ],
          ),
          // Stories Routes
          GoRoute(
            path: 'story/:storyId',
            name: 'story-viewer',
            builder: (context, state) {
              final storyId = state.pathParameters['storyId']!;
              final userId = state.uri.queryParameters['userId'];
              return StoryViewerScreen(
                storyId: storyId,
                userId: userId,
              );
            },
          ),
          // Profile Routes
          GoRoute(
            path: 'profile',
            name: 'profile',
            builder: (context, state) => const ProfileScreen(),
            routes: [
              GoRoute(
                path: 'edit',
                name: 'edit-profile',
                builder: (context, state) => const ProfileEditScreen(),
              ),
            ],
          ),
          // Friends Routes
          GoRoute(
            path: 'friends',
            name: 'friends',
            builder: (context, state) => const FriendsScreen(),
            routes: [
              GoRoute(
                path: 'add',
                name: 'add-friends',
                builder: (context, state) => const AddFriendsScreen(),
              ),
            ],
          ),
          // Plant Features Routes
          GoRoute(
            path: 'plants',
            name: 'plants',
            builder: (context, state) => const PlantFeaturesScreen(),
          ),
        ],
=======
>>>>>>> baf556a5d654e56b6d571fc759b0e5caa549cb96
      ),
    ],
    errorBuilder: (BuildContext context, GoRouterState state) => Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.error_outline,
              size: 64,
              color: Colors.red,
            ),
            const SizedBox(height: 16),
            Text(
              'Page not found',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 8),
            Text(
              'The page you are looking for does not exist.',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => context.go('/home'),
              child: const Text('Go Home'),
            ),
          ],
        ),
      ),
    ),
  );
});
// Route Names for easy access
class AppRoutes {
  static const String splash = '/splash';
  static const String login = '/login';
  static const String register = '/register';
  static const String home = '/home';
}
</file>

<file path="frontend/lib/features/plant_community/models/plant_community_models.dart">
import 'package:json_annotation/json_annotation.dart';
part 'plant_community_models.g.dart';
@JsonSerializable()
class PlantQuestion {
  final String id;
  final String userId;
  final String title;
  final String content;
  final String? imageUrl;
  final String? plantSpeciesId;
  final String category;
  final List<String> tags;
  final int upvotes;
  final int downvotes;
  final int views;
  final int answerCount;
  final bool isSolved;
  final String? acceptedAnswerId;
  final DateTime createdAt;
  final DateTime? updatedAt;
  // User info
  final String? userDisplayName;
  final String? userAvatarUrl;
  // Plant species info
  final String? speciesCommonName;
  final String? speciesScientificName;
  // User interaction
  final String? userVote; // 'up', 'down', or null
  final bool isBookmarked;
  const PlantQuestion({
    required this.id,
    required this.userId,
    required this.title,
    required this.content,
    this.imageUrl,
    this.plantSpeciesId,
    this.category = QuestionCategory.general,
    this.tags = const [],
    this.upvotes = 0,
    this.downvotes = 0,
    this.views = 0,
    this.answerCount = 0,
    this.isSolved = false,
    this.acceptedAnswerId,
    required this.createdAt,
    this.updatedAt,
    this.userDisplayName,
    this.userAvatarUrl,
    this.speciesCommonName,
    this.speciesScientificName,
    this.userVote,
    this.isBookmarked = false,
  });
  factory PlantQuestion.fromJson(Map<String, dynamic> json) {
    return PlantQuestion(
      id: json['id'] as String,
      userId: json['userId'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      category: json['category'] as String? ?? QuestionCategory.general,
      tags: (json['tags'] as List<dynamic>?)?.cast<String>() ?? [],
      upvotes: json['upvotes'] as int? ?? 0,
      downvotes: json['downvotes'] as int? ?? 0,
      views: json['views'] as int? ?? 0,
      answerCount: json['answerCount'] as int? ?? 0,
      isSolved: json['isSolved'] as bool? ?? false,
      acceptedAnswerId: json['acceptedAnswerId'] as String?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : null,
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      speciesCommonName: json['speciesCommonName'] as String?,
      speciesScientificName: json['speciesScientificName'] as String?,
      userVote: json['userVote'] as String?,
      isBookmarked: json['isBookmarked'] as bool? ?? false,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'title': title,
      'content': content,
      'imageUrl': imageUrl,
      'plantSpeciesId': plantSpeciesId,
      'category': category,
      'tags': tags,
      'upvotes': upvotes,
      'downvotes': downvotes,
      'views': views,
      'answerCount': answerCount,
      'isSolved': isSolved,
      'acceptedAnswerId': acceptedAnswerId,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
      'userDisplayName': userDisplayName,
      'userAvatarUrl': userAvatarUrl,
      'speciesCommonName': speciesCommonName,
      'speciesScientificName': speciesScientificName,
      'userVote': userVote,
      'isBookmarked': isBookmarked,
    };
  }
  PlantQuestion copyWith({
    String? id,
    String? userId,
    String? title,
    String? content,
    String? imageUrl,
    String? plantSpeciesId,
    String? category,
    List<String>? tags,
    int? upvotes,
    int? downvotes,
    int? views,
    int? answerCount,
    bool? isSolved,
    String? acceptedAnswerId,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? userDisplayName,
    String? userAvatarUrl,
    String? speciesCommonName,
    String? speciesScientificName,
    String? userVote,
    bool? isBookmarked,
  }) {
    return PlantQuestion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      content: content ?? this.content,
      imageUrl: imageUrl ?? this.imageUrl,
      plantSpeciesId: plantSpeciesId ?? this.plantSpeciesId,
      category: category ?? this.category,
      tags: tags ?? this.tags,
      upvotes: upvotes ?? this.upvotes,
      downvotes: downvotes ?? this.downvotes,
      views: views ?? this.views,
      answerCount: answerCount ?? this.answerCount,
      isSolved: isSolved ?? this.isSolved,
      acceptedAnswerId: acceptedAnswerId ?? this.acceptedAnswerId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      userDisplayName: userDisplayName ?? this.userDisplayName,
      userAvatarUrl: userAvatarUrl ?? this.userAvatarUrl,
      speciesCommonName: speciesCommonName ?? this.speciesCommonName,
      speciesScientificName: speciesScientificName ?? this.speciesScientificName,
      userVote: userVote ?? this.userVote,
      isBookmarked: isBookmarked ?? this.isBookmarked,
    );
  }
}
@JsonSerializable()
class PlantAnswer {
  final String id;
  final String questionId;
  final String userId;
  final String content;
  final String? imageUrl;
  final int upvotes;
  final int downvotes;
  final bool isAccepted;
  final DateTime createdAt;
  final DateTime? updatedAt;
  // User info
  final String? userDisplayName;
  final String? userAvatarUrl;
  // User interaction
  final String? userVote; // 'up', 'down', or null
  const PlantAnswer({
    required this.id,
    required this.questionId,
    required this.userId,
    required this.content,
    this.imageUrl,
    this.upvotes = 0,
    this.downvotes = 0,
    this.isAccepted = false,
    required this.createdAt,
    this.updatedAt,
    this.userDisplayName,
    this.userAvatarUrl,
    this.userVote,
  });
  factory PlantAnswer.fromJson(Map<String, dynamic> json) {
    return PlantAnswer(
      id: json['id'] as String,
      questionId: json['questionId'] as String,
      userId: json['userId'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      upvotes: json['upvotes'] as int? ?? 0,
      downvotes: json['downvotes'] as int? ?? 0,
      isAccepted: json['isAccepted'] as bool? ?? false,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : null,
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      userVote: json['userVote'] as String?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'questionId': questionId,
      'userId': userId,
      'content': content,
      'imageUrl': imageUrl,
      'upvotes': upvotes,
      'downvotes': downvotes,
      'isAccepted': isAccepted,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
      'userDisplayName': userDisplayName,
      'userAvatarUrl': userAvatarUrl,
      'userVote': userVote,
    };
  }
}
@JsonSerializable()
class PlantTrade {
  final String id;
  final String userId;
  final String title;
  final String description;
  final String tradeType; // 'trade', 'sell', 'give_away'
  final String? price;
  final List<String> imageUrls;
  final String location;
  final String? plantSpeciesId;
  final List<String> tags;
  final String status; // 'active', 'completed', 'cancelled'
  final int viewCount;
  final int interestedCount;
  final DateTime createdAt;
  final DateTime? updatedAt;
  // User info
  final String? userDisplayName;
  final String? userAvatarUrl;
  // Plant species info
  final String? speciesCommonName;
  final String? speciesScientificName;
  // User interaction
  final bool isBookmarked;
  final bool hasExpressedInterest;
  const PlantTrade({
    required this.id,
    required this.userId,
    required this.title,
    required this.description,
    required this.tradeType,
    this.price,
    this.imageUrls = const [],
    required this.location,
    this.plantSpeciesId,
    this.tags = const [],
    this.status = 'active',
    this.viewCount = 0,
    this.interestedCount = 0,
    required this.createdAt,
    this.updatedAt,
    this.userDisplayName,
    this.userAvatarUrl,
    this.speciesCommonName,
    this.speciesScientificName,
    this.isBookmarked = false,
    this.hasExpressedInterest = false,
  });
  factory PlantTrade.fromJson(Map<String, dynamic> json) {
    return PlantTrade(
      id: json['id'] as String,
      userId: json['userId'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      tradeType: json['tradeType'] as String,
      price: json['price'] as String?,
      imageUrls: (json['imageUrls'] as List<dynamic>?)?.cast<String>() ?? [],
      location: json['location'] as String,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags: (json['tags'] as List<dynamic>?)?.cast<String>() ?? [],
      status: json['status'] as String? ?? 'active',
      viewCount: json['viewCount'] as int? ?? 0,
      interestedCount: json['interestedCount'] as int? ?? 0,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : null,
      userDisplayName: json['userDisplayName'] as String?,
      userAvatarUrl: json['userAvatarUrl'] as String?,
      speciesCommonName: json['speciesCommonName'] as String?,
      speciesScientificName: json['speciesScientificName'] as String?,
      isBookmarked: json['isBookmarked'] as bool? ?? false,
      hasExpressedInterest: json['hasExpressedInterest'] as bool? ?? false,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'title': title,
      'description': description,
      'tradeType': tradeType,
      'price': price,
      'imageUrls': imageUrls,
      'location': location,
      'plantSpeciesId': plantSpeciesId,
      'tags': tags,
      'status': status,
      'viewCount': viewCount,
      'interestedCount': interestedCount,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
      'userDisplayName': userDisplayName,
      'userAvatarUrl': userAvatarUrl,
      'speciesCommonName': speciesCommonName,
      'speciesScientificName': speciesScientificName,
      'isBookmarked': isBookmarked,
      'hasExpressedInterest': hasExpressedInterest,
    };
  }
}
@JsonSerializable()
class PlantQuestionRequest {
  final String title;
  final String content;
  final String? imageUrl;
  final String? plantSpeciesId;
  final List<String> tags;
  const PlantQuestionRequest({
    required this.title,
    required this.content,
    this.imageUrl,
    this.plantSpeciesId,
    this.tags = const [],
  });
  factory PlantQuestionRequest.fromJson(Map<String, dynamic> json) {
    return PlantQuestionRequest(
      title: json['title'] as String,
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags: (json['tags'] as List<dynamic>?)?.cast<String>() ?? [],
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'content': content,
      'imageUrl': imageUrl,
      'plantSpeciesId': plantSpeciesId,
      'tags': tags,
    };
  }
}
@JsonSerializable()
class PlantAnswerRequest {
  final String content;
  final String? imageUrl;
  const PlantAnswerRequest({
    required this.content,
    this.imageUrl,
  });
  factory PlantAnswerRequest.fromJson(Map<String, dynamic> json) {
    return PlantAnswerRequest(
      content: json['content'] as String,
      imageUrl: json['imageUrl'] as String?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'content': content,
      'imageUrl': imageUrl,
    };
  }
}
@JsonSerializable()
class PlantTradeRequest {
  final String title;
  final String description;
  final String tradeType;
  final String? price;
  final List<String> imageUrls;
  final String location;
  final String? plantSpeciesId;
  final List<String> tags;
  const PlantTradeRequest({
    required this.title,
    required this.description,
    required this.tradeType,
    this.price,
    this.imageUrls = const [],
    required this.location,
    this.plantSpeciesId,
    this.tags = const [],
  });
  factory PlantTradeRequest.fromJson(Map<String, dynamic> json) {
    return PlantTradeRequest(
      title: json['title'] as String,
      description: json['description'] as String,
      tradeType: json['tradeType'] as String,
      price: json['price'] as String?,
      imageUrls: (json['imageUrls'] as List<dynamic>?)?.cast<String>() ?? [],
      location: json['location'] as String,
      plantSpeciesId: json['plantSpeciesId'] as String?,
      tags: (json['tags'] as List<dynamic>?)?.cast<String>() ?? [],
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'description': description,
      'tradeType': tradeType,
      'price': price,
      'imageUrls': imageUrls,
      'location': location,
      'plantSpeciesId': plantSpeciesId,
      'tags': tags,
    };
  }
}
@JsonSerializable()
class PlantCommunityState {
  final bool isLoading;
  final List<PlantQuestion> questions;
  final List<PlantAnswer> answers;
  final List<PlantTrade> trades;
  final String? error;
  // Pagination
  final bool hasMoreQuestions;
  final bool hasMoreTrades;
  final int currentQuestionPage;
  final int currentTradePage;
  // Filters
  final String? selectedCategory;
  final String? searchQuery;
  final String? sortBy;
  const PlantCommunityState({
    this.isLoading = false,
    this.questions = const [],
    this.answers = const [],
    this.trades = const [],
    this.error,
    this.hasMoreQuestions = false,
    this.hasMoreTrades = false,
    this.currentQuestionPage = 1,
    this.currentTradePage = 1,
    this.selectedCategory,
    this.searchQuery,
    this.sortBy,
  });
  factory PlantCommunityState.fromJson(Map<String, dynamic> json) {
    return PlantCommunityState(
      isLoading: json['isLoading'] as bool? ?? false,
      questions: (json['questions'] as List<dynamic>?)?.map((e) => PlantQuestion.fromJson(e as Map<String, dynamic>)).toList() ?? [],
      answers: (json['answers'] as List<dynamic>?)?.map((e) => PlantAnswer.fromJson(e as Map<String, dynamic>)).toList() ?? [],
      trades: (json['trades'] as List<dynamic>?)?.map((e) => PlantTrade.fromJson(e as Map<String, dynamic>)).toList() ?? [],
      error: json['error'] as String?,
      hasMoreQuestions: json['hasMoreQuestions'] as bool? ?? false,
      hasMoreTrades: json['hasMoreTrades'] as bool? ?? false,
      currentQuestionPage: json['currentQuestionPage'] as int? ?? 1,
      currentTradePage: json['currentTradePage'] as int? ?? 1,
      selectedCategory: json['selectedCategory'] as String?,
      searchQuery: json['searchQuery'] as String?,
      sortBy: json['sortBy'] as String?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'isLoading': isLoading,
      'questions': questions.map((e) => e.toJson()).toList(),
      'answers': answers.map((e) => e.toJson()).toList(),
      'trades': trades.map((e) => e.toJson()).toList(),
      'error': error,
      'hasMoreQuestions': hasMoreQuestions,
      'hasMoreTrades': hasMoreTrades,
      'currentQuestionPage': currentQuestionPage,
      'currentTradePage': currentTradePage,
      'selectedCategory': selectedCategory,
      'searchQuery': searchQuery,
      'sortBy': sortBy,
    };
  }
  PlantCommunityState copyWith({
    bool? isLoading,
    List<PlantQuestion>? questions,
    List<PlantAnswer>? answers,
    List<PlantTrade>? trades,
    String? error,
    bool? hasMoreQuestions,
    bool? hasMoreTrades,
    int? currentQuestionPage,
    int? currentTradePage,
    String? selectedCategory,
    String? searchQuery,
    String? sortBy,
  }) {
    return PlantCommunityState(
      isLoading: isLoading ?? this.isLoading,
      questions: questions ?? this.questions,
      answers: answers ?? this.answers,
      trades: trades ?? this.trades,
      error: error ?? this.error,
      hasMoreQuestions: hasMoreQuestions ?? this.hasMoreQuestions,
      hasMoreTrades: hasMoreTrades ?? this.hasMoreTrades,
      currentQuestionPage: currentQuestionPage ?? this.currentQuestionPage,
      currentTradePage: currentTradePage ?? this.currentTradePage,
      selectedCategory: selectedCategory ?? this.selectedCategory,
      searchQuery: searchQuery ?? this.searchQuery,
      sortBy: sortBy ?? this.sortBy,
    );
  }
}
// Constants
class TradeType {
  static const String trade = 'trade';
  static const String sell = 'sell';
  static const String giveAway = 'give_away';
  static const List<String> all = [trade, sell, giveAway];
  static String getDisplayName(String type) {
    switch (type) {
      case trade:
        return 'Trade';
      case sell:
        return 'Sell';
      case giveAway:
        return 'Give Away';
      default:
        return type;
    }
  }
}
class QuestionCategory {
  static const String general = 'general';
  static const String care = 'care';
  static const String identification = 'identification';
  static const String pests = 'pests';
  static const String diseases = 'diseases';
  static const String propagation = 'propagation';
  static const String troubleshooting = 'troubleshooting';
  static const List<String> all = [
    general,
    care,
    identification,
    pests,
    diseases,
    propagation,
    troubleshooting,
  ];
  static String getDisplayName(String category) {
    switch (category) {
      case general:
        return 'General';
      case care:
        return 'Plant Care';
      case identification:
        return 'Plant ID';
      case pests:
        return 'Pests';
      case diseases:
        return 'Diseases';
      case propagation:
        return 'Propagation';
      case troubleshooting:
        return 'Troubleshooting';
      default:
        return category;
    }
  }
  static String getIcon(String category) {
    switch (category) {
      case general:
        return '';
      case care:
        return '';
      case identification:
        return '';
      case pests:
        return '';
      case diseases:
        return '';
      case propagation:
        return '';
      case troubleshooting:
        return '';
      default:
        return '';
    }
  }
}
class SortOption {
  static const String newest = 'newest';
  static const String oldest = 'oldest';
  static const String mostUpvoted = 'most_upvoted';
  static const String mostAnswered = 'most_answered';
  static const String unsolved = 'unsolved';
  static const List<String> questionSortOptions = [
    newest,
    oldest,
    mostUpvoted,
    mostAnswered,
    unsolved,
  ];
  static const List<String> tradeSortOptions = [
    newest,
    oldest,
  ];
  static String getDisplayName(String option) {
    switch (option) {
      case newest:
        return 'Newest';
      case oldest:
        return 'Oldest';
      case mostUpvoted:
        return 'Most Upvoted';
      case mostAnswered:
        return 'Most Answered';
      case unsolved:
        return 'Unsolved';
      default:
        return option;
    }
  }
}
</file>

<file path="frontend/lib/features/profile/presentation/screens/profile_edit_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/models/user.dart';
import '../../../auth/providers/auth_provider.dart';
/// Profile edit screen for updating user information
class ProfileEditScreen extends ConsumerStatefulWidget {
  const ProfileEditScreen({super.key});
  @override
  ConsumerState<ProfileEditScreen> createState() => _ProfileEditScreenState();
}
class _ProfileEditScreenState extends ConsumerState<ProfileEditScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _bioController = TextEditingController();
  final _locationController = TextEditingController();
  final _websiteController = TextEditingController();
  bool _isLoading = false;
  bool _hasChanges = false;
  bool _controllersInitialized = false;
  @override
  void initState() {
    super.initState();
    // Add listeners to detect changes
    _nameController.addListener(_onFieldChanged);
    _bioController.addListener(_onFieldChanged);
    _locationController.addListener(_onFieldChanged);
    _websiteController.addListener(_onFieldChanged);
  }
  @override
  void dispose() {
    _nameController.dispose();
    _bioController.dispose();
    _locationController.dispose();
    _websiteController.dispose();
    super.dispose();
  }
  void _initializeControllers(WidgetRef ref) {
    final authState = ref.read(authProvider);
    // Initialize with mock data for demonstration
    _nameController.text = authState?.user?.displayName ?? 'Plant Lover';
    _bioController.text = 'Passionate about plants and sustainable living \nSharing my green journey with fellow plant enthusiasts!';
    _locationController.text = 'San Francisco, CA';
    _websiteController.text = 'https://myplantblog.com';
  }
  void _onFieldChanged() {
    if (!_hasChanges) {
      setState(() {
        _hasChanges = true;
      });
    }
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Initialize controllers with ref access
    if (!_controllersInitialized) {
      _initializeControllers(ref);
      _controllersInitialized = true;
    }
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Profile'),
        leading: IconButton(
          onPressed: () => _handleBackPress(context),
          icon: const Icon(Icons.close),
        ),
        actions: [
          TextButton(
            onPressed: _hasChanges && !_isLoading ? _saveProfile : null,
            child: _isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Text('Save'),
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Profile picture section
              _buildProfilePictureSection(theme),
              const SizedBox(height: 32),
              // Basic information
              _buildBasicInfoSection(theme),
              const SizedBox(height: 24),
              // Bio section
              _buildBioSection(theme),
              const SizedBox(height: 24),
              // Contact information
              _buildContactInfoSection(theme),
              const SizedBox(height: 24),
              // Privacy settings
              _buildPrivacySection(theme),
              const SizedBox(height: 32),
              // Danger zone
              _buildDangerZone(theme),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildProfilePictureSection(ThemeData theme) {
    return Center(
      child: Column(
        children: [
          Stack(
            children: [
              CircleAvatar(
                radius: 60,
                backgroundColor: theme.colorScheme.primary,
                child: Text(
                  _nameController.text.split(' ').map((name) => name.isNotEmpty ? name[0] : '').join(),
                  style: TextStyle(
                    fontSize: 36,
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onPrimary,
                  ),
                ),
              ),
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: theme.colorScheme.surface,
                      width: 2,
                    ),
                  ),
                  child: IconButton(
                    onPressed: _changeProfilePicture,
                    icon: Icon(
                      Icons.camera_alt,
                      color: theme.colorScheme.onPrimary,
                      size: 20,
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          TextButton(
            onPressed: _changeProfilePicture,
            child: const Text('Change Profile Picture'),
          ),
        ],
      ),
    );
  }
  Widget _buildBasicInfoSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Basic Information',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        TextFormField(
          controller: _nameController,
          decoration: const InputDecoration(
            labelText: 'Display Name',
            hintText: 'Enter your display name',
            prefixIcon: Icon(Icons.person),
          ),
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'Display name is required';
            }
            if (value.trim().length < 2) {
              return 'Display name must be at least 2 characters';
            }
            return null;
          },
          textCapitalization: TextCapitalization.words,
        ),
        const SizedBox(height: 16),
        TextFormField(
          controller: _locationController,
          decoration: const InputDecoration(
            labelText: 'Location',
            hintText: 'Enter your location',
            prefixIcon: Icon(Icons.location_on),
          ),
          textCapitalization: TextCapitalization.words,
        ),
      ],
    );
  }
  Widget _buildBioSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Bio',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        TextFormField(
          controller: _bioController,
          decoration: InputDecoration(
            labelText: 'Bio',
            hintText: 'Tell others about yourself and your plant journey...',
            prefixIcon: const Icon(Icons.info_outline),
            alignLabelWithHint: true,
            helperText: '${_bioController.text.length}/500 characters',
          ),
          maxLines: 4,
          maxLength: 500,
          validator: (value) {
            if (value != null && value.length > 500) {
              return 'Bio must be 500 characters or less';
            }
            return null;
          },
          textCapitalization: TextCapitalization.sentences,
        ),
      ],
    );
  }
  Widget _buildContactInfoSection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Contact Information',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        TextFormField(
          controller: _websiteController,
          decoration: const InputDecoration(
            labelText: 'Website',
            hintText: 'https://yourwebsite.com',
            prefixIcon: Icon(Icons.link),
          ),
          keyboardType: TextInputType.url,
          validator: (value) {
            if (value != null && value.isNotEmpty) {
              final urlPattern = r'^https?:\/\/.+';
              if (!RegExp(urlPattern).hasMatch(value)) {
                return 'Please enter a valid URL starting with http:// or https://';
              }
            }
            return null;
          },
        ),
      ],
    );
  }
  Widget _buildPrivacySection(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Privacy Settings',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                _buildPrivacyOption(
                  'Private Account',
                  'Only approved followers can see your posts',
                  false,
                  (value) {
                    setState(() {
                      _hasChanges = true;
                    });
                    _showComingSoon('Private Account');
                  },
                ),
                const Divider(),
                _buildPrivacyOption(
                  'Show Activity Status',
                  'Let others see when you\'re active',
                  true,
                  (value) {
                    setState(() {
                      _hasChanges = true;
                    });
                    _showComingSoon('Activity Status');
                  },
                ),
                const Divider(),
                _buildPrivacyOption(
                  'Allow Plant Identification',
                  'Let others identify plants in your photos',
                  true,
                  (value) {
                    setState(() {
                      _hasChanges = true;
                    });
                    _showComingSoon('Plant Identification');
                  },
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  Widget _buildPrivacyOption(
    String title,
    String subtitle,
    bool value,
    ValueChanged<bool> onChanged,
  ) {
    return Row(
      children: [
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
              Text(
                subtitle,
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),
        Switch(
          value: value,
          onChanged: onChanged,
        ),
      ],
    );
  }
  Widget _buildDangerZone(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Danger Zone',
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: Colors.red,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          color: Colors.red.shade50,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.warning,
                      color: Colors.red.shade700,
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Delete Account',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color: Colors.red.shade700,
                            ),
                          ),
                          Text(
                            'Permanently delete your account and all data',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.red.shade600,
                            ),
                          ),
                        ],
                      ),
                    ),
                    OutlinedButton(
                      onPressed: _showDeleteAccountDialog,
                      style: OutlinedButton.styleFrom(
                        foregroundColor: Colors.red.shade700,
                        side: BorderSide(color: Colors.red.shade700),
                      ),
                      child: const Text('Delete'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  void _changeProfilePicture() {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Change Profile Picture',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildImageSourceOption(
                  Icons.camera_alt,
                  'Camera',
                  () {
                    Navigator.pop(context);
                    _showComingSoon('Camera');
                  },
                ),
                _buildImageSourceOption(
                  Icons.photo_library,
                  'Gallery',
                  () {
                    Navigator.pop(context);
                    _showComingSoon('Gallery');
                  },
                ),
                _buildImageSourceOption(
                  Icons.delete,
                  'Remove',
                  () {
                    Navigator.pop(context);
                    _showComingSoon('Remove Photo');
                  },
                ),
              ],
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }
  Widget _buildImageSourceOption(
    IconData icon,
    String label,
    VoidCallback onTap,
  ) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Icon(
              icon,
              color: Theme.of(context).colorScheme.primary,
              size: 24,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: const TextStyle(fontSize: 12),
          ),
        ],
      ),
    );
  }
  void _handleBackPress(BuildContext context) {
    if (_hasChanges) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Discard Changes?'),
          content: const Text(
            'You have unsaved changes. Are you sure you want to discard them?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                Navigator.pop(context); // Close dialog
                context.pop(); // Go back
              },
              child: const Text('Discard'),
            ),
          ],
        ),
      );
    } else {
      context.pop();
    }
  }
  Future<void> _saveProfile() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    setState(() {
      _isLoading = true;
    });
    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 2));
      if (mounted) {
        setState(() {
          _hasChanges = false;
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Profile updated successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to update profile: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
  void _showDeleteAccountDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text(
          'Delete Account',
          style: TextStyle(color: Colors.red),
        ),
        content: const Text(
          'This action cannot be undone. All your data, including posts, plants, and connections will be permanently deleted.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              _showComingSoon('Account Deletion');
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
  void _showComingSoon(String feature) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$feature feature coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }
}
</file>

<file path="frontend/lib/features/profile/presentation/screens/profile_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/models/user.dart';
import '../../../auth/providers/auth_provider.dart';
/// Profile screen displaying user information and settings
class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final authState = ref.watch(authProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        actions: [
          IconButton(
            onPressed: () => context.push('/profile/edit'),
            icon: const Icon(Icons.edit),
            tooltip: 'Edit Profile',
          ),
          PopupMenuButton<String>(
            onSelected: (value) => _handleMenuAction(context, ref, value),
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'settings',
                child: Row(
                  children: [
                    Icon(Icons.settings),
                    SizedBox(width: 8),
                    Text('Settings'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'privacy',
                child: Row(
                  children: [
                    Icon(Icons.privacy_tip),
                    SizedBox(width: 8),
                    Text('Privacy'),
                  ],
                ),
              ),
              const PopupMenuItem(
                value: 'help',
                child: Row(
                  children: [
                    Icon(Icons.help),
                    SizedBox(width: 8),
                    Text('Help & Support'),
                  ],
                ),
              ),
              const PopupMenuDivider(),
              const PopupMenuItem(
                value: 'logout',
                child: Row(
                  children: [
                    Icon(Icons.logout, color: Colors.red),
                    SizedBox(width: 8),
                    Text('Logout', style: TextStyle(color: Colors.red)),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
      body: _buildBody(context, theme, authState, ref),
    );
  }
  Widget _buildBody(BuildContext context, ThemeData theme, AuthState authState, WidgetRef ref) {
    if (authState.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (authState.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Error loading profile: ${authState.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => ref.refresh(authProvider),
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }
    return _buildProfileContent(context, theme, authState);
  }
  Widget _buildProfileContent(BuildContext context, ThemeData theme, AuthState state) {
    // Mock user data for demonstration
    final mockUser = MockUser(
      id: state.user?.id ?? 'user1',
      name: state.user?.displayName ?? 'Plant Lover',
      email: state.user?.email ?? 'plantlover@example.com',
      bio: 'Passionate about plants and sustainable living \nSharing my green journey with fellow plant enthusiasts!',
      location: 'San Francisco, CA',
      joinDate: DateTime(2023, 1, 15),
      followersCount: 1247,
      followingCount: 892,
      postsCount: 156,
      plantsCount: 23,
    );
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // Profile header
          _buildProfileHeader(context, theme, mockUser),
          const SizedBox(height: 24),
          // Stats section
          _buildStatsSection(theme, mockUser),
          const SizedBox(height: 24),
          // Bio section
          _buildBioSection(theme, mockUser),
          const SizedBox(height: 24),
          // Quick actions
          _buildQuickActions(context, theme),
          const SizedBox(height: 24),
          // Recent activity
          _buildRecentActivity(theme),
        ],
      ),
    );
  }
  Widget _buildProfileHeader(BuildContext context, ThemeData theme, MockUser user) {
    return Column(
      children: [
        // Profile picture
        Stack(
          children: [
            CircleAvatar(
              radius: 60,
              backgroundColor: theme.colorScheme.primary,
              child: Text(
                user.displayName.split(' ').map((name) => name[0]).join(),
                style: TextStyle(
                  fontSize: 36,
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.onPrimary,
                ),
              ),
            ),
            Positioned(
              bottom: 0,
              right: 0,
              child: Container(
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.colorScheme.surface,
                    width: 2,
                  ),
                ),
                child: IconButton(
                  onPressed: () {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Change profile picture (Demo mode)'),
                      ),
                    );
                  },
                  icon: Icon(
                    Icons.camera_alt,
                    color: theme.colorScheme.onPrimary,
                    size: 20,
                  ),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        // Name and verification
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              user.displayName,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 8),
            Icon(
              Icons.verified,
              color: theme.colorScheme.primary,
              size: 20,
            ),
          ],
        ),
        const SizedBox(height: 4),
        // Email
        Text(
          user.email,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurface.withOpacity(0.7),
          ),
        ),
        const SizedBox(height: 8),
        // Location and join date
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.location_on,
              size: 16,
              color: theme.colorScheme.onSurface.withOpacity(0.7),
            ),
            const SizedBox(width: 4),
            Text(
              user.location,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
            const SizedBox(width: 16),
            Icon(
              Icons.calendar_today,
              size: 16,
              color: theme.colorScheme.onSurface.withOpacity(0.7),
            ),
            const SizedBox(width: 4),
            Text(
              'Joined ${_formatJoinDate(user.joinDate)}',
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
          ],
        ),
      ],
    );
  }
  Widget _buildStatsSection(ThemeData theme, MockUser user) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem(theme, 'Posts', user.postsCount.toString()),
            _buildStatDivider(theme),
            _buildStatItem(theme, 'Plants', user.plantsCount.toString()),
            _buildStatDivider(theme),
            _buildStatItem(theme, 'Followers', _formatCount(user.followersCount)),
            _buildStatDivider(theme),
            _buildStatItem(theme, 'Following', _formatCount(user.followingCount)),
          ],
        ),
      ),
    );
  }
  Widget _buildStatItem(ThemeData theme, String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: theme.colorScheme.primary,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurface.withOpacity(0.7),
          ),
        ),
      ],
    );
  }
  Widget _buildStatDivider(ThemeData theme) {
    return Container(
      height: 40,
      width: 1,
      color: theme.colorScheme.outline.withOpacity(0.3),
    );
  }
  Widget _buildBioSection(ThemeData theme, MockUser user) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.info_outline,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(width: 8),
                Text(
                  'About',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              user.bio,
              style: theme.textTheme.bodyMedium,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildQuickActions(BuildContext context, ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Quick Actions',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildActionButton(
                  context,
                  theme,
                  Icons.eco,
                  'My Plants',
                  () => _showComingSoon(context, 'My Plants'),
                ),
                _buildActionButton(
                  context,
                  theme,
                  Icons.bookmark,
                  'Saved',
                  () => _showComingSoon(context, 'Saved Posts'),
                ),
                _buildActionButton(
                  context,
                  theme,
                  Icons.analytics,
                  'Insights',
                  () => _showComingSoon(context, 'Profile Insights'),
                ),
                _buildActionButton(
                  context,
                  theme,
                  Icons.share,
                  'Share',
                  () => _showShareProfile(context),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildActionButton(
    BuildContext context,
    ThemeData theme,
    IconData icon,
    String label,
    VoidCallback onTap,
  ) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.colorScheme.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Icon(
              icon,
              color: theme.colorScheme.primary,
              size: 24,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: theme.textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  Widget _buildRecentActivity(ThemeData theme) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Recent Activity',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ..._buildActivityItems(theme),
          ],
        ),
      ),
    );
  }
  List<Widget> _buildActivityItems(ThemeData theme) {
    final activities = [
      ('Posted a new plant photo', '2 hours ago', Icons.camera_alt),
      ('Liked 5 posts', '1 day ago', Icons.favorite),
      ('Added new plant to collection', '3 days ago', Icons.eco),
      ('Followed 3 new gardeners', '1 week ago', Icons.person_add),
    ];
    return activities.map((activity) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 12),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: theme.colorScheme.primary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                activity.$3,
                color: theme.colorScheme.primary,
                size: 16,
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    activity.$1,
                    style: theme.textTheme.bodyMedium,
                  ),
                  Text(
                    activity.$2,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      );
    }).toList();
  }
  void _handleMenuAction(BuildContext context, WidgetRef ref, String action) {
    switch (action) {
      case 'settings':
        _showComingSoon(context, 'Settings');
        break;
      case 'privacy':
        _showComingSoon(context, 'Privacy Settings');
        break;
      case 'help':
        _showComingSoon(context, 'Help & Support');
        break;
      case 'logout':
        _showLogoutDialog(context, ref);
        break;
    }
  }
  void _showComingSoon(BuildContext context, String feature) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$feature coming soon!'),
        action: SnackBarAction(
          label: 'OK',
          onPressed: () {},
        ),
      ),
    );
  }
  void _showShareProfile(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Share Profile',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text('Profile sharing feature coming soon!'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ],
        ),
      ),
    );
  }
  void _showLogoutDialog(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Logout'),
        content: const Text('Are you sure you want to logout?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              ref.read(authProvider.notifier).logout();
              context.go('/login');
            },
            child: const Text('Logout'),
          ),
        ],
      ),
    );
  }
  String _formatJoinDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return '${months[date.month - 1]} ${date.year}';
  }
  String _formatCount(int count) {
    if (count >= 1000000) {
      return '${(count / 1000000).toStringAsFixed(1)}M';
    } else if (count >= 1000) {
      return '${(count / 1000).toStringAsFixed(1)}K';
    }
    return count.toString();
  }
}
/// Mock user model for demonstration
class MockUser {
  final String id;
  final String name;
  final String email;
  final String bio;
  final String location;
  final DateTime joinDate;
  final int followersCount;
  final int followingCount;
  final int postsCount;
  final int plantsCount;
  MockUser({
    required this.id,
    required this.name,
    required this.email,
    required this.bio,
    required this.location,
    required this.joinDate,
    required this.followersCount,
    required this.followingCount,
    required this.postsCount,
    required this.plantsCount,
  });
  String get displayName => name;
}
</file>

<file path="frontend/pubspec.yaml">
name: plant_social
description: A plant-focused social messaging platform built with Flutter
publish_to: 'none'
version: 1.0.0+1
environment:
  sdk: '>=3.0.0 <4.0.0'
  flutter: ">=3.0.0"
dependencies:
  flutter:
    sdk: flutter
  freezed_annotation: ^2.4.1
  # State Management
  flutter_riverpod: ^2.4.9
  riverpod_annotation: ^2.3.3
  # UI Components
  cupertino_icons: ^1.0.2
  google_fonts: ^6.1.0
  flutter_svg: ^2.0.9
  cached_network_image: ^3.3.0
  # Navigation
  go_router: ^12.1.3
  # Network & API
  dio: ^5.4.0
  retrofit: ^4.0.3
  json_annotation: ^4.8.1
  # Storage
  flutter_secure_storage: ^9.0.0
  shared_preferences: ^2.2.2
  # Camera & Media
  camera: ^0.10.5+5
  image_picker: ^1.0.4
  video_player: ^2.8.1
  photo_view: ^0.14.0
  # Real-time Communication
  web_socket_channel: ^2.4.0
  # Permissions
  permission_handler: ^11.1.0
  # Utils
  intl: ^0.18.1
  uuid: ^4.2.1
  path_provider: ^2.1.1
  # Image Processing
  image: ^4.1.3
  # Notifications
  flutter_local_notifications: ^16.3.0
  # Location
  geolocator: ^10.1.0
  # Contacts
  contacts_service: ^0.6.3
dev_dependencies:
  flutter_test:
    sdk: flutter
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  # Code Generation
  build_runner: ^2.4.7
  riverpod_generator: ^2.3.9
  retrofit_generator: ^8.0.4
  # Linting
  flutter_lints: ^3.0.0
  # Testing
  mockito: ^5.4.4
  integration_test:
    sdk: flutter
flutter:
  uses-material-design: true
  assets:
    - assets/images/
    - assets/icons/
    - assets/animations/
</file>

</files>
